<tool id="csaw_normOffsets" name="normOffsets" version="@VERSION@.0">
  <description>normalizes counts across libraries</description>
  <macros>
    <import>csaw_macros.xml</import>
  </macros>
  <expand macro="requirements" />
  <command detect_errors="exit_code"><![CDATA[
    Rscript '$script']]>
  </command>
  <configfiles>
    <configfile name="script"><![CDATA[
## Setup R error handling to go to stderr
options(show.error.messages=F, error=function(){cat(geterrmessage(),file=stderr());q("no",1,F)})
loc <- Sys.setlocale("LC_MESSAGES", "en_US.UTF-8")

## Import library
library(csaw)

counts <- scan("$counts", what=integer())
counts <- matrix(counts, ncol= as.numeric("$ncol"))
data <- SummarizedExperiment(list(counts=counts))
data[["totals"]] <- colSums(counts)

#if str($assay_id) != ''
  assay_id <- as.numeric(gsub("([0-9]+).*$", "\\1", "$assay_id"))
  if (is.na(assay_id)){
    assay_id <- "$assay_id"
  }
#else
  assay_id <- NULL
#end if

#if str($type_select.type_selector) == "scaling"
  #if str($type_select.weighted) == "true"
    weighted <- TRUE
  #else
    weighted <- FALSE
  #end if

  #if str($type_select.scaling_select.scaling_selector) == "yes"
      ##lib_size <- scan("$type_select.scaling_select.lib_size", what=integer())
      method_s <- as.character("$type_select.scaling_select.method_select.method_selector")

      #if str($type_select.scaling_select.method_select.method_selector) == "TMM"
        #if str($type_select.scaling_select.method_select.refColumn_select.refColumn_selector) == "integer"
          refColumn <- as.numeric("$type_select.scaling_select.method_select.refColumn_select.refColumn")
        #else
          refColumn <- scan("$type_select.scaling_select.method_select.refColumn_select.refColumn", what=integer())
        #end if
        logratioTrim <- as.numeric("$type_select.scaling_select.method_select.logratioTrim")
        sumTrim <- as.numeric("$type_select.scaling_select.method_select.sumTrim")
        acutoff <- as.numeric("$type_select.scaling_select.method_select.acutoff")

        result1 <- normFactors(data, weighted=weighted, method="TMM", refColumn=refColumn, logratioTrim=logratioTrim, sumTrim=sumTrim, Acutoff=acutoff, assay.id=assay_id, se.out=FALSE)
      #else if str($type_select.scaling_select.method_select.method_selector) == "upperquartile"
        p <- as.numeric("$type_select.scaling_select.method_select.p")
        result1 <- normFactors(data, weighted=weighted, method="upperquartile", p=p, assay.id=assay_id, se.out=FALSE)
      #else
        result1 <- normFactors(data, weighted=weighted, method=method_s, assay.id=assay_id, se.out=FALSE)
    #end if
  #else
    result1 <- normFactors(data, weighted=weighted, assay.id=assay_id, se.out=FALSE)
  #end if
  write.table(result1, file="$output1", row.names=FALSE, col.names=FALSE)
#else
  #if str($type_select.loess_select.loess_selector) == "yes"
    span <- as.numeric("$type_select.loess_select.span")
    iterations <- as.numeric("$type_select.loess_select.iterations")
    min_weight <- as.numeric("$type_select.loess_select.min_weight")
    max_weight <- as.numeric("$type_select.loess_select.max_weight")

    #if str($type_select.loess_select.equal_weights_as_null) == "true"
      equal_weights_as_null <- TRUE
    #else
      equal_weights_as_null <- FALSE
    #end if

    result2 <- normOffsets(data, type="loess", weights=NULL, span=span, iterations=iterations, min.weight=min_weight, max.weight=max_weight, equal.weights.as.null=equal_weights_as_null, assay.id="counts", se.out=FALSE)
  #else
    result2 <- normOffsets(data, type="loess", assay.id="counts", se.out=FALSE)
  #end if
  write.table(result2, file="$output2", row.names=FALSE, col.names=FALSE)
#end if
]]>
    </configfile>
  </configfiles>
  <inputs>
    <param name="counts" type="data" format="tabular" label="Upload a count matrix for the SummarizedExperiment object" />
    <param name="ncol" type="integer" value="" label="Number of columns of the count matrix" />
    <conditional name="type_select">
      <param name="type_selector" type="select" label="What type of normalization is to be performed?" >
        <option value="scaling">scaling</option>
        <option value="loess">loess</option>
      </param>
      <when value="scaling">
        <param name="weighted" type="boolean" truevalue="true" falsevalue="" checked="false" label="Use precision weights for TMM normalization?" />
        <conditional name="scaling_select">
          <param name="scaling_selector" type="select" label="Add other paramaters to be passed to calcNormFactors?">
            <option value="yes">Yes</option>
            <option value="no" selected="true">No</option>
          </param>
          <when value="yes">
            <!--lib_size doesn't work-->
            <!--<param name="lib_size" type="data" format="tabular" label="Upload a dataframe with a column of library sizes" />-->
            <conditional name="method_select">
              <param name="method_selector" type="select" label="Normalization method to be used" >
                <option value="TMM">TMM</option>
                <option value="RLE">RLE</option>
                <option value="upperquartile">upperquartile</option>
                <option value="none">none</option>
              </param>
              <when value="TMM">
                <conditional name="refColumn_select">
                  <param name="refColumn_selector" type="select" label="Use a column or upload a dataframe of columns to use as reference?" >
                    <option value="integer">Enter a column number</option>
                    <option value="vector">Upload a dataframe of columns</option>
                  </param>
                  <when value="integer">
                    <param name="refColumn" type="integer" value="" label="Enter a column number" />
                  </when>
                  <when value="vector">
                    <param name="refColumn" type="data" format="tabular" label="Upload a dataframe of column numbers stored in one column" />
                  </when>
                </conditional>
                <param name="logratioTrim" type="float" value="0.3" label="Amount of trim to use on log-ratios (M values)" />
                <param name="sumTrim" type="float" value="0.05" label="Amount of trim to use on the combined absolute levels (A values)" />
                <!--doWeighting doesn't work-->
                <!--<param name="doWeighting" type="boolean" truevalue="true" falsevalue="" checked="true" label="Compute (asymptotic binomial precision) weights?" />-->
                <param name="acutoff" type="float" value="-1e10" label="Cutoff on A values to use before trimming" />
              </when>
              <when value="RLE"> </when>
              <when value="upperquartile"> 
                <param name="p" type="float" value="0.75" label="Percentile (between 0 and 1) of the counts that is aligned" />
              </when>
              <when value="none"> </when>
            </conditional>
          </when>
          <when value="no"> </when>
        </conditional>
      </when>
      <when value="loess">
        <conditional name="loess_select">
          <param name="loess_selector" type="select" label="Add other paramaters to be passed to loessFit?">
            <option value="yes">Yes</option>
            <option value="no" selected="true">No</option>
          </param>
          <when value="yes">
            <!--<param name="weights" type="data" format="tabular" optonal="true" label="Upload a dataframe of non-negative prior weights stored in one column" />-->
            <param name="span" type="float" value="0.3" label="Specify the proportion of data to be used in the local regression moving window" help="Enter a positive value between 0 and 1. Larger numbers give smoother fits." />
            <param name="iterations" type="integer" value="4" label="Iterations" help="This is the number of local regression fits. Values greater than 1 produce robust fits." />
            <param name="min_weight" type="float" value="1e-5" label="Minimum weight" />
            <param name="max_weight" type="float" value="1e5" label="Maximum weight" />
            <param name="equal_weights_as_null" type="boolean" truevalue="true" falsevalue="" checked="true" label="Treat equal weights as if weights are NULL?" help="Applies even if all weights are all zero." />
          </when>
          <when value="no"> </when>
        </conditional>
      </when>
    </conditional>
    <param name="assay_id" type="text" value="counts" optional="true" label="Specify the assay values to use for normalization" />
    <!--<param name="se_out" type="boolean" truevalue="true" falsevalue="" checked="true" label="Return a SummarizedExperiment object?" />-->
  </inputs>
  <outputs>
    <data name="output1" format="txt" label="normFactors on ${on_string}: output">
      <filter>type_select['type_selector'] == 'scaling'</filter>
    </data>
    <data name="output2" format="txt" label="${tool.name} on ${on_string}: output" >
      <filter>type_select['type_selector'] == 'loess'</filter>
    </data>
  </outputs>

  <tests>
    <test>
      <param name="counts" value="normOffsets_counts.tabular" />
      <param name="ncol" value="4" />
      <conditional name="type_select">
        <param name="type_selector" value="scaling" />
          <conditional name="scaling_select">
            <param name="weighted" value="false" />
            <param name="scaling_selector" value="no" />
          </conditional>
      </conditional>
      <param name="assay_id" value="counts" />
      <output name="output1" value="normOffsets_output1.txt" />
    </test>
    <test>
      <param name="counts" value="normOffsets_counts.tabular" />
      <param name="ncol" value="4" />
      <conditional name="type_select">
        <param name="type_selector" value="scaling" />
          <conditional name="scaling_select">
            <param name="weighted" value="false" />
            <param name="scaling_selector" value="yes" />
              <!--<param name="lib_size" value="normOffsets_libSize.tabular" />-->
              <conditional name="method_select">
                <param name="method_selector" value="none" />
              </conditional>
          </conditional>
      </conditional>
      <param name="assay_id" value="counts" />
      <output name="output1" value="normOffsets_output2.txt" />
    </test>
    <test>
      <param name="counts" value="normOffsets_counts.tabular" />
      <param name="ncol" value="4" />
      <conditional name="type_select">
        <param name="type_selector" value="scaling" />
          <conditional name="scaling_select">
            <param name="weighted" value="false" />
            <param name="scaling_selector" value="yes" />
            <!--<param name="lib_size" value="normOffsets_libSize.tabular" />-->
              <conditional name="method_select">
                <param name="method_selector" value="TMM" />
                  <conditional name="refColumn_select">
                    <param name="refColumn_selector" value="integer" />
                      <param name="refColumn" value="1" />
                  </conditional>
                  <param name="logratioTrim" value="0.3" />
                  <param name="sumTrim" value="0.05" />
                  <!--<param name="doWeighting" value="true" />-->
                  <param name="acutoff" value="-1e10" />
              </conditional>
          </conditional>
      </conditional>
      <param name="weighted" value="false" />
      <param name="assay_id" value="counts" />
      <output name="output1" value="normOffsets_output3.txt" />
    </test>
    <test>
      <param name="counts" value="normOffsets_counts.tabular" />
      <param name="ncol" value="4" />
      <conditional name="type_select">
        <param name="type_selector" value="scaling" />
        <param name="weighted" value="false" />
          <conditional name="scaling_select">
            <param name="scaling_selector" value="yes" />
              <!--<param name="lib_size" value="normOffsets_libSize.txt" />-->
              <conditional name="method_select">
                <param name="method_selector" value="upperquartile" />
                <param name="p" value="0.75" />
              </conditional>
          </conditional>
      </conditional>
      <param name="assay_id" value="counts" />
      <output name="output1" value="normOffsets_output4.txt" />
    </test>
    <test>
      <param name="counts" value="normOffsets_counts.tabular" />
      <param name="ncol" value="4" />
      <conditional name="type_select">
        <param name="type_selector" value="loess" />
          <conditional name="loess_select">
            <param name="loess_selector" value="no" />
          </conditional>
      </conditional>
      <param name="assay_id" value="counts" />
      <output name="output2" value="normOffsets_output5.txt" />
    </test>
    <test>
      <param name="counts" value="normOffsets_counts.tabular" />
      <param name="ncol" value="4" />
      <conditional name="type_select">
        <param name="type_selector" value="loess" />
          <conditional name="loess_select">
            <param name="loess_selector" value="yes" />
            <param name="span" value="0.3" />
            <param name="iterations" value="4" />
            <param name="min_weight" value="1e-5" />
            <param name="max_weight" value="1e5" />
            <param name="equal_weights_as_null" value="true" />
            <param name="method" value="weightedLowess" />
          </conditional>
      </conditional>
      <param name="assay_id" value="counts" />
      <output name="output2" value="normOffsets_output6.txt" />
    </test>
  </tests>
  <help><![CDATA[
      Calculate normalization factors or offsets using count data from multiple libraries.

      The normFactors function provides a convenience wrapper for the calcNormFactors function in the edgeR package. This uses the trimmed mean of M-values (TMM) method to remove composition biases, typically in background regions of the genome. Precision weighting is turned off by default so as to avoid upweighting high-abundance regions. These are more likely to be bound and thus more likely to be differentially bound. Assigning excessive weight to such regions will defeat the purpose of trimming when normalizing the coverage of background regions. The normOffsets function with type="loess" performs non-linear normalization similar to the fast loess algorithm in normalizeCyclicLoess. This aims to account for mean dependencies in the efficiency biases between libraries. For each sample, a lowess curve is fitted to the log-counts against the log-average count. The fitted value for each genomic window is used as an offset in a generalized linear model for that feature and sample. The use of the average count provides more stability than the average log-count when low counts are present for differentially bound regions. 

      normOffsets with type="scaling" behaves the same as normFactors, but is deprecated to avoid confusion when the function returns normalization factors. 
    ]]></help>
  <expand macro="citations" />
</tool>