<tool id="csaw_testing" name="testing" version="@VERSION@.0">
    <description>with csaw</description>
    <macros>
       <import>csaw_macros.xml</import>
    </macros>
    <expand macro="requirements" />
    <command detect_errors="exit_code"><![CDATA[
        Rscript '$script'
    ]]></command>
    <configfiles><configfile name="script"><![CDATA[
## Setup R error handling to go to stderr
options(show.error.messages=F, error=function(){cat(geterrmessage(),file=stderr());q("no",1,F)})
loc <- Sys.setlocale("LC_MESSAGES", "en_US.UTF-8")

## Import library
library(csaw)
library(Rsamtools)

#if str($method_select.method) == "clusterFDR"
    ids <- scan("$method_select.id", what = integer())
    threshold <- as.numeric("$method_select.threshold")
    target <- as.numeric("$method_select.target")
    adjp <- scan("$method_select.adjp", what = numeric())

    #if str($method_select.weight_select.weight_selector) == "yes"
        weight <- scan("$method_select.weight_select.weight", what=numeric())
    #else
        weight <- NULL
    #end if

    grid_length <- as.numeric("$method_select.grid_length")
    iterations <- as.numeric("$method_select.iterations")

    ## Create a custom function
    set.seed(100)
    windows <- GRanges("chrA", IRanges(1:1000, 1:1000))
    test.p <- runif(1000)
    test.p[c(1:10, 100:110, 220:240)] <- 0
    is.sig <- p.adjust(test.p, method="BH") <= threshold
    clusterFUN <- function(x) { mergeWindows(windows[x], tol=0)[[1]] }

    result1 <- clusterFDR(ids, threshold, weight=NULL)
    result2 <- controlClusterFDR(target, adjp, clusterFUN,  weight=NULL, grid.length=grid_length, iterations=iterations)

    result <- list(c(result1[1]))
    result <- append(result, result2[[1]])
    result <- append(result, result2[[2]])

    write.table(do.call(rbind, result), file="$clusterFDR_output", quote = FALSE, row.names = c("clusterFDR ", "threshold ", "FDR "), col.names = FALSE)
#else if str($method_select.method) == "combineTests"
    ids <-scan("$method_select.ids", what = integer())
    tab <- read.table("$method_select.tab", sep="", header=T)
    #if str($method_select.weight_select.weight_selector) == "yes"
        w <- scan("$method_select.weight_select.weight", what=numeric())
    #else
        w <- NULL
    #end if
    @COLNAMES_METHOD@
    result <- combineTests(ids, tab, weight=w, pval.col=pval_col, fc.col=fc_col)
    write.table(result, file="$combineTests_output", quote = FALSE, row.names=FALSE)
#else if str($method_select.method) == "getBestTest"
    ids <- scan("$method_select.ids", what = integer())
    tab <- read.table("$method_select.tab", header=TRUE)

    #if str($method_select.by_pval) == "true"
        by_pval <- TRUE
    #else
        by_pval <- FALSE
    #end if

    #if str($method_select.weight_select.weight_selector) == "yes"
        weight <- scan("$method_select.weight_select.weight", what = numeric())
    #else
        weight <- NULL
    #end if

    #if str($method_select.pval_col) != ''
        pval_col <- as.numeric(gsub("([0-9]+).*$", "\\1", "$method_select.pval_col"))
        if (is.na(pval_col)){
            pval_col <- "$method_select.pval_col"
        }
    #else
        pval_col <- NULL
    #end if
    #if str($method_select.cpm_col) != ''
        cpm_col <- as.numeric(gsub("([0-9]+).*$", "\\1", "$method_select.cpm_col"))
        if (is.na(cpm_col)){
            cpm_col <- "$method_select.cpm_col"
        }
    #else
        cpm_col <- NA
    #end if

    best <- getBestTest(ids, tab, by.pval=by_pval, weight=weight, pval.col=pval_col, cpm.col=cpm_col)
    write.table(best, "$getBestTest_output", quote = FALSE, col.names = TRUE, row.names=FALSE)
#else if str($method_select.method) == "overlapStats"
    @WINDOWCOUNTS_METHOD@
    data <- window_counts

    ## Region of interest
    #if str($method_select.region.named) == "true"
      reg <- read.table("$method_select.region.GRanges", header=T)
    #else
      reg <- read.table("$method_select.region.GRanges", header=F)
    #end if
    gRange <- reg[[1]]
    start <- reg[[2]]
    end <- reg[[3]]
    regions <- GRanges(gRange, IRanges(start, end))

    olap <- findOverlaps(regions, rowRanges(data))
    tab <- read.table("$method_select.tab", sep="", header=T)

    #if str($method_select.output_select.output_selector) == 'combineOverlaps'
      @OVERLAPSTATS_W@
      result1 <- combineOverlaps(olap, tab , o.weight=o_weight, i.weight=i_weight)
      write.table(result1, "$overlapStats_output1", quote = FALSE, row.names=FALSE)
    #else if str($method_select.output_select.output_selector) == 'getBestOverlaps'
      @OVERLAPSTATS_W@
      result2 <- getBestOverlaps(olap, tab, o.weight=o_weight, i.weight=i_weight)
      write.table(result2, "$overlapStats_output2", quote = FALSE, row.names=FALSE)
    #else if str($method_select.output_select.output_selector) == 'empiricalOverlaps'
      @OVERLAPSTATS_W@
      result3 <- empiricalOverlaps(olap, tab, o.weight=o_weight, i.weight=i_weight)
      write.table(result3, "$overlapStats_output3", quote = FALSE, row.names=FALSE)
    #else if str($method_select.output_select.output_selector) == 'mixedOverlaps'
      @OVERLAPSTATS_W@
      result4 <- mixedOverlaps(olap, tab, o.weight=o_weight, i.weight=i_weight)
      write.table(result4, "$overlapStats_output4", quote = FALSE, row.names=FALSE)
    #else if str($method_select.output_select.output_selector) == 'summitOverlaps'
      region_best <- read.table("$method_select.output_select.region_best", sep="", header=T)
      #if str($method_select.output_select.o_summit_select.o_summit_selector) == 'boolean'
        o_summit <- scan("$method_select.output_select.o_summit_select.o_summit", what=logical())
      #else if str($method_select.output_select.o_summit_select.o_summit_selector) == 'integer'
        o_summit <- scan("$method_select.output_select.o_summit_select.o_summit", what=interger())
      #else
        o_summit <- NULL
      #end if
      #if str($method_select.output_select.i_summit_select.i_summit_selector) == 'boolean'
        i_summit <- scan("$method_select.output_select.i_summit_select.i_summit", what=logical())
      #else if str($method_select.output_select.i_summit_select.i_summit_selector) == 'integer'
        i_summit <- scan("$method_select.output_select.i_summit_select.i_summit", what=interger())
      #else
        i_summit <- NULL
      #end if
      result5 <- summitOverlaps(olap, region_best, o.summit=o_summit, i.summit=i_summit)
      write.table(result5, "$overlapStats_output5", quote = FALSE, col.names=FALSE, row.names=FALSE)
    #end if
#else
    ids <- scan("$method_select.ids", what=integer())

    #if str($method_select.summit_select.summit_selector) == "boolean"
      summits <- scan("$method_select.summit_select.summits", what=logical())
    #else
      summits <- scan("$method_select.summit_select.summits", what=integer())
    #end if

    result <- upweightSummit(ids, summits)

    write.table(result, "$upweightSummit_output", quote = FALSE, col.names = FALSE, row.names = FALSE)
#end if
]]></configfile>
    </configfiles>
    <inputs>
        <conditional name="method_select">
            <param name="method" type="select" label="Method" >
                <option value="clusterFDR">Compute the FDR across clusters based on the test-level FDR threshold</option>
                <option value="combineTests">Combines p-values across clustered tests using Simes’ method to control the cluster FDR</option>
                <option value="getBestTest">Find the test with the strongest evidence for rejection of the null in each cluster</option>
                <option value="overlapStats">Compute assorted statistics for overlaps between windows and regions in a Hits object</option>
                <option value="upweightSummit">Upweight the highest-abudance window(s) in a cluster</option>
            </param>
            <when value="clusterFDR"> 
                <param name="id" type="data" format="tabular" label="Cluster IDs for each significant test below threshold" />
                <param name="threshold" type="float" value="" label="The FDR threshold used to define the significant tests" />
                <param name="target" type="float" value="" optional="true" label="The desired cluster-level FDR threshold" />
                <param name="adjp" type="data" format="tabular" label="Window-level adjusted p-values" />
                <conditional name="weight_select">
                    <param name="weight_selector" type="select" label="Specify frequency weights?" help="The specification is assumed to contain frequency weights of significant tests/windows. For example, a weight of 2 for a test would be equivalent to repeating that test (i.e., repeating the same window so it shows up twice in your analysis). These weights should be the same as those used during weighted FDR control to compute adjusted p-values. In general, you should not set this argument unless you know what you’re doing.">
                        <option value="yes">Yes</option>
                        <option value="no" selected="true">No</option>
                    </param>
                    <when value="yes">
                        <param name="weight" type="data" format="tabular" label="Frequency weights" help="A dataframe of a column of weights" />
                    </when>
                    <when value="no"> </when>
                </conditional>
                <param name="grid_length" type="integer" value="21" label="Specify the number of points to use in the grid search" />
                <param name="iterations" type="integer" value="4" label="Specify the number of iterations of the grid search" />
            </when>
            <when value="combineTests"> 
                <param name="ids" type="data" format="tabular" label="Cluster ID for each test" help="Upload as a dataframe where each row is an integer." />
                <param name="tab" type="data" format="tabular" label="Dataframe of results with PValue and at least one logFC field for each test" />
                <conditional name="weight_select">
                  <param name="weight_selector" type="select" label="Specify weights for each window?" help="If none specified, the weight defaults to 1 for each test. Supplying different relative weight values may be useful for downweighting low-confidence tests, e.g., those in repeat regions. In Simes’ procedure, weights are interpreted as relative frequencies of the tests in each cluster.">
                    <option value="yes">Yes</option>
                    <option value="no" selected="true">No</option>
                  </param>
                  <when value="yes">
                    <param name="weight" type="data" format="tabular" label="Weights for each window" help="Upload as a dataframe where each row is a numeric value." />
                  </when>
                  <when value="no"> </when>
                </conditional>
                <expand macro="col_names" />
            </when>
            <when value="getBestTest">
                <param name="ids" type="data" format="tabular" label="Cluster IDs for each test" />
                <param name="tab" type="data" format="tabular" label="A dataframe of results with a PValue field for each test" />
                <param name="by_pval" type="boolean" truevalue="true" falsevalue="" checked="true" label="Perform selection on corrected p-values" />
                <conditional name="weight_select">
                  <param name="weight_selector" type="select" label="Specify weights for each window?">
                    <option value="yes">Yes</option>
                    <option value="no" selected="true">No</option>
                  </param>
                  <when value="yes">
                    <param name="weight" type="data" format="tabular" label="Weights for each window" help="A dataframe with a column of weights" />
                  </when>
                  <when value="no"> </when>
                </conditional>
                  <param name="pval_col" type="text" optional="true" label="Specify the column of tab containing the p-values" help="Enter a string or integer" >
                    <sanitizer>
                      <valid>
                        <add value="." />
                      </valid>
                    </sanitizer>
                  </param>
                  <param name="cpm_col" type="text" optional="true" label="Specify the column of tab containing the log-CPM" help="Enter a string or integer" >
                    <sanitizer>
                      <valid>
                        <add value="." />
                      </valid>
                    </sanitizer>
                  </param>
            </when>
            <when value="overlapStats">
                <section name="windowCounts" title="Count reads overlapping each window" expanded="True">
                  <expand macro="windowCounts" />
                </section>
                <section name="region" title="Query of overlaps between regions" expanded="True">
                  <expand macro="gRanges" />
                </section>
                <param name="tab" type="data" format="tabular" label="Upload a ataframe of DE results for each window" />
                <conditional name="output_select">
                  <param name="output_selector" type="select" label="Select the function to compute overlaps between windows and regions" >
                    <option value="combineOverlaps">combineOverlaps</option>
                    <option value="getBestOverlaps">getBestOverlaps</option>
                    <option value="empiricalOverlaps">empiricalOverlaps</option>
                    <option value="mixedOverlaps">mixedOverlaps</option>
                    <option value="summitOverlaps">summitOverlaps</option>
                  </param>
                  <when value="combineOverlaps">
                    <expand macro="overlapStats_weights" />
                  </when>
                  <when value="getBestOverlaps">
                    <expand macro="overlapStats_weights" />
                  </when>
                  <when value="empiricalOverlaps">
                    <expand macro="overlapStats_weights" />
                  </when>
                  <when value="mixedOverlaps">
                    <expand macro="overlapStats_weights" />
                  </when>
                  <when value="summitOverlaps">
                    <param name="region_best" type="data" format="tabular" label="Specifying the window index that is the summit for each region" help="The data is designed to accept the best field in the output of getBestOverlaps (select create output to be used for summitOverlaps). This contains the index for the individual window that is the summit within each region."/>
                    <conditional name="o_summit_select">
                      <param name="o_summit_selector" type="select" label="Specify the overlapped windows that are summits by boolean values, integer indices, or none?" >
                        <option value="boolean">Boolean Values</option>
                        <option value="integer">Integer Indices</option>
                        <option value="none" selected="true">None</option>
                      </param>
                      <when value="boolean">
                        <param name="o_summit" type="data" format="tabular" label="Specify the overlapped windows that are summits by boolean values" help="Upload a dataframe with a column of boolean values" />
                      </when>
                      <when value="integer">
                        <param name="o_summit" type="data" format="tabular" label="Specify the overlapped windows that are summits by the corresponding integer indices" help="Upload a dataframe with a column of integer indices" />
                      </when>
                      <when value="none"> </when>
                    </conditional>
                    <conditional name="i_summit_select">
                      <param name="i_summit_selector" type="select" label="Specify the individual windows that are summits by boolean values, integer indices, or none?" >
                        <option value="boolean">Boolean Values</option>
                        <option value="integer">Integer Indices</option>
                        <option value="none" selected="true">None</option>
                      </param>
                      <when value="boolean">
                        <param name="i_summit" type="data" format="tabular" label="Specify the individual windows that are summits by boolean values" help="Upload a dataframe with a column of boolean values" />
                      </when>
                      <when value="integer">
                        <param name="i_summit" type="data" format="tabular" label="Specify the individual windows that are summits by the corresponding integer indices" help="Upload a dataframe with a column of integer indices" />
                      </when>
                      <when value="none"> </when>
                    </conditional>
                  </when>
                </conditional>
            </when>
            <when value="upweightSummit">
                <param name="ids" type="data" format="tabular" label="cluster IDs" />
                <conditional name="summit_select">
                  <param name="summit_selector" type="select" label="Indicate whether each window is a summit by boolean values or integer indices?" >
                    <option value="boolean">Boolean Values</option>
                    <option value="integer">Integer Indices</option>
                  </param>
                  <when value="boolean">
                    <param name="summits" type="data" format="tabular" label="Indicate the whether each window is a summit by boolean values" help="Upload a dataframe with a column of boolean values" />
                  </when>
                  <when value="integer">
                    <param name="summits" type="data" format="tabular" label="Indicate the whether each window is a summit by integer indices" help="Upload a dataframe with a column of integer indices" />
                  </when>
                </conditional>    
            </when>
        </conditional>
    </inputs>
    <outputs>
        <data name="clusterFDR_output" format="txt" label="clusterFDR on ${on_string}: output">
            <filter>method_select['method'] == 'clusterFDR'</filter>
        </data>
        <data name="combineTests_output" format="txt" label="combineTests on ${on_string}: output">
             <filter>method_select['method'] == 'combineTests'</filter>
        </data>
        <data name="getBestTest_output" format="txt" label="getBestTest on ${on_string}: output">
             <filter>method_select['method'] == 'getBestTest'</filter>
        </data>
        <data name="overlapStats_output1" format="txt" label="overlapStats on ${on_string}: combineOverlaps output" >
          <filter>method_select['method'] == 'overlapStats' and method_select['output_select']['output_selector'] == 'combineOverlaps' </filter>
        </data>
        <data name="overlapStats_output2" format="txt" label="overlapStats on ${on_string}: getBestOverlaps output" >
          <filter>method_select['method'] == 'overlapStats' and method_select['output_select']['output_selector'] == 'getBestOverlaps' </filter>
        </data>
        <data name="overlapStats_output3" format="txt" label="overlapStats on ${on_string}: empiricalOverlaps output" >
          <filter>method_select['method'] == 'overlapStats' and method_select['output_select']['output_selector'] == 'empiricalOverlaps' </filter>
        </data>
        <data name="overlapStats_output4" format="txt" label="overlapStats on ${on_string}:  mixedOverlaps output" >
          <filter>method_select['method'] == 'overlapStats' and method_select['output_select']['output_selector'] == 'mixedOverlaps' </filter>
        </data>
        <data name="overlapStats_output5" format="txt" label="overlapStats on ${on_string}:  summitOverlaps output" >
          <filter>method_select['method'] == 'overlapStats' and method_select['output_select']['output_selector'] == 'summitOverlaps' </filter>
        </data>
        <data name="upweightSummit_output" format="txt" label="upweightSummit on ${on_string}: output">
            <filter>method_select['method'] == 'upweightSummit'</filter>
        </data>
    </outputs>
    <tests>
        <!--<test expect_num_outputs="1">
            <conditional name="method_select">
                <param name="method" value="clusterFDR" />
                <param name="id" value="id.tabular" />
                <param name="threshold" value="0.05" />
                <param name="target" value="0.05" />
                <param name="adjp" value="adjp.tabular" />
                <conditional name="weight_select">
                    <param name="weight_selector" value="no" />
                </conditional>
                <param name="grid_length" value="21" />
                <param name="iterations" value="4" />
            </conditional>
            <output name="clusterFDR_output" file="clusterFDR_output1.txt"/>
        </test>
        <test expect_num_outputs="1">
            <conditional name="method_select">
                <param name="method" value="clusterFDR" />
                <param name="id" value="id.tabular" />
                <param name="threshold" value="0.05" />
                <param name="target" value="0.05" />
                <param name="adjp" value="adjp.tabular" />
                <conditional name="weight_select">
                    <param name="weight_selector" value="yes" />
                    <param name="weight" value="clusterFDR_w.tabular" />
                </conditional>
                <param name="grid_length" value="21" />
                <param name="iterations" value="4" />
            </conditional>
            <output name="clusterFDR_output" file="clusterFDR_output2.txt"/>
        </test>-->

        <test expect_num_outputs="1">
            <conditional name="method_select">
                <param name="method" value="combineTests" />
                <param name="ids" value="comTest_ids.tabular" />
                <param name="tab" value="comTest_tab.tabular" />
                <conditional name="weight_select">
                    <param name="weight_selector" value="no" />
                </conditional>
                <param name="pval_col" value="PValue" />
                <param name="fc_col" value="logFC.whee" />
            </conditional>
            <output name="combineTests_output" value="combineTests_output.txt" />
        </test>
        <test expect_num_outputs="1">
            <conditional name="method_select">
                <param name="method" value="combineTests" />
                <param name="ids" value="comTest_ids.tabular" />
                <param name="tab" value="comTest_tab.tabular" />
                <conditional name="weight_select">
                    <param name="weight_selector" value="yes" />
                    <param name="weight" value="comTest_w.tabular" />
                </conditional>
                <param name="pval_col" value="PValue" />
                <param name="fc_col" value="logFC.whee" />
            </conditional>
            <output name="combineTests_output" value="combineTests_output2.txt" />
        </test>
        <test expect_num_outputs="1">
            <conditional name="method_select">
                <param name="method" value="getBestTest" />
                <param name="ids" value="getBestTest_ids.tabular" />
                <param name="tab" value="getBestTest_tab.tabular" />
                <param name="by_pval" value="true" />
                <conditional name="weight_select">
                    <param name="weight_selector" value="no"/>
                </conditional>
                <param name="pval_col" value="3" />
                <param name="cpm_col" value="2" />
            </conditional>
            <output name="getBestTest_output" value="getBestTest_output1.txt" />
        </test>
        <test expect_num_outputs="1">
            <conditional name="method_select">
                <param name="method" value="getBestTest" />
                <param name="ids" value="getBestTest_ids.tabular" />
                <param name="tab" value="getBestTest_tab.tabular" />
                <param name="by_pval" value="true" />
                <conditional name="weight_select">
                    <param name="weight_selector" value="yes" />
                    <param name="weight" value="getBestTest_w.tabular" />
                </conditional>
                <param name="pval_col" value="3" />
                <param name="cpm_col" value="2" />
            </conditional>
            <output name="getBestTest_output" value="getBestTest_output2.txt" />
        </test>
        <test expect_num_outputs="1">
            <conditional name="method_select">
                <param name="method" value="overlapStats" />
                <section name="windowCounts">
                    <repeat name="bam_input">
                        <param name="bam_file" value="rep1.bam" ftype="bam" />
                    </repeat>
                    <repeat name="bam_input">
                        <param name="bam_file" value="rep2.bam" ftype="bam" />
                    </repeat>
                    <param name="width" value="1" />
                    <param name="filter" value="1" />
                </section>
                <section name="region">
                    <param name="GRanges" value="overlapStats_regions.tabular" />
                    <param name="named" value="true" />
                </section>
                <param name="tab" value="overlapStats_tab.tabular" />
                <conditional name="output_select">
                    <param name="output_selector" value="combineOverlaps" />
                    <conditional name="o_weight_select">
                        <param name="o_weight_selector" value="no" />
                    </conditional>
                    <conditional name="i_weight_select">
                        <param name="i_weight_selector" value="no" />
                    </conditional>
                </conditional>
            </conditional>
            <output name="overlapStats_output1" value="overlapStats_output1.txt" />
        </test>
        <test expect_num_outputs="1">
            <conditional name="method_select">
                <param name="method" value="overlapStats" />
                <section name="windowCounts">
                    <repeat name="bam_input">
                      <param name="bam_file" value="rep1.bam" ftype="bam" />
                    </repeat>
                    <repeat name="bam_input">
                      <param name="bam_file" value="rep2.bam" ftype="bam" />
                    </repeat>
                    <param name="width" value="1" />
                    <param name="filter" value="1" />
                </section>
                <section name="region">
                    <param name="GRanges" value="overlapStats_regions.tabular" />
                    <param name="named" value="true" />
                </section>
                <param name="tab" value="overlapStats_tab.tabular" />
                <conditional name="output_select">
                    <param name="output_selector" value="combineOverlaps" />
                    <conditional name="o_weight_select">
                        <param name="o_weight_selector" value="yes" />
                        <param name="o_weight" value="overlapStats_o_weights.tabular" />
                    </conditional>
                    <conditional name="i_weight_select">
                        <param name="i_weight_selector" value="yes" />
                        <param name="i_weight" value="overlapStats_i_weights.tabular" />
                    </conditional>
                </conditional>
            </conditional>
            <output name="overlapStats_output1" value="overlapStats_output2.txt" />
        </test>
        <test expect_num_outputs="1">
            <conditional name="method_select">
                <param name="method" value="overlapStats" />
                <section name="windowCounts">
                    <repeat name="bam_input">
                      <param name="bam_file" value="rep1.bam" ftype="bam" />
                    </repeat>
                    <repeat name="bam_input">
                      <param name="bam_file" value="rep2.bam" ftype="bam" />
                    </repeat>
                    <param name="width" value="1" />
                    <param name="filter" value="1" />
                </section>
                <section name="region">
                    <param name="GRanges" value="overlapStats_regions.tabular" />
                    <param name="named" value="true" />
                </section>
                <param name="tab" value="overlapStats_tab.tabular" />
                <conditional name="output_select">
                    <param name="output_selector" value="getBestOverlaps" />
                    <conditional name="o_weight_select">
                        <param name="o_weight_selector" value="yes" />
                        <param name="o_weight" value="overlapStats_o_weights.tabular" />
                    </conditional>
                    <conditional name="i_weight_select">
                        <param name="i_weight_selector" value="yes" />
                        <param name="i_weight" value="overlapStats_i_weights.tabular" />
                    </conditional>
                </conditional>
            </conditional>
            <output name="overlapStats_output2" value="overlapStats_output3.txt" />
        </test>
        <test expect_num_outputs="1">
            <conditional name="method_select">
                <param name="method" value="overlapStats" />
                <section name="windowCounts">
                    <repeat name="bam_input">
                        <param name="bam_file" value="rep1.bam" ftype="bam" />
                    </repeat>
                    <repeat name="bam_input">
                        <param name="bam_file" value="rep2.bam" ftype="bam" />
                    </repeat>
                    <param name="width" value="1" />
                    <param name="filter" value="1" />
                </section>
                <section name="region">
                    <param name="GRanges" value="overlapStats_regions.tabular" />
                    <param name="named" value="true" />
                </section>
                <param name="tab" value="overlapStats_tab.tabular" />
                <conditional name="output_select">
                    <param name="output_selector" value="empiricalOverlaps" />
                    <conditional name="o_weight_select">
                        <param name="o_weight_selector" value="yes" />
                        <param name="o_weight" value="overlapStats_o_weights.tabular" />
                    </conditional>
                    <conditional name="i_weight_select">
                        <param name="i_weight_selector" value="yes" />
                        <param name="i_weight" value="overlapStats_i_weights.tabular" />
                    </conditional>
                </conditional>
            </conditional>
            <output name="overlapStats_output3" value="overlapStats_output4.txt" />
        </test>
        <test expect_num_outputs="1">
            <conditional name="method_select">
                <param name="method" value="overlapStats" />
                <section name="windowCounts">
                    <repeat name="bam_input">
                        <param name="bam_file" value="rep1.bam" ftype="bam" />
                    </repeat>
                    <repeat name="bam_input">
                        <param name="bam_file" value="rep2.bam" ftype="bam" />
                    </repeat>
                    <param name="width" value="1" />
                    <param name="filter" value="1" />
                </section>
                <section name="region">
                    <param name="GRanges" value="overlapStats_regions.tabular" />
                    <param name="named" value="true" />
                </section>
                <param name="tab" value="overlapStats_tab.tabular" />
                <conditional name="output_select">
                    <param name="output_selector" value="mixedOverlaps" />
                    <conditional name="o_weight_select">
                        <param name="o_weight_selector" value="yes" />
                        <param name="o_weight" value="overlapStats_o_weights.tabular" />
                    </conditional>
                    <conditional name="i_weight_select">
                        <param name="i_weight_selector" value="yes" />
                        <param name="i_weight" value="overlapStats_i_weights.tabular" />
                    </conditional>
                </conditional>
            </conditional>
            <output name="overlapStats_output4" value="overlapStats_output5.txt" />
        </test>
        <test expect_num_outputs="1">
            <conditional name="method_select">
                <param name="method" value="overlapStats" />
                <section name="windowCounts">
                    <repeat name="bam_input">
                        <param name="bam_file" value="rep1.bam" ftype="bam" />
                    </repeat>
                    <repeat name="bam_input">
                        <param name="bam_file" value="rep2.bam" ftype="bam" />
                    </repeat>
                    <param name="width" value="1" />
                    <param name="filter" value="1" />
                </section>
                <section name="region">
                    <param name="GRanges" value="overlapStats_regions.tabular" />
                    <param name="named" value="true" />
                </section>
                <param name="tab" value="overlapStats_tab.tabular" />
                <conditional name="output_select">
                    <param name="output_selector" value="summitOverlaps" />
                    <param name="region_best" value="overlapStats_best.tabular" />
                    <conditional name="o_summit_select">
                        <param name="o_summit_selector" value="boolean" />
                        <param name="o_summit" value="overlapStats_o_summit.tabular" />
                    </conditional>
                    <conditional name="i_summit_select">
                        <param name="i_summit_selector" value="boolean" />
                        <param name="i_summit" value="overlapStats_i_summit.tabular" />
                    </conditional>
                </conditional>
            </conditional>
            <output name="overlapStats_output5" value="overlapStats_output6.txt" />
        </test>        


        <!--<test expect_num_outputs="1">
            <conditional name="method_select">
                <param name="method" value="upweightSummit" />
              <param name="ids" value="upweightSummit_ids.tabular" />
              <conditional name="summit_select">
                <param name="summit_selector" value="boolean" />
                <param name="summits" value="upweightSummit_summits.tabular" />
              </conditional>
            </conditional>
            <output name="upweightSummit_output" value="upweightSummit_output.txt" />
        </test>-->
    </tests>
    <help><![CDATA[

Compute the FDR across clusters based on the test-level FDR threshold
======================================================================

The cluster-level FDR, the windowlevel FDR threshold to control the cluster-level FDR near target, and the estimate of the cluster-level FDR corresponding to threshold are returned.

This mehtod computes an informal estimate of the cluster-level FDR, where each cluster is formed by aggregating only significant tests. In the context of ChIP-seq, each significant test refers to a DB window that is detected at a FDR below threshold. The idea is to obtain an error rate while reporting the precise coordinates of a DB subinterval in a complex region. 

The cluster-level FDR is defined as the proportion of reported clusters that have no true positives. Simply using threshold is not appropriate, as the cluster- and window-level FDRs are not equivalent. This function also differs from the standard pipeline that is based on combineTests. Specifically, region definition in combineTests must be independent of DB so that precise coordinates of the DB subinterval cannot be reported. This is overcome here, by clustering directly on DB windows and applying post-hoc control of the cluster-level FDR. Note that the calculation of the cluster-level FDR here is not statistically rigorous. In particular, the observed number of false positive tests is estimated based on threshold and the total number of significant tests. This is not guaranteed to be an upper bound, especially with few or correlated tests. Thus, users should use the standard combineTests-based pipeline wherever possible. Clustering on significant windows should only be performed where the precise coordinates of the DB subinterval are important for interpretation.

It returns:

- `clusterFDR`: a number as the cluster-level FDR.
- `threshold`: the windowlevel FDR threshold to control the cluster-level FDR near target
- `FDR`: the estimate of the cluster-level FDR corresponding to threshold.


Combines p-values across clustered tests using Simes’ method to control the cluster FDR
=======================================================================================

This method uses Simes’ procedure to compute the combined p-value for each cluster of tests with the same value of ids. Each combined p-value represents evidence against the global null hypothesis, i.e., all individual nulls are true in each cluster. This may be more relevant than examining each test individually when multiple tests in a cluster represent parts of the same underlying event, e.g.,
genomic regions consisting of clusters of windows. The BH method is also applied to control the FDR across all clusters. 

The importance of each test within a cluster can be adjusted by supplying different relative weight values. This may be useful for downweighting low-confidence tests, e.g., those in repeat regions. In Simes’ procedure, weights are interpreted as relative frequencies of the tests in each cluster. Note that these weights have no effect between clusters and will not be used to adjust the computed FDR.

By default, the relevant fields in tab are identified by matching the column names to their expected values. Multiple fields in tab containing the logFC substring are allowed, e.g., to accommodate ANOVA-like contrasts. 

A simple clustering approach for windows is provided in mergeWindows. However, anything can be used so long as it is independent of the p-values and does not compromise type I error control, e.g., promoters, gene bodies, independently called peaks. Any tests with NA values for ids will be ignored.

It returns:

A DataFrame with one row per cluster and various fields (Each row is named according to the ID of the corresponding cluster):

- `nWindows`: specifying the total number of windows in each cluster
- `*.up and *.down`: for each log-FC column in tab, containing the number of windows with log-FCs above 0.5 or below -0.5, respectively
- `PValue`: combined p-value
- `FDR`: containing the q-value corresponding to the combined p-value
- `direction`: specifying the dominant direction of change for windows in each cluster.


Find the test with the strongest evidence for rejection of the null in each cluster
===================================================================================

Clusters are identified as those tests with the same value of ids (any NA values are ignored). By perfroming selection on corrected p-values, the tool identifies the test with the lowest p-value as that with the strongest evidence against the null in each cluster. The p-value of the chosen test is adjusted using the Bonferroni correction, based on the total number of tests in the parent cluster. This is necessary to obtain strong control of the family-wise error rate such that the best test can be taken from each cluster for further consideration.

The importance of each window in each cluster can be adjusted by supplying different relative weight values. Each weight is interpreted as a different threshold for each test in the cluster. Larger weights correspond to lower thresholds, i.e., less evidence is needed to reject the null for tests deemed to be more important. This may be useful for upweighting particular tests, e.g., windows containing a motif for the TF of interest.

Note the difference between this function and combineTests. The latter presents evidence for any rejections within a cluster. This function specifies the exact location of the rejection in the cluster, which may be more useful in some cases but at the cost of conservativeness. In both cases, clustering procedures such as mergeWindows can be used to identify the cluster.

If perfrom selection on corrected p-values is not selected, the best test is defined as that with the highest log-CPM value. This should be independent of the p-value so no adjustment is necessary. Weights are not applied here. This mode may be useful when abundance is correlated to rejection under the alternative hypothesis, e.g., picking high-abundance regions that are more likely to contain peaks.

It returns:

A DataFrame with one row per cluster.

- `best`: the index for the best test in the cluster
- `PValue`: the (possibly adjusted) p-value for that test
- `FDR`:  the q-value corresponding to the adjusted p-value
- `logFC`: logFC values
- `logCPM`: logCPM values

Compute assorted statistics for overlaps between windows and regions in a Hits object
=====================================================================================

 The method provide convenient wrappers around combineTests, getBestTest, empiricalFDR, mixedClusters and upweightSummit for handling overlaps between windows and arbitrary prespecified regions. They accept Hits objects produced by running findOverlaps between regions (as query) and windows (as subject). Each set of windows overlapping a region is defined as a cluster to compute various statistics.

A wrapper is necessary as a window may overlap multiple regions. If so, the multiple instances of that window are defined as distinct “overlapped” windows, where each overlapped window is assigned to a different region. Each overlapped window is represented by a row of olap. In contrast, the “individual” window just refers to the window itself, regardless of what it overlaps. This is represented by each row of the RangedSummarizedExperiment object and the tab derived from it.

For combineOverlaps, getBestOverlaps, empiricalOverlaps and mixedOverlaps, it returns:

A dataframe from their respective wrapped functions. Each row of the dataframe corresponds to a region, where regions without overlapped windows are assigned NA values.

For summitOverlaps, it returns:

- `weights`: a column of weights. This can be used as weights for each overlapped window in the other two functions

Upweight the highest-abudance window(s) in a cluster
====================================================

This function computes weights for each window in a cluster, where the highest-abundance windows are upweighted. These weights are intended for use in combineTests, such that the summits of a cluster have a greater influence on the combined p-value. This is more graduated than simply using the summits alone, as potential DB between summits can still be detected. 

Summits can be obtained through findMaxima or by running getBestTest. The exact value of the weight is arbitrary. Greater weight represents a stronger belief that DB occurs at the most abundant window. Here, the weighting scheme is designed such that the maximum Simes correction is not more than twice that without weighting. It will also be no more than twice that from applying Simes’ method on the summits alone. This (restrained) conservativeness is an acceptable cost for considering DB events elsewhere in the cluster, while still focusing on the most abundant site.

It returns:

- `weights`: numeric column of weights, where the highest-abundance window in each cluster is assigned a greater weight. Any windows with NA values for ids or summits will have a weight of zero.
    ]]></help>
    <expand macro="citations" />
</tool>