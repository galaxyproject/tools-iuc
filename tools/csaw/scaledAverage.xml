<tool id="csaw_scaledAverage" name="scaledAverage" version="@VERSION@.0">
  <description>computes the scaled average abundance</description>
  <macros>
    <import>csaw_macros.xml</import>
  </macros>
  <expand macro="requirements" />
  <command detect_errors="exit_code"><![CDATA[
    Rscript '$script']]>
  </command>
  <configfiles>
    <configfile name="script"><![CDATA[
## Setup R error handling to go to stderr
options(show.error.messages=F, error=function(){cat(geterrmessage(),file=stderr());q("no",1,F)})
loc <- Sys.setlocale("LC_MESSAGES", "en_US.UTF-8")

## Import library
library(csaw)
library(Rsamtools)

#if str($data_select.data_selector) == "windowCounts"
  @WINDOWCOUNTS_SELECT@
  data <- window_counts
#else
  @REGIONCOUNTS_SELECT@
  data <- region_counts
#end if

scale <- as.numeric("$scale")

#if str($prior_count) != ""
  prior_count <- as.numeric($prior_count)
#else
  prior_count <- NULL
#end if

#if str($dispersion) != ""
  dispersion <- as.numeric($dispersion)
#else
  dispersion <- NULL
#end if

assay_id <- as.numeric(gsub("([0-9]+).*$", "\\1", "$assay_id"))
if (is.na(assay_id)){
  assay_id <- "$assay_id"
}

result <- scaledAverage(data, scale=scale, prior.count=prior_count, dispersion=dispersion, assay.id=assay_id)
write.table(result, "$output", quote = FALSE, col.names = FALSE, row.names = FALSE)
]]>
    </configfile>
  </configfiles>
  <inputs>
    <conditional name="data_select">
      <param name="data_selector" type="select" label="Create a RangedSummarizedExperiment object by windowCounts or regionCounts?">
        <option value="windowCounts">windowCounts</option>
        <option value="regionCounts">regionCounts</option>
      </param>
      <when value="windowCounts">
        <expand macro="windowCounts" />
      </when>
      <when value="regionCounts">
        <expand macro="regionCounts" />
      </when>
    </conditional>
    <param name="scale" type="float" value="1" label="Indicate the magnitude with which each abundance is to be downscaled" help="For example, if scale=2, the average count is halved, i.e., the returned abundances are decreased by 1 (as they are log2-transformed values)." />
    <param name="prior_count" type="float" value="" optional="true" label="Specify the prior count to add" />
    <param name="dispersion" type="float" value="" optional="true" label="Specify the dispersion for GLM fitting" />
    <param name="assay_id" type="text" value="counts" label="Indicate which assay of y contains the counts" />
  </inputs>
  <outputs>
    <data name="output" format="txt" label="${tool.name} on ${on_string}: output" />
  </outputs>
  <tests>
    <test>
      <conditional name="data_select">
      <param name="data_selector" value="windowCounts"/>
        <repeat name="bam_input">
          <param name="bam_file" value="rep1.bam" ftype="bam" />
        </repeat>
        <repeat name="bam_input">
          <param name="bam_file" value="rep2.bam" ftype="bam" />
        </repeat>
        <param name="width" value="50" />
        <param name="filter" value="1" />
      </conditional>
      <param name="scale" value="4" />
      <param name="prior_count" value="5" />
      <param name="dispersion" value="1" />
      <param name="assay_id" value="counts" />
      <output name="output" value="scaledAverage_output1.txt" />
    </test>
    <test>
      <conditional name="data_select">
        <param name="data_selector" value="regionCounts"/>
          <repeat name="bam_input">
            <param name="bam_file" value="rep1.bam" ftype="bam" />
          </repeat>
          <repeat name="bam_input">
            <param name="bam_file" value="rep2.bam" ftype="bam" />
          </repeat>
          <param name="GRanges" value="scaledAvg_regions.tabular" />
          <param name="named" value="true" />
          <conditional name="ext_selector">
            <param name="ext_select" value="integer" />
            <param name="ext" value="100" />
          </conditional>
          <conditional name="readParam_select">
              <param name="readParam_selector" value="no" />
          </conditional>
      </conditional>
      <param name="scale" value="4" />
      <param name="prior_count" value="5" />
      <param name="dispersion" value="1" />
      <param name="assay_id" value="counts" />
      <output name="output" value="scaledAverage_output2.txt" />
    </test>
    <test>
      <conditional name="data_select">
        <param name="data_selector" value="regionCounts"/>
          <repeat name="bam_input">
            <param name="bam_file" value="rep1.bam" ftype="bam" />
          </repeat>
          <repeat name="bam_input">
            <param name="bam_file" value="rep2.bam" ftype="bam" />
          </repeat>
          <param name="GRanges" value="scaledAvg_regions.tabular" />
          <param name="named" value="true" />
          <conditional name="ext_selector">
            <param name="ext_select" value="integer" />
            <param name="ext" value="100" />
          </conditional>
          <conditional name="readParam_select">
            <param name="readParam_selector" value="yes" />
            <param name="pe" value="none" />
            <param name="max_frag" value="500" />
            <param name="dedup" value="false" />
            <param name="minq" value="" />
            <param name="forward" value="NA" />
            <param name="restrict" value="chrB" />
            <conditional name="discard_select">
              <param name="discard" value="no" />
            </conditional>
          </conditional>
      </conditional>
      <param name="scale" value="4" />
      <param name="prior_count" value="5" />
      <param name="dispersion" value="1" />
      <param name="assay_id" value="counts" />
      <output name="output" value="scaledAverage_output3.txt" />
    </test>
  </tests>
  <help><![CDATA[
    Compute the scaled average abundance for each feature.

    This function computes the average abundance of each feature in the SummarizedExperiment object containing a count matrix, and downscales it according to scale. The aim is to set scale based on the relative width of regions, to allow abundances to be compared between regions of different size.

    This function mimics the behaviour of aveLogCPM but handles the prior.count with some subtlety. Specifically, it scales up the prior count by scale before adding it to the counts. This ensures that the “effective” prior is the same after the abundance is scaled down. Otherwise, the use of the same prior would incorrectly result in a smaller abundance for larger regions, regardless of the read density.

    An additional difference from aveLogCPM is that the prior count is not scaled up before being added to the library sizes/offsets. (See addPriorCount for more details.) This ensures that the modified offsets do not depend on scale, which allows abundances to be compared between regions of differing size. Otherwise, larger regions with greater scale would always have (slightly) larger modified offsets and lower abundances than appropriate.

    Note that the adjustment for width assumes that reads are uniformly distributed throughout each region. This is reasonable for most background regions, but may not be for enriched regions. When the distribution is highly heterogeneous, the downscaled abundance of a large region will not be an accurate representation of the abundance of the smaller regions nested within.
    ]]></help>
  <expand macro="citations" />
</tool>