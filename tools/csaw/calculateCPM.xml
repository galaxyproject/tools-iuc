<tool id="csaw_calculateCPM" name="calculateCPM" version="@VERSION@.0">
    <description>calculates CPM values</description>
    <macros>
       <import>csaw_macros.xml</import>
    </macros>
    <expand macro="requirements" />
    <command detect_errors="exit_code"><![CDATA[
        Rscript '$script'
    ]]></command>
    <configfiles><configfile name="script"><![CDATA[
## Setup R error handling to go to stderr
options(show.error.messages=F, error=function(){cat(geterrmessage(),file=stderr());q("no",1,F)})
loc <- Sys.setlocale("LC_MESSAGES", "en_US.UTF-8")

## Import library
library(csaw)
library(Rsamtools)

#if str($method_select.method) == "calculateCPM"
    @WINDOWCOUNTS_METHOD@

    object <- window_counts

    #if str($method_select.calculateCPM.log_select.log_selector) == "yes"
        log <- TRUE
        use_norm_factors <- FALSE
        use_offsets <- FALSE
        prior_count <- as.numeric("$method_select.calculateCPM.log_select.prior_count")
    #else
        log <- FALSE
        #if str($method_select.calculateCPM.log_select.use_norm_factors) == "true"
            use_norm_factors <- TRUE
        #else
            use_norm_factors <- FALSE
        #end if

        #if str($method_select.calculateCPM.log_select.use_offsets) == "true"
            use_offsets <- TRUE
        #else
            use_offsets <- FALSE
        #end if
        prior_count <- 1
    #end if

    #if str($method_select.calculateCPM.assay_id) != ''
        assay_id <- "$method_select.calculateCPM.assay_id"
    #else
        assay_id <- "counts"
    #end if

    result <- calculateCPM(object, use.norm.factors=use_norm_factors, use.offsets=use_offsets, log=log, prior.count=prior_count, assay.id=assay_id)

    write.table(result, "$calculateCPM_output", row.names=FALSE, col.names=FALSE)
#else if str($method_select.method) == "checkBimodality"
    bamFiles <- c()
    #for $i in $method_select.bam_input
        bamFiles <- c(bamFiles, '$i.bam_file')
    #end for
    indexBam(bamFiles)

    @GRANGES_METHOD@

    w <- as.numeric("$method_select.width")

    @READPARAM_METHOD@

    prior_count <- as.numeric("$method_select.prior_count")
    #if str($method_select.invert) == ''
        inver <- F
    #else
        inver <- T
    #end if
            
    scores <- checkBimodality(bamFiles, regions, width=w, param=p, prior.count=prior_count, invert=inver)
    scores <- list(scores)
    write.table(scores, file="$checkBimodality_output", quote = FALSE, row.names = FALSE, col.names = FALSE)
#else if str($method_select.method) == "combineTests"
    ids <-scan("$method_select.ids", what = integer())
    tab <- read.table("$method_select.tab", sep="", header=T)
    #if str($method_select.weight_select.weight_selector) == "yes"
        w <- scan("$method_select.weight_select.weight", what=numeric())
    #else
        w <- NULL
    #end if
    @COLNAMES_METHOD@
    result <- combineTests(ids, tab, weight=w, pval.col=pval_col, fc.col=fc_col)
    write.table(result, file="$combineTests_output", quote = FALSE, row.names=FALSE)
#end if
]]>
        </configfile>
    </configfiles>
    <inputs>
        <conditional name="method_select">
            <param name="method" type="select" label="Method" >
                <option value="calculateCPM">Calculate counts-per-million (CPM) values for each feature</option>
                <option value="checkBimodality">Compute the maximum bimodality score across all base pairs in each region</option>
                <option value="combineTests">Combines p-values across clustered tests using Simes’ method to control the cluster FDR</option>
                <option value="filterWindows">Compute filter statistics for windows, based on proportions or using enrichment over background</option>
                <option value="findMaxima">Find the local maxima for a given set of genomic regions</option>
                <option value="getBestTest">Find the test with the strongest evidence for rejection of the null in each cluster</option>
                <option value="getPESizes">Compute the length of the sequenced fragment for each read pair in paired-end tag (PE) data</option>
                <option value="getWidths">Get the widths of the read counting interval for each region</option>
                <option value="overlapStats">Compute assorted statistics for overlaps between windows and regions in a Hits object</option>
                <option value="scaledAverage">Compute the scaled average abundance for each feature</option>
                <option value="strandedCounts">Obtain strand-specific counts for each genomic window or region</option>
            </param>
            <when value="calculateCPM">
                <section name="windowCounts" title="Count reads overlapping each window" expanded="true">
                  <expand macro="windowCounts" />
                </section>
                <section name="calculateCPM" title="Calculates counts-per-million values" expanded="true">
                    <conditional name="log_select">
                        <param name="log_selector" type="select" label="Return log2-transformed CPM values?" help="CPMs are calculated in the standard manner when log2-transformed CPM values are not returned, use normalization factors and use offsets are false. Otherwise, if log2-transformed CPM values are returned, then a library size-adjusted prior count is added to both the counts and the library sizes. This is done after addition of a prior count to both the counts and library sizes.">
                            <option value="yes" selected="true">Yes</option>
                            <option value="no">No</option>
                        </param>
                        <when value="yes">
                            <param name="prior_count" type="float" value="1" label="Prior count to add" />
                        </when>
                        <when value="no">
                            <param name="use_norm_factors" type="boolean" truevalue="true" falsevalue="" checked="true" label="Use normalization factors?" help="If yes is selected the effective library size is used for computing CPMs, provided that normalization factors are available in the object. This is defined as the product of the library size and the normalization factor." />
                            <param name="use_offsets" type="boolean" truevalue="true" falsevalue="" checked="false" label="Use offsets?" help="If yes is selected the offsets are converted into effective library sizes using scaleOffset." />
                        </when>
                    </conditional>
                    <param name="assay_id" type="text" value="counts" optional="true" label="Indicate which assay of y contains the counts" />
                </section>
            </when>
            <when value="checkBimodality">
                <repeat name="bam_input" title="Upload indexed BAM files in sorted order" >
                    <param name="bam_file" type="data" format="bam" label="BAM file" />
                </repeat>
                <expand macro="gRanges" />
                <param name="width" type="integer" value="100" label="Span with which to compute bimodality" />
                <expand macro="readParam_select" />
                <param name="prior_count" type="integer" value="2" label="Prior count to compute bimodality scores" />
                <param name="invert" type="boolean" truevalue="true" falsevalue="" checked="false" label="Invert bimodality score?" />
            </when> 
            <when value="combineTests"> 
                <param name="ids" type="data" format="tabular" label="Cluster ID for each test" help="Upload as a dataframe where each row is an integer." />
                <param name="tab" type="data" format="tabular" label="Dataframe of results with PValue and at least one logFC field for each test" />
                <conditional name="weight_select">
                  <param name="weight_selector" type="select" label="Specify weights for each window?" help="If none specified, the weight defaults to 1 for each test. Supplying different relative weight values may be useful for downweighting low-confidence tests, e.g., those in repeat regions. In Simes’ procedure, weights are interpreted as relative frequencies of the tests in each cluster.">
                    <option value="yes">Yes</option>
                    <option value="no" selected="true">No</option>
                  </param>
                  <when value="yes">
                    <param name="weight" type="data" format="tabular" label="Weights for each window" help="Upload as a dataframe where each row is a numeric value." />
                  </when>
                  <when value="no"> </when>
                </conditional>
                <expand macro="col_names" />
            </when>
            <when value="filterWindows"> </when>
            <when value="findMaxima"> </when>
            <when value="getBestTest"> </when>
            <when value="getPESizes"> </when>
            <when value="getWidths"> </when>
            <when value="overlapStats"> </when>
            <when value="scaledAverage"> </when>
            <when value="strandedCounts"> </when>
        </conditional>
    </inputs>

    <outputs>
        <data name="calculateCPM_output" format="txt" label="calculateCPM on ${on_string}: output">
             <filter>method_select['method'] == 'calculateCPM'</filter>
        </data>
        <data name="checkBimodality_output" format="txt" label="checkBimodality on ${on_string}: output">
             <filter>method_select['method'] == 'checkBimodality'</filter>
        </data>
        <data name="combineTests_output" format="txt" label="combineTests on ${on_string}: output">
             <filter>method_select['method'] == 'combineTests'</filter>
        </data>
    </outputs>

    <tests>
        <!--<test expect_num_outputs="1">
            <conditional name="method_select">
                <param name="method" value="calculateCPM" />
                <section name="windowCounts">
                    <repeat name="bam_input">
                        <param name="bam_file" value="rep1.bam" ftype="bam" />
                    </repeat>
                    <repeat name="bam_input">
                        <param name="bam_file" value="rep2.bam" ftype="bam" />
                    </repeat>
                    <param name="spacing" value="50" />
                    <param name="width" value="50" />
                    <conditional name="ext_selector">
                        <param name="ext_select" value="integer" />
                        <param name="ext" value="100" />
                    </conditional>
                    <param name="shift" value="0" />
                    <param name="filter" value="1" />
                    <param name="bin" value="false" />
                    <conditional name="readParam_select">
                        <param name="readParam_selector" value="no" />
                    </conditional>
                </section>
                <section name="calculateCPM">
                    <conditional name="log_select">
                        <param name="log_selector" value="no"/>
                        <param name="use_norm_factors" value="true" />
                    <param name="use_offsets" value="false" />
                    </conditional>
                    <param name="assay_id" value="counts" />
                </section>
            </conditional>
            <output name="calculateCPM_output" value="calculateCPM_output0.txt" />
        </test>
        <test expect_num_outputs="1">
            <conditional name="method_select">
                <param name="method" value="calculateCPM" />
                <section name="windowCounts">
                    <repeat name="bam_input">
                        <param name="bam_file" value="rep1.bam" ftype="bam" />
                    </repeat>
                    <repeat name="bam_input">
                        <param name="bam_file" value="rep2.bam" ftype="bam" />
                    </repeat>
                    <param name="spacing" value="50" />
                    <param name="width" value="50" />
                    <conditional name="ext_selector">
                        <param name="ext_select" value="integer" />
                        <param name="ext" value="100" />
                    </conditional>
                    <param name="shift" value="0" />
                    <param name="filter" value="1" />
                    <param name="bin" value="false" />
                    <conditional name="readParam_select">
                        <param name="readParam_selector" value="no" />
                    </conditional>
                </section>
                <section name="calculateCPM">
                    <conditional name="log_select">
                        <param name="log_selector" value="yes"/>
                        <param name="prior_count" value="1" />
                    </conditional>
                    <param name="assay_id" value="counts" />
                </section>
            </conditional>
            <output name="calculateCPM_output" value="calculateCPM_output1.txt" />
        </test>
        <test expect_num_outputs="1">
            <conditional name="method_select">
                <param name="method" value="calculateCPM" />
                <section name="windowCounts">
                    <repeat name="bam_input">
                        <param name="bam_file" value="rep1.bam" ftype="bam" />
                    </repeat>
                    <repeat name="bam_input">
                        <param name="bam_file" value="rep2.bam" ftype="bam" />
                    </repeat>
                    <param name="spacing" value="50" />
                    <param name="width" value="50" />
                    <conditional name="ext_selector">
                        <param name="ext_select" value="list" />
                        <param name="ext_list1" value="50, 100" />
                        <param name="ext_list2" value="80" />
                    </conditional>
                    <param name="shift" value="0" />
                    <param name="filter" value="1" />
                    <param name="bin" value="false" />
                    <conditional name="readParam_select">
                        <param name="readParam_selector" value="no" />
                    </conditional>
                </section>
                <section name="calculateCPM">
                    <conditional name="log_select">
                        <param name="log_selector" value="yes"/>
                        <param name="prior_count" value="1" />
                    </conditional>
                    <param name="assay_id" value="counts" />
                </section>
            </conditional>
            <output name="calculateCPM_output" value="calculateCPM_output2.txt" />
        </test>
        <test expect_num_outputs="1">
            <conditional name="method_select">
                <param name="method" value="calculateCPM" />
                <section name="windowCounts">
                    <repeat name="bam_input">
                        <param name="bam_file" value="rep1.bam" ftype="bam" />
                    </repeat>
                    <repeat name="bam_input">
                        <param name="bam_file" value="rep2.bam" ftype="bam" />
                    </repeat>
                    <param name="spacing" value="50" />
                    <param name="width" value="50" />
                    <conditional name="ext_selector">
                        <param name="ext_select" value="integer" />
                        <param name="ext" value="100" />
                    </conditional>
                    <param name="shift" value="0" />
                    <param name="filter" value="1" />
                    <param name="bin" value="false" />
                    <conditional name="readParam_select">
                        <param name="readParam_selector" value="yes" />
                        <param name="pe" value="none" />
                        <param name="max_frag" value="500" />
                        <param name="dedup" value="false" />
                        <param name="minq" value="1" />
                        <param name="forward" value="NA" />
                        <param name="restrict" value="chrA" />
                        <conditional name="discard_select">
                            <param name="discard" value="no" />
                        </conditional>
                    </conditional>
                </section>
                <section name="calculateCPM">
                    <conditional name="log_select">
                        <param name="log_selector" value="yes"/>
                        <param name="prior_count" value="1" />
                    </conditional>
                    <param name="assay_id" value="counts" />
                </section>
            </conditional>
            <output name="calculateCPM_output" value="calculateCPM_output3.txt" />
        </test>
        <test expect_num_outputs="1">
            <conditional name="method_select">
                <param name="method" value="calculateCPM" />
                <section name="windowCounts">
                    <repeat name="bam_input">
                        <param name="bam_file" value="rep1.bam" ftype="bam" />
                    </repeat>
                    <repeat name="bam_input">
                        <param name="bam_file" value="rep2.bam" ftype="bam" />
                    </repeat>
                    <param name="spacing" value="50" />
                    <param name="width" value="50" />
                    <conditional name="ext_selector">
                        <param name="ext_select" value="integer" />
                        <param name="ext" value="100" />
                    </conditional>
                    <param name="shift" value="0" />
                    <param name="filter" value="1" />
                    <param name="bin" value="false" />
                    <conditional name="readParam_select">
                        <param name="readParam_selector" value="yes" />
                        <param name="pe" value="none" />
                        <param name="max_frag" value="500" />
                        <param name="dedup" value="false" />
                        <param name="minq" value="1" />
                        <param name="forward" value="NA" />
                        <param name="restrict" value="chrA" />
                        <conditional name="discard_select">
                            <param name="discard" value="yes" />
                            <param name="GRanges" value="gRange_discard.tabular" />
                            <param name="named" value="false" />
                        </conditional>
                    </conditional>
                </section>
                <section name="calculateCPM">
                    <conditional name="log_select">
                        <param name="log_selector" value="yes"/>
                        <param name="prior_count" value="1" />
                    </conditional>
                    <param name="assay_id" value="counts" />
                </section>
            </conditional>
            <output name="calculateCPM_output" value="calculateCPM_output4.txt" />
        </test>
        <test expect_num_outputs="1">
            <conditional name="method_select">
                <param name="method" value="checkBimodality" />
                <repeat name="bam_input">
                    <param name="bam_file" value="rep1.bam" ftype="bam" />
                </repeat>
                <repeat name="bam_input">
                    <param name="bam_file" value="rep2.bam" ftype="bam" />
                </repeat>
                <param name="GRanges" value="gRange_regions.tabular" />
                <param name="named" value="false" />
                <param name="width" value="200" />
                <conditional name="readParam_select">
                    <param name="readParam_selector" value="no" />
                </conditional>
                <param name="prior_count" value="5" />
                <param name="invert" value="false" />
            </conditional>
            <output name="checkBimodality_output" file="checkBiomodality_output1.txt" />
        </test>
        <test expect_num_outputs="1">
            <conditional name="method_select">
                <param name="method" value="checkBimodality" />
                <repeat name="bam_input">
                    <param name="bam_file" value="rep1.bam" ftype="bam" />
                </repeat>
                <repeat name="bam_input">
                    <param name="bam_file" value="rep2.bam" ftype="bam" />
                </repeat>
                <param name="GRanges" value="gRange_regions.tabular" />
                <param name="named" value="false" />
                <param name="width" value="200" />
                <conditional name="readParam_select">
                    <param name="readParam_selector" value="yes" />
                    <param name="pe" value="both" />
                    <param name="max_frag" value="100" />
                    <param name="dedup" value="false" />
                    <param name="minq" value="20" />
                    <param name="forward" value="NA" />
                    <param name="restrict" value="" />
                    <conditional name="discard_select">
                        <param name="discard" value="no" />
                    </conditional>
                </conditional>
                <param name="prior_count" value="5" />
                <param name="invert" value="False" />
            </conditional>
            <output name="checkBimodality_output" file="checkBiomodality_output2.txt" />
        </test>
        <test expect_num_outputs="1">
            <conditional name="method_select">
                <param name="method" value="checkBimodality" />
                <repeat name="bam_input">
                    <param name="bam_file" value="rep1.bam" ftype="bam" />
                </repeat>
                <repeat name="bam_input">
                    <param name="bam_file" value="rep2.bam" ftype="bam" />
                </repeat>
                <param name="GRanges" value="gRange_regions.tabular" />
                <param name="named" value="false" />
                <param name="width" value="200" />
                <conditional name="readParam_select">
                    <param name="readParam_selector" value="yes" />
                    <param name="pe" value="both" />
                    <param name="max_frag" value="100" />
                    <param name="dedup" value="false" />
                    <param name="minq" value="20" />
                    <param name="forward" value="NA" />
                    <param name="restrict" value="chrA" />
                    <conditional name="discard_select">
                        <param name="discard" value="yes" />
                        <param name="GRanges" value="gRange_discard.tabular" />
                        <param name="named" value="false" />
                    </conditional>
                </conditional>
                <param name="prior_count" value="5" />
                <param name="invert" value="False" />
            </conditional>
            <output name="checkBimodality_output" file="checkBiomodality_output3.txt" />
        </test>-->
        <test expect_num_outputs="1">
            <conditional name="method_select">
                <param name="method" value="combineTests" />
                <param name="ids" value="comTest_ids.tabular" />
                <param name="tab" value="comTest_tab.tabular" />
                <conditional name="weight_select">
                    <param name="weight_selector" value="no" />
                </conditional>
                <param name="pval_col" value="PValue" />
                <param name="fc_col" value="logFC.whee" />
            </conditional>
            <output name="combineTests_output" value="combineTests_output.txt" />
        </test>
        <test expect_num_outputs="1">
            <conditional name="method_select">
                <param name="method" value="combineTests" />
                <param name="ids" value="comTest_ids.tabular" />
                <param name="tab" value="comTest_tab.tabular" />
                <conditional name="weight_select">
                    <param name="weight_selector" value="yes" />
                    <param name="weight" value="comTest_w.tabular" />
                </conditional>
                <param name="pval_col" value="PValue" />
                <param name="fc_col" value="logFC.whee" />
            </conditional>
            <output name="combineTests_output" value="combineTests_output2.txt" />
        </test>
    </tests>
    <help><![CDATA[
Calculate counts-per-million (CPM) values for each feature
==========================================================

It returns:

- `CPM values`: A matrix of the same dimensions as object, containing (log-)transformed CPM values for each feature in each sample


Compute the maximum bimodality score across all base pairs in each region
=========================================================================

Consider a base position x. This function counts the number of forward- and reverse-strand reads within the interval [x-width+1, x]. It then calculates the forward:reverse ratio after adding prior.count to both counts. This is repeated for the interval [x, x+width-1], and the reverse:forward ratio is then computed. The smaller of these two ratios is used as the bimodality score. Sites with high bimodality scores will be enriched for forward- and reverse-strand enrichment on the left and right of the site, respectively. Given a genomic region, this function will treat each base position as a site. The largest bimodality score across all positions will be reported for each region. The idea is to assist with the identification of transcription factor binding sites, which exhibit strong strand bimodality. The function will be less useful for broad targets like histone marks. If multiple bam.files are specified, they are effectively pooled so that counting uses all reads in all files. A separate value of width can be specified for each library, to account for differences in fragmentation – see the ext argument for windowCounts for more details. In practice, this is usually unnecessary. Setting width to the average fragment length yields satisfactory results in most cases. If invert is set, the bimodality score will be flipped around, i.e., it will be maximized when reversestrand coverage dominates on the left, and forward-strand coverage dominates on the right. This is designed for use in CAGE analyses where this inverted bimodality is symptomatic of enhancer RNAs.

It returns:

- `Scores`: A column containing the maximum bimodality score (row) across all bases in each region (column)


Combines p-values across clustered tests using Simes’ method to control the cluster FDR
=======================================================================================

This method uses Simes’ procedure to compute the combined p-value for each cluster of tests with the same value of ids. Each combined p-value represents evidence against the global null hypothesis, i.e., all individual nulls are true in each cluster. This may be more relevant than examining each test individually when multiple tests in a cluster represent parts of the same underlying event, e.g.,
genomic regions consisting of clusters of windows. The BH method is also applied to control the FDR across all clusters. 

The importance of each test within a cluster can be adjusted by supplying different relative weight values. This may be useful for downweighting low-confidence tests, e.g., those in repeat regions. In Simes’ procedure, weights are interpreted as relative frequencies of the tests in each cluster. Note that these weights have no effect between clusters and will not be used to adjust the computed FDR.

By default, the relevant fields in tab are identified by matching the column names to their expected values. Multiple fields in tab containing the logFC substring are allowed, e.g., to accommodate ANOVA-like contrasts. 

A simple clustering approach for windows is provided in mergeWindows. However, anything can be used so long as it is independent of the p-values and does not compromise type I error control, e.g., promoters, gene bodies, independently called peaks. Any tests with NA values for ids will be ignored.

It returns:

A DataFrame with one row per cluster and various fields (Each row is named according to the ID of the corresponding cluster):

- `nWindows`: specifying the total number of windows in each cluster
- `*.up and *.down`: for each log-FC column in tab, containing the number of windows with log-FCs above 0.5 or below -0.5, respectively
- `PValue`: combined p-value
- `FDR`: containing the q-value corresponding to the combined p-value
- `direction`: specifying the dominant direction of change for windows in each cluster.


Compute filter statistics for windows, based on proportions or using enrichment over background
===============================================================================================

Find the local maxima for a given set of genomic regions
========================================================

Find the test with the strongest evidence for rejection of the null in each cluster
===================================================================================

Compute the length of the sequenced fragment for each read pair in paired-end tag (PE) data
===========================================================================================

Get the widths of the read counting interval for each region
============================================================

Compute assorted statistics for overlaps between windows and regions in a Hits object
=====================================================================================

Compute the scaled average abundance for each feature
=====================================================

Obtain strand-specific counts for each genomic window or region
===============================================================

Calculates counts-per-million values
====================================

    ]]></help>
    <expand macro="citations" />
</tool>