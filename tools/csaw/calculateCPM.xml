<tool id="csaw_statistics" name="Statistics" version="@VERSION@.0">
    <description>computes statistics</description>
    <macros>
       <import>csaw_macros.xml</import>
    </macros>
    <expand macro="requirements" />
    <command detect_errors="exit_code"><![CDATA[
        Rscript '$script'
    ]]></command>
    <configfiles><configfile name="script"><![CDATA[
## Setup R error handling to go to stderr
options(show.error.messages=F, error=function(){cat(geterrmessage(),file=stderr());q("no",1,F)})
loc <- Sys.setlocale("LC_MESSAGES", "en_US.UTF-8")

## Import library
library(csaw)
library(Rsamtools)

#if str($method_select.method) == "calculateCPM"
    @WINDOWCOUNTS_METHOD@

    object <- window_counts

    #if str($method_select.calculateCPM.log_select.log_selector) == "yes"
        log <- TRUE
        use_norm_factors <- FALSE
        use_offsets <- FALSE
        prior_count <- as.numeric("$method_select.calculateCPM.log_select.prior_count")
    #else
        log <- FALSE
        #if str($method_select.calculateCPM.log_select.use_norm_factors) == "true"
            use_norm_factors <- TRUE
        #else
            use_norm_factors <- FALSE
        #end if

        #if str($method_select.calculateCPM.log_select.use_offsets) == "true"
            use_offsets <- TRUE
        #else
            use_offsets <- FALSE
        #end if
        prior_count <- 1
    #end if

    #if str($method_select.calculateCPM.assay_id) != ''
        assay_id <- "$method_select.calculateCPM.assay_id"
    #else
        assay_id <- "counts"
    #end if

    result <- calculateCPM(object, use.norm.factors=use_norm_factors, use.offsets=use_offsets, log=log, prior.count=prior_count, assay.id=assay_id)

    write.table(result, "$calculateCPM_output", row.names=FALSE, col.names=FALSE)
#else if str($method_select.method) == "checkBimodality"
    bamFiles <- c()
    #for $i in $method_select.bam_input
        bamFiles <- c(bamFiles, '$i.bam_file')
    #end for
    indexBam(bamFiles)

    @GRANGES_METHOD@

    w <- as.numeric("$method_select.width")

    @READPARAM_METHOD@

    prior_count <- as.numeric("$method_select.prior_count")
    #if str($method_select.invert) == ''
        inver <- F
    #else
        inver <- T
    #end if
            
    scores <- checkBimodality(bamFiles, regions, width=w, param=p, prior.count=prior_count, invert=inver)
    scores <- list(scores)
    write.table(scores, file="$checkBimodality_output", quote = FALSE, row.names = FALSE, col.names = FALSE)
#else if str($method_select.method) == "combineTests"
    ids <-scan("$method_select.ids", what = integer())
    tab <- read.table("$method_select.tab", sep="", header=T)
    #if str($method_select.weight_select.weight_selector) == "yes"
        w <- scan("$method_select.weight_select.weight", what=numeric())
    #else
        w <- NULL
    #end if
    @COLNAMES_METHOD@
    result <- combineTests(ids, tab, weight=w, pval.col=pval_col, fc.col=fc_col)
    write.table(result, file="$combineTests_output", quote = FALSE, row.names=FALSE)
#else if str($method_select.method) == "filterWindows"
    #if str($method_select.filter_method_select.filter_method_selector) == "filterWindows"
        @WINDOWCOUNTS_FILTERWINDOWS_DATA@  

        data <- windowCounts(bamFiles, spacing=spacing, width=width, ext=ext, shift=shift, filter=filter, bin=bin, param=p)
        type <- "$method_select.filter_method_select.type"

        #if str($method_select.filter_method_select.assay_data) != "counts"
            assay_data <- as.numeric(gsub("([0-9]+).*$", "\\1", "$method_select.filter_method_select.assay_data"))
            if (is.na(assay_data)){
                assay_data <- "$method_select.filter_method_select.assay_data"
            }
        #else
            assay_data <- "$method_select.filter_method_select.assay_data"
        #end if

        #if str($method_select.filter_method_select.assay_back) != "counts"
            assay_back <- as.numeric(gsub("([0-9]+).*$", "\\1", "$method_select.filter_method_select.assay_back"))
            if (is.na(assay_back)){
                assay_back <- "$method_select.filter_method_select.assay_back"
            }
        #else
            assay_back <- "$method_select.filter_method_select.assay_back"
        #end if

        prior_count <- as.numeric("$method_select.filter_method_select.prior_count")

        #if str($method_select.filter_method_select.scale_info_select.scale_info_selector) == "yes"

            @WINDOWCOUNTS_FILTERWINDOWS_SCALE_DATA@

            data_scale_info <- windowCounts(bamFiles_scale_info, spacing=spacing_scale_info, width=width_scale_info, ext=ext_scale_info, shift=shift_scale_info, filter=filter_scale_info, bin=bin_scale_info, param=p_scale_info)

            @WINDOWCOUNTS_FILTERWINDOWS_SCALE_BG@

            scale_info <- scaleControlFilter(data_scale_info, background_scale_info)
        #else
            scale_info <- NULL
        #end if

        #if str($method_select.filter_method_select.background_select.background_selector) == "yes"
            @WINDOWCOUNTS_FILTERWINDOWS_BACKGROUND@

            result <- filterWindows(data, background, type=type, assay.data=assay_data, assay.back=assay_back, prior.count=prior_count, scale.info=scale_info)

            #if str($method_select.filter_method_select.type) != "proportion"
                write.table(result[[1]], file = "$filterW_abundances_output", quote = FALSE, col.names = FALSE, row.names=FALSE)
                write.table(result[[2]], file = "$filterW_back_abundances_output", quote = FALSE, col.names = FALSE, row.names=FALSE)
                write.table(result[[3]], file = "$filterW_filter_output", quote = FALSE, col.names = FALSE, row.names=FALSE)

                #if str($method_select.filter_method_select.keep_select.keep_selector) == "yes" 
                    keep <- result[[3]] > as.numeric("$method_select.filter_method_select.keep_select.keep")
                    new_data <- data[keep,]

                    #if str($method_select.filter_method_select.keep_select.keep_sum) == "true"
                        keep_sum <- sum(keep)
                        write.table(keep_sum, file = "$filterW_keepsum_output", quote = FALSE, col.names = FALSE, row.names=FALSE)
                    #end if
                #end if

            #else
                write.table(result[[1]], file = "$filterW_abundances_output", quote = FALSE, col.names = FALSE, row.names=FALSE)
                write.table(result[[2]], file = "$filterW_filter_output", quote = FALSE, col.names = FALSE, row.names=FALSE)

                    #if str($method_select.filter_method_select.keep_select.keep_selector) == "yes" 
                        keep <- result[[2]] > as.numeric("$method_select.filter_method_select.keep_select.keep")
                        new_data <- data[keep,]

                        #if str($method_select.filter_method_select.keep_select.keep_sum) == "true"
                            keep_sum <- sum(keep)
                            write.table(keep_sum, file = "$filterW_keepsum_output", quote = FALSE, col.names = FALSE, row.names=FALSE)
                        #end if
                    #end if
            #end if
        #else
            result <- filterWindows(data, type=type, assay.data=assay_data, assay.back=assay_back, prior.count=prior_count, scale.info=scale_info)
            write.table(result[[1]], file = "$filterW_abundances_output", quote = FALSE, col.names = FALSE, row.names=FALSE)
            write.table(result[[2]], file = "$filterW_filter_output", quote = FALSE, col.names = FALSE, row.names=FALSE)

            #if str($method_select.filter_method_select.keep_select.keep_selector) == "yes" 
                keep <- result[[2]] > as.numeric("$method_select.filter_method_select.keep_select.keep")
                new_data <- data[keep,]

                #if str($method_select.filter_method_select.keep_select.keep_sum) == "true"
                    keep_sum <- sum(keep)
                    write.table(keep_sum, file = "$filterW_keepsum_output", quote = FALSE, col.names = FALSE, row.names=FALSE)
                #end if
            #end if
        #end if
    #end if
#else if str($method_select.method) == "findMaxima"
    @GRANGES_METHOD@
    range <- as.numeric("$method_select.range")
    metric <- scan("$method_select.metric", what=numeric())
    #if str($method_select.ignore_strand) == 'true'
        ignore_strand <- TRUE
    #else
        ignore_strand <- FALSE
    #end if
    result <- findMaxima(regions, range, metric, ignore.strand=ignore_strand)
    write.table(result, file = "$findMaxima_output", quote = FALSE, col.names = FALSE, row.names=FALSE)
#else if str($method_select.method) == "getBestTest"
    ids <- scan("$method_select.ids", what = integer())
    tab <- read.table("$method_select.tab", header=TRUE)

    #if str($method_select.by_pval) == "true"
        by_pval <- TRUE
    #else
        by_pval <- FALSE
    #end if

    #if str($method_select.weight_select.weight_selector) == "yes"
        weight <- scan("$method_select.weight_select.weight", what = numeric())
    #else
        weight <- NULL
    #end if

    #if str($method_select.pval_col) != ''
        pval_col <- as.numeric(gsub("([0-9]+).*$", "\\1", "$method_select.pval_col"))
        if (is.na(pval_col)){
            pval_col <- "$method_select.pval_col"
        }
    #else
        pval_col <- NULL
    #end if
    #if str($method_select.cpm_col) != ''
        cpm_col <- as.numeric(gsub("([0-9]+).*$", "\\1", "$method_select.cpm_col"))
        if (is.na(cpm_col)){
            cpm_col <- "$method_select.cpm_col"
        }
    #else
        cpm_col <- NA
    #end if

    best <- getBestTest(ids, tab, by.pval=by_pval, weight=weight, pval.col=pval_col, cpm.col=cpm_col)
    write.table(best, "$getBestTest_output", quote = FALSE, col.names = TRUE, row.names=FALSE)
#else if str($method_select.method) == "getPESizes"
    bamFile <- "$method_select.bam_file"
    indexBam(bamFile)

    #if str($method_select.readParam_select.readParam_selector) == 'yes'
      pe <- "$method_select.readParam_select.pe"
      max_frag <- as.numeric("$method_select.readParam_select.max_frag")

      #if str($method_select.readParam_select.dedup) == ''
        ded_up <- F
      #else
        ded_up <- T
      #end if

      #if str($method_select.readParam_select.minq) != ''
        min_q <- as.numeric("$method_select.readParam_select.minq")
      #else
        min_q <- NA
      #end if

      #if str($method_select.readParam_select.forward) == 'NA'
        forward <- NA
      #else if str($method_select.readParam_select.forward) == 'forward'
        forward <- TRUE
      #else if str($method_select.readParam_select.forward) == 'reverse'
        forward <- FALSE
      #end if

      restrict <- as.character(unlist(strsplit(gsub(" ", "", "$method_select.readParam_select.restrict", ","), ",")))

      #if str($method_select.readParam_select.discard_select.discard) == 'yes'
        #if str($method_select.readParam_select.discard_select.named) == "true"
          data <- read.table("$method_select.readParam_select.discard_select.GRanges", header=T)
        #else
          data <- read.table("$method_select.readParam_select.discard_select.GRanges", header=F)
        #end if
        gRange <- data[[1]]
        start <- data[[2]]
        end <- data[[3]]
        discard <- GRanges(gRange, IRanges(start, end))
      #else
        discard <- GRanges()
      #end if
      p <- readParam(pe=pe, max.frag=max_frag, dedup=ded_up, minq=min_q, forward=forward, discard=discard, BPPARAM=SerialParam())
    #else
      p <- readParam(pe="both")
    #end if  

    result <- getPESizes(bamFile, param=p)

    write.table(result[[1]], "$getPESizes_sizes_output", quote = FALSE, col.names = FALSE, row.names=FALSE)
    write.table(result[[2]], "$getPESizes_diagnostics_output", quote = FALSE, col.names = FALSE, row.names=TRUE)
#else if str($method_select.method) == "getWidths"
    #if str($method_select.data_select.data_selector) == "windowCounts"
      @WINDOWCOUNTS_SELECT_METHOD@
      data <- window_counts
    #else
      @REGIONCOUNTS_SELECT_METHOD@
      data <- region_counts
    #end if

    result <- getWidths(data)
    write.table(result, "$getWidths_output", quote = FALSE, col.names = FALSE, row.names = FALSE)
#else if str($method_select.method) == "overlapStats"
    @WINDOWCOUNTS_METHOD@
    data <- window_counts

    ## Region of interest
    #if str($method_select.region.named) == "true"
      reg <- read.table("$method_select.region.GRanges", header=T)
    #else
      reg <- read.table("$method_select.region.GRanges", header=F)
    #end if
    gRange <- reg[[1]]
    start <- reg[[2]]
    end <- reg[[3]]
    regions <- GRanges(gRange, IRanges(start, end))

    olap <- findOverlaps(regions, rowRanges(data))
    tab <- read.table("$method_select.tab", sep="", header=T)

    #if str($method_select.output_select.output_selector) == 'combineOverlaps'
      @OVERLAPSTATS_W@
      result1 <- combineOverlaps(olap, tab , o.weight=o_weight, i.weight=i_weight)
      write.table(result1, "$overlapStats_output1", quote = FALSE, row.names=FALSE)
    #else if str($method_select.output_select.output_selector) == 'getBestOverlaps'
      @OVERLAPSTATS_W@
      result2 <- getBestOverlaps(olap, tab, o.weight=o_weight, i.weight=i_weight)
      write.table(result2, "$overlapStats_output2", quote = FALSE, row.names=FALSE)
    #else if str($method_select.output_select.output_selector) == 'empiricalOverlaps'
      @OVERLAPSTATS_W@
      result3 <- empiricalOverlaps(olap, tab, o.weight=o_weight, i.weight=i_weight)
      write.table(result3, "$overlapStats_output3", quote = FALSE, row.names=FALSE)
    #else if str($method_select.output_select.output_selector) == 'mixedOverlaps'
      @OVERLAPSTATS_W@
      result4 <- mixedOverlaps(olap, tab, o.weight=o_weight, i.weight=i_weight)
      write.table(result4, "$overlapStats_output4", quote = FALSE, row.names=FALSE)
    #else if str($method_select.output_select.output_selector) == 'summitOverlaps'
      region_best <- read.table("$overlapStats_output_select.region_best", sep="", header=T)
      #if str($method_select.output_select.o_summit_select.o_summit_selector) == 'boolean'
        o_summit <- scan("$method_select.output_select.o_summit_select.o_summit", what=logical())
      #else if str($method_select.output_select.o_summit_select.o_summit_selector) == 'integer'
        o_summit <- scan("$method_select.output_select.o_summit_select.o_summit", what=interger())
      #else
        o_summit <- NULL
      #end if
      #if str($method_select.output_select.i_summit_select.i_summit_selector) == 'boolean'
        i_summit <- scan("$method_select.output_select.i_summit_select.i_summit", what=logical())
      #else if str($method_select.output_select.i_summit_select.i_summit_selector) == 'integer'
        i_summit <- scan("$method_select.output_select.i_summit_select.i_summit", what=interger())
      #else
        i_summit <- NULL
      #end if
      result5 <- summitOverlaps(olap, region_best, o.summit=o_summit, i.summit=i_summit)
      write.table(result5, "$overlapStats_output5", quote = FALSE, col.names=FALSE, row.names=FALSE)
    #end if
#else 

#end if
]]>
        </configfile>
    </configfiles>
    <inputs>
        <conditional name="method_select">
            <param name="method" type="select" label="Method" >
                <option value="calculateCPM">Calculate counts-per-million (CPM) values for each feature</option>
                <option value="checkBimodality">Compute the maximum bimodality score across all base pairs in each region</option>
                <option value="combineTests">Combines p-values across clustered tests using Simes’ method to control the cluster FDR</option>
                <option value="filterWindows">Compute filter statistics for windows, based on proportions or using enrichment over background</option>
                <option value="findMaxima">Find the local maxima for a given set of genomic regions</option>
                <option value="getBestTest">Find the test with the strongest evidence for rejection of the null in each cluster</option>
                <option value="getPESizes">Compute the length of the sequenced fragment for each read pair in paired-end tag (PE) data</option>
                <option value="getWidths">Get the widths of the read counting interval for each region</option>
                <option value="overlapStats">Compute assorted statistics for overlaps between windows and regions in a Hits object</option>
                <option value="scaledAverage">Compute the scaled average abundance for each feature</option>
                <option value="strandedCounts">Obtain strand-specific counts for each genomic window or region</option>
            </param>
            <when value="calculateCPM">
                <section name="windowCounts" title="Count reads overlapping each window" expanded="true">
                  <expand macro="windowCounts" />
                </section>
                <section name="calculateCPM" title="Calculates counts-per-million values" expanded="true">
                    <conditional name="log_select">
                        <param name="log_selector" type="select" label="Return log2-transformed CPM values?" help="CPMs are calculated in the standard manner when log2-transformed CPM values are not returned, use normalization factors and use offsets are false. Otherwise, if log2-transformed CPM values are returned, then a library size-adjusted prior count is added to both the counts and the library sizes. This is done after addition of a prior count to both the counts and library sizes.">
                            <option value="yes" selected="true">Yes</option>
                            <option value="no">No</option>
                        </param>
                        <when value="yes">
                            <param name="prior_count" type="float" value="1" label="Prior count to add" />
                        </when>
                        <when value="no">
                            <param name="use_norm_factors" type="boolean" truevalue="true" falsevalue="" checked="true" label="Use normalization factors?" help="If yes is selected the effective library size is used for computing CPMs, provided that normalization factors are available in the object. This is defined as the product of the library size and the normalization factor." />
                            <param name="use_offsets" type="boolean" truevalue="true" falsevalue="" checked="false" label="Use offsets?" help="If yes is selected the offsets are converted into effective library sizes using scaleOffset." />
                        </when>
                    </conditional>
                    <param name="assay_id" type="text" value="counts" optional="true" label="Indicate which assay of y contains the counts" />
                </section>
            </when>
            <when value="checkBimodality">
                <repeat name="bam_input" title="Upload indexed BAM files in sorted order" >
                    <param name="bam_file" type="data" format="bam" label="BAM file" />
                </repeat>
                <expand macro="gRanges" />
                <param name="width" type="integer" value="100" label="Span with which to compute bimodality" />
                <expand macro="readParam_select" />
                <param name="prior_count" type="integer" value="2" label="Prior count to compute bimodality scores" />
                <param name="invert" type="boolean" truevalue="true" falsevalue="" checked="false" label="Invert bimodality score?" />
            </when> 
            <when value="combineTests"> 
                <param name="ids" type="data" format="tabular" label="Cluster ID for each test" help="Upload as a dataframe where each row is an integer." />
                <param name="tab" type="data" format="tabular" label="Dataframe of results with PValue and at least one logFC field for each test" />
                <conditional name="weight_select">
                  <param name="weight_selector" type="select" label="Specify weights for each window?" help="If none specified, the weight defaults to 1 for each test. Supplying different relative weight values may be useful for downweighting low-confidence tests, e.g., those in repeat regions. In Simes’ procedure, weights are interpreted as relative frequencies of the tests in each cluster.">
                    <option value="yes">Yes</option>
                    <option value="no" selected="true">No</option>
                  </param>
                  <when value="yes">
                    <param name="weight" type="data" format="tabular" label="Weights for each window" help="Upload as a dataframe where each row is a numeric value." />
                  </when>
                  <when value="no"> </when>
                </conditional>
                <expand macro="col_names" />
            </when>
            <when value="filterWindows">
                <conditional name="filter_method_select">
                    <param name="filter_method_selector" type="select" label="Filtering method" >
                        <option value="filterWindows">filterWindows</option>
                        <option value="scaleControlFilter">scaleControlFilter</option>
                    </param>
                    <when value="filterWindows">
                        <section name="data" title="Data: A RangedSummarizedExperiment object containing window-level counts" expanded="true">
                            <expand macro="windowCounts" />
                        </section>
                        <conditional name="background_select">
                            <param name="background_selector" type="select" label="Specify background defined by a RangedSummarizedExperiment for filtering?">
                                <option value="yes">Yes</option>
                                <option value="no" selected="true">No</option>
                            </param>
                            <when value="yes">                    
                                <section name="background" title="Background: A RangedSummarizedExperiment object" expanded="true">
                                    <conditional name="data_select">
                                        <param name="data_selector" type="select" label="Create a RangedSummarizedExperiment object by windowCounts or regionCounts?">
                                            <option value="windowCounts">windowCounts</option>
                                            <option value="regionCounts">regionCounts</option>
                                        </param>
                                        <when value="windowCounts">
                                            <expand macro="windowCounts" />
                                        </when>
                                        <when value="regionCounts">
                                            <expand macro="regionCounts" />
                                        </when>
                                    </conditional>
                                </section>
                            </when>
                            <when value="no"> </when>
                        </conditional>
                        <param name="type" type="select" label="Type of filtering to perfrom" help="When proportion is not selected the background RangedSummarizedExperiment object should contain counts for background regions" >
                            <option value="global" selected="true">global</option>
                            <option value="local">local</option>
                            <option value="control">control</option>
                            <option value="proportion">proportion</option>
                        </param>
                        <param name="assay_data" type="text" value="counts" label="Specify the assay containing window/bin counts in data" />
                        <param name="assay_back" type="text" value="counts" label="Specify the assay containing window/bin counts in background." />
                        <param name="prior_count" type="float" value="2" label="Specify the prior count to use in aveLogCPM" /> 
                        <conditional name="scale_info_select">
                            <param name="scale_info_selector" type="select" label="Include scaleControlFilter information?" help="i.e., a normalization factor and library sizes for ChIP and control samples.">
                                <option value="yes">Yes</option>
                                <option value="no" selected="true">No</option>
                            </param>
                            <when value="yes">
                                <section name="data" title="Data: A RangedSummarizedExperiment object containing bin-level counts" expanded="true">
                                    <expand macro="windowCounts" />
                                </section>
                                <section name="background" title="Background: A RangedSummarizedExperiment object containg bin-level counts for negative control samples" expanded="true">
                                    <conditional name="data_select">
                                        <param name="data_selector" type="select" label="Create a RangedSummarizedExperiment object by windowCounts or regionCounts?">
                                            <option value="windowCounts">windowCounts</option>
                                            <option value="regionCounts">regionCounts</option>
                                        </param>
                                        <when value="windowCounts">
                                            <expand macro="windowCounts" />
                                        </when>
                                        <when value="regionCounts">
                                            <expand macro="regionCounts" />
                                        </when>
                                    </conditional>
                                </section>
                            </when>
                            <when value="no"> </when>
                        </conditional>
                        <conditional name="keep_select">
                            <param name="keep_selector" type="select" label="Specify the percentage in decimals to filter out in count data?" >
                                <option value="yes">Yes</option>
                                <option value="no" selected="true">No</option>
                            </param>
                            <when value="yes">
                                <param name="keep" type="float" value="" label="Specify the percentage in decimals to filter out in count data" />
                                <param name="keep_sum" type="boolean" truevalue="true" falsevalue="" checked="false" label="Output the sum of the filtered count data?" />
                            </when>
                            <when value="no"> </when>
                        </conditional>      
                    </when>
                    <when value="scaleControlFilter">
                        <section name="data" title="Data: A RangedSummarizedExperiment object containing bin-level counts" expanded="true">
                            <expand macro="windowCounts" />
                        </section>
                        <section name="background" title="Background: A RangedSummarizedExperiment object containg bin-level counts for negative control samples" expanded="true">
                            <expand macro="windowCounts" />
                        </section>
                    </when>
                </conditional>
            </when>
            <when value="findMaxima">
                <expand macro="gRanges" />
                <param name="range" type="integer" value="" label="Specify the range of surrounding regions to consider as local" />
                <param name="metric" type="data" format="tabular" label="Values for which the local maxima is found" help="A dataframe with a column of values" />
                <param name="ignore_strand" type="boolean" truevalue="true" falsevalue="" checked="true" label="Consider the strandedness of regions?" help="If no is selected, then the entries in regions are split into their separate strands." />
            </when>
            <when value="getBestTest">
                <param name="ids" type="data" format="tabular" label="Cluster IDs for each test" />
                <param name="tab" type="data" format="tabular" label="A dataframe of results with a PValue field for each test" />
                <param name="by_pval" type="boolean" truevalue="true" falsevalue="" checked="true" label="Perform selection on corrected p-values" />
                <conditional name="weight_select">
                  <param name="weight_selector" type="select" label="Specify weights for each window?">
                    <option value="yes">Yes</option>
                    <option value="no" selected="true">No</option>
                  </param>
                  <when value="yes">
                    <param name="weight" type="data" format="tabular" label="Weights for each window" help="A dataframe with a column of weights" />
                  </when>
                  <when value="no"> </when>
                </conditional>
                  <param name="pval_col" type="text" optional="true" label="Specify the column of tab containing the p-values" help="Enter a string or integer" >
                    <sanitizer>
                      <valid>
                        <add value="." />
                      </valid>
                    </sanitizer>
                  </param>
                  <param name="cpm_col" type="text" optional="true" label="Specify the column of tab containing the log-CPM" help="Enter a string or integer" >
                    <sanitizer>
                      <valid>
                        <add value="." />
                      </valid>
                    </sanitizer>
                  </param>
            </when>
            <when value="getPESizes">
                <param name="bam_file" type="data" format="bam" label="BAM file" />
                <conditional name="readParam_select">
                  <param name="readParam_selector" type="select" label="Specify read loading parameters?" >
                    <option value="yes">Yes</option>
                    <option value="no" selected="true">No</option>
                  </param>
                  <when value="yes">
                    <param name="pe" type="select" label="Is paired-end data present in the BAM file(s)?" help="Reads are assumed to be single-end when None is selected">
                      <option value="none">None</option>
                      <option value="both" selected="true">Both Files</option>
                      <option value="first">First File</option>
                      <option value="second">Second File</option>
                    </param>
                    <param name="max_frag" type="integer" value="500" label="Maximum fragment length corresponding to a read pair" />
                    <param name="dedup" type="boolean" truevalue="true" falsevalue="" checked="false" label="Ignore marked duplicate reads?" help="Marked duplicate reads will be removed with if yes is selected. This may be necessary when many rounds of PCR have been performed. However, it is not recommended for routine counting as it will interfere with the downstream statistical methods. Note that the duplicate field must be set beforehand in the BAM file for this argument to have any effect" />
                    <param name="minq" type="integer" value="" optional="true" label="Minimum mapping quality score for an aligned read" help="Reads will be filtered by their mapping quality scores. This is generally recommended to remove low-confidence alignments. The exact threshold for minq will depend on the range of scores provided by the aligner. No filtering on the score will be performed if no value specified." />
                    <param name="forward" type="select" label="How should the reads be extracted?">
                      <option value="NA">Extract from all strands</option>
                      <option value="forward">Extract only from forward strands</option>
                      <option value="reverse">Extract only from reverse strands</option>
                    </param>
                    <param name="restrict" type="text" optional="true" label="Names of allowable chromosomes from which readswill be extracted" help="Reads will only be extracted for the specified chromosomes. This is useful to restrict the analysis to interesting chromosomes, e.g., no contigs/scaffolds or mitochondria."/>
                    <conditional name="discard_select">
                      <param name="discard" type="select" label="Discard any alignments?" help="A read will be removed if the corresponding alignment is wholly contained within the supplied ranges. This is useful for removing reads in repeat regions.">
                        <option value="yes">Yes</option>
                        <option value="no" selected="true">No</option>
                      </param>
                      <when value="yes">
                        <expand macro="gRanges" />
                      </when>
                      <when value="no"> </when>
                    </conditional>
                      <!--BiocParallelParam object-->
                  </when>
                  <when value="no"> </when>
                </conditional>
            </when>
            <when value="getWidths">
                <conditional name="data_select">
                  <param name="data_selector" type="select" label="Create a RangedSummarizedExperiment object by windowCounts or regionCounts?">
                    <option value="windowCounts">windowCounts</option>
                    <option value="regionCounts">regionCounts</option>
                  </param>
                  <when value="windowCounts">
                    <expand macro="windowCounts" />
                  </when>
                  <when value="regionCounts">
                    <expand macro="regionCounts" />
                  </when>
                </conditional>
            </when>
            <when value="overlapStats">
                <section name="windowCounts" title="Count reads overlapping each window" expanded="True">
                  <expand macro="windowCounts" />
                </section>
                <section name="region" title="Query of overlaps between regions" expanded="True">
                  <expand macro="gRanges" />
                </section>
                <param name="tab" type="data" format="tabular" label="Upload a ataframe of DE results for each window" />
                <conditional name="output_select">
                  <param name="output_selector" type="select" label="Select the function to compute overlaps between windows and regions" >
                    <option value="combineOverlaps">combineOverlaps</option>
                    <option value="getBestOverlaps">getBestOverlaps</option>
                    <option value="empiricalOverlaps">empiricalOverlaps</option>
                    <option value="mixedOverlaps">mixedOverlaps</option>
                    <option value="summitOverlaps">summitOverlaps</option>
                  </param>
                  <when value="combineOverlaps">
                    <expand macro="overlapStats_weights" />
                  </when>
                  <when value="getBestOverlaps">
                    <expand macro="overlapStats_weights" />
                  </when>
                  <when value="empiricalOverlaps">
                    <expand macro="overlapStats_weights" />
                  </when>
                  <when value="mixedOverlaps">
                    <expand macro="overlapStats_weights" />
                  </when>
                  <when value="summitOverlaps">
                    <param name="region_best" type="data" format="tabular" label="Specifying the window index that is the summit for each region" help="The data is designed to accept the best field in the output of getBestOverlaps (select create output to be used for summitOverlaps). This contains the index for the individual window that is the summit within each region."/>
                    <conditional name="o_summit_select">
                      <param name="o_summit_selector" type="select" label="Specify the overlapped windows that are summits by boolean values, integer indices, or none?" >
                        <option value="boolean">Boolean Values</option>
                        <option value="integer">Integer Indices</option>
                        <option value="none" selected="true">None</option>
                      </param>
                      <when value="boolean">
                        <param name="o_summit" type="data" format="tabular" label="Specify the overlapped windows that are summits by boolean values" help="Upload a dataframe with a column of boolean values" />
                      </when>
                      <when value="integer">
                        <param name="o_summit" type="data" format="tabular" label="Specify the overlapped windows that are summits by the corresponding integer indices" help="Upload a dataframe with a column of integer indices" />
                      </when>
                      <when value="none"> </when>
                    </conditional>
                    <conditional name="i_summit_select">
                      <param name="i_summit_selector" type="select" label="Specify the individual windows that are summits by boolean values, integer indices, or none?" >
                        <option value="boolean">Boolean Values</option>
                        <option value="integer">Integer Indices</option>
                        <option value="none" selected="true">None</option>
                      </param>
                      <when value="boolean">
                        <param name="i_summit" type="data" format="tabular" label="Specify the individual windows that are summits by boolean values" help="Upload a dataframe with a column of boolean values" />
                      </when>
                      <when value="integer">
                        <param name="i_summit" type="data" format="tabular" label="Specify the individual windows that are summits by the corresponding integer indices" help="Upload a dataframe with a column of integer indices" />
                      </when>
                      <when value="none"> </when>
                    </conditional>
                  </when>
                </conditional>
            </when>
            <when value="scaledAverage"> </when>
            <when value="strandedCounts"> </when>
        </conditional>
    </inputs>

    <outputs>
        <data name="calculateCPM_output" format="txt" label="calculateCPM on ${on_string}: output">
             <filter>method_select['method'] == 'calculateCPM'</filter>
        </data>
        <data name="checkBimodality_output" format="txt" label="checkBimodality on ${on_string}: output">
             <filter>method_select['method'] == 'checkBimodality'</filter>
        </data>
        <data name="combineTests_output" format="txt" label="combineTests on ${on_string}: output">
             <filter>method_select['method'] == 'combineTests'</filter>
        </data>
        <data name="filterW_abundances_output" format="txt" label="filterWindows on ${on_string}: abundances output" >
            <filter>method_select['method'] == 'filterWindows' and method_select['filter_method_select']['filter_method_selector'] == 'filterWindows'</filter>
        </data>
        <data name="filterW_back_abundances_output" format="txt" label="filterWindows on ${on_string}: back abundances output" >
            <filter>method_select['method'] == 'filterWindows' and method_select['filter_method_select']['background_select']['background_selector'] == 'yes'</filter>
        </data>
        <data name="filterW_filter_output" format="txt" label="filterWindows on ${on_string}: filter output" >
            <filter>method_select['method'] == 'filterWindows' and method_select['filter_method_select']['filter_method_selector'] == 'filterWindows'</filter>
        </data>
        <!--filter not working-->
        <data name="filterW_keepsum_output" format="txt" label="filterWindows on ${on_string}: filtered count sum output" >
            <filter>method_select['method'] == 'filterWindows' and  method_select['filter_method_select']['keep_select']['keep_selector'] == 'yes' and method_select['filter_method_select']['keep_select']['keep_sum'] == 'true' </filter>
        </data>
        <data name="findMaxima_output" format="txt" label="findMaxima on ${on_string}: output">
             <filter>method_select['method'] == 'findMaxima'</filter>
        </data>
        <data name="getBestTest_output" format="txt" label="getBestTest on ${on_string}: output">
             <filter>method_select['method'] == 'getBestTest'</filter>
        </data>
        <data name="getPESizes_sizes_output" format="txt" label="getPESizes on ${on_string}: sizes output">
             <filter>method_select['method'] == 'getPESizes'</filter>
        </data>
        <data name="getPESizes_diagnostics_output" format="txt" label="getPESizes on ${on_string}: diagnostics output">
             <filter>method_select['method'] == 'getPESizes'</filter>
        </data>
        <data name="getWidths_output" format="txt" label="getWidths on ${on_string}: output">
             <filter>method_select['method'] == 'getWidths'</filter>
        </data>
        <data name="overlapStats_output1" format="txt" label="overlapStats on ${on_string}: combineOverlaps output" >
          <filter>method_select['method'] == 'overlapStats' and method_select['output_select']['output_selector'] == 'combineOverlaps' </filter>
        </data>
        <data name="overlapStats_output2" format="txt" label="overlapStats on ${on_string}: getBestOverlaps output" >
          <filter>method_select['method'] == 'overlapStats' and method_select['output_select']['output_selector'] == 'getBestOverlaps' </filter>
        </data>
        <data name="overlapStats_output3" format="txt" label="overlapStats on ${on_string}: empiricalOverlaps output" >
          <filter>method_select['method'] == 'overlapStats' and method_select['output_select']['output_selector'] == 'empiricalOverlaps' </filter>
        </data>
        <data name="overlapStats_output4" format="txt" label="overlapStats on ${on_string}:  mixedOverlaps output" >
          <filter>method_select['method'] == 'overlapStats' and method_select['output_select']['output_selector'] == 'mixedOverlaps' </filter>
        </data>
        <data name="overlapStats_output5" format="txt" label="overlapStats on ${on_string}:  summitOverlaps output" >
          <filter>method_select['method'] == 'overlapStats' and method_select['output_select']['output_selector'] == 'summitOverlaps' </filter>
        </data>
    </outputs>

    <tests>
        <!--<test expect_num_outputs="1">
            <conditional name="method_select">
                <param name="method" value="calculateCPM" />
                <section name="windowCounts">
                    <repeat name="bam_input">
                        <param name="bam_file" value="rep1.bam" ftype="bam" />
                    </repeat>
                    <repeat name="bam_input">
                        <param name="bam_file" value="rep2.bam" ftype="bam" />
                    </repeat>
                    <param name="spacing" value="50" />
                    <param name="width" value="50" />
                    <conditional name="ext_selector">
                        <param name="ext_select" value="integer" />
                        <param name="ext" value="100" />
                    </conditional>
                    <param name="shift" value="0" />
                    <param name="filter" value="1" />
                    <param name="bin" value="false" />
                    <conditional name="readParam_select">
                        <param name="readParam_selector" value="no" />
                    </conditional>
                </section>
                <section name="calculateCPM">
                    <conditional name="log_select">
                        <param name="log_selector" value="no"/>
                        <param name="use_norm_factors" value="true" />
                    <param name="use_offsets" value="false" />
                    </conditional>
                    <param name="assay_id" value="counts" />
                </section>
            </conditional>
            <output name="calculateCPM_output" value="calculateCPM_output0.txt" />
        </test>
        <test expect_num_outputs="1">
            <conditional name="method_select">
                <param name="method" value="calculateCPM" />
                <section name="windowCounts">
                    <repeat name="bam_input">
                        <param name="bam_file" value="rep1.bam" ftype="bam" />
                    </repeat>
                    <repeat name="bam_input">
                        <param name="bam_file" value="rep2.bam" ftype="bam" />
                    </repeat>
                    <param name="spacing" value="50" />
                    <param name="width" value="50" />
                    <conditional name="ext_selector">
                        <param name="ext_select" value="integer" />
                        <param name="ext" value="100" />
                    </conditional>
                    <param name="shift" value="0" />
                    <param name="filter" value="1" />
                    <param name="bin" value="false" />
                    <conditional name="readParam_select">
                        <param name="readParam_selector" value="no" />
                    </conditional>
                </section>
                <section name="calculateCPM">
                    <conditional name="log_select">
                        <param name="log_selector" value="yes"/>
                        <param name="prior_count" value="1" />
                    </conditional>
                    <param name="assay_id" value="counts" />
                </section>
            </conditional>
            <output name="calculateCPM_output" value="calculateCPM_output1.txt" />
        </test>
        <test expect_num_outputs="1">
            <conditional name="method_select">
                <param name="method" value="calculateCPM" />
                <section name="windowCounts">
                    <repeat name="bam_input">
                        <param name="bam_file" value="rep1.bam" ftype="bam" />
                    </repeat>
                    <repeat name="bam_input">
                        <param name="bam_file" value="rep2.bam" ftype="bam" />
                    </repeat>
                    <param name="spacing" value="50" />
                    <param name="width" value="50" />
                    <conditional name="ext_selector">
                        <param name="ext_select" value="list" />
                        <param name="ext_list1" value="50, 100" />
                        <param name="ext_list2" value="80" />
                    </conditional>
                    <param name="shift" value="0" />
                    <param name="filter" value="1" />
                    <param name="bin" value="false" />
                    <conditional name="readParam_select">
                        <param name="readParam_selector" value="no" />
                    </conditional>
                </section>
                <section name="calculateCPM">
                    <conditional name="log_select">
                        <param name="log_selector" value="yes"/>
                        <param name="prior_count" value="1" />
                    </conditional>
                    <param name="assay_id" value="counts" />
                </section>
            </conditional>
            <output name="calculateCPM_output" value="calculateCPM_output2.txt" />
        </test>
        <test expect_num_outputs="1">
            <conditional name="method_select">
                <param name="method" value="calculateCPM" />
                <section name="windowCounts">
                    <repeat name="bam_input">
                        <param name="bam_file" value="rep1.bam" ftype="bam" />
                    </repeat>
                    <repeat name="bam_input">
                        <param name="bam_file" value="rep2.bam" ftype="bam" />
                    </repeat>
                    <param name="spacing" value="50" />
                    <param name="width" value="50" />
                    <conditional name="ext_selector">
                        <param name="ext_select" value="integer" />
                        <param name="ext" value="100" />
                    </conditional>
                    <param name="shift" value="0" />
                    <param name="filter" value="1" />
                    <param name="bin" value="false" />
                    <conditional name="readParam_select">
                        <param name="readParam_selector" value="yes" />
                        <param name="pe" value="none" />
                        <param name="max_frag" value="500" />
                        <param name="dedup" value="false" />
                        <param name="minq" value="1" />
                        <param name="forward" value="NA" />
                        <param name="restrict" value="chrA" />
                        <conditional name="discard_select">
                            <param name="discard" value="no" />
                        </conditional>
                    </conditional>
                </section>
                <section name="calculateCPM">
                    <conditional name="log_select">
                        <param name="log_selector" value="yes"/>
                        <param name="prior_count" value="1" />
                    </conditional>
                    <param name="assay_id" value="counts" />
                </section>
            </conditional>
            <output name="calculateCPM_output" value="calculateCPM_output3.txt" />
        </test>
        <test expect_num_outputs="1">
            <conditional name="method_select">
                <param name="method" value="calculateCPM" />
                <section name="windowCounts">
                    <repeat name="bam_input">
                        <param name="bam_file" value="rep1.bam" ftype="bam" />
                    </repeat>
                    <repeat name="bam_input">
                        <param name="bam_file" value="rep2.bam" ftype="bam" />
                    </repeat>
                    <param name="spacing" value="50" />
                    <param name="width" value="50" />
                    <conditional name="ext_selector">
                        <param name="ext_select" value="integer" />
                        <param name="ext" value="100" />
                    </conditional>
                    <param name="shift" value="0" />
                    <param name="filter" value="1" />
                    <param name="bin" value="false" />
                    <conditional name="readParam_select">
                        <param name="readParam_selector" value="yes" />
                        <param name="pe" value="none" />
                        <param name="max_frag" value="500" />
                        <param name="dedup" value="false" />
                        <param name="minq" value="1" />
                        <param name="forward" value="NA" />
                        <param name="restrict" value="chrA" />
                        <conditional name="discard_select">
                            <param name="discard" value="yes" />
                            <param name="GRanges" value="gRange_discard.tabular" />
                            <param name="named" value="false" />
                        </conditional>
                    </conditional>
                </section>
                <section name="calculateCPM">
                    <conditional name="log_select">
                        <param name="log_selector" value="yes"/>
                        <param name="prior_count" value="1" />
                    </conditional>
                    <param name="assay_id" value="counts" />
                </section>
            </conditional>
            <output name="calculateCPM_output" value="calculateCPM_output4.txt" />
        </test>
        <test expect_num_outputs="1">
            <conditional name="method_select">
                <param name="method" value="checkBimodality" />
                <repeat name="bam_input">
                    <param name="bam_file" value="rep1.bam" ftype="bam" />
                </repeat>
                <repeat name="bam_input">
                    <param name="bam_file" value="rep2.bam" ftype="bam" />
                </repeat>
                <param name="GRanges" value="gRange_regions.tabular" />
                <param name="named" value="false" />
                <param name="width" value="200" />
                <conditional name="readParam_select">
                    <param name="readParam_selector" value="no" />
                </conditional>
                <param name="prior_count" value="5" />
                <param name="invert" value="false" />
            </conditional>
            <output name="checkBimodality_output" file="checkBiomodality_output1.txt" />
        </test>
        <test expect_num_outputs="1">
            <conditional name="method_select">
                <param name="method" value="checkBimodality" />
                <repeat name="bam_input">
                    <param name="bam_file" value="rep1.bam" ftype="bam" />
                </repeat>
                <repeat name="bam_input">
                    <param name="bam_file" value="rep2.bam" ftype="bam" />
                </repeat>
                <param name="GRanges" value="gRange_regions.tabular" />
                <param name="named" value="false" />
                <param name="width" value="200" />
                <conditional name="readParam_select">
                    <param name="readParam_selector" value="yes" />
                    <param name="pe" value="both" />
                    <param name="max_frag" value="100" />
                    <param name="dedup" value="false" />
                    <param name="minq" value="20" />
                    <param name="forward" value="NA" />
                    <param name="restrict" value="" />
                    <conditional name="discard_select">
                        <param name="discard" value="no" />
                    </conditional>
                </conditional>
                <param name="prior_count" value="5" />
                <param name="invert" value="False" />
            </conditional>
            <output name="checkBimodality_output" file="checkBiomodality_output2.txt" />
        </test>
        <test expect_num_outputs="1">
            <conditional name="method_select">
                <param name="method" value="checkBimodality" />
                <repeat name="bam_input">
                    <param name="bam_file" value="rep1.bam" ftype="bam" />
                </repeat>
                <repeat name="bam_input">
                    <param name="bam_file" value="rep2.bam" ftype="bam" />
                </repeat>
                <param name="GRanges" value="gRange_regions.tabular" />
                <param name="named" value="false" />
                <param name="width" value="200" />
                <conditional name="readParam_select">
                    <param name="readParam_selector" value="yes" />
                    <param name="pe" value="both" />
                    <param name="max_frag" value="100" />
                    <param name="dedup" value="false" />
                    <param name="minq" value="20" />
                    <param name="forward" value="NA" />
                    <param name="restrict" value="chrA" />
                    <conditional name="discard_select">
                        <param name="discard" value="yes" />
                        <param name="GRanges" value="gRange_discard.tabular" />
                        <param name="named" value="false" />
                    </conditional>
                </conditional>
                <param name="prior_count" value="5" />
                <param name="invert" value="False" />
            </conditional>
            <output name="checkBimodality_output" file="checkBiomodality_output3.txt" />
        </test>
        <test expect_num_outputs="1">
            <conditional name="method_select">
                <param name="method" value="combineTests" />
                <param name="ids" value="comTest_ids.tabular" />
                <param name="tab" value="comTest_tab.tabular" />
                <conditional name="weight_select">
                    <param name="weight_selector" value="no" />
                </conditional>
                <param name="pval_col" value="PValue" />
                <param name="fc_col" value="logFC.whee" />
            </conditional>
            <output name="combineTests_output" value="combineTests_output.txt" />
        </test>
        <test expect_num_outputs="1">
            <conditional name="method_select">
                <param name="method" value="combineTests" />
                <param name="ids" value="comTest_ids.tabular" />
                <param name="tab" value="comTest_tab.tabular" />
                <conditional name="weight_select">
                    <param name="weight_selector" value="yes" />
                    <param name="weight" value="comTest_w.tabular" />
                </conditional>
                <param name="pval_col" value="PValue" />
                <param name="fc_col" value="logFC.whee" />
            </conditional>
            <output name="combineTests_output" value="combineTests_output2.txt" />
        </test>-->
        <!--This test is not working due to filter not working
        <test expect_num_outputs="3">
            <conditional name="method_select">
                <param name="method" value="filterWindows" />
                <conditional name="filter_method_select">
                    <param name="filter_method_selector" value="filterWindows" />
                    <section name="data">
                        <repeat name="bam_input">
                            <param name="bam_file" value="rep1.bam" ftype="bam" />
                        </repeat>
                        <repeat name="bam_input">
                            <param name="bam_file" value="rep2.bam" ftype="bam" />
                        </repeat>
                        <param name="spacing" value="50" />
                        <param name="width" value="" />
                        <conditional name="ext_selector">
                            <param name="ext_select" value="integer" />
                            <param name="ext" value="100" />
                        </conditional>
                        <param name="shift" value="0" />
                        <param name="filter" value="1" />
                        <param name="bin" value="false" />
                        <conditional name="readParam_select">
                            <param name="readParam_selector" value="no" />
                        </conditional>
                    </section>
                    <conditional name="background_select">
                        <param name="background_selector" value="no" />
                    </conditional>
                    <param name="type" value="proportion" />
                    <param name="assay_data" value="counts" />
                    <param name="assay_back" value="counts" />
                    <param name="prior_count" value="2" />
                    <conditional name="scale_info_select">
                        <param name="scale_info_selector" value="no" />
                    </conditional>
                    <conditional name="keep_select">
                        <param name="keep_selector" value="yes" />
                        <param name="keep" value="0.99" />
                        <param name="keep_sum" value="true" />
                    </conditional>
                </conditional>
            </conditional>
            <output name="filterW_abundances_output" value="filterWindows_abundances_output1.txt" />
            <output name="filterW_filter_output" value="filterWindows_filter_output1.txt" />
            <output name="filterW_keepsum_output" value="filterWindows_filtered_count_sum_output.txt" />
        </test>-->
        <!--<test expect_num_outputs="3">
            <conditional name="method_select">
                <param name="method" value="filterWindows" />
                <conditional name="filter_method_select">
                    <param name="filter_method_selector" value="filterWindows" />
                    <section name="data">
                        <repeat name="bam_input">
                            <param name="bam_file" value="rep1.bam" ftype="bam" />
                        </repeat>
                        <repeat name="bam_input">
                            <param name="bam_file" value="rep2.bam" ftype="bam" />
                        </repeat>
                        <param name="spacing" value="50" />
                        <param name="width" value="" />
                        <conditional name="ext_selector">
                            <param name="ext_select" value="integer" />
                            <param name="ext" value="100" />
                        </conditional>
                        <param name="shift" value="0" />
                        <param name="filter" value="1" />
                        <param name="bin" value="false" />
                        <conditional name="readParam_select">
                            <param name="readParam_selector" value="no" />
                        </conditional>
                    </section>
                    <conditional name="background_select">
                        <param name="background_selector" value="yes" />
                        <section name="background">
                            <conditional name="data_select">
                                <param name="data_selector" value="windowCounts" />
                                <repeat name="bam_input">
                                <param name="bam_file" value="rep1.bam" ftype="bam" />
                                </repeat>
                                <repeat name="bam_input">
                                    <param name="bam_file" value="rep2.bam" ftype="bam" />
                                </repeat>
                                <param name="spacing" value="50" />
                                <param name="width" value="300" />
                                <conditional name="ext_selector">
                                    <param name="ext_select" value="integer" />
                                    <param name="ext" value="100" />
                                </conditional>
                                <param name="shift" value="0" />
                                <param name="filter" value="1" />
                                <param name="bin" value="true" />
                                <conditional name="readParam_select">
                                    <param name="readParam_selector" value="no" />
                                </conditional>
                            </conditional>
                        </section>
                    </conditional>
                    <param name="type" value="global" />
                    <param name="assay_data" value="counts" />
                    <param name="assay_back" value="counts" />
                    <param name="prior_count" value="2" />
                    <conditional name="keep_select">
                        <param name="keep_selector" value="no" />
                    </conditional>
                    <conditional name="scale_info_select">
                        <param name="scale_info_selector" value="no" />
                    </conditional>
                </conditional>
            </conditional>
            <output name="filterW_abundances_output" value="filterWindows_abundances_output2.txt" />
            <output name="filterW_back_abundances_output" value="filterWindows_back_abundances_output.txt" />
            <output name="filterW_filter_output" value="filterWindows_filter_output2.txt" />
        </test>
        <test expect_num_outputs="2">
            <conditional name="method_select">
                <param name="method" value="filterWindows" />
                <conditional name="filter_method_select">
                    <param name="filter_method_selector" value="filterWindows" />
                    <section name="data">
                        <repeat name="bam_input">
                            <param name="bam_file" value="rep1.bam" ftype="bam" />
                        </repeat>
                        <repeat name="bam_input">
                            <param name="bam_file" value="rep2.bam" ftype="bam" />
                        </repeat>
                        <param name="spacing" value="50" />
                        <param name="width" value="" />
                        <conditional name="ext_selector">
                            <param name="ext_select" value="integer" />
                            <param name="ext" value="100" />
                        </conditional>
                        <param name="shift" value="0" />
                        <param name="filter" value="1" />
                        <param name="bin" value="false" />
                        <conditional name="readParam_select">
                            <param name="readParam_selector" value="no" />
                        </conditional>
                    </section>
                    <conditional name="background_select">
                        <param name="background_selector" value="no" />
                    </conditional>
                    <param name="type" value="global" />
                    <param name="assay_data" value="counts" />
                    <param name="assay_back" value="counts" />
                    <param name="prior_count" value="2" />
                    <conditional name="scale_info_select">
                        <param name="scale_info_selector" value="yes" />
                        <section name="data">
                            <repeat name="bam_input">
                                <param name="bam_file" value="rep1.bam" ftype="bam" />
                            </repeat>
                            <repeat name="bam_input">
                                <param name="bam_file" value="rep2.bam" ftype="bam" />
                            </repeat>
                            <param name="spacing" value="50" />
                            <param name="width" value="" />
                            <conditional name="ext_selector">
                                <param name="ext_select" value="integer" />
                                <param name="ext" value="100" />
                            </conditional>
                            <param name="shift" value="0" />
                            <param name="filter" value="1" />
                            <param name="bin" value="false" />
                            <conditional name="readParam_select">
                                <param name="readParam_selector" value="no" />
                            </conditional>
                        </section>
                        <section name="background">
                            <conditional name="data_select">
                                <param name="data_selector" value="windowCounts" />
                                <repeat name="bam_input">
                                    <param name="bam_file" value="rep1.bam" ftype="bam" />
                                </repeat>
                                <repeat name="bam_input">
                                    <param name="bam_file" value="rep2.bam" ftype="bam" />
                                </repeat>
                                <param name="spacing" value="50" />
                                <param name="width" value="" />
                                <conditional name="ext_selector">
                                    <param name="ext_select" value="integer" />
                                    <param name="ext" value="100" />
                                </conditional>
                                <param name="shift" value="0" />
                                <param name="filter" value="1" />
                                <param name="bin" value="false" />
                                <conditional name="readParam_select">
                                    <param name="readParam_selector" value="no" />
                                </conditional>
                            </conditional>
                        </section>
                    </conditional>
                    <conditional name="keep_select">
                        <param name="keep_selector" value="no" />
                    </conditional>
                </conditional>
            </conditional>
            <output name="filterW_abundances_output" value="filterWindows_abundances_output3.txt" />
            <output name="filterW_filter_output" value="filterWindows_filter_output3.txt" />
        </test>
        <test expect_num_outputs="3">
            <conditional name="method_select">
                <param name="method" value="filterWindows" />
                <conditional name="filter_method_select">
                    <param name="filter_method_selector" value="filterWindows" />
                    <section name="data">
                        <repeat name="bam_input">
                            <param name="bam_file" value="rep1.bam" ftype="bam" />
                        </repeat>
                        <repeat name="bam_input">
                            <param name="bam_file" value="rep2.bam" ftype="bam" />
                        </repeat>
                        <param name="spacing" value="50" />
                        <param name="width" value="" />
                        <conditional name="ext_selector">
                            <param name="ext_select" value="integer" />
                            <param name="ext" value="100" />
                        </conditional>
                        <param name="shift" value="0" />
                        <param name="filter" value="1" />
                        <param name="bin" value="false" />
                        <conditional name="readParam_select">
                            <param name="readParam_selector" value="no" />
                        </conditional>
                    </section>
                    <conditional name="background_select">
                        <param name="background_selector" value="yes" />
                        <section name="background">
                            <conditional name="data_select">
                                <param name="data_selector" value="regionCounts" />
                                <repeat name="bam_input">
                                <param name="bam_file" value="rep1.bam" ftype="bam" />
                                </repeat>
                                <repeat name="bam_input">
                                    <param name="bam_file" value="rep2.bam" ftype="bam" />
                                </repeat>
                                <param name="GRanges" value="filterWindows_regions.tabular" />
                                <param name="named" value="true" />
                                <conditional name="ext_selector">
                                    <param name="ext_select" value="integer" />
                                    <param name="ext" value="100" />
                                </conditional>
                                <conditional name="readParam_select">
                                    <param name="readParam_selector" value="no" />
                                </conditional>
                            </conditional>
                        </section>
                    </conditional>
                    <param name="type" value="local" />
                    <param name="assay_data" value="counts" />
                    <param name="assay_back" value="counts" />
                    <param name="prior_count" value="2" />
                    <conditional name="keep_select">
                        <param name="keep_selector" value="no" />
                    </conditional>
                    <conditional name="scale_info_select">
                        <param name="scale_info_selector" value="no" />
                    </conditional>
                </conditional>
            </conditional>
            <output name="filterW_abundances_output" value="filterWindows_abundances_output4.txt" />
            <output name="filterW_back_abundances_output" value="filterWindows_back_abundances_output2.txt" />
            <output name="filterW_filter_output" value="filterWindows_filter_output4.txt" />
        </test>
        <test expect_num_outputs="1">
            <conditional name="method_select">
                <param name="method" value="findMaxima" />
                <param name="GRanges" value="findMax_regions.tabular" />
                <param name="range" value="10" />
                <param name="named" value="true" />
                <param name="metric" value="findMax_metric.tabular" />
                <param name="ignore_strand" value="true" />
            </conditional>
            <output name="findMaxima_output" value="findMaxima_output.txt" />
        </test>
        <test expect_num_outputs="1">
            <conditional name="method_select">
                <param name="method" value="getBestTest" />
                <param name="ids" value="getBestTest_ids.tabular" />
                <param name="tab" value="getBestTest_tab.tabular" />
                <param name="by_pval" value="true" />
                <conditional name="weight_select">
                    <param name="weight_selector" value="no"/>
                </conditional>
                <param name="pval_col" value="3" />
                <param name="cpm_col" value="2" />
            </conditional>
            <output name="getBestTest_output" value="getBestTest_output1.txt" />
        </test>
        <test expect_num_outputs="1">
            <conditional name="method_select">
                <param name="method" value="getBestTest" />
                <param name="ids" value="getBestTest_ids.tabular" />
                <param name="tab" value="getBestTest_tab.tabular" />
                <param name="by_pval" value="true" />
                <conditional name="weight_select">
                    <param name="weight_selector" value="yes" />
                    <param name="weight" value="getBestTest_w.tabular" />
                </conditional>
                <param name="pval_col" value="3" />
                <param name="cpm_col" value="2" />
            </conditional>
            <output name="getBestTest_output" value="getBestTest_output2.txt" />
        </test>
        <test expect_num_outputs="2">
            <conditional name="method_select">
                <param name="method" value="getPESizes" />
                <param name="bam_file" value="pet.bam" ftype="bam" />
                <conditional name="readParam_select">
                    <param name="readParam_selector" value="no" />
                </conditional>
            </conditional>
          <output name="getPESizes_sizes_output" value="getPESizes_sizes_output1.txt" />
          <output name="getPESizes_diagnostics_output" value="getPESizes__diagnostics_output1.txt" />
        </test>
        <test expect_num_outputs="2">
            <conditional name="method_select">
                <param name="method" value="getPESizes" />
                <param name="bam_file" value="pet.bam" ftype="bam" />
                <conditional name="readParam_select">
                    <param name="readParam_selector" value="yes" />
                    <param name="pe" value="both" />
                    <param name="max_frag" value="100" />
                    <param name="dedup" value="false" />
                    <param name="minq" value="20" />
                    <param name="forward" value="NA" />
                    <param name="restrict" value="chrA" />
                    <conditional name="discard_select">
                      <param name="discard" value="no" />
                    </conditional>
                </conditional>
            </conditional>
            <output name="getPESizes_sizes_output" value="getPESizes_sizes_output2.txt" />
            <output name="getPESizes_diagnostics_output" value="getPESizes__diagnostics_output2.txt" />
        </test>
        <test expect_num_outputs="2">
            <conditional name="method_select">
                <param name="method" value="getPESizes" />
                <param name="bam_file" value="pet.bam" ftype="bam" />
                <conditional name="readParam_select">
                    <param name="readParam_selector" value="yes" />
                    <param name="pe" value="both" />
                    <param name="max_frag" value="100" />
                    <param name="dedup" value="false" />
                    <param name="minq" value="20" />
                    <param name="forward" value="NA" />
                    <param name="restrict" value="chrA" />
                    <conditional name="discard_select">
                      <param name="discard" value="yes" />
                      <param name="GRanges" value="gRange_discard.tabular" />
                    </conditional>
                </conditional>
            </conditional>
            <output name="getPESizes_sizes_output" value="getPESizes_sizes_output3.txt" />
            <output name="getPESizes_diagnostics_output" value="getPESizes__diagnostics_output3.txt" />
        </test>
        <test expect_num_outputs="1">
            <conditional name="method_select">
                <param name="method" value="getWidths" />
                <conditional name="data_select">
                    <param name="data_selector" value="windowCounts" />
                    <repeat name="bam_input">
                      <param name="bam_file" value="rep1.bam" ftype="bam" />
                    </repeat>
                    <repeat name="bam_input">
                        <param name="bam_file" value="rep2.bam" ftype="bam" />
                    </repeat>
                    <param name="spacing" value="50" />
                    <param name="width" value="" />
                    <conditional name="ext_selector">
                      <param name="ext_select" value="list" />
                      <param name="ext_list1" value="50, 100" />
                      <param name="ext_list2" value="80" />
                    </conditional>
                    <param name="shift" value="0" />
                    <param name="filter" value="1" />
                    <param name="bin" value="false" />
                    <conditional name="readParam_select">
                      <param name="readParam_selector" value="no" />
                    </conditional>
                </conditional>
            </conditional>
            <output name="getWidths_output" value="getWidths_output1.txt" />
        </test>
        <test expect_num_outputs="1">
            <conditional name="method_select">
                <param name="method" value="getWidths" />
                <conditional name="data_select">
                    <param name="data_selector" value="windowCounts" />
                    <repeat name="bam_input">
                      <param name="bam_file" value="rep1.bam" ftype="bam" />
                    </repeat>
                    <repeat name="bam_input">
                        <param name="bam_file" value="rep2.bam" ftype="bam" />
                    </repeat>
                    <param name="spacing" value="50" />
                    <param name="width" value="" />
                    <conditional name="ext_selector">
                        <param name="ext_select" value="integer" />
                        <param name="ext" value="100" />
                    </conditional>
                    <param name="shift" value="0" />
                    <param name="filter" value="1" />
                    <param name="bin" value="false" />
                    <conditional name="readParam_select">
                      <param name="readParam_selector" value="yes" />
                      <param name="pe" value="none" />
                      <param name="max_frag" value="500" />
                      <param name="dedup" value="false" />
                      <param name="minq" value="" />
                      <param name="forward" value="NA" />
                      <param name="restrict" value="chrA" />
                      <conditional name="discard_select">
                        <param name="discard" value="no" />
                      </conditional>
                    </conditional>
                </conditional>
            </conditional>
            <output name="getWidths_output" value="getWidths_output2.txt" />
        </test>-->
        <test expect_num_outputs="1">
            <conditional name="method_select">
                <param name="method" value="getWidths" />
                <conditional name="data_select">
                    <param name="data_selector" value="windowCounts" />
                    <repeat name="bam_input">
                      <param name="bam_file" value="rep1.bam" ftype="bam" />
                    </repeat>
                    <repeat name="bam_input">
                        <param name="bam_file" value="rep2.bam" ftype="bam" />
                    </repeat>
                    <param name="spacing" value="50" />
                    <param name="width" value="" />
                    <conditional name="ext_selector">
                        <param name="ext_select" value="integer" />
                        <param name="ext" value="100" />
                    </conditional>
                    <param name="shift" value="0" />
                    <param name="filter" value="1" />
                    <param name="bin" value="false" />
                    <conditional name="readParam_select">
                        <param name="readParam_selector" value="yes" />
                        <param name="pe" value="none" />
                        <param name="max_frag" value="500" />
                        <param name="dedup" value="false" />
                        <param name="minq" value="" />
                        <param name="forward" value="NA" />
                        <param name="restrict" value="chrA" />
                        <conditional name="discard_select">
                            <param name="discard" value="yes" />
                            <param name="GRanges" value="gRange_discard.tabular" />
                        </conditional>
                    </conditional>
                </conditional>
            </conditional>
            <output name="getWidths_output" value="getWidths_output3.txt" />
        </test>
        <test expect_num_outputs="1">
            <conditional name="method_select">
                <param name="method" value="getWidths" />
                <conditional name="data_select">
                    <param name="data_selector" value="regionCounts" />
                    <repeat name="bam_input">
                        <param name="bam_file" value="rep1.bam" ftype="bam" />
                    </repeat>
                    <repeat name="bam_input">
                        <param name="bam_file" value="rep2.bam" ftype="bam" />
                    </repeat>
                    <param name="GRanges" value="gRange_regionsCount.tabular" />
                    <param name="named" value="true" />
                    <conditional name="ext_selector">
                        <param name="ext_select" value="integer" />
                        <param name="ext" value="100" />
                    </conditional>
                    <conditional name="readParam_select">
                        <param name="readParam_selector" value="no" />
                    </conditional>
                </conditional>
            </conditional>
            <output name="getWidths_output" value="getWidths_output4.txt" />
        </test>
        <test expect_num_outputs="1">
            <conditional name="method_select">
                <param name="method" value="getWidths" />
                <conditional name="data_select">
                    <param name="data_selector" value="regionCounts" />
                    <repeat name="bam_input">
                        <param name="bam_file" value="rep1.bam" ftype="bam" />
                    </repeat>
                    <repeat name="bam_input">
                        <param name="bam_file" value="rep2.bam" ftype="bam" />
                    </repeat>
                    <param name="GRanges" value="gRange_regionsCount.tabular" />
                    <param name="named" value="true" />
                    <conditional name="ext_selector">
                        <param name="ext_select" value="list" />
                        <param name="ext_list1" value="50, 100" />
                        <param name="ext_list2" value="80" />
                    </conditional>
                    <conditional name="readParam_select">
                        <param name="readParam_selector" value="yes" />
                        <param name="pe" value="none" />
                        <param name="max_frag" value="500" />
                        <param name="dedup" value="false" />
                        <param name="minq" value="" />
                        <param name="forward" value="NA" />
                        <param name="restrict" value="chrB" />
                        <conditional name="discard_select">
                            <param name="discard" value="no" />
                        </conditional>
                    </conditional>
                </conditional>
            </conditional>
            <output name="getWidths_output" value="getWidths_output5.txt" />
        </test>
        <!--
        <test expect_num_outputs="1">
            <conditional name="method_select">
                <param name="method" value="overlapStats" />
                <conditional name="data_select">
                    <param name="data_selector" value="regionCounts" />
                    <repeat name="bam_input">
                        <param name="bam_file" value="rep1.bam" ftype="bam" />
                    </repeat>
                    <repeat name="bam_input">
                        <param name="bam_file" value="rep2.bam" ftype="bam" />
                    </repeat>
                    <param name="GRanges" value="gRange_regionsCount.tabular" />
                    <param name="named" value="true" />
                    <conditional name="ext_selector">
                        <param name="ext_select" value="list" />
                        <param name="ext_list1" value="50, 100" />
                        <param name="ext_list2" value="80" />
                    </conditional>
                    <conditional name="readParam_select">
                        <param name="readParam_selector" value="yes" />
                        <param name="pe" value="none" />
                        <param name="max_frag" value="500" />
                        <param name="dedup" value="false" />
                        <param name="minq" value="" />
                        <param name="forward" value="NA" />
                        <param name="restrict" value="chrB" />
                        <conditional name="discard_select">
                            <param name="discard" value="yes" />
                            <param name="GRanges" value="gRange_discard.tabular" />
                        </conditional>
                    </conditional>
                </conditional>
            </conditional>
            <output name="getWidths_output" value="getWidths_output6.txt" />
        </test>-->
        <!--
        <test expect_num_outputs="1">
            <conditional name="method_select">
                <param name="method" value="overlapStats" />
                <section name="windowCounts">
                    <repeat name="bam_input">
                        <param name="bam_file" value="rep1.bam" ftype="bam" />
                    </repeat>
                    <repeat name="bam_input">
                        <param name="bam_file" value="rep2.bam" ftype="bam" />
                    </repeat>
                    <param name="width" value="1" />
                    <param name="filter" value="1" />
                </section>
                <section name="region">
                    <param name="GRanges" value="overlapStats_regions.tabular" />
                    <param name="named" value="true" />
                </section>
                <param name="tab" value="overlapStats_tab.tabular" />
                <conditional name="output_select">
                    <param name="output_selector" value="combineOverlaps" />
                    <conditional name="o_weight_select">
                        <param name="o_weight_selector" value="no" />
                    </conditional>
                    <conditional name="i_weight_select">
                        <param name="i_weight_selector" value="no" />
                    </conditional>
                </conditional>
            </conditional>
            <output name="overlapStats_output1" value="overlapStats_output1.txt" />
        </test>
        <test expect_num_outputs="1">
            <conditional name="method_select">
                <param name="method" value="overlapStats" />
                <section name="windowCounts">
                    <repeat name="bam_input">
                      <param name="bam_file" value="rep1.bam" ftype="bam" />
                    </repeat>
                    <repeat name="bam_input">
                      <param name="bam_file" value="rep2.bam" ftype="bam" />
                    </repeat>
                    <param name="width" value="1" />
                    <param name="filter" value="1" />
                </section>
                <section name="region">
                    <param name="GRanges" value="overlapStats_regions.tabular" />
                    <param name="named" value="true" />
                </section>
                <param name="tab" value="overlapStats_tab.tabular" />
                <conditional name="output_select">
                    <param name="output_selector" value="combineOverlaps" />
                    <conditional name="o_weight_select">
                        <param name="o_weight_selector" value="yes" />
                        <param name="o_weight" value="overlapStats_o_weights.tabular" />
                    </conditional>
                    <conditional name="i_weight_select">
                        <param name="i_weight_selector" value="yes" />
                        <param name="i_weight" value="overlapStats_i_weights.tabular" />
                    </conditional>
                </conditional>
            </conditional>
            <output name="overlapStats_output1" value="overlapStats_output2.txt" />
        </test>
        <test expect_num_outputs="1">
            <conditional name="method_select">
                <param name="method" value="overlapStats" />
                <section name="windowCounts">
                    <repeat name="bam_input">
                      <param name="bam_file" value="rep1.bam" ftype="bam" />
                    </repeat>
                    <repeat name="bam_input">
                      <param name="bam_file" value="rep2.bam" ftype="bam" />
                    </repeat>
                    <param name="width" value="1" />
                    <param name="filter" value="1" />
                </section>
                <section name="region">
                    <param name="GRanges" value="overlapStats_regions.tabular" />
                    <param name="named" value="true" />
                </section>
                <param name="tab" value="overlapStats_tab.tabular" />
                <conditional name="output_select">
                    <param name="output_selector" value="getBestOverlaps" />
                    <conditional name="o_weight_select">
                        <param name="o_weight_selector" value="yes" />
                        <param name="o_weight" value="overlapStats_o_weights.tabular" />
                    </conditional>
                    <conditional name="i_weight_select">
                        <param name="i_weight_selector" value="yes" />
                        <param name="i_weight" value="overlapStats_i_weights.tabular" />
                    </conditional>
                </conditional>
            </conditional>
            <output name="overlapStats_output2" value="overlapStats_output3.txt" />
        </test>
        <test expect_num_outputs="1">
            <conditional name="method_select">
                <param name="method" value="overlapStats" />
                <section name="windowCounts">
                    <repeat name="bam_input">
                        <param name="bam_file" value="rep1.bam" ftype="bam" />
                    </repeat>
                    <repeat name="bam_input">
                        <param name="bam_file" value="rep2.bam" ftype="bam" />
                    </repeat>
                    <param name="width" value="1" />
                    <param name="filter" value="1" />
                </section>
                <section name="region">
                    <param name="GRanges" value="overlapStats_regions.tabular" />
                    <param name="named" value="true" />
                </section>
                <param name="tab" value="overlapStats_tab.tabular" />
                <conditional name="output_select">
                    <param name="output_selector" value="empiricalOverlaps" />
                    <conditional name="o_weight_select">
                        <param name="o_weight_selector" value="yes" />
                        <param name="o_weight" value="overlapStats_o_weights.tabular" />
                    </conditional>
                    <conditional name="i_weight_select">
                        <param name="i_weight_selector" value="yes" />
                        <param name="i_weight" value="overlapStats_i_weights.tabular" />
                    </conditional>
                </conditional>
            </conditional>
            <output name="overlapStats_output3" value="overlapStats_output4.txt" />
        </test>
        <test expect_num_outputs="1">
            <conditional name="method_select">
                <param name="method" value="overlapStats" />
                <section name="windowCounts">
                    <repeat name="bam_input">
                        <param name="bam_file" value="rep1.bam" ftype="bam" />
                    </repeat>
                    <repeat name="bam_input">
                        <param name="bam_file" value="rep2.bam" ftype="bam" />
                    </repeat>
                    <param name="width" value="1" />
                    <param name="filter" value="1" />
                </section>
                <section name="region">
                    <param name="GRanges" value="overlapStats_regions.tabular" />
                    <param name="named" value="true" />
                </section>
                <param name="tab" value="overlapStats_tab.tabular" />
                <conditional name="output_select">
                    <param name="output_selector" value="mixedOverlaps" />
                    <conditional name="o_weight_select">
                        <param name="o_weight_selector" value="yes" />
                        <param name="o_weight" value="overlapStats_o_weights.tabular" />
                    </conditional>
                    <conditional name="i_weight_select">
                        <param name="i_weight_selector" value="yes" />
                        <param name="i_weight" value="overlapStats_i_weights.tabular" />
                    </conditional>
                </conditional>
            </conditional>
            <output name="overlapStats_output4" value="overlapStats_output5.txt" />
        </test>
        <test expect_num_outputs="1">
            <conditional name="method_select">
                <param name="method" value="overlapStats" />
                <section name="windowCounts">
                    <repeat name="bam_input">
                        <param name="bam_file" value="rep1.bam" ftype="bam" />
                    </repeat>
                    <repeat name="bam_input">
                        <param name="bam_file" value="rep2.bam" ftype="bam" />
                    </repeat>
                    <param name="width" value="1" />
                    <param name="filter" value="1" />
                </section>
                <section name="region">
                    <param name="GRanges" value="overlapStats_regions.tabular" />
                    <param name="named" value="true" />
                </section>
                <param name="tab" value="overlapStats_tab.tabular" />
                <conditional name="output_select">
                    <param name="output_selector" value="summitOverlaps" />
                    <param name="region_best" value="overlapStats_best.tabular" />
                    <conditional name="o_summit_select">
                        <param name="o_summit_selector" value="boolean" />
                        <param name="o_summit" value="overlapStats_o_summit.tabular" />
                    </conditional>
                    <conditional name="i_summit_select">
                        <param name="i_summit_selector" value="boolean" />
                        <param name="i_summit" value="overlapStats_i_summit.tabular" />
                    </conditional>
                </conditional>
            </conditional>
            <output name="overlapStats_output5" value="overlapStats_output6.txt" />
        </test>-->

    </tests>
    <help><![CDATA[
Calculate counts-per-million (CPM) values for each feature
==========================================================

It returns:

- `CPM values`: A matrix of the same dimensions as object, containing (log-)transformed CPM values for each feature in each sample


Compute the maximum bimodality score across all base pairs in each region
=========================================================================

Consider a base position x. This function counts the number of forward- and reverse-strand reads within the interval [x-width+1, x]. It then calculates the forward:reverse ratio after adding prior.count to both counts. This is repeated for the interval [x, x+width-1], and the reverse:forward ratio is then computed. The smaller of these two ratios is used as the bimodality score. Sites with high bimodality scores will be enriched for forward- and reverse-strand enrichment on the left and right of the site, respectively. Given a genomic region, this function will treat each base position as a site. The largest bimodality score across all positions will be reported for each region. The idea is to assist with the identification of transcription factor binding sites, which exhibit strong strand bimodality. The function will be less useful for broad targets like histone marks. If multiple bam.files are specified, they are effectively pooled so that counting uses all reads in all files. A separate value of width can be specified for each library, to account for differences in fragmentation – see the ext argument for windowCounts for more details. In practice, this is usually unnecessary. Setting width to the average fragment length yields satisfactory results in most cases. If invert is set, the bimodality score will be flipped around, i.e., it will be maximized when reversestrand coverage dominates on the left, and forward-strand coverage dominates on the right. This is designed for use in CAGE analyses where this inverted bimodality is symptomatic of enhancer RNAs.

It returns:

- `Scores`: A column containing the maximum bimodality score (row) across all bases in each region (column)


Combines p-values across clustered tests using Simes’ method to control the cluster FDR
=======================================================================================

This method uses Simes’ procedure to compute the combined p-value for each cluster of tests with the same value of ids. Each combined p-value represents evidence against the global null hypothesis, i.e., all individual nulls are true in each cluster. This may be more relevant than examining each test individually when multiple tests in a cluster represent parts of the same underlying event, e.g.,
genomic regions consisting of clusters of windows. The BH method is also applied to control the FDR across all clusters. 

The importance of each test within a cluster can be adjusted by supplying different relative weight values. This may be useful for downweighting low-confidence tests, e.g., those in repeat regions. In Simes’ procedure, weights are interpreted as relative frequencies of the tests in each cluster. Note that these weights have no effect between clusters and will not be used to adjust the computed FDR.

By default, the relevant fields in tab are identified by matching the column names to their expected values. Multiple fields in tab containing the logFC substring are allowed, e.g., to accommodate ANOVA-like contrasts. 

A simple clustering approach for windows is provided in mergeWindows. However, anything can be used so long as it is independent of the p-values and does not compromise type I error control, e.g., promoters, gene bodies, independently called peaks. Any tests with NA values for ids will be ignored.

It returns:

A DataFrame with one row per cluster and various fields (Each row is named according to the ID of the corresponding cluster):

- `nWindows`: specifying the total number of windows in each cluster
- `*.up and *.down`: for each log-FC column in tab, containing the number of windows with log-FCs above 0.5 or below -0.5, respectively
- `PValue`: combined p-value
- `FDR`: containing the q-value corresponding to the combined p-value
- `direction`: specifying the dominant direction of change for windows in each cluster.


Compute filter statistics for windows, based on proportions or using enrichment over background
===============================================================================================

Convenient function to compute filter statistics for windows, based on proportions or using enrichment over background.

Proportion-based filtering supposes that a certain percentage of the genome is genuinely bound. If type="proportion", the filter statistic is defined as the ratio of the rank to the total number of windows. Rank is in ascending order, i.e., higher abundance windows have higher ratios. Windows are retained that have rank ratios above a threshold, e.g., 0.99 if 1% of the genome is assumed to be bound.

All other values of type will perform background-based filtering, where abundances of the windows are compared to those of putative background regions. The filter statistic are generally defined as the difference between window and background abundances, i.e., the log-fold increase in the counts. Windows can be filtered to retain those with large filter statistics, to select those that are more likely to contain genuine binding sites. The differences between the methods center around how the background abundances are obtained for each window.

If type="global", the median average abundance across the genome is used as a global estimate of the background abundance. This should be used when background contains unfiltered counts for large (2 - 10 kbp) genomic bins, from which the background abundance can be computed. The filter statistic for each window is defined as the difference between the window abundance and the global background. If background is not supplied, the background abundance is directly computed from entries in data.

If type="local", the counts of each row in data are subtracted from those of the corresponding row in background. The average abundance of the remaining counts is computed and used as the background abundance. The filter statistic is defined by subtracting the background abundance from the corresponding window abundance for each row. This is designed to be used when background contains counts for expanded windows, to determine the local background estimate.

If type="control", the background abundance is defined as the average abundance of each row in background. The filter statistic is defined as the difference between the average abundance of each row in data and that of the corresponding row in background. This is designed to be used when background contains read counts for each window in the control sample(s). Unlike type="local", there is no subtraction of the counts in background prior to computing the average abundance.

If filterWindows is selected as the filtering method, it returns:

- `abundances`: a column containing the average abundance of each row in data
- `filter`: a column containing the filter statistic for the given type for each row
- `back.abundances`: a column containing the average abundance of each entry in background

If scaleControlFilter is selected, it returns:

- `scale`: a column containing the scaling factor for multiplying the control counts
- `data.totals`: a column containing the library sizes for data
- `back.totals`: a column containing the library sizes for background

In addition if the percentage to filter out in count data is specified, it returns:

- 'keepsum': the sum of the filtered data


Find the local maxima for a given set of genomic regions
========================================================

For each region, this method will examine all regions within range on either side. It will then determine if the current region has the maximum value of metric across this range. A typical metric to maximize might be the sum of counts or the average abundance across all libraries. 

Preferably, regions should contain regularly sized and spaced windows or bins, e.g., from windowCounts. In particular, the algorithm will not support nested regions and will fail correspondingly if any are detected. 

The method is run separately on the entries for each strand, and the results are collated into a single output. This may be useful for strand-specific applications.

It returns:

- `local maxima`: a column indicating whether each region (row) in regions is a local maxima


Find the test with the strongest evidence for rejection of the null in each cluster
===================================================================================

Clusters are identified as those tests with the same value of ids (any NA values are ignored). By perfroming selection on corrected p-values, the tool identifies the test with the lowest p-value as that with the strongest evidence against the null in each cluster. The p-value of the chosen test is adjusted using the Bonferroni correction, based on the total number of tests in the parent cluster. This is necessary to obtain strong control of the family-wise error rate such that the best test can be taken from each cluster for further consideration.

The importance of each window in each cluster can be adjusted by supplying different relative weight values. Each weight is interpreted as a different threshold for each test in the cluster. Larger weights correspond to lower thresholds, i.e., less evidence is needed to reject the null for tests deemed to be more important. This may be useful for upweighting particular tests, e.g., windows containing a motif for the TF of interest.

Note the difference between this function and combineTests. The latter presents evidence for any rejections within a cluster. This function specifies the exact location of the rejection in the cluster, which may be more useful in some cases but at the cost of conservativeness. In both cases, clustering procedures such as mergeWindows can be used to identify the cluster.

If perfrom selection on corrected p-values is not selected, the best test is defined as that with the highest log-CPM value. This should be independent of the p-value so no adjustment is necessary. Weights are not applied here. This mode may be useful when abundance is correlated to rejection under the alternative hypothesis, e.g., picking high-abundance regions that are more likely to contain peaks.

It returns:

A DataFrame with one row per cluster.

- `best`: the index for the best test in the cluster
- `PValue`: the (possibly adjusted) p-value for that test
- `FDR`:  the q-value corresponding to the adjusted p-value
- `logFC`: logFC values
- `logCPM`: logCPM values


Compute the length of the sequenced fragment for each read pair in paired-end tag (PE) data
===========================================================================================

This method computes a number of diagnostics for paired-end data in a supplied BAM file. The aims is to provide an indication of the quality of library preparation and sequencing.

Any read pair with exactly one unmapped read is discarded, and the number of read pairs lost in this manner is recorded. Obviously, read pairs with both reads unmapped will be ignored completely, as will any unpaired reads in the BAM file. 

Of the mapped pairs, the valid (i.e., proper) read pairs are identified. This involves several criteria:

- Read pairs must be intrachromosomal. If the reads are on different chromosomes, the read pair will be recorded as being interchromosomal.
- The two reads in the pair must lie on opposite strands. Otherwise, the read pair will be considered as being improperly orientated.
- The 5’ end of the forward read must not map to a higher genomic coordinate than the 5’ end of the reverse read. Otherwise, the read pair will be considered as being improperly orientated. 

Note that the 3’ end of one read is allowed to overrun the 5’ end of the other. This avoids being too stringent in the presence of sequencing errors, untrimmed adaptors, etc. at the start or ends of reads. Each valid read pair corresponds to a DNA fragment where both ends are sequenced. The size of the fragment can be determined by calculating the distance between the 5’ ends of the mapped reads. The distribution of sizes is useful for assessing the quality of the library preparation, along with all of the recorded diagnostics. Note that any max.frag specification in param will be ignored; sizes for all valid pairs will be returned.

It returns:

- `sizes`: a column of fragment lengths for all valid read pairs in the library
- `diagnostics`: a column containing the total number of reads, the number of mapped reads, number of mapped singleton reads, pairs with exactly one unmapped read, number of improperly orientated read pairs and interchromosomal pairs


Get the widths of the read counting interval for each region
============================================================

Widths of all regions are increased by the average fragment length during the calculations. This is because each count represents the number of (imputed) fragments overlapping each region. Thus, a 1 bp window has an effective width that includes the average length of each fragment.

It returns:

- `width`: a column containing the effective width, in base pairs, of each region (row)


Compute assorted statistics for overlaps between windows and regions in a Hits object
=====================================================================================

 The method provide convenient wrappers around combineTests, getBestTest, empiricalFDR, mixedClusters and upweightSummit for handling overlaps between windows and arbitrary prespecified regions. They accept Hits objects produced by running findOverlaps between regions (as query) and windows (as subject). Each set of windows overlapping a region is defined as a cluster to compute various statistics.

A wrapper is necessary as a window may overlap multiple regions. If so, the multiple instances of that window are defined as distinct “overlapped” windows, where each overlapped window is assigned to a different region. Each overlapped window is represented by a row of olap. In contrast, the “individual” window just refers to the window itself, regardless of what it overlaps. This is represented by each row of the RangedSummarizedExperiment object and the tab derived from it.

For combineOverlaps, getBestOverlaps, empiricalOverlaps and mixedOverlaps, it returns:

A dataframe from their respective wrapped functions. Each row of the dataframe corresponds to a region, where regions without overlapped windows are assigned NA values.

For summitOverlaps, it returns:

- `weights`: a column of weights. This can be used as weights for each overlapped window in the other two functions.


Compute the scaled average abundance for each feature
=====================================================

Obtain strand-specific counts for each genomic window or region
===============================================================

Calculates counts-per-million values
====================================

    ]]></help>
    <expand macro="citations" />
</tool>