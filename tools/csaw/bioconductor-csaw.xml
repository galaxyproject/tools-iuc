<tool id="bioconductor-csaw" name="csaw" version="@VERSION@.0">
    <description>detects differentially bound regions</description>

     <macros>
       <import>csaw_macros.xml</import>
    </macros>

     <expand macro="requirements" />

    <command detect_errors="exit_code"><![CDATA[
        Rscript '$script'
    ]]></command>

    <configfiles>
        <configfile name="script"><![CDATA[
## Setup R error handling to go to stderr
options(show.error.messages=F, error=function(){cat(geterrmessage(),file=stderr());q("no",1,F)})
loc <- Sys.setlocale("LC_MESSAGES", "en_US.UTF-8")

## Import library
library(csaw)

##clusterWindows
#if str($clusterWindows_select.clusterWindows) == 'yes'
    clust_grange <- as.character(unlist(strsplit(gsub(" ", "", "${clusterWindows_select.GRanges}", ","), ",")))
    i_range <- read.table("${clusterWindows_select.IRanges}")
    clust_regions <- GRanges(clust_grange, IRanges(i_range[[1]],i_range[[2]]))
    tab <- read.table("${clusterWindows_select.tab}")
    clust_target <- as.numeric("${clusterWindows_select.target}")
    #if str($clusterWindows_select.pval_col) != ''
        pval_col <- as.numeric(gsub("([0-9]+).*$", "\\1", "${clusterWindows_select.pval_col}"))
        if (is.na(pval_col)){
            pval_col <- "${clusterWindows_select.pval_col}"
        }
    #else
        pval_col <- NULL
    #end if
    #if str($clusterWindows_select.fc_col) != ''
        fc_col <- as.numeric(gsub("([0-9]+).*$", "\\1", "${clusterWindows_select.fc_col}"))
        if (is.na(fc_col)){
            fc_col <- "${clusterWindows_select.fc_col}"
        }
    #else
        fc_col <- NA
    #end if
    tol <- as.numeric("${clusterWindows_select.tol}")
    #if str($clusterWindows_select.weight) != ''
        clust_weight <- as.numeric("${clusterWindows_select.weight}")
    #else
        clust_weight <- NULL
    #end if
    #if str($clusterWindows_select.grid_param_select) == 'yes'
        clust_length <- as.numeric("${clusterWindows_select.grid_param_select.length}")
        clust_range <- as.numeric("${clusterWindows_select.grid_param_select.length}")
        #if str($clusterWindows_select.grid_param_select.grid_param_select.iter) != ''
            clust_iter <- as.numeric("${clusterWindows_select.grid_param_select.iter}")
        #else
            clust_iter <- NULL
        #end if
        #if str($clusterWindows_select.grid_param_select.grid_param_select.scale) != ''
            clust_scale <- as.numeric("${clusterWindows_select.grid_param_select.scale}")
        #else 
            clust_scale <- NULL
        #end if
        clust_grid_param <- list(length=clust_length, range=clust_range, iter=clust_iter, scale=clust_scale)
    #else
        clust_grid_param <- NULL
    #end if

    sink("$clusterWindows_output")
       clusterWindows(clust_regions, tab, clust_target, pval.col=pval_col, fc.col=fc_col, tol, weight=clust_weight, grid.param=clust_grid_param)
    sink()
#end if

##combineTests
#if str($combineTests_select.combineTests) == 'yes'
    comTest_ids <-scan("${combineTests_select.ids}", what = integer())
    comTest_tab <- read.table("${combineTests_select.tab}", sep="", header=T)
    #if str($combineTests_select.weight) != ''
        comTest_w <- scan("${combineTests_select.weight}", what=numeric())
    #else
        comTest_w <- NULL
    #end if
    #if str($combineTests_select.pval_col) != ''
        comTest_pval_col <- as.numeric(gsub("([0-9]+).*$", "\\1", "${combineTests_select.pval_col}"))
        if (is.na(comTest_pval_col)){
            comTest_pval_col <- "${combineTests_select.pval_col}"
        }
    #else
        comTest_pval_col <- NULL
    #end if
    #if str($combineTests_select.fc_col) != ''
        comTest_fc_col <- as.numeric(gsub("([0-9]+).*$", "\\1", "${combineTests_select.fc_col}"))
        if (is.na(comTest_fc_col)){
            comTest_fc_col <- "${combineTests_select.fc_col}"
        }
    #else
        comTest_fc_col <- NULL
    #end if
    sink("$combineTests_output")
       combineTests(comTest_ids, comTest_tab, weight=comTest_w, pval.col=comTest_pval_col, fc.col=comTest_fc_col)
    sink()
#end if

##consolidateClusters
#if str($consolidateClusters_select.consolidateClusters) == 'yes'
    gRangeList <- c()
    IRangeList <- list()
    width <- c()
    #for $i in $consolidateClusters_select.gRange_obj
        #if str($i.width) != ''
            width <- c(width, as.numeric("${i.width}"))
        #end if
        gRangeList <- c(gRangeList, "${i.GRanges}")
        IRangeList <- append(IRangeList, list(scan("${i.IRanges}", what=numeric())))
    #end for
    dataList <- c()
    for (i in seq(gRangeList)){
        dataList <- c(dataList, GRanges(gRangeList[i], IRanges(IRangeList[[i]], width=width[i])))
    }
    resultList <- list()
    #for $i in $consolidateClusters_select.db
        resultList <- append(resultList, list(read.table("${i.result_list}", header=T)))
    #end for
    #if str($consolidateClusters_select.equiweight) == 'true'
        equiweight <- TRUE
    #else
        equiweight <- FALSE
    #end if
    conClust_tol <- as.numeric("${consolidateClusters_select.tol}")
    #if str($consolidateClusters_select.pval_col) != ''
        conClust_pval_col <- as.numeric(gsub("([0-9]+).*$", "\\1", "${consolidateClusters_select.pval_col}"))
        if (is.na(conClust_pval_col)){
            conClust_pval_col <- "${consolidateClusters_select.pval_col}"
        }
    #else
        conClust_pval_col <- NULL
    #end if
    #if str("$consolidateClusters_select.fc_col")!= ''
        conClust_fc_col <- as.numeric(gsub("([0-9]+).*$", "\\1", "${consolidateClusters_select.fc_col}"))
        if (is.na(conClust_fc_col)){
            conClust_fc_col <- "${consolidateClusters_select.fc_col}"
        }
    #else
        conClust_fc_col <- NULL
    #end if
    
    sink("$consolidateClusters_output")
       consolidateClusters(dataList, resultList, equiweight=equiweight, tol=conClust_tol, pval.col=conClust_pval_col, fc.col=conClust_fc_col)
    sink()

#end if

##consolidateSizes_select
#if str($consolidateSizes_select.consolidateSizes) == 'yes'
    cS_gRangeList <- c()
    cS_IRangeList <- list()
    cS_width <- c()
    #for $i in $consolidateSizes_select.gRange_obj
        #if str($i.width) != ''
            cS_width <- c(cS_width, as.numeric("${i.width}"))
        #end if
        cS_gRangeList <- c(cS_gRangeList, "${i.GRanges}")
        cS_IRangeList <- append(cS_IRangeList, list(scan("${i.IRanges}", what=numeric())))
    #end for
    cS_dataList <- c()
    for (i in seq(cS_gRangeList)){
        cS_dataList <- c(cS_dataList, GRanges(cS_gRangeList[i], IRanges(cS_IRangeList[[i]], width=cS_width[i])))
    }
     cS_resultList <- list()
    #for $i in $consolidateSizes_select.db
        cS_resultList <- append(cS_resultList, list(read.table("${i.result_list}", header=T)))
    #end for
    #if str($consolidateSizes_select.equiweight) == 'true'
        cS_equiweight <- TRUE
    #else
        cS_equiweight <- FALSE
    #end if
    cS_tol <- as.numeric("${consolidateSizes_select.tol}")
    #if str($consolidateSizes_select.max_width) != ''
        cS_maxWidth <- as.numeric("${consolidateSizes_select.max_width}")
    #else
        cS_maxWidth <- NULL
    #end if
    #if str($consolidateSizes_select.GRanges) != ''
        cS_gRange <- as.character(unlist(strsplit(gsub(" ", "", "${consolidateSizes_select.GRanges}", ","), ",")))
        cS_b <- unlist(strsplit(gsub(" ", "", "${consolidateSizes_select.IRanges}", ","), ";"))
        cS_c <- gsub("\\[|\\]", "", cS_b)
        cS_d <- lapply(cS_c, function(x){x <- as.numeric(unlist(strsplit(x, ",")))})
        cS_e <- c()
        cS_f <- c()
        for (i in seq(cS_d)){ 
            cS_e <- c(cS_e, cS_d[[i]][1])
            cS_f <- c(cS_f, cS_d[[i]][2])
        }
    cS_regions <- GRanges(cS_gRange, IRanges(cS_e,cS_f))
    #else
        cS_regions <-NULL
    #end if
    
    sink("$consolidateSizes_output")
        consolidateSizes(cS_dataList, cS_resultList, equiweight=cS_equiweight, merge.args=list(tol=cS_tol, max.width=cS_maxWidth), region=cS_regions)
    sink()
#end if

##mergeWindows
#if str($mergeWindows_select.mergeWindows) == 'yes'
    mW_gRange <- as.character(unlist(strsplit(gsub(" ", "", "${mergeWindows_select.GRanges}", ","), ",")))
        mW_b <- unlist(strsplit(gsub(" ", "", "${mergeWindows_select.IRanges}", ","), ";"))
        mW_c <- gsub("\\[|\\]", "", mW_b)
        mW_d <- lapply(mW_c, function(x){x <- as.numeric(unlist(strsplit(x, ",")))})
        mW_e <- c()
        mW_f <- c()
        for (i in seq(mW_d)){ 
            mW_e <- c(mW_e, mW_d[[i]][1])
            mW_f <- c(mW_f, mW_d[[i]][2])
        }
    mW_regions <- GRanges(mW_gRange, IRanges(mW_e,mW_f))
    mW_tol <- as.numeric("${mergeWindows_select.tol}")
    #if str($mergeWindows_select.max_width) != ''
        mW_maxWidth <- as.numeric("${consolidateSizes_select.max_width}")
    #else
        mW_maxWidth <- NULL
    #end if
    #if str($mergeWindows_select.ignore_strand) == 'true'
        ignore_strand <- T
    #else
        ignore_strand <- F
    #end if

sink("$mergeWindows_output")
    mergeWindows(mW_regions, mW_tol, sign=NULL, max.width=mW_maxWidth, ignore.strand=ignore_strand)
sink()

#end if

]]>
        </configfile>
    </configfiles>

    <inputs>

        <!--Page 8 value?-->
        <conditional name="combineTests_select">
            <param name="combineTests" type="select" label="Combines p-values across clustered tests using Simes’ method to control the cluster FDR?" help="Use Simes’ procedure to compute the combined p-value for each cluster of tests with the same value of ids. Each combined p-value represents evidence against the global null hypothesis, i.e., all individual nulls are true in each cluster. This may be more relevant than examining each test individually when multiple tests in a cluster represent parts of the same underlying event, e.g., genomic regions consisting of clusters of windows. The BH method is also applied to control the FDR across all clusters." >
                <option value="yes">Yes</option>
                <option value="no" selected="true">No</option>
            </param>
            <when value="yes">
                <expand macro="combineTest_param" />
            </when>
            <when value="no"> </when>
        </conditional>
        <conditional name="consolidateClusters_select">
            <param name="consolidateClusters" type="select" label="Consolidate DB results from multiple analyses with cluster-level FDR control?" help="Typically involving different window sizes. The aim is to provide comprehensive detection of DB at a range of spatial resolutions. Significant windows from each analysis are identified and used for clustering with cluster windows. This represents the post-hoc counterpart to consolidateSizes.">
                <option value="yes">Yes</option>
                <option value="no" selected="true">No</option>
            </param>
            <when value="yes">
                <!--RangedSummarizedExperiment?
                    arguments to be passed to clusterWindow?-->
                <expand macro="consolidate_param" />
                <expand macro="col_names" />
            </when>
            <when value="no"> </when>
        </conditional>
         <conditional name="consolidateSizes_select">
            <param name="consolidateSizes" type="select" label="Consolidate DB results from multiple window sizes?" help="A comprehensive detection of DB at a range of spatial resolutions. Windows of all sizes are clustered together and the p-values from all windows in each cluster are combined." >
                <option value="yes">Yes</option>
                <option value="no">No</option>
            </param>
            <when value="yes">
                <expand macro="consolidate_param" />
                <param name="tol" type="float" value="" optional="true" label="Maximum distance between adjacent windows"/>
                <param name="max_width" type="float" value="" optional="true" label="Maximum size of merged intervals"  />
                <param name="GRanges" type="text" optional="true" label="Objects" />
                <param name="IRanges" type="text" optional="true" label="Ranges" help="Enter the interval in square brackets separated by a comma and a colon for each range, e.g. [1, 100]; [500, 580]">
                    <sanitizer>
                        <valid>
                            <add value="[" />
                            <add value="]" />
                            <add value=";" />
                        </valid>
                    </sanitizer> 
                </param>
                
                <!--TO DO: merge.args
                            combine.args
                            overlap.args-->
            </when>
            <when value="no"> </when>
        </conditional>
        <conditional name="mergeWindows_select">
            <param name="mergeWindows" type="select" label="Use a simple single-linkage approach to merge adjacent or overlapping windows into clusters?" help="Windows in regions are merged if the gap between the end of one window and the start of the next is no greater than tol. Adjacent windows can then be chained together to build a cluster of windows across the linear genome.">
                <option value="yes">Yes</option>
                <option value="no" selected="true">No</option>
            </param>
            <when value="yes">
                <expand macro="gRanges" />
                <param name="tol" type="float" value="" optional="true" label="Maximum distance between adjacent windows" help="A value of zero means that the windows must be contiguous whereas negative values specify minimum overlaps" />
                <!--sign-->
                <param name="max_width" type="float" value="" optional="true" label="Maximum size of merged intervals" help="Specification prevents the formation of excessively large clusters when many adjacent regions are present. Any cluster that is wider than the max width is split into multiple subclusters of (roughly) equal size. Specifically, the cluster interval is partitioned into the smallest number of equally-sized subintervals where each subinterval is smaller than max width. Windows are then assigned to each subinterval based on the location of the window midpoints. Suggested values range from 2000 to 10000 bp, but no limits are placed on the maximum size if no value entered." />
                <param name="ignore_strand" type="boolean" truevalue="true" falsevalue="" checked="true" label="Ignore the strandedness of regions?" help="If no is selected, the entries in regions are split into their separate strands." />
            </when>
            <when value="no"> </when>

        </conditional>



        
        
    </inputs>

    <outputs>
        <data name="output" format="txt" label="${tool.name} on ${on_string}: Output" >
            <filter>checkBimodality_select['checkBimodality'] == 'yes'</filter>
        </data>
        <data name="clusterFDR_output" format="txt" label="${tool.name} on ${on_string}: clusterFDR Output" >
            <filter>clusterFDR_select['clusterFDR'] == 'yes'</filter>
        </data>
        <data name="clusterWindows_output" format="txt" label="${tool.name} on ${on_string}: clusterWindows Output" >
            <filter>clusterWindows_select['clusterWindows'] == 'yes'</filter>
        </data>
        <data name="combineTests_output" format="txt" label="${tool.name} on ${on_string}: combineTests Output" >
            <filter>combineTests_select['combineTests'] == 'yes'</filter>
        </data>
        <data name="consolidateClusters_output" format="txt" label="${tool.name} on ${on_string}: consolidateClusters Output" >
            <filter>consolidateClusters_select['consolidateClusters'] == 'yes'</filter>
        </data>
        <data name="consolidateSizes_output" format="txt" label="${tool.name} on ${on_string}: consolidateSizes Output" >
            <filter>consolidateSizes_select['consolidateSizes'] == 'yes'</filter>
        </data>
        <data name="mergeWindows_output" format="txt" label="${tool.name} on ${on_string}: mergeWindows Output" >
            <filter>mergeWindows_select['mergeWindows'] == 'yes'</filter>
        </data>
    
    </outputs>

    <tests>
    	<!--<test>
			<repeat name="bam_input">
                <param name="bam_file" value="rep1.bam" ftype="bam" />
            </repeat>
            <repeat name="bam_input">
                <param name="bam_file" value="rep2.bam" ftype="bam" />
            </repeat>

            <param name="GRanges" value="chrA, chrA, chrB, chrC" />

            <param name="IRanges" value="[1, 100]; [500, 580]; [100, 500]; [1000, 1500]" />
           
        </test>-->

        <!-- consolidate sizes: chrA¸ chrA, chrB, chrC [1, 200]; [500, 1000]; [100, 700]; [1000, 1500]-->
        <!-- merge windows [498, 538]; [940, 980], [609, 649]-->

    </tests>

    <help><![CDATA[
        Detection of differentially bound regions in ChIP-seq data with sliding windows, with methods for normalization and proper FDR control.
    ]]></help>


</tool>