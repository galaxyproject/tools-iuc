<tool id="bioconductor-csaw" name="csaw" version="@VERSION@.0">
    <description>detects differentially bound regions</description>

     <macros>
       <import>csaw_macros.xml</import>
    </macros>

     <expand macro="requirements" />

    <command detect_errors="exit_code"><![CDATA[
        Rscript '$script'
    ]]></command>

    <configfiles>
        <configfile name="script"><![CDATA[
## Setup R error handling to go to stderr
options(show.error.messages=F, error=function(){cat(geterrmessage(),file=stderr());q("no",1,F)})
loc <- Sys.setlocale("LC_MESSAGES", "en_US.UTF-8")

## Import library
library(csaw)

## checkBimodality
	#if str($checkBimodality_select.checkBimodality) == 'yes'
		bamFiles <- c()
    	#for $i in $checkBimodality_select.bam_input
        	bamFiles <- c(bamFiles, "${i.bam_file}")
    	#end for

    	gRange <- as.character(unlist(strsplit(gsub(" ", "", "${checkBimodality_select.GRanges}", ","), ",")))
    	b <- unlist(strsplit(gsub(" ", "", "${checkBimodality_select.IRanges}", ","), ";"))
    	c <- gsub("\\[|\\]", "", b)
    	d <- lapply(c, function(x){x <- as.numeric(unlist(strsplit(x, ",")))})
    	e <- c()
    	f <- c()
		for (i in seq(d)){ 
			e <- c(e, d[[i]][1])
			f <- c(f, d[[i]][2])
		}

        gRange <- as.character(unlist(strsplit(gsub(" ", "", "${checkBimodality_select.GRanges}", ","), ",")))
        b <- unlist(strsplit(gsub(" ", "", "${checkBimodality_select.IRanges}", ","), ";"))
        c <- gsub("\\[|\\]", "", b)
        d <- lapply(c, function(x){x <- as.numeric(unlist(strsplit(x, ",")))})
        e <- c()
        f <- c()
        for (i in seq(d)){ 
        e <- c(e, d[[i]][1])
        f <- c(f, d[[i]][2])
    }
		regions <- GRanges(gRange, IRanges(e,f))

        w <- as.numeric("${checkBimodality_select.width}")

        #if str($checkBimodality_select.readParam_select.readParam_selector) == 'yes'
            pe <- "$checkBimodality_select.readParam_select.pe"
            max_frag <- as.numeric("$checkBimodality_select.readParam_select.max_frag")

            #if str($checkBimodality_select.readParam_select.dedup) == ''
                ded_up <- F
            #else
                ded_up <- T
            #end if

            #if str($checkBimodality_select.readParam_select.minq) != ''
                min_q <- as.numeric("${checkBimodality_select.readParam_select.minq}")
            #else
                min_q <- NA
            #end if

            #if str($checkBimodality_select.readParam_select.foward) == 'NA'
                forward <- NA
            #else if str($checkBimodality_select.readParam_select.foward) == 'forward'
                forward <- TRUE
            #else if str($checkBimodality_select.readParam_select.foward) == 'reverse'
                forward <- FALSE
            #end if

            restrict <- as.character(unlist(strsplit(gsub(" ", "", "${checkBimodality_select.readParam_select.restrict}", ","), ",")))
            #if str($checkBimodality_select.readParam_select.discard_select) == 'yes'
                dis_gRange <- as.character(unlist(strsplit(gsub(" ", "", "${checkBimodality_select.discard_select.GRanges}", ","), ",")))
                    dis_b <- unlist(strsplit(gsub(" ", "", "${checkBimodality_select.IRanges}", ","), ";"))
                    dis_c <- gsub("\\[|\\]", "", dis_b)
                    dis_d <- lapply(dis_c, function(x){x <- as.numeric(unlist(strsplit(x, ",")))})
                    dis_e <- c()
                    dis_f <- c()
                    for (i in seq(dis_d)){ 
                        dis_e <- c(dis_e, dis_d[[i]][1])
                        dis_f <- c(dis_f, dis_d[[i]][2])
                    }
                discard <- GRanges(dis_gRange, IRanges(dis_e, dis_f))
            #else
                discard <- GRanges()
            #end if
            p <- readParam(pe=pe, max.frag=max_frag, dedup=ded_up, minq=min_q, forward=forward, discard=discard, BPPARAM=SerialParam())
        #else
            p <- readParam
        #end if  

        prior_count <- as.numeric("${checkBimodality_select.prior_count}")
        #if str($checkBimodality_select.invert) == ''
            inver <- F
        #else
            inver <- T
        #end if
        
        sink("$output")
            print("hi")
        sink()
         
    #end if

##clusterFDR
#if str($clusterFDR_select.clusterFDR) == 'yes'
    id <- scan("${clusterFDR_select.id}", what = integer())
    threshold <- as.numeric("${clusterFDR_select.threshold}")
    target <- as.numeric("${clusterFDR_select.target}")
    adjp <- scan("${clusterFDR_select.adjp}", what = numeric())
    #if str($clusterFDR_select.weight) != ''
        weight <- as.numeric("${clusterFDR_select.weight}")
    #else
        weight <- NULL
    #end if
    #if str($clusterFDR_select.grid_param_select) == 'yes'
        length <- as.numeric("${clusterFDR_select.grid_param_select.length}")
        range <- as.numeric("${clusterFDR_select.grid_param_select.length}")
        #if str($clusterFDR_select.grid_param_select.grid_param_select.iter) != ''
            iter <- as.numeric("${clusterFDR_select.grid_param_select.iter}")
        #else
            iter <- NULL
        #end if
        #if str($clusterFDR_select.grid_param_select.grid_param_select.scale) != ''
            scale <- as.numeric("${clusterFDR_select.grid_param_select.scale}")
        #else 
            scale <- NULL
        #end if
        grid_param <- list(length=length, range=range, iter=iter, scale=scale)
    #else
        grid_param <- NULL
    #end if
   
    sink("$clusterFDR_output")
        cluster_fdr <- clusterFDR(id, threshold, weight=weight)
        control_cluster <- controlClusterFDR(target, adjp, weight=weight, grid.param=grid_param)
    sink()
#end if

##clusterWindows
#if str($clusterWindows_select.clusterWindows) == 'yes'
    clust_grange <- as.character(unlist(strsplit(gsub(" ", "", "${clusterWindows_select.GRanges}", ","), ",")))
    i_range <- read.table("${clusterWindows_select.IRanges}")
    clust_regions <- GRanges(clust_grange, IRanges(i_range[[1]],i_range[[2]]))
    tab <- read.table("${clusterWindows_select.tab}")
    clust_target <- as.numeric("${clusterWindows_select.target}")
    #if str($clusterWindows_select.pval_col) != ''
        pval_col <- as.numeric(gsub("([0-9]+).*$", "\\1", "${clusterWindows_select.pval_col}"))
        if (is.na(pval_col)){
            pval_col <- "${clusterWindows_select.pval_col}"
        }
    #else
        pval_col <- NULL
    #end if
    #if str($clusterWindows_select.fc_col) != ''
        fc_col <- as.numeric(gsub("([0-9]+).*$", "\\1", "${clusterWindows_select.fc_col}"))
        if (is.na(fc_col)){
            fc_col <- "${clusterWindows_select.fc_col}"
        }
    #else
        fc_col <- NA
    #end if
    tol <- as.numeric("${clusterWindows_select.tol}")
    #if str($clusterWindows_select.weight) != ''
        clust_weight <- as.numeric("${clusterWindows_select.weight}")
    #else
        clust_weight <- NULL
    #end if
    #if str($clusterWindows_select.grid_param_select) == 'yes'
        clust_length <- as.numeric("${clusterWindows_select.grid_param_select.length}")
        clust_range <- as.numeric("${clusterWindows_select.grid_param_select.length}")
        #if str($clusterWindows_select.grid_param_select.grid_param_select.iter) != ''
            clust_iter <- as.numeric("${clusterWindows_select.grid_param_select.iter}")
        #else
            clust_iter <- NULL
        #end if
        #if str($clusterWindows_select.grid_param_select.grid_param_select.scale) != ''
            clust_scale <- as.numeric("${clusterWindows_select.grid_param_select.scale}")
        #else 
            clust_scale <- NULL
        #end if
        clust_grid_param <- list(length=clust_length, range=clust_range, iter=clust_iter, scale=clust_scale)
    #else
        clust_grid_param <- NULL
    #end if

    sink("$clusterWindows_output")
       clusterWindows(clust_regions, tab, clust_target, pval.col=pval_col, fc.col=fc_col, tol, weight=clust_weight, grid.param=clust_grid_param)
    sink()
#end if

##combineTests
#if str($combineTests_select.combineTests) == 'yes'
    comTest_ids <-scan("${combineTests_select.ids}", what = integer())
    comTest_tab <- read.table("${combineTests_select.tab}", sep="", header=T)
    #if str($combineTests_select.weight) != ''
        comTest_w <- scan("${combineTests_select.weight}", what=numeric())
    #else
        comTest_w <- NULL
    #end if
    #if str($combineTests_select.pval_col) != ''
        comTest_pval_col <- as.numeric(gsub("([0-9]+).*$", "\\1", "${combineTests_select.pval_col}"))
        if (is.na(comTest_pval_col)){
            comTest_pval_col <- "${combineTests_select.pval_col}"
        }
    #else
        comTest_pval_col <- NULL
    #end if
    #if str($combineTests_select.fc_col) != ''
        comTest_fc_col <- as.numeric(gsub("([0-9]+).*$", "\\1", "${combineTests_select.fc_col}"))
        if (is.na(comTest_fc_col)){
            comTest_fc_col <- "${combineTests_select.fc_col}"
        }
    #else
        comTest_fc_col <- NULL
    #end if
    sink("$combineTests_output")
       combineTests(comTest_ids, comTest_tab, weight=comTest_w, pval.col=comTest_pval_col, fc.col=comTest_fc_col)
    sink()
#end if

##consolidateClusters
#if str($consolidateClusters_select.consolidateClusters) == 'yes'
    gRangeList <- c()
    IRangeList <- list()
    width <- c()
    #for $i in $consolidateClusters_select.gRange_obj
        #if str($i.width) != ''
            width <- c(width, as.numeric("${i.width}"))
        #end if
        gRangeList <- c(gRangeList, "${i.GRanges}")
        IRangeList <- append(IRangeList, list(scan("${i.IRanges}", what=numeric())))
    #end for
    dataList <- c()
    for (i in seq(gRangeList)){
        dataList <- c(dataList, GRanges(gRangeList[i], IRanges(IRangeList[[i]], width=width[i])))
    }
    resultList <- list()
    #for $i in $consolidateClusters_select.db
        resultList <- append(resultList, list(read.table("${i.result_list}", header=T)))
    #end for
    #if str($consolidateClusters_select.equiweight) == 'true'
        equiweight <- TRUE
    #else
        equiweight <- FALSE
    #end if
    conClust_tol <- as.numeric("${consolidateClusters_select.tol}")
    #if str($consolidateClusters_select.pval_col) != ''
        conClust_pval_col <- as.numeric(gsub("([0-9]+).*$", "\\1", "${consolidateClusters_select.pval_col}"))
        if (is.na(conClust_pval_col)){
            conClust_pval_col <- "${consolidateClusters_select.pval_col}"
        }
    #else
        conClust_pval_col <- NULL
    #end if
    #if str("$consolidateClusters_select.fc_col")!= ''
        conClust_fc_col <- as.numeric(gsub("([0-9]+).*$", "\\1", "${consolidateClusters_select.fc_col}"))
        if (is.na(conClust_fc_col)){
            conClust_fc_col <- "${consolidateClusters_select.fc_col}"
        }
    #else
        conClust_fc_col <- NULL
    #end if
    
    sink("$consolidateClusters_output")
       consolidateClusters(dataList, resultList, equiweight=equiweight, tol=conClust_tol, pval.col=conClust_pval_col, fc.col=conClust_fc_col)
    sink()

#end if

]]>
        </configfile>
    </configfiles>

    <inputs>
    	<conditional name="checkBimodality_select">
    		<param name="checkBimodality" type="select" label="Compute the maximum bimodality score across all base pairs in each region?" >
    			<option value="yes">Yes</option>
    			<option value="no" selected="true">No</option>
    		</param>
    		<when value="yes">
				<repeat name="bam_input" title="Upload indexed BAM files in sorted order" >
            		<param name="bam_file" type="data" format="bam" label="BAM file" />
        		</repeat>
        		<expand macro="gRanges" />
        		<!--width list?-->
        		<param name="width" type="integer" value="100" label="Span with which to compute bimodality" />
        		<conditional name="readParam_select">
        			<param name="readParam_selector" type="select" label="Specify read loading parameters?" >
        				<option value="yes">Yes</option>
    					<option value="no" selected="true">No</option>
    				</param>
    				<when value="yes">
                        <expand macro="readParam" />
    				</when>
    				<when value="no"> </when>
    			</conditional>
    			<param name="prior_count" type="integer" value="2" label="Prior count to compute bimodality scores" />
    			<param name="invert" type="boolean" truevalue="true" falsevalue="" checked="false" label="Invert bimodality score?" />
        	</when>
        	<when value="no"> </when>
        </conditional>

        <conditional name="clusterFDR_select">
            <param name="clusterFDR" type="select" label="Compute the FDR across clusters based on the test-level FDR threshold?" >
                <option value="yes">Yes</option>
                <option value="no" selected="true">No</option>
            </param>
            <when value="yes">
                <param name="id" type="data" format="tabular" label="Cluster IDs for each significant test below threshold" />
                <param name="threshold" type="float" value="" label="The FDR threshold used to define the significant tests" />
                <!--Separate output for controlClusterFDR?-->
                <param name="target" type="float" value="" optional="true" label="The desired cluster-level FDR threshold" />
                <param name="adjp" type="data" format="tabular" label="Window-level adjusted p-values" />
                <!--Include weights? Advanced Settings-->
                <expand macro="weight" />
                <expand macro="grid_param" />
            </when>
            <when value="no"> </when>
        </conditional>
        <conditional name="clusterWindows_select">
            <param name="clusterWindows" type="select" label="Clusters significant windows while controlling the cluster-level FDR?">
                <option value="yes">Yes</option>
                <option value="no" selected="true">No</option>
            </param>
            <when value="yes">
                <param name="GRanges" type="text" label="Objects" />
                <param name="IRanges" type="data" format="tabular" label="Ranges" help="Upload as a dataframe where each row is a interval separated by a space" />
                <param name="tab" type="data" format="tabular" label="Dataframe of results with a PValue field for each window" />
                <param name="target" type="float" value="" label="Desired cluster-level FDR" />
                <expand macro="col_names" />
                <param name="tol" type="float" value="" optional="true" label="Maximum distance between adjacent windows"/>
                <expand macro="weight" />
                <expand macro="grid_param" />
            </when>
            <when value="no"> </when>
        </conditional>
        <!--Page 8 value?-->
        <conditional name="combineTests_select">
            <param name="combineTests" type="select" label="Combines p-values across clustered tests using Simes’ method to control the cluster FDR?" help="Use Simes’ procedure to compute the combined p-value for each cluster of tests with the same value of ids. Each combined p-value represents evidence against the global null hypothesis, i.e., all individual nulls are true in each cluster. This may be more relevant than examining each test individually when multiple tests in a cluster represent parts of the same underlying event, e.g., genomic regions consisting of clusters of windows. The BH method is also applied to control the FDR across all clusters." >
                <option value="yes">Yes</option>
                <option value="no" selected="true">No</option>
            </param>
            <when value="yes">
                <param name="ids" type="data" format="tabular" label="Cluster ID for each test" help="Upload as a dataframe where each row is an integer." />
                <param name="tab" type="data" format="tabular" label="Dataframe of results with PValue and at least one logFC field for each test" />
                <param name="weight" type="data" format="tabular" optional="true" label="Weights for each window" help="Upload as a dataframe where each row is a numeric value. If none specified, the weight defaults to 1 for each test. Supplying different relative weight values may be useful for downweighting low-confidence tests, e.g., those in repeat regions. In Simes’ procedure, weights are interpreted as relative frequencies of the tests in each cluster." />
                <expand macro="col_names" />
            </when>
            <when value="no"> </when>
        </conditional>
        <conditional name="consolidateClusters_select">
            <param name="consolidateClusters" type="select" label="Consolidate DB results from multiple analyses with cluster-level FDR control?" help="Typically involving different window sizes. The aim is to provide comprehensive detection of DB at a range of spatial resolutions. Significant windows from each analysis are identified and used for clustering with cluster windows. This represents the post-hoc counterpart to consolidateSizes.">
                <option value="yes">Yes</option>
                <option value="no" selected="true">No</option>
            </param>
            <when value="yes">
                <!--RangedSummarizedExperiment?
                    arguments to be passed to clusterWindow?-->
                <expand macro="consolidate_param" />
                <param name="tol" type="float" value="" optional="true" label="Maximum distance between adjacent windows"/>
                <expand macro="col_names" />
            </when>
            <when value="no"> </when>
        </conditional>
        <conditional name="consolidateSizes_select">
            <param name="consolidateSizes" type="select" label="Consolidate DB results from multiple window sizes?">
                <option value="yes">Yes</option>
                <option value="no">No</option>
            </param>
            <when value="yes">
                <expand macro="consolidate_param" />
                
            </when>
            <when value="no"> </when>
        </conditional>
        
    </inputs>

    <outputs>
        <data name="output" format="txt" label="${tool.name} on ${on_string}: Output" >
            <filter>checkBimodality_select['checkBimodality'] == 'yes'</filter>
        </data>
        <data name="clusterFDR_output" format="txt" label="${tool.name} on ${on_string}: clusterFDR Output" >
            <filter>clusterFDR_select['clusterFDR'] == 'yes'</filter>
        </data>
        <data name="clusterWindows_output" format="txt" label="${tool.name} on ${on_string}: clusterWindows Output" >
            <filter>clusterWindows_select['clusterWindows'] == 'yes'</filter>
        </data>
        <data name="combineTests_output" format="txt" label="${tool.name} on ${on_string}: combineTests Output" >
            <filter>combineTests_select['combineTests'] == 'yes'</filter>
        </data>
        <data name="consolidateClusters_output" format="txt" label="${tool.name} on ${on_string}: consolidateClusters Output" >
            <filter>consolidateClusters_select['consolidateClusters'] == 'yes'</filter>
        </data>
        
    </outputs>

    <tests>
    	<!--<test>
			<repeat name="bam_input">
                <param name="bam_file" value="rep1.bam" ftype="bam" />
            </repeat>
            <repeat name="bam_input">
                <param name="bam_file" value="rep2.bam" ftype="bam" />
            </repeat>

            <param name="GRanges" value="chrA, chrA, chrB, chrC" />

            <param name="IRanges" value="[1, 100]; [500, 580]; [100, 500]; [1000, 1500]" />
           
        </test>-->
    </tests>

    <help><![CDATA[
        Detection of differentially bound regions in ChIP-seq data with sliding windows, with methods for normalization and proper FDR control.
    ]]></help>


</tool>