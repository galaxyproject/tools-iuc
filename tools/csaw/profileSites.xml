<tool id="csaw_profileSites" name="profileSites" version="@VERSION@.0">
  <description>profiles binding sites</description>
  <macros>
    <import>csaw_macros.xml</import>
  </macros>
  <expand macro="requirements" />
  <command detect_errors="exit_code"><![CDATA[
    Rscript '$script']]>
  </command>
  <configfiles>
    <configfile name="script"><![CDATA[
## Setup R error handling to go to stderr
options(show.error.messages=F, error=function(){cat(geterrmessage(),file=stderr());q("no",1,F)})
loc <- Sys.setlocale("LC_MESSAGES", "en_US.UTF-8")

## Import library
library(csaw)
library(Rsamtools)

bamFiles <- c()
#for $i in $bam_input
  bamFiles <- c(bamFiles, '${i.bam_file}')
#end for
indexBam(bamFiles)

@GRANGES@
@READPARAM@

range = as.numeric("$range")

#if str($ext_select.ext_selector) == "integer"
  ext <- as.numeric("$ext_select.ext")
#else
  ext <- scan("$ext_select.ext", what=integer())
  ext <- list(ext)
#end if

#if str($average) == 'true'
  avg <- TRUE
#else
  avg <- FALSE
#end if

normalize <- as.character("$normalize")
strand <- as.character("$strand")

result <- profileSites(bamFiles, regions, param=p, range=range, ext=ext, average=avg, normalize=normalize, strand=strand)

write.table(result, "$output", quote = FALSE, col.names = FALSE, row.names = FALSE)

#if str($wwhm_select.wwhm_selector) == "yes"
  proportion <- as.numeric("$wwhm_select.proportion")

  #if str($wwhm_select.ext_select.ext_selector) == "yes"
    ext <- NA
    #if str($wwhm_select.ext_select.rlen_select.rlen_selector) == "numeric"
      rlen <- as.numeric("$wwhm_select.ext_select.rlen_select.rlen")
    #else
      rlen <- scan("wwhm_select.ext_select.rlen_select.rlen", what=numeric())
    #end if
  #else
    rlen <- NULL
  #end if

  result2 <- wwhm(result, regions, ext=ext, proportion=proportion, rlen=rlen)
  write.table(result2, "$wwhm_output", quote = FALSE, col.names = FALSE, row.names = FALSE)
#end if
]]>
    </configfile>
  </configfiles>
  <inputs>
    <repeat name="bam_input" title="Upload indexed BAM files in sorted order" >
      <param name="bam_file" type="data" format="bam" label="BAM file" />
    </repeat>
    <param name="GRanges" type="data" format="tabular" label="Specify which profiles are to be aggregated" help="Upload as a dataframe where the first column is the sequence names, the second column is the start position of the range, and the third column is the end position of the range." />
    <param name="named" type="boolean" truevalue="true" falsevalue="" checked="false" label="Are the columns of the dataframe named?" />
    <expand macro="readParam_select" />
    <param name="range" type="integer" value="5000" label="Specify the range over which the profile will be collected" />
    <conditional name="ext_select">
      <param name="ext_selector" type="select" label="Enter an integer or upload a dataframe specifying the average fragment length for single-end data" >
        <option value="integer" selected="true">Integer</option>
        <option value="dataframe">Dataframe</option>
      </param>
      <when value="integer">
        <param name="ext" type="integer" value="100" label="Specify the average fragment length for single-end data" />
      </when> 
      <when value="dataframe">
        <param name="ext" type="data" format="tabular" label="Upload a dataframe with one column specifying the average fragment length for single-end data" />
      </when> 
    </conditional>
    <param name="average" type="boolean" truevalue="true" falsevalue="" checked="true" label="Average the profiles across regions?" help="If no is selected, a separate profile will be returned for each region instead. This may be useful, e.g., for constructing heatmaps of enrichment across many regions." /> 
    <param name="normalize" type="select" label="Specify how normalization of each regionâ€™s profile should be performed prior to averaging" help="none means that no normalization is performed, i.e., counts per base are directly averaged across all regions. total means the profile for each region is divided by the sum of coverages across all bases in the interval. This effectively normalizes for the total number of reads in each region. max means the profile for each region is divided by its maximum value. This ensures that the maximum height of each region is the same." >
      <option value="none" selected="true">none</option>
      <option value="total">total</option>
      <option value="max">max</option>
    </param>
    <param name="strand" type="select" label="Indicate how stranded regions should be handled" >
      <option value="ignore">ignore</option>
      <option value="use">use</option>
      <option value="match">match</option>
    </param>
    <conditional name="wwhm_select">
      <param name="wwhm_selector" type="select" label="Get the width of the window from the half-maximum of the coverage profile?" >
        <option value="yes">Yes</option>
        <option value="no" selected="true">No</option>
      </param>
      <when value="yes">
        <conditional name="ext_select">
          <param name="ext_selector" type="select" label="Are fragments unextended reads?" >
            <option value="yes">Yes</option>
            <option value="no" selected="true">No</option>
          </param>
          <when value="yes">
            <conditional name="rlen_select">
              <param name="rlen_selector" type="select" label="Enter a numeric value or upload a dataframe containing read lengths?">
                <option value="numeric">Numeric Value</option>
                <option value="dataframe">Dataframe</option>
              </param>
              <when value="numeric">
                <param name="rlen" type="float" value="" label="Read length" />
              </when>
              <when value="dataframe">
                <param name="rlen" type="data" format="tabular" label="Read lengths" help="A dataframe containing a column of read lengths" />
              </when>
            </conditional>
          </when>
          <when value="no"> </when>
        </conditional>
        <param name="proportion" type="float" value="0.5" label="Specify the proportion of the maximum coverage at which to compute the window width" />
      </when>
      <when value="no"> </when>
    </conditional>
  </inputs>

  <outputs>
    <data name="output" format="txt" label="${tool.name} on ${on_string}: output" />
    <data name="wwhm_output" format="txt" label="wwhm on ${on_string}: output" >
      <filter>wwhm_select['wwhm_selector'] == 'yes'</filter>
    </data>
  </outputs>

  <tests>
    <test expect_num_outputs="1">
      <repeat name="bam_input">
        <param name="bam_file" value="rep1.bam" ftype="bam" />
      </repeat>
      <param name="GRanges" value="profileSites_gRange.tabular" />
      <param name="named" value="true" />
      <conditional name="readParam_select">
        <param name="readParam_selector" value="no"/>
      </conditional>
      <param name="range" value="200" />
      <conditional name="ext_select">
        <param name="ext_selector" value="integer" />
        <param name="ext" value="100" />
      </conditional>
      <param name="average" value="true" />
      <param name="normalize" value="none" />
      <param name="strand" value="ignore" />
      <conditional name="wwhm_select">
        <param name="wwhm_selector" value="no" />
      </conditional>
      <output name="output" value="profileSites_output1.txt" />
    </test>
    <test expect_num_outputs="1">
      <repeat name="bam_input">
        <param name="bam_file" value="rep1.bam" ftype="bam" />
      </repeat>
      <param name="GRanges" value="profileSites_gRange.tabular" />
      <param name="named" value="true" />
      <conditional name="readParam_select">
        <param name="readParam_selector" value="yes" />
        <param name="pe" value="both" />
        <param name="max_frag" value="100" />
        <param name="dedup" value="false" />
        <param name="minq" value="20" />
        <param name="forward" value="NA" />
        <param name="restrict" value="chrA" />
        <conditional name="discard_select">
          <param name="discard" value="no" />
        </conditional>
      </conditional>
      <param name="range" value="200" />
      <conditional name="ext_select">
        <param name="ext_selector" value="integer" />
        <param name="ext" value="100" />
      </conditional>
      <param name="average" value="true" />
      <param name="normalize" value="none" />
      <param name="strand" value="ignore" />
      <conditional name="wwhm_select">
        <param name="wwhm_selector" value="no" />
      </conditional>
      <output name="output" value="profileSites_output2.txt" />
    </test>
    <test expect_num_outputs="2">
      <repeat name="bam_input">
        <param name="bam_file" value="rep1.bam" ftype="bam" />
      </repeat>
      <param name="GRanges" value="profileSites_gRange.tabular" />
      <param name="named" value="true" />
      <conditional name="readParam_select">
        <param name="readParam_selector" value="no"/>
      </conditional>
      <param name="range" value="5000" />
      <conditional name="ext_select">
        <param name="ext_selector" value="integer" />
        <param name="ext" value="100" />
      </conditional>
      <param name="average" value="true" />
      <param name="normalize" value="none" />
      <param name="strand" value="ignore" />
      <conditional name="wwhm_select">
        <param name="wwhm_selector" value="yes" />
        <conditional name="ext_select">
          <param name="ext_selector" value="no" />
        </conditional>
        <param name="proportion" value="0.5" />
      </conditional>
      <output name="output" value="profileSites_output3.txt" />
      <output name="wwhm_output" value="wwhm_output1.txt" />
    </test>
    <test expect_num_outputs="2">
      <repeat name="bam_input">
        <param name="bam_file" value="rep1.bam" ftype="bam" />
      </repeat>
      <param name="GRanges" value="profileSites_gRange.tabular" />
      <param name="named" value="true" />
      <conditional name="readParam_select">
        <param name="readParam_selector" value="no"/>
      </conditional>
      <param name="range" value="5000" />
      <conditional name="ext_select">
        <param name="ext_selector" value="integer" />
        <param name="ext" value="100" />
      </conditional>
      <param name="average" value="true" />
      <param name="normalize" value="none" />
      <param name="strand" value="ignore" />
      <conditional name="wwhm_select">
        <param name="wwhm_selector" value="yes" />
        <conditional name="ext_select">
          <param name="ext_selector" value="yes" />
          <conditional name="rlen_select">
              <param name="rlen_selector" value="numeric" />
              <param name="rlen" value="10" />
          </conditional>
        </conditional>
        <param name="proportion" value="0.5" />
      </conditional>
      <output name="output" value="profileSites_output3.txt" />
      <output name="wwhm_output" value="wwhm_output2.txt" />
    </test>
  </tests>

  <help><![CDATA[
Get the coverage profile around potential binding sites
=======================================================

This tool computes the average coverage profile around the specified regions. Specifically, the profile is constructed by counting the number of fragments overlapping each base in the interval flanking each entry of regions. The interval for each entry is centred at its start location (base zero) and spans the flanking range on either side.

Single-end reads are directionally extended to ext to impute the fragment. For paired-end reads, the interval between each pair is used as the fragment. If multiple bam.files are specified, reads are pooled across files for counting into each profile. By default, an average of the coverage profiles across all regions is returned. Thus, the shape of the average profile is largely determined by high-abundance regions.

The profile can be used to examine average coverage around known features of interest, like genes or transcription start sites. Its shape can guide the choice of the window size in windowCounts, or to determine if larger regions should be used in regionCounts. For the former, restricting the regions to locally maximal windows with findMaxima is recommended to capture the profile of binding events.

It returns:

If average the profiles across regions is selected, it returns:

- `average coverages`: a numeric column of average coverages for each base position within range, where the average is taken over all regions. The column is named according to the relative position of each base to the start of the region. The interpretation of the coverages will depend on the value of normalize.

If average the profiles across regions is not selected, it returns:

- `coverage values`: an integer matrix of coverage values. Each row of the matrix corresponds to an entry in regions, while each column corresponds to a base position with range. Column names are set to the relative position of each base to the start of each region.


Get the width of the window from the half-maximum of the coverage profile
=========================================================================

This method computes the ideal window size, based on the width of the peak in the coverage profile at the specified proportion of the maximum. Obviously, the values of regions and ext should be the same as those used in profileSites (set ext to the median fragment length for paired-end data). The regions should contain windows of a constant size. Some subtleties are involved in obtaining the window width. First, twice the average fragment length must be subtracted from the peak width, as the profile is constructed from (inferred) fragments.
The size of the viewpoints in regions must also be subtracted, to account for the inflated peak width when spatial resolution is lost after aggregation across many windows.

- `width`: an integer specifying the ideal window width
    ]]></help>
  <expand macro="citations" />
</tool>