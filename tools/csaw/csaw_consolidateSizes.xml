<tool id="csaw_consolidateSizes" name="Consolidate Sizes" version="@VERSION@.0">
    <description>computes the max bimodality score</description>

     <macros>
       <import>csaw_macros.xml</import>
    </macros>

     <expand macro="requirements" />

    <command detect_errors="exit_code"><![CDATA[
        Rscript '$script'
    ]]></command>

    <configfiles>
        <configfile name="script"><![CDATA[
## Setup R error handling to go to stderr
options(show.error.messages=F, error=function(){cat(geterrmessage(),file=stderr());q("no",1,F)})
loc <- Sys.setlocale("LC_MESSAGES", "en_US.UTF-8")

## Import library
library(csaw)
##consolidateSizes_select
#if str($consolidateSizes_select.consolidateSizes) == 'yes'
    cS_gRangeList <- c()
    cS_IRangeList <- list()
    cS_width <- c()
    #for $i in $consolidateSizes_select.gRange_obj
        #if str($i.width) != ''
            cS_width <- c(cS_width, as.numeric("${i.width}"))
        #end if
        cS_gRangeList <- c(cS_gRangeList, "${i.GRanges}")
        cS_IRangeList <- append(cS_IRangeList, list(scan("${i.IRanges}", what=numeric())))
    #end for
    cS_dataList <- c()
    for (i in seq(cS_gRangeList)){
        cS_dataList <- c(cS_dataList, GRanges(cS_gRangeList[i], IRanges(cS_IRangeList[[i]], width=cS_width[i])))
    }
     cS_resultList <- list()
    #for $i in $consolidateSizes_select.db
        cS_resultList <- append(cS_resultList, list(read.table("${i.result_list}", header=T)))
    #end for
    #if str($consolidateSizes_select.equiweight) == 'true'
        cS_equiweight <- TRUE
    #else
        cS_equiweight <- FALSE
    #end if
    cS_tol <- as.numeric("${consolidateSizes_select.tol}")
    #if str($consolidateSizes_select.max_width) != ''
        cS_maxWidth <- as.numeric("${consolidateSizes_select.max_width}")
    #else
        cS_maxWidth <- NULL
    #end if
    #if str($consolidateSizes_select.GRanges) != ''
        cS_gRange <- as.character(unlist(strsplit(gsub(" ", "", "${consolidateSizes_select.GRanges}", ","), ",")))
        cS_b <- unlist(strsplit(gsub(" ", "", "${consolidateSizes_select.IRanges}", ","), ";"))
        cS_c <- gsub("\\[|\\]", "", cS_b)
        cS_d <- lapply(cS_c, function(x){x <- as.numeric(unlist(strsplit(x, ",")))})
        cS_e <- c()
        cS_f <- c()
        for (i in seq(cS_d)){ 
            cS_e <- c(cS_e, cS_d[[i]][1])
            cS_f <- c(cS_f, cS_d[[i]][2])
        }
    cS_regions <- GRanges(cS_gRange, IRanges(cS_e,cS_f))
    #else
        cS_regions <-NULL
    #end if
    
    sink("$consolidateSizes_output")
        consolidateSizes(cS_dataList, cS_resultList, equiweight=cS_equiweight, merge.args=list(tol=cS_tol, max.width=cS_maxWidth), region=cS_regions)
    sink()
#end if

]]>
        </configfile>
    </configfiles>
    <inputs>
    	 <conditional name="consolidateSizes_select">
            <param name="consolidateSizes" type="select" label="Consolidate DB results from multiple window sizes?" help="A comprehensive detection of DB at a range of spatial resolutions. Windows of all sizes are clustered together and the p-values from all windows in each cluster are combined." >
                <option value="yes">Yes</option>
                <option value="no">No</option>
            </param>
            <when value="yes">
                <expand macro="consolidate_param" />
                <param name="tol" type="float" value="" optional="true" label="Maximum distance between adjacent windows"/>
                <param name="max_width" type="float" value="" optional="true" label="Maximum size of merged intervals"  />
                <param name="GRanges" type="text" optional="true" label="Objects" />
                <param name="IRanges" type="text" optional="true" label="Ranges" help="Enter the interval in square brackets separated by a comma and a colon for each range, e.g. [1, 100]; [500, 580]">
                    <sanitizer>
                        <valid>
                            <add value="[" />
                            <add value="]" />
                            <add value=";" />
                        </valid>
                    </sanitizer> 
                </param>
                
                <!--TO DO: merge.args
                            combine.args
                            overlap.args-->
            </when>
            <when value="no"> </when>
        </conditional>
    </inputs>

    <outputs>
        <data name="output" format="txt" label="${tool.name} on ${on_string}: checkBiomodality output" />
    </outputs>

    <tests>
        <test>
            <repeat name="bam_input">
                <param name="bam_file" value="rep1.bam" ftype="bam" />
            </repeat>
            <repeat name="bam_input">
                <param name="bam_file" value="rep2.bam" ftype="bam" />
            </repeat>
            <param name="GRanges" value="chrA, chrA, chrB, chrC" />
            <param name="IRanges" value="range1.tabular" />
            <param name="width" value="200" />
            <conditional name="readParam_select">
                <param name="readParam_selector" value="no" />
            </conditional>
            <param name="prior_count" value="5" />
            <param name="invert" value="false" />
            <output name="output" file="checkBiomodality_output1.txt" />
        </test>
        <test>
            <repeat name="bam_input">
                <param name="bam_file" value="rep1.bam" ftype="bam" />
            </repeat>
            <repeat name="bam_input">
                <param name="bam_file" value="rep2.bam" ftype="bam" />
            </repeat>
            <param name="GRanges" value="chrA, chrA, chrB, chrC" />
            <param name="IRanges" value="range1.tabular" />
            <param name="width" value="200" />
            <conditional name="readParam_select">
                <param name="readParam_selector" value="yes" />
                <param name="pe" value="both" />
                <param name="max_frag" value="100" />
                <param name="dedup" value="false" />
                <param name="minq" value="20" />
                <param name="forward" value="NA" />
                <param name="restrict" value="" />
                <param name="discard" value="no" />
            </conditional>
            <param name="prior_count" value="5" />
            <param name="invert" value="False" />
            <output name="output" file="checkBiomodality_output2.txt" />
        </test>
        <test>
            <repeat name="bam_input">
                <param name="bam_file" value="rep1.bam" ftype="bam" />
            </repeat>
            <repeat name="bam_input">
                <param name="bam_file" value="rep2.bam" ftype="bam" />
            </repeat>
            <param name="GRanges" value="chrA, chrA, chrB, chrC" />
            <param name="IRanges" value="range1.tabular" />
            <param name="width" value="200" />
            <conditional name="readParam_select">
                <param name="readParam_selector" value="yes" />
                <param name="pe" value="both" />
                <param name="max_frag" value="100" />
                <param name="dedup" value="false" />
                <param name="minq" value="20" />
                <param name="forward" value="NA" />
                <param name="restrict" value="mitochondria" />
                <conditional name="discard_select">
                    <param name="discard" value="yes" />
                    <param name="GRanges" value="chrA" />
                    <param name="IRanges" value="range_readParam.tabular" />
                </conditional>
            </conditional>
            <param name="prior_count" value="5" />
            <param name="invert" value="False" />
            <output name="output" file="checkBiomodality_output3.txt" />
        </test>
    </tests>

    <help><![CDATA[
        Consider a base position x. This function counts the number of forward- and reverse-strand reads within the interval [x-width+1, x]. It then calculates the forward:reverse ratio after adding prior.count to both counts. This is repeated for the interval [x, x+width-1], and the reverse:forward ratio is then computed. The smaller of these two ratios is used as the bimodality score. Sites with high bimodality scores will be enriched for forward- and reverse-strand enrichment on the left and right of the site, respectively. Given a genomic region, this function will treat each base position as a site. The largest bimodality score across all positions will be reported for each region. The idea is to assist with the identification of transcription factor binding sites, which exhibit strong strand bimodality. The function will be less useful for broad targets like histone marks. If multiple bam.files are specified, they are effectively pooled so that counting uses all reads in all files. A separate value of width can be specified for each library, to account for differences in fragmentation â€“ see the ext argument for windowCounts for more details. In practice, this is usually unnecessary. Setting width to the average fragment length yields satisfactory results in most cases. If invert is set, the bimodality score will be flipped around, i.e., it will be maximized when reversestrand coverage dominates on the left, and forward-strand coverage dominates on the right. This is designed for use in CAGE analyses where this inverted bimodality is symptomatic of enhancer RNAs
    ]]></help>


</tool>