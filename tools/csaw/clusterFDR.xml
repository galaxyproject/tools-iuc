<tool id="csaw_clusterFDR" name="clusterFDR" version="@VERSION@.0">
    <description>compute the cluster-level FDR</description>
    <macros>
       <import>csaw_macros.xml</import>
    </macros>
    <expand macro="requirements" />
    <command detect_errors="exit_code"><![CDATA[
        Rscript '$script'
    ]]></command>
    <configfiles>
        <configfile name="script"><![CDATA[
## Setup R error handling to go to stderr
options(show.error.messages=F, error=function(){cat(geterrmessage(),file=stderr());q("no",1,F)})
loc <- Sys.setlocale("LC_MESSAGES", "en_US.UTF-8")

## Import library
library(csaw)

#if str($method_select.method) == "clusterFDR"
    ids <- scan("$method_select.id", what = integer())
    threshold <- as.numeric("$method_select.threshold")
    target <- as.numeric("$method_select.target")
    adjp <- scan("$method_select.adjp", what = numeric())
    grid_length <- as.numeric("$method_select.grid_length")
    iterations <- as.numeric("$method_select.iterations")

    ## Create a custom function
    set.seed(100)
    windows <- GRanges("chrA", IRanges(1:1000, 1:1000))
    test.p <- runif(1000)
    test.p[c(1:10, 100:110, 220:240)] <- 0
    is.sig <- p.adjust(test.p, method="BH") <= threshold
    clusterFUN <- function(x) { mergeWindows(windows[x], tol=0)[[1]] }

    result1 <- clusterFDR(ids, threshold, weight=NULL)
    result2 <- controlClusterFDR(target, adjp, clusterFUN,  weight=NULL, grid.length=grid_length, iterations=iterations)

    result <- list(c(result1[1]))
    result <- append(result, result2[[1]])
    result <- append(result, result2[[2]])

    write.table(do.call(rbind, result), file="$clusterFDR_output", quote = FALSE, row.names = c("clusterFDR ", "threshold ", "FDR "), col.names = FALSE)
#else
    @GRANGES_METHOD@

    tab <- read.table("$method_select.tab")
    clust_target <- as.numeric("$target")

    @COLNAMES_METHOD@
    tol <- as.numeric("$method_select.tol")
    grid_length <- as.numeric("$method_select.grid_length")
    iterations <- as.numeric("$method_select.iterations")

    #if str($method_select.weight_select.weight_selector) == "yes"
        weight <- scan("$method_select.weight_select.weight", what=numeric())
    #else
        weight <- NULL
    #end if

    #if str($method_select.mergeWindows_select.mergeWindows_selector) == "yes"
        #if str($method_select.mergeWindows_select.sign_select.sign_selector) == "yes"
            sign <- scan("$method_select.mergeWindows_select.sign_select.sign", what=logical())
        #else 
            sign <- NULL
        #end if

        #if str($method_select.mergeWindows_select.max_width) != ""
            max_width <- as.numeric("$mergeWindows_select.max_width")
        #else
            max_width <- NULL
        #end if

        #if str($method_select.mergeWindows_select.ignore_strand) == "yes"
            ignore_strand <- TRUE
        #else
            ignore_strand <- FALSE
        #end if

        result <- clusterWindows(regions, tab, clust_target, pval.col=pval_col, fc.col=fc_col, tol, max.width=max_width, ignore.strand=ignore_strand, weight=weight, grid.length=grid_length, iterations=iterations)
    #else
        result <- clusterWindows(regions, tab, clust_target, pval.col=pval_col, fc.col=fc_col, tol, weight=weight, grid.length=grid_length, iterations=iterations)
    #end if
        
    write.table(result[[1]], file="$clusterW_id_output", quote=FALSE, row.names=FALSE, col.names=FALSE)
    write.table(result[[2]], file="$clusterW_region_output", quote=FALSE, row.names=FALSE, col.names=FALSE)
    write.table(result[[3]], file="$clusterW_fdr_output", quote=FALSE, row.names=FALSE, col.names=FALSE)
#end if
    
]]>
        </configfile>
    </configfiles>
    <inputs>
        <conditional name="method_select">
            <param name="method" type="select" label="Method" >
                <option value="clusterFDR">Compute the FDR across clusters based on the test-level FDR threshold</option>
                <option value="clusterWindows">Clusters significant windows into clusters while controlling the cluster-level FDR</option>
            </param>
            <when value="clusterFDR"> 
                <param name="id" type="data" format="tabular" label="Cluster IDs for each significant test below threshold" />
                <param name="threshold" type="float" value="" label="The FDR threshold used to define the significant tests" />
                <param name="target" type="float" value="" optional="true" label="The desired cluster-level FDR threshold" />
                <param name="adjp" type="data" format="tabular" label="Window-level adjusted p-values" />
                <!--Excluded weight because for internal use was noted-->
                <param name="grid_length" type="integer" value="21" label="Specify the number of points to use in the grid search" />
                <param name="iterations" type="integer" value="4" label="Specify the number of iterations of the grid search" />
            </when>
            <when value="clusterWindows">
                <expand macro="gRanges" />
                <param name="tab" type="data" format="tabular" label="Dataframe of results with a PValue field for each window" />
                <param name="target" type="float" value="" label="Desired cluster-level FDR" />
                <expand macro="col_names" />
                <param name="tol" type="float" value="" optional="true" label="Maximum distance between adjacent windows"/>
                <conditional name="weight_select">
                    <param name="weight_selector" type="select" label="Specify frequency weights?" help="The specification is assumed to contain frequency weights of significant tests/windows. For example, a weight of 2 for a test would be equivalent to repeating that test (i.e., repeating the same window so it shows up twice in your analysis). These weights should be the same as those used during weighted FDR control to compute adjusted p-values. In general, you should not set this argument unless you know what you’re doing.">
                        <option value="yes">Yes</option>
                        <option value="no" selected="true">No</option>
                    </param>
                    <when value="yes">
                        <param name="weight" type="data" format="tabular" label="Frequency weights" help="A dataframe of a column of weights" />
                    </when>
                    <when value="no"> </when>
                </conditional>
                <expand macro="mergeWindows_select" />
                <param name="grid_length" type="integer" value="21" label="Specify the number of points to use in the grid search" />
                <param name="iterations" type="integer" value="4" label="Specify the number of iterations of the grid search" />
            </when>
            <when value="mixedClusters">
                <param name="ids" type="data" format="tabular" label="Cluster ID for each test" help="Upload as a dataframe where each row is an integer." />
                <param name="tab" type="data" format="tabular" label="Dataframe of results with PValue and at least one logFC field for each test" />
                <conditional name="weight_select">
                  <param name="weight_selector" type="select" label="Specify weights for each window?" help="If none specified, the weight defaults to 1 for each test. Supplying different relative weight values may be useful for downweighting low-confidence tests, e.g., those in repeat regions. In Simes’ procedure, weights are interpreted as relative frequencies of the tests in each cluster.">
                    <option value="yes">Yes</option>
                    <option value="no" selected="true">No</option>
                  </param>
                  <when value="yes">
                    <param name="weight" type="data" format="tabular" label="Weights for each window" help="Upload as a dataframe where each row is a numeric value." />
                  </when>
                  <when value="no"> </when>
                </conditional>
                <expand macro="col_names" />
            </when>
        </conditional>
    </inputs>

    <outputs>
        <data name="clusterFDR_output" format="txt" label="clusterFDR on ${on_string}: output">
            <filter>method_select['method'] == 'clusterFDR'</filter>
        </data>
        <data name="clusterW_id_output" format="txt" label="clusterWindows on ${on_string}: id output" >
            <filter>method_select['method'] == 'clusterWindows'</filter>
        </data>
        <data name="clusterW_region_output" format="txt" label="clusterWindows on ${on_string}: region output" >
            <filter>method_select['method'] == 'clusterWindows'</filter>
        </data>
        <data name="clusterW_fdr_output" format="txt" label="clusterWindows on ${on_string}: FDR output" >
            <filter>method_select['method'] == 'clusterWindows'</filter>
        </data>
    </outputs>

    <tests>
        <test expect_num_outputs="1">
            <conditional name="method_select">
                <param name="method" value="clusterFDR" />
                <param name="id" value="id.tabular" />
                <param name="threshold" value="0.05" />
                <param name="target" value="0.05" />
                <param name="adjp" value="adjp.tabular" />
                <param name="grid_length" value="21" />
                <param name="iterations" value="4" />
            </conditional>
            <output name="clusterFDR_output" file="clusterFDR_output1.txt"/>
        </test>
        <test expect_num_outputs="3">
            <conditional name="method_select">
                <param name="method" value="clusterWindows" />
                <param name="GRanges" value="gRange_region3.tabular" />
                <param name="named" value="false" />
                <param name="tab" value="tab.tabular" />
                <param name="target" value="0.05" />
                <param name="pval_col" value="PValue" />
                <param name="fc_col" value="logFC" />
                <param name="tol" value="10" />
                <conditional name="weight_select">
                    <param name="weight_selector" value="yes" />
                    <param name="weight" value="emFDR_w.tabular" />
                </conditional>
                <conditional name="mergeWindows_select" >
                    <param name="mergeWindows_selector" value="no" />
                </conditional>
                <param name="grid_length" value="21" />
                <param name="iterations" value="4" />
            </conditional>
            <output name="id_output" file="clusterWindows_id_output0.txt"/>
            <output name="region_output" file="clusterWindows_region_output0.txt"/>
            <output name="fdr_output" file="clusterWindows_FDR_output0.txt"/>
        </test>
        <test expect_num_outputs="3">
            <conditional name="method_select">
                <param name="method" value="clusterWindows" />
                <param name="GRanges" value="gRange_region3.tabular" />
                <param name="named" value="false" />
                <param name="tab" value="tab.tabular" />
                <param name="target" value="0.05" />
                <param name="pval_col" value="PValue" />
                <param name="fc_col" value="logFC" />
                <param name="tol" value="10" />
                <conditional name="weight_select">
                    <param name="weight_selector" value="no" />
                </conditional>
                <conditional name="mergeWindows_select" >
                    <param name="mergeWindows_selector" value="no" />
                </conditional>
                <param name="grid_length" value="21" />
                <param name="iterations" value="4" />
            </conditional>
            <output name="id_output" file="clusterWindows_id_output1.txt"/>
            <output name="region_output" file="clusterWindows_region_output1.txt"/>
            <output name="fdr_output" file="clusterWindows_FDR_output1.txt"/>
        </test>
        <test expect_num_outputs="3">
            <conditional name="method_select">
                <param name="method" value="clusterWindows" />
                <param name="GRanges" value="gRange_region3.tabular" />
                <param name="tab" value="tab.tabular" />
                <param name="target" value="0.05" />
                <param name="pval_col" value="PValue" />
                <param name="fc_col" value="logFC" />
                <param name="tol" value="10" />
                <conditional name="weight_select">
                    <param name="weight_selector" value="no" />
                </conditional>
                <conditional name="mergeWindows_select" >
                    <param name="mergeWindows_selector" value="yes" />
                    <conditional name="sign_select">
                        <param name="sign_selector" value="no" />
                    </conditional>
                    <param name="max_width" value="10" />
                    <param name="ignore_strand" value="true" />
                </conditional>
                <param name="grid_length" value="21" />
                <param name="iterations" value="4" />
            </conditional>
            <output name="id_output" file="clusterWindows_id_output2.txt"/>
            <output name="region_output" file="clusterWindows_region_output2.txt"/>
            <output name="fdr_output" file="clusterWindows_FDR_output2.txt"/>
        </test>
        <test expect_num_outputs="3">
            <conditional name="method_select">
                <param name="method" value="clusterWindows" />
                <param name="GRanges" value="gRange_region3.tabular" />
                <param name="tab" value="tab.tabular" />
                <param name="target" value="0.05" />
                <param name="pval_col" value="PValue" />
                <param name="fc_col" value="logFC" />
                <param name="tol" value="10" />
                <conditional name="weight_select">
                    <param name="weight_selector" value="no" />
                </conditional>
                <conditional name="mergeWindows_select" >
                    <param name="mergeWindows_selector" value="yes" />
                    <conditional name="sign_select">
                        <param name="sign_selector" value="yes" />
                        <param name="sign" value="mergeW_sign.tabular" />
                    </conditional>
                    <param name="max_width" value="10" />
                    <param name="ignore_strand" value="true" />
                </conditional>
                <param name="grid_length" value="21" />
                <param name="iterations" value="4" />
            </conditional>
            <output name="id_output" file="clusterWindows_id_output3.txt"/>
            <output name="region_output" file="clusterWindows_region_output3.txt"/>
            <output name="fdr_output" file="clusterWindows_FDR_output3.txt"/>
        </test>
        <test expect_num_outputs="1">
            <conditional name="method_select">
                <param name="method" value="mixedClusters" />
              <param name="ids" value="mixedClusters_ids.tabular" />
              <param name="tab" value="mixedClusters_tab.tabular" />
              <conditional name="weight_select">
                <param name="weight_selector" value="no" />
              </conditional>
              <param name="pval_col" value="" />
              <param name="fc_col" value="" />
            </conditional>
            <output name="mixedC_output" value="mixedClusters_output.txt" />
        </test>
        <test expect_num_outputs="1">
            <conditional name="method_select">
                <param name="method" value="mixedClusters" />
              <param name="ids" value="mixedClusters_ids.tabular" />
              <param name="tab" value="mixedClusters_tab.tabular" />
              <conditional name="weight_select">
                <param name="weight_selector" value="yes" />
                <param name="weight" value="comTest_w.tabular" />
              </conditional>
              <param name="pval_col" value="" />
              <param name="fc_col" value="" />
            </conditional>
          <output name="mixedC_output" value="mixedClusters_output2.txt" />
        </test>
    </tests>

    <help><![CDATA[

Compute the FDR across clusters based on the test-level FDR threshold
======================================================================

The cluster-level FDR, the windowlevel FDR threshold to control the cluster-level FDR near target, and the estimate of the cluster-level FDR corresponding to threshold are returned.

This mehtod computes an informal estimate of the cluster-level FDR, where each cluster is formed by aggregating only significant tests. In the context of ChIP-seq, each significant test refers to a DB window that is detected at a FDR below threshold. The idea is to obtain an error rate while reporting the precise coordinates of a DB subinterval in a complex region. 

The cluster-level FDR is defined as the proportion of reported clusters that have no true positives. Simply using threshold is not appropriate, as the cluster- and window-level FDRs are not equivalent. This function also differs from the standard pipeline that is based on combineTests. Specifically, region definition in combineTests must be independent of DB so that precise coordinates of the DB subinterval cannot be reported. This is overcome here, by clustering directly on DB windows and applying post-hoc control of the cluster-level FDR. Note that the calculation of the cluster-level FDR here is not statistically rigorous. In particular, the observed number of false positive tests is estimated based on threshold and the total number of significant tests. This is not guaranteed to be an upper bound, especially with few or correlated tests. Thus, users should use the standard combineTests-based pipeline wherever possible. Clustering on significant windows should only be performed where the precise coordinates of the DB subinterval are important for interpretation.

It returns:

- `clusterFDR`: a number as the cluster-level FDR.
- `threshold`: the windowlevel FDR threshold to control the cluster-level FDR near target
- `FDR`: the estimate of the cluster-level FDR corresponding to threshold.

======================================================================================

Clusters significant windows into clusters while controlling the cluster-level FDR
===================================================================================

Windows are identified as DB based on the adjusted p-values in tab. Only these DB windows are then used directly for clustering via mergeWindows. This identifies DB regions consisting solely of DB windows. 

DB-based clustering is obviously not blind to the DB status, so standard methods for FDR control are not valid. Instead, post-hoc control of the cluster-level FDR is applied by using controlClusterFDR. This aims to control the cluster-level FDR at target. The aim is to provide some interpretable results when DB-blind clustering is not appropriate, e.g., for diffuse marks involving long stretches of the genome. Reporting each marked stretch in its entirety would be cumbersome, so this method allows the DB subintervals to be identified directly.

It returns:

- `ids`: A list of ids. Non-significant windows are marked with NA.
- `regions`: Region coordinates of each cluster
- `FDR`: the estimate of the cluster-level FDR for the returned regions

    ]]></help>
    <expand macro="citations" />
</tool>