<?xml version="1.0"?>
<macros>
  <token name="@VERSION@">1.12.0</token>
  <token name="@GRANGES@">
    <![CDATA[
    gRange <- as.character(unlist(strsplit(gsub(" ", "", "${GRanges}", ","), ",")))
    rangeData <- read.table("$IRanges", header=F)
    start <- c(rangeData[[1]])
    end <- c(rangeData[[2]])

    regions <- GRanges(gRange, IRanges(start, end))
  ]]>
  </token>
  <token name="@COLNAMES@">
    <![CDATA[
    #if str($pval_col) != ''
        pval_col <- as.numeric(gsub("([0-9]+).*$", "\\1", "$pval_col"))
        if (is.na(pval_col)){
            pval_col <- "$pval_col"
        }
    #else
        pval_col <- NULL
    #end if
    #if str($fc_col) != ''
        fc_col <- as.numeric(gsub("([0-9]+).*$", "\\1", "$fc_col"))
        if (is.na(fc_col)){
            fc_col <- "$fc_col"
        }
    #else
        fc_col <- NA
    #end if
  ]]>
  </token>
  <token name="@DATALIST@">
    <![CDATA[
    gRangeList <- c()
    IRangeList <- list()
    #for $i in $gRange_obj
        gRangeList <- c(gRangeList, as.character(unlist(strsplit(gsub(" ", "", "${i.GRanges}", ","), ","))))
        IRangeList <- append(IRangeList, list(read.table("${i.IRanges}")))
    #end for

    dataList <- c()
    for (i in seq(gRangeList)){
        dataList <- c(dataList, GRanges(gRangeList[i], IRanges(IRangeList[[i]][[1]], IRangeList[[i]][[2]])))
    }
  ]]>
  </token>
  <token name="@RESULTLIST@">
    <![CDATA[
    resultList <- list()
    #for $i in $db
        resultList <- append(resultList, list(read.table("${i.result_list}", header=T)))
    #end for
  ]]>
  </token>
  <token name="@EQUIWEIGHT@">
    <![CDATA[
    #if str($equiweight) == 'true'
        equiweight <- TRUE
    #else
        equiweight <- FALSE
    #end if
  ]]>
  </token>
  <token name="@MAXWIDTH@">
    <![CDATA[
    #if str($max_width) != ''
        maxWidth <- as.numeric("$max_width")
    #else
        maxWidth <- NULL
    #end if
  ]]>
  </token>

  <xml name="requirements">
    <requirements>
      <requirement type="package" version="@VERSION@">bioconductor-csaw</requirement>
    </requirements>
  </xml>
  <xml name="citations">
    <citations>
          
    </citations>
  </xml>
  <xml name="gRanges">
    <param name="GRanges" type="text" label="Sequence Names" />
    <param name="IRanges" type="data" format="tabular" label="Ranges" help="Upload as a dataframe where the first column is the start position and the second column is the end position." />
  </xml>
  <xml name="readParam">
    <param name="pe" type="select" label="Is paired-end data present in the BAM file(s)?" help="Reads are assumed to be single-end when None is selected">
      <option value="none">None</option>
      <option value="both">Both Files</option>
      <option value="first">First File</option>
      <option value="second">Second File</option>
    </param>
    <param name="max_frag" type="integer" value="500" label="Maximum fragment length corresponding to a read pair" />
    <param name="dedup" type="boolean" truevalue="true" falsevalue="" checked="false" label="Ignore marked duplicate reads?" help="Marked duplicate reads will be removed with if yes is selected. This may be necessary when many rounds of PCR have been performed. However, it is not recommended for routine counting as it will interfere with the downstream statistical methods. Note that the duplicate field must be set beforehand in the BAM file for this argument to have any effect" />
    <param name="minq" type="integer" value="" optional="true" label="Minimum mapping quality score for an aligned read" help="Reads will be filtered by their mapping quality scores. This is generally recommended to remove low-confidence alignments. The exact threshold for minq will depend on the range of scores provided by the aligner. No filtering on the score will be performed if no value specified." />
    <param name="forward" type="select" label="How should the reads be extracted?">
      <option value="NA">Extract from all strands</option>
      <option value="forward">Extract only from forward strands</option>
      <option value="reverse">Extract only from reverse strands</option>
    </param>
    <param name="restrict" type="text" optional="true" label="Names of allowable chromosomes from which readswill be extracted" help="Reads will only be extracted for the specified chromosomes. This is useful to restrict the analysis to interesting chromosomes, e.g., no contigs/scaffolds or mitochondria."/>
    <conditional name="discard_select">
      <param name="discard" type="select" label="Discard any alignments?" help="A read will be removed if the corresponding alignment is wholly contained within the supplied ranges. This is useful for removing reads in repeat regions.">
        <option value="yes">Yes</option>
        <option value="no" selected="true">No</option>
      </param>
      <when value="yes">
        <expand macro="gRanges" />
      </when>
      <when value="no"> </when>
    </conditional>
      <!--BiocParallelParam object-->
  </xml>
  <xml name="weight">
    <param name="weight" type="float" value="" optional="true" label="Frequency weights" help="Argument assumed to contain frequency weights of significant tests/windows. For example, a weight of 2 for a test would be equivalent to repeating that test (i.e., repeating the same window so it shows up twice in your analysis). These weights should be the same as those used during weighted FDR control to compute adjusted p-values." />
  </xml>
  <xml name="grid_param">
    <conditional name="grid_param_select">
      <param name="grid_param" type="select" label="Tune grid search settings?" help="At each iteration, the grid point with the closest cluster-level FDR to target is chosen and the grid is recentered around that point. The size of the grid is also scaled down to provide greater resolution.">
        <option value="yes">Yes</option>
        <option value="no" selected="true">No</option>
      </param>
      <when value="yes">
        <param name="length" type="integer" value="21" optional="true" label="Length of the grid" />
        <param name="range" type="float" value="20" optional="true" label="Range of the grid in logit units" />
        <param name="iter" type="integer" value="" optional="true" label="Number of iterations of the grid search" />
        <param name="scale" type="float" value="" optional="true" label="How much should the range of the grid be downscaled at each iteration?" />
      </when>
      <when value="no"> </when>
    </conditional>
  </xml>
  <xml name="col_names">
    <param name="pval_col" type="text" optional="true" label="Specify the column of tab with the p-values" help="Enter a string or integer" >
      <sanitizer>
        <valid>
          <add value="." />
        </valid>
      </sanitizer>
    </param>
    <param name="fc_col" type="text" optional="true" label="Specify the column of tab with the log-fold changes" help="Enter a string or integer" >
      <sanitizer>
        <valid>
          <add value="." />
        </valid>
      </sanitizer>
    </param>
  </xml>
  <xml name="clusterWindows_param">
    <expand macro="gRanges" />
    <param name="tab" type="data" format="tabular" label="Dataframe of results with a PValue field for each window" />
    <param name="target" type="float" value="" label="Desired cluster-level FDR" />
    <macro expand="col_names" />
    <param name="tol" type="float" value="" optional="true" label="Maximum distance between adjacent windows"/>
  </xml>
  <xml name="combineTest_param">
    <param name="ids" type="data" format="tabular" label="Cluster ID for each test" help="Upload as a dataframe where each row is an integer." />
    <param name="tab" type="data" format="tabular" label="Dataframe of results with PValue and at least one logFC field for each test" />
    <param name="weight" type="data" format="tabular" optional="true" label="Weights for each window" help="Upload as a dataframe where each row is a numeric value. If none specified, the weight defaults to 1 for each test. Supplying different relative weight values may be useful for downweighting low-confidence tests, e.g., those in repeat regions. In Simesâ€™ procedure, weights are interpreted as relative frequencies of the tests in each cluster." />
    <expand macro="col_names" />
  </xml>
  <xml name="consolidate_param">
    <repeat name="gRange_obj" title="Enter GRanges objects">
      <expand macro="gRanges" />
    </repeat>
    <repeat name="db" title="Upload dataframes containing the DB test results for each entry of data">
      <param name="result_list" type="data" format="tabular" label="DB test results" />
    </repeat>
    <param name="equiweight" type="boolean" truevalue="true" falsevalue="" checked="true" label="Enforce equal weighting from each analysis?" help="Some effort is required to equalize the contribution of the results from each analysis. This is done by setting selecting yes, where the weight of each window is inversely proportional to the number of windows from that analysis." />
    <param name="tol" type="float" value="" label="Maximum distance between adjacent windows"/>
  </xml>
  <xml name="mergeWindows_param">
    <expand macro="gRanges" />
    <param name="tol" type="float" value="" optional="true" label="Maximum distance between adjacent windows" help="A value of zero means that the windows must be contiguous whereas negative values specify minimum overlaps" />
    <conditional name="sign_select">
      <param name="sign_selector" type="select" label="Specify a positive log-FC for each window?" >
        <option value="yes">Yes</option>
        <option value="no" selected="true">No</option>
      </param>
      <when value="yes">
        <param name="sign" type="boolean" truevalue="true" falsevalue="" checked="true" label="Positive log-FC for each window?" />
      </when>
      <when value="no"> </when>
    </conditional>
    <param name="max_width" type="float" value="" optional="true" label="Maximum size of merged intervals" help="Specification prevents the formation of excessively large clusters when many adjacent regions are present. Any cluster that is wider than the max width is split into multiple subclusters of (roughly) equal size. Specifically, the cluster interval is partitioned into the smallest number of equally-sized subintervals where each subinterval is smaller than max width. Windows are then assigned to each subinterval based on the location of the window midpoints. Suggested values range from 2000 to 10000 bp, but no limits are placed on the maximum size if no value entered." />
    <param name="ignore_strand" type="boolean" truevalue="true" falsevalue="" checked="true" label="Ignore the strandedness of regions?" help="If no is selected, the entries in regions are split into their separate strands." />
  </xml>
  <xml name="findOverlaps">
    <param name="query" type="data" format="tabular" label="Ranges" help="Upload as a dataframe where the first column is the start position and the second column is the end position." />
    <param name="subject" type="data" format="tabular" label="Ranges" help="Upload as a dataframe where the first column is the start position and the second column is the end position." />
    <param name="maxgap" type="integer" value="-1" label="Maximum Gap" help="A single integer >= -1. If type is set to any, maxgap is interpreted as the maximum gap that is allowed between 2 ranges for the ranges to be considered as overlapping. The gap between 2 ranges is the number of positions that separate them. The gap between 2 adjacent ranges is 0. By convention when one range has its start or end strictly inside the other (i.e. non-disjoint ranges), the gap is considered to be -1. If type is set to anything else, maxgap has a special meaning that depends on the particular type." />
    <param name="minoverlap" type="integer" value="0" label="Minimum Overlap" help="A single non-negative integer. Only ranges with a minimum of minoverlap overlapping positions are considered to be overlapping. When type is any, at least one of maxgap and minoverlap must be set to its default value." />
    <param name="type" type="select" label="Types of overlap" help="If type is start or end, the intervals are required to have matching starts or ends, respectively. Specifying equal as the type returns the intersection of the start and end matches. If type is within, the query interval must be wholly contained within the subject interval. Note that all matches must additionally satisfy the minoverlap constraint described above." >
      <option value="any">Any</option>
      <option value="start">Start</option>
      <option value="last">Last</option>
      <option value="within">Within</option>
      <option value="equal">Equal</option>
    </param>
    <param name="select" type="select" label="Select" help="When select is all, the results are returned as a HitsList object. Otherwise the returned value depends on the drop argument. When select not all or drop, an IntegerList is returned, where each element of the result corresponds to a space in query. 

    When select is drop, an integer vector is returned containing indices that are offset to align with the unlisted query." >
      <option value="all">All</option>
      <option value="first">First</option>
      <option value="last">Last</option>
      <option value="arbitrary">Arbitrary</option>
    </param>
  </xml>
</macros>
