<?xml version="1.0"?>
<macros>
  <token name="@VERSION@">1.16.0</token>
  <token name="@GRANGES@"><![CDATA[
    #if str($named) == "true"
      data <- read.table("$GRanges", header=T)
    #else
      data <- read.table("$GRanges", header=F)
    #end if
    gRange <- data[[1]]
    start <- data[[2]]
    end <- data[[3]]
    regions <- GRanges(gRange, IRanges(start, end))
  ]]>
  </token>

  <!--<token name="@SEC_GRANGES@"><![CDATA[
  gRange <- as.character(unlist(strsplit(gsub(" ", "", "${region.GRanges}", ","), ",")))
  rangeData <- read.table("$region.IRanges", header=F)
  start <- c(rangeData[[1]])
  end <- c(rangeData[[2]])
  regions <- GRanges(gRange, IRanges(start, end))
    ]]>
  </token>-->
  <token name="@COLNAMES@">
    <![CDATA[
    #if str($pval_col) != ''
        pval_col <- as.numeric(gsub("([0-9]+).*$", "\\1", "$pval_col"))
        if (is.na(pval_col)){
            pval_col <- "$pval_col"
        }
    #else
        pval_col <- NULL
    #end if
    #if str($fc_col) != ''
        fc_col <- as.numeric(gsub("([0-9]+).*$", "\\1", "$fc_col"))
        if (is.na(fc_col)){
            fc_col <- "$fc_col"
        }
    #else
        fc_col <- NA
    #end if
  ]]>
  </token>
  <!--<token name="@DATALIST@">
    <![CDATA[
    gRangeList <- c()
    IRangeList <- list()
    #for $i in $gRange_obj
        gRangeList <- c(gRangeList, as.character(unlist(strsplit(gsub(" ", "", "${i.GRanges}", ","), ","))))
        IRangeList <- append(IRangeList, list(read.table("${i.IRanges}")))
    #end for

    dataList <- c()
    for (i in seq(gRangeList)){
        dataList <- c(dataList, GRanges(gRangeList[i], IRanges(IRangeList[[i]][[1]], IRangeList[[i]][[2]])))
    }
  ]]>
  </token>
  <token name="@RESULTLIST@">
    <![CDATA[
    resultList <- list()
    #for $i in $db
        resultList <- append(resultList, list(read.table("${i.result_list}", header=T)))
    #end for
  ]]>
  </token>

  <token name="@EQUIWEIGHT@">
    <![CDATA[
    #if str($equiweight) == 'true'
        equiweight <- TRUE
    #else
        equiweight <- FALSE
    #end if
  ]]>
  </token>-->
  
  <!--<token name="@MAXWIDTH@">
    <![CDATA[
    #if str($max_width) != ''
        maxWidth <- as.numeric("$max_width")
    #else
        maxWidth <- NULL
    #end if
  ]]>
  </token>-->

  <token name="@READPARAM@">
    <![CDATA[
    #if str($readParam_select.readParam_selector) == 'yes'
        pe <- "$readParam_select.pe"
        max_frag <- as.numeric("$readParam_select.max_frag")

        #if str($readParam_select.dedup) == ''
            ded_up <- F
        #else
            ded_up <- T
        #end if

        #if str($readParam_select.minq) != ''
            min_q <- as.numeric("${readParam_select.minq}")
        #else
          min_q <- NA
        #end if

        #if str($readParam_select.forward) == 'NA'
          forward <- NA
        #else if str($readParam_select.forward) == 'forward'
          forward <- TRUE
        #else if str($readParam_select.forward) == 'reverse'
            forward <- FALSE
        #end if

        restrict <- as.character(unlist(strsplit(gsub(" ", "", "${readParam_select.restrict}", ","), ",")))

        #if str($readParam_select.discard_select.discard) == 'yes'
          #if str($readParam_select.discard_select.named) == "true"
            data <- read.table("$readParam_select.discard_select.GRanges", header=T)
          #else
            data <- read.table("$readParam_select.discard_select.GRanges", header=F)
          #end if
          gRange <- data[[1]]
          start <- data[[2]]
          end <- data[[3]]
          discard <- GRanges(gRange, IRanges(start, end))
        #else
          discard <- GRanges()
        #end if
        p <- readParam(pe=pe, max.frag=max_frag, dedup=ded_up, minq=min_q, forward=forward, discard=discard, BPPARAM=SerialParam())
    #else
        p <- readParam()
    #end if  
  ]]>
  </token>

  <!--macros for filterWindows-->
  <token name="@WINDOWSCOUNTS_REPEAT@">
    <![CDATA[
    ## parameters for windowCounts repeat
    bamFiles <- c()
    r <- c()
    count <- c()
    spacing <- list()
    shift <- list()
    filter <- list()
    binList <- list()
    widthList <- list()
    extList <- list()
    readP <- list()
    window_counts <- c()

    #for $i, $j in enumerate($windowCounts.data)
        #for $x, $y in enumerate($j.bam_input)
            r <- c(r, $x)
            bamFiles <- c(bamFiles, "$y.bam_file")
        #end for

        spacing <- append(spacing, list(as.numeric("$j.spacing")))

        #if str($j.width) != ''
            width <- as.numeric("$j.width")
        #else
            width <- as.numeric("$j.spacing")
        #end if

        widthList <- append(widthList, list(width))

        #if str($j.ext_selector.ext_select) == 'integer'
            ext <- as.numeric("$j.ext_selector.ext")
        #else
            #if "$j.ext_selector.ext_list1" != ""
                ext1 <- as.numeric(unlist(strsplit("$j.ext_selector.ext_list1", ",")))
            #else
                ext1 <- NA
            #end if
            #if "$j.ext_selector.ext_list2" != ""
                ext2 <- as.numeric(unlist(strsplit("$j.ext_selector.ext_list2", ",")))
            #else
                ext2 <- NA
            #end if
            ext <- list(ext1, ext2)
        #end if

        extList <- append(extList, list(ext))
        shift <- append(shift, list(as.numeric($j.shift)))
        filter <- append(filter, list(as.numeric($j.filter)))

        #if str($j.bin) == "true"
            bin <- TRUE
        #else
            bin <- FALSE
        #end if
        binList <- append(binList, list(bin))

        #if str($j.readParam_select.readParam_selector) == 'yes'
            pe <- "$j.readParam_select.pe"
            max_frag <- as.numeric("$j.readParam_select.max_frag")

            #if str($j.readParam_select.dedup) == ''
                ded_up <- F
            #else
                ded_up <- T
            #end if

            #if str($j.readParam_select.minq) != ''
              min_q <- as.numeric("${j.readParam_select.minq}")
            #else
              min_q <- NA
            #end if

            #if str($j.readParam_select.forward) == 'NA'
              forward <- NA
            #else if str($j.readParam_select.forward) == 'forward'
              forward <- TRUE
            #else if str($j.readParam_select.forward) == 'reverse'
                forward <- FALSE
            #end if

            restrict <- as.character(unlist(strsplit(gsub(" ", "", "${j.readParam_select.restrict}", ","), ",")))

            #if str($j.readParam_select.discard_select.discard) == 'yes'
              #if str($j.readParam_select.discard_select.named) == "true"
                data <- read.table("$j.readParam_select.discard_select.GRanges", header=T)
              #else
                data <- read.table("$j.readParam_select.discard_select.GRanges", header=F)
              #end if
              gRange <- data[[1]]
              start <- data[[2]]
              end <- data[[3]]
              discard <- GRanges(gRange, IRanges(start, end))
            #else
              discard <- GRanges()
            #end if
            p <- readParam(pe=pe, max.frag=max_frag, dedup=ded_up, minq=min_q, forward=forward, discard=discard, BPPARAM=SerialParam())
        #else
            p <- readParam()
        #end if

        readP <- append(readP, list(p))
    #end for

    len <- length(r)-1

    for(i in seq(1, len)) {
        if(r[i] == 0){
            count <- c(count, c(r[i+1]+1)) 
        }
    }

    if(tail(r, n=1) == 0) {
      count <- c(count, 1)
    }

    bamList <- list()

    if(tail(count, n=1) == 1) {
        len <- length(count) - 1
        for (i in seq(1,len)){
            bam <- bamFiles[1: count[i]]
            bamList <- append(bamList, list(bam))
            bamLen <- length(bamFiles)
            bamFiles <- bamFiles[(count[i]+1):bamLen]
        }
        bamList <- append(bamList, list(bamFiles))
    } else {
        len <- length(count)
        for (i in seq(1,len)){
            bam <- bamFiles[1: count[i]]
            bamList <- append(bamList, list(bam))
            bamLen <- length(bamFiles)
            bamFiles <- bamFiles[(count[i]+1):bamLen]
        }
    }

    for (i in bamList) {

        indexBam(i)
    }

    for (i in seq(spacing)) {

        window <- windowCounts(bamList[[i]], spacing=spacing[[i]], width=widthList[[i]], ext=extList[[i]], shift=shift[[i]], filter=filter[[i]], bin=binList[[i]], param=readP[[i]])

        window_counts <- c(window_counts, window)
    }

    dataList <- window_counts
  ]]>
  </token>
  <token name="@WINDOWCOUNTS_FILTERWINDOWS_DATA@">
    <![CDATA[
    bamFiles <- c()
    #for $i in $filter_method_select.data.bam_input
        bamFiles <- c(bamFiles, '${i.bam_file}')
    #end for
    indexBam(bamFiles)

    spacing <- as.numeric("$filter_method_select.data.spacing")
    #if str($filter_method_select.data.width) != ''
        width <- as.numeric("$filter_method_select.data.width")
    #else
        width <- spacing
    #end if
    #if str($filter_method_select.data.ext_selector.ext_select) == 'integer'
        ext <- as.numeric("$filter_method_select.data.ext_selector.ext")
    #else
        #if "$filter_method_select.data.ext_selector.ext_list1" != ""
            ext1 <- as.numeric(unlist(strsplit("$filter_method_select.data.ext_selector.ext_list1", ",")))
        #else
            ext1 <- NA
        #end if
        #if "$filter_method_select.data.ext_selector.ext_list2" != ""
            ext2 <- as.numeric(unlist(strsplit("$filter_method_select.data.ext_selector.ext_list2", ",")))
        #else
            ext2 <- NA
        #end if
        ext <- list(ext1, ext2)
    #end if
    shift <- as.numeric("$filter_method_select.data.shift")
    filter <- as.numeric("$filter_method_select.data.filter")
    #if str($filter_method_select.data.bin) == "true"
        bin <- TRUE
    #else
        bin <- FALSE
    #end if

    #if str($filter_method_select.data.readParam_select.readParam_selector) == 'yes'
        pe <- "$filter_method_select.data.readParam_select.pe"
        max_frag <- as.numeric("$filter_method_select.data.readParam_select.max_frag")

        #if str($filter_method_select.data.readParam_select.dedup) == ''
            ded_up <- F
        #else
            ded_up <- T
        #end if

        #if str($filter_method_select.data.readParam_select.minq) != ''
          min_q <- as.numeric("${filter_method_select.data.readParam_select.minq}")
        #else
          min_q <- NA
        #end if

        #if str($filter_method_select.data.readParam_select.forward) == 'NA'
          forward <- NA
        #else if str($filter_method_select.data.readParam_select.forward) == 'forward'
          forward <- TRUE
        #else if str($filter_method_select.data.readParam_select.forward) == 'reverse'
            forward <- FALSE
        #end if

        restrict <- as.character(unlist(strsplit(gsub(" ", "", "${filter_method_select.data.readParam_select.restrict}", ","), ",")))

        #if str($filter_method_select.data.readParam_select.discard_select.discard) == 'yes'
          #if str($filter_method_select.data.readParam_select.discard_select.named) == "true"
            data <- read.table("$filter_method_select.data.readParam_select.discard_select.GRanges", header=T)
          #else
            data <- read.table("$filter_method_select.data.readParam_select.discard_select.GRanges", header=F)
          #end if
          gRange <- data[[1]]
          start <- data[[2]]
          end <- data[[3]]
          discard <- GRanges(gRange, IRanges(start, end))
        #else
          discard <- GRanges()
        #end if
        p <- readParam(pe=pe, max.frag=max_frag, dedup=ded_up, minq=min_q, forward=forward, discard=discard, BPPARAM=SerialParam())
    #else
        p <- readParam()
    #end if
  ]]>
  </token>
  <token name="@WINDOWCOUNTS_FILTERWINDOWS_BACKGROUND@">
    <![CDATA[
        bamFiles_bg <- c()
        #for $i in $filter_method_select.background_select.background.bam_input
            bamFiles_bg <- c(bamFiles_bg, '${i.bam_file}')
        #end for
        indexBam(bamFiles_bg)

        spacing_bg <- as.numeric("$filter_method_select.background_select.background.spacing")
        #if str($filter_method_select.background_select.background.width) != ''
            width_bg <- as.numeric("$filter_method_select.background_select.background.width")
        #else
            width_bg <- spacing_bg
        #end if
        #if str($filter_method_select.background_select.background.ext_selector.ext_select) == 'integer'
            ext_bg <- as.numeric("$filter_method_select.background_select.background.ext_selector.ext")
        #else
            #if "$filter_method_select.background_select.background.ext_selector.ext_list1" != ""
                ext1_bg <- as.numeric(unlist(strsplit("$filter_method_select.background_select.background.ext_selector.ext_list1", ",")))
            #else
                ext1_bg <- NA
            #end if
            #if "$filter_method_select.background_select.background.ext_selector.ext_list2" != ""
                ext2_bg <- as.numeric(unlist(strsplit("$filter_method_select.background_select.background.ext_selector.ext_list2", ",")))
            #else
                ext2_bg <- NA
            #end if
            ext_bg <- list(ext1_bg, ext2_bg)
        #end if
        shift_bg <- as.numeric("$filter_method_select.background_select.background.shift")
        filter_bg <- as.numeric("$filter_method_select.background_select.background.filter")
        #if str($filter_method_select.background_select.background.bin) == "true"
            bin_bg <- TRUE
        #else
            bin_bg <- FALSE
        #end if

        #if str($filter_method_select.background_select.background.readParam_select.readParam_selector) == 'yes'
            pe_bg <- "$filter_method_select.background_select.background.readParam_select.pe"
            max_frag_bg <- as.numeric("$filter_method_select.background_select.background.readParam_select.max_frag")

            #if str($filter_method_select.background_select.background.readParam_select.dedup) == ''
                ded_up_bg <- F
            #else
                ded_up_bg <- T
            #end if

            #if str($filter_method_select.background_select.background.readParam_select.minq) != ''
              min_q_bg <- as.numeric("${filter_method_select.background_select.background.readParam_select.minq}")
            #else
              min_q_bg <- NA
            #end if

            #if str($filter_method_select.background_select.background.readParam_select.forward) == 'NA'
              forward_bg <- NA
            #else if str($filter_method_select.background_select.background.readParam_select.forward) == 'forward'
              forward_bg <- TRUE
            #else if str($filter_method_select.background_select.background.readParam_select.forward) == 'reverse'
                forward_bg <- FALSE
            #end if

            restrict_bg <- as.character(unlist(strsplit(gsub(" ", "", "${filter_method_select.background_select.background.readParam_select.restrict}", ","), ",")))

            #if str($filter_method_select.background_select.background.readParam_select.discard_select.discard) == 'yes'
              #if str($filter_method_select.background_select.background.readParam_select.discard_select.named) == "true"
                data_bg <- read.table("$filter_method_select.background_select.background.readParam_select.discard_select.GRanges", header=T)
              #else
                data_bg <- read.table("$filter_method_select.background_select.background.readParam_select.discard_select.GRanges", header=F)
              #end if
              gRange_bg <- data_bg[[1]]
              start_bg <- data_bg[[2]]
              end_bg <- data_bg[[3]]
              discard_bg <- GRanges(gRange_bg, IRanges(start_bg, end_bg))
            #else
              discard_bg <- GRanges()
            #end if
            p_bg <- readParam(pe=pe_bg, max.frag=max_frag_bg, dedup=ded_up_bg, minq=min_q_bg, forward=forward_bg, discard=discard_bg, BPPARAM=SerialParam())
        #else
            p_bg <- readParam()
        #end if
  ]]>
  </token>
  <token name="@WINDOWCOUNTS_FILTERWINDOWS_SCALE_DATA@">
    <![CDATA[
            bamFiles_scale_info <- c()
            #for $i in $filter_method_select.scale_info_select.data.bam_input
                bamFiles_scale_info <- c(bamFiles_scale_info, '${i.bam_file}')
            #end for
            indexBam(bamFiles_scale_info)

            spacing_scale_info <- as.numeric("$filter_method_select.scale_info_select.data.spacing")
            #if str($filter_method_select.scale_info_select.data.width) != ''
                width_scale_info <- as.numeric("$filter_method_select.scale_info_select.data.width")
            #else
                width_scale_info <- spacing_scale_info
            #end if
            #if str($filter_method_select.scale_info_select.data.ext_selector.ext_select) == 'integer'
                ext_scale_info <- as.numeric("$filter_method_select.scale_info_select.data.ext_selector.ext")
            #else
                #if "$filter_method_select.scale_info_select.data.ext_selector.ext_list1" != ""
                    ext1_scale_info <- as.numeric(unlist(strsplit("$filter_method_select.scale_info_select.data.ext_selector.ext_list1", ",")))
                #else
                    ext1_scale_info <- NA
                #end if
                #if "$filter_method_select.scale_info_select.data.ext_selector.ext_list2" != ""
                    ext2_scale_info <- as.numeric(unlist(strsplit("$filter_method_select.scale_info_select.data.ext_selector.ext_list2", ",")))
                #else
                    ext2_scale_info <- NA
                #end if
                ext_scale_info <- list(ext1_scale_info, ext2_scale_info)
            #end if
            shift_scale_info <- as.numeric("$filter_method_select.scale_info_select.data.shift")
            filter_scale_info <- as.numeric("$filter_method_select.scale_info_select.data.filter")
            #if str($filter_method_select.scale_info_select.data.bin) == "true"
                bin_scale_info <- TRUE
            #else
                bin_scale_info <- FALSE
            #end if

            #if str($filter_method_select.scale_info_select.data.readParam_select.readParam_selector) == 'yes'
                pe_scale_info <- "$filter_method_select.scale_info_select.data.readParam_select.pe"
                max_frag_scale_info <- as.numeric("$filter_method_select.scale_info_select.data.readParam_select.max_frag")

                #if str($filter_method_select.scale_info_select.data.readParam_select.dedup) == ''
                    ded_up_scale_info <- F
                #else
                    ded_up_scale_info <- T
                #end if

                #if str($filter_method_select.scale_info_select.data.readParam_select.minq) != ''
                  min_q_scale_info <- as.numeric("${filter_method_select.scale_info_select.data.readParam_select.minq}")
                #else
                  min_q_scale_info <- NA
                #end if

                #if str($filter_method_select.scale_info_select.data.readParam_select.forward) == 'NA'
                  forward_scale_info <- NA
                #else if str($filter_method_select.scale_info_select.data.readParam_select.forward) == 'forward'
                  forward_scale_info <- TRUE
                #else if str($filter_method_select.scale_info_select.data.readParam_select.forward) == 'reverse'
                    forward_scale_info <- FALSE
                #end if

                restrict_scale_info <- as.character(unlist(strsplit(gsub(" ", "", "${filter_method_select.scale_info_select.data.readParam_select.restrict}", ","), ",")))

                #if str($filter_method_select.scale_info_select.data.readParam_select.discard_select.discard) == 'yes'
                  #if str($filter_method_select.scale_info_select.data.readParam_select.discard_select.named) == "true"
                    data_scale_info <- read.table("$filter_method_select.scale_info_select.data.readParam_select.discard_select.GRanges", header=T)
                  #else
                    data_scale_info <- read.table("$filter_method_select.scale_info_select.data.readParam_select.discard_select.GRanges", header=F)
                  #end if
                  gRange_scale_info <- data_scale_info[[1]]
                  start_scale_info <- data_scale_info[[2]]
                  end_scale_info <- data_scale_info[[3]]
                  discard_scale_info <- GRanges(gRange_scale_info, IRanges(start_scale_info, end_scale_info))
                #else
                  discard_scale_info <- GRanges()
                #end if
                p_scale_info <- readParam(pe=pe_scale_info, max.frag=max_frag_scale_info, dedup=ded_up_scale_info, minq=min_q_scale_info, forward=forward_scale_info, discard=discard_scale_info, BPPARAM=SerialParam())
            #else
                p_scale_info <- readParam()
            #end if
  ]]>
  </token>
  <token name="@WINDOWCOUNTS_FILTERWINDOWS_SCALE_BG@">
    <![CDATA[
            bamFiles_scale_info_bg <- c()
            #for $i in $filter_method_select.scale_info_select.background.bam_input
                bamFiles_scale_info_bg <- c(bamFiles_scale_info_bg, '${i.bam_file}')
            #end for
            indexBam(bamFiles_scale_info_bg)

            spacing_scale_info_bg <- as.numeric("$filter_method_select.scale_info_select.background.spacing")
            #if str($filter_method_select.scale_info_select.background.width) != ''
                width_scale_info_bg <- as.numeric("$filter_method_select.scale_info_select.background.width")
            #else
                width_scale_info_bg <- spacing_scale_info
            #end if
            #if str($filter_method_select.scale_info_select.background.ext_selector.ext_select) == 'integer'
                ext_scale_info_bg <- as.numeric("$filter_method_select.scale_info_select.background.ext_selector.ext")
            #else
                #if "$filter_method_select.scale_info_select.background.ext_selector.ext_list1" != ""
                    ext1_scale_info_bg <- as.numeric(unlist(strsplit("$filter_method_select.scale_info_select.background.ext_selector.ext_list1", ",")))
                #else
                    ext1_scale_info_bg <- NA
                #end if
                #if "$filter_method_select.scale_info_select.background.ext_selector.ext_list2" != ""
                    ext2_scale_info_bg <- as.numeric(unlist(strsplit("$filter_method_select.scale_info_select.background.ext_selector.ext_list2", ",")))
                #else
                    ext2_scale_info_bg <- NA
                #end if
                ext_scale_info_bg <- list(ext1_scale_info, ext2_scale_info)
            #end if
            shift_scale_info_bg <- as.numeric("$filter_method_select.scale_info_select.background.shift")
            filter_scale_info_bg <- as.numeric("$filter_method_select.scale_info_select.background.filter")
            #if str($filter_method_select.scale_info_select.background.bin) == "true"
                bin_scale_info_bg <- TRUE
            #else
                bin_scale_info_bg <- FALSE
            #end if

            #if str($filter_method_select.scale_info_select.background.readParam_select.readParam_selector) == 'yes'
                pe_scale_info_bg <- "$filter_method_select.scale_info_select.background.readParam_select.pe"
                max_frag_scale_info_bg <- as.numeric("$filter_method_select.scale_info_select.background.readParam_select.max_frag")

                #if str($filter_method_select.scale_info_select.background.readParam_select.dedup) == ''
                    ded_up_scale_info_bg <- F
                #else
                    ded_up_scale_info_bg <- T
                #end if

                #if str($filter_method_select.scale_info_select.background.readParam_select.minq) != ''
                  min_q_scale_info_bg <- as.numeric("${filter_method_select.scale_info_select.background.readParam_select.minq}")
                #else
                  min_q_scale_info_bg <- NA
                #end if

                #if str($filter_method_select.scale_info_select.background.readParam_select.forward) == 'NA'
                  forward_scale_info_bg <- NA
                #else if str($filter_method_select.scale_info_select.background.readParam_select.forward) == 'forward'
                  forward_scale_info_bg <- TRUE
                #else if str($filter_method_select.scale_info_select.background.readParam_select.forward) == 'reverse'
                    forward_scale_info_bg <- FALSE
                #end if

                restrict_scale_info_bg <- as.character(unlist(strsplit(gsub(" ", "", "${filter_method_select.scale_info_select.background.readParam_select.restrict}", ","), ",")))

                #if str($filter_method_select.scale_info_select.background.readParam_select.discard_select.discard) == 'yes'
                  #if str($filter_method_select.scale_info_select.background.readParam_select.discard_select.named) == "true"
                    data_scale_info_bg <- read.table("$filter_method_select.scale_info_select.background.readParam_select.discard_select.GRanges", header=T)
                  #else
                    data_scale_info_bg <- read.table("$filter_method_select.scale_info_select.background.readParam_select.discard_select.GRanges", header=F)
                  #end if
                  gRange_scale_info_bg <- data_scale_info[[1]]
                  start_scale_info_bg <- data_scale_info[[2]]
                  end_scale_info_bg <- data_scale_info[[3]]
                  discard_scale_info_bg <- GRanges(gRange_scale_info, IRanges(start_scale_info, end_scale_info))
                #else
                  discard_scale_info_bg <- GRanges()
                #end if
                p_scale_info_bg <- readParam(pe=pe_scale_info_bg, max.frag=max_frag_scale_info_bg, dedup=ded_up_scale_info_bg, minq=min_q_scale_info_bg, forward=forward_scale_info_bg, discard=discard_scale_info_bg, BPPARAM=SerialParam())
            #else
                p_scale_info_bg <- readParam()
            #end if
  ]]>
  </token>
  <!--readparam for strandedCounts-->
  <!-- <token name="@READPARAM_SC@">
    <![CDATA[
    #if str($readParam_select.readParam_selector) == 'yes'
        pe <- "$readParam_select.pe"
        max_frag <- as.numeric("$readParam_select.max_frag")

        #if str($readParam_select.dedup) == ''
            ded_up <- F
        #else
            ded_up <- T
        #end if

        #if str($readParam_select.minq) != ''
            min_q <- as.numeric("${readParam_select.minq}")
        #else
          min_q <- NA
        #end if

        #if str($readParam_select.forward) == 'NA'
          forward <- NA
        #else if str($readParam_select.forward) == 'forward'
          forward <- TRUE
        #else if str($readParam_select.forward) == 'reverse'
            forward <- FALSE
        #end if

        restrict <- as.character(unlist(strsplit(gsub(" ", "", "${readParam_select.restrict}", ","), ",")))
        #if str($readParam_select.discard_select) == 'yes'
          dis_gRange <- as.character(unlist(strsplit(gsub(" ", "", "${discard_select.GRanges}", ","), ",")))
          dis_b <- unlist(strsplit(gsub(" ", "", "${discard_select.IRanges}", ","), ";"))
          dis_c <- gsub("\\[|\\]", "", dis_b)
          dis_d <- lapply(dis_c, function(x){x <- as.numeric(unlist(strsplit(x, ",")))})
          dis_e <- c()
          dis_f <- c()
          for (i in seq(dis_d)){ 
            dis_e <- c(dis_e, dis_d[[i]][1])
            dis_f <- c(dis_f, dis_d[[i]][2])
          }
          discard <- GRanges(dis_gRange, IRanges(dis_e, dis_f))
        #else
          discard <- GRanges()
        #end if
        p <- readParam(pe=pe, max.frag=max_frag, dedup=ded_up, minq=min_q, forward=forward, discard=discard, BPPARAM=SerialParam())
    #else
        p <- readParam(forward=NULL)
    #end if  
  ]]>
  </token>-->
  
  <!-- WITH SECTION -->
  <!--<token name="@READPARAM_WC@">
    <![CDATA[
    #if str($data_select.windowCounts.readParam_select.readParam_selector) == 'yes'
        pe <- "$data_select.windowCounts.readParam_select.pe"
        max_frag <- as.numeric("$data_select.windowCounts.readParam_select.max_frag")

        #if str($data_select.windowCounts.readParam_select.dedup) == ''
            ded_up <- F
        #else
            ded_up <- T
        #end if

        #if str($data_select.windowCounts.readParam_select.minq) != ''
            min_q <- as.numeric("${data_select.windowCounts.readParam_select.minq}")
        #else
          min_q <- NA
        #end if

        #if str($data_select.windowCounts.readParam_select.forward) == 'NA'
          forward <- NA
        #else if str($data_select.windowCounts.readParam_select.forward) == 'forward'
          forward <- TRUE
        #else if str($data_select.windowCounts.readParam_select.forward) == 'reverse'
            forward <- FALSE
        #end if

        restrict <- as.character(unlist(strsplit(gsub(" ", "", "${data_select.windowCounts.readParam_select.restrict}", ","), ",")))
        #if str($windowCounts.readParam_select.discard_select) == 'yes'
          dis_gRange <- as.character(unlist(strsplit(gsub(" ", "", "${data_select.windowCounts.discard_select.GRanges}", ","), ",")))
          dis_b <- unlist(strsplit(gsub(" ", "", "${data_select.windowCounts.discard_select.IRanges}", ","), ";"))
          dis_c <- gsub("\\[|\\]", "", dis_b)
          dis_d <- lapply(dis_c, function(x){x <- as.numeric(unlist(strsplit(x, ",")))})
          dis_e <- c()
          dis_f <- c()
          for (i in seq(dis_d)){ 
            dis_e <- c(dis_e, dis_d[[i]][1])
            dis_f <- c(dis_f, dis_d[[i]][2])
          }
          discard <- GRanges(dis_gRange, IRanges(dis_e, dis_f))
        #else
          discard <- GRanges()
        #end if
        p <- readParam(pe=pe, max.frag=max_frag, dedup=ded_up, minq=min_q, forward=forward, discard=discard, BPPARAM=SerialParam())
    #else
        p <- readParam()
    #end if  
  ]]>
  </token>-->
  <!--<token name="@READPARAM_RC@">
    <![CDATA[
    #if str($data_select.regionCounts.readParam_select.readParam_selector) == 'yes'
        pe <- "$data_select.regionCounts.readParam_select.pe"
        max_frag <- as.numeric("$data_select.regionCounts.readParam_select.max_frag")

        #if str($data_select.regionCounts.readParam_select.dedup) == ''
            ded_up <- F
        #else
            ded_up <- T
        #end if

        #if str($data_select.regionCounts.readParam_select.minq) != ''
            min_q <- as.numeric("${data_select.regionCounts.readParam_select.minq}")
        #else
          min_q <- NA
        #end if

        #if str($data_select.regionCounts.readParam_select.forward) == 'NA'
          forward <- NA
        #else if str($data_select.regionCounts.readParam_select.forward) == 'forward'
          forward <- TRUE
        #else if str($data_select.regionCounts.readParam_select.forward) == 'reverse'
            forward <- FALSE
        #end if

        restrict <- as.character(unlist(strsplit(gsub(" ", "", "${data_select.regionCounts.readParam_select.restrict}", ","), ",")))
        #if str($data_select.regionCounts.readParam_select.discard_select) == 'yes'
          dis_gRange <- as.character(unlist(strsplit(gsub(" ", "", "${data_select.regionCounts.discard_select.GRanges}", ","), ",")))
          dis_b <- unlist(strsplit(gsub(" ", "", "${data_select.regionCounts.discard_select.IRanges}", ","), ";"))
          dis_c <- gsub("\\[|\\]", "", dis_b)
          dis_d <- lapply(dis_c, function(x){x <- as.numeric(unlist(strsplit(x, ",")))})
          dis_e <- c()
          dis_f <- c()
          for (i in seq(dis_d)){ 
            dis_e <- c(dis_e, dis_d[[i]][1])
            dis_f <- c(dis_f, dis_d[[i]][2])
          }
          discard <- GRanges(dis_gRange, IRanges(dis_e, dis_f))
        #else
          discard <- GRanges()
        #end if
        p <- readParam(pe=pe, max.frag=max_frag, dedup=ded_up, minq=min_q, forward=forward, discard=discard, BPPARAM=SerialParam())
    #else
        p <- readParam()
    #end if  
  ]]>-->

  <token name="@READPARAM_RC@">
    <![CDATA[
    #if str($data_select.readParam_select.readParam_selector) == 'yes'
        pe <- "$data_select.readParam_select.pe"
        max_frag <- as.numeric("$data_select.readParam_select.max_frag")

        #if str($data_select.readParam_select.dedup) == ''
            ded_up <- F
        #else
            ded_up <- T
        #end if

        #if str($data_select.readParam_select.minq) != ''
            min_q <- as.numeric("${data_select.readParam_select.minq}")
        #else
          min_q <- NA
        #end if

        #if str($data_select.readParam_select.forward) == 'NA'
          forward <- NA
        #else if str($data_select.readParam_select.forward) == 'forward'
          forward <- TRUE
        #else if str($data_select.readParam_select.forward) == 'reverse'
            forward <- FALSE
        #end if

        restrict <- as.character(unlist(strsplit(gsub(" ", "", "${data_select.readParam_select.restrict}", ","), ",")))

        #if str($data_select.readParam_select.discard_select.discard) == 'yes'
          #if str($data_select.readParam_select.discard_select.named) == "true"
            data <- read.table("$data_select.readParam_select.discard_select.GRanges", header=T)
          #else
            data <- read.table("$data_select.readParam_select.discard_select.GRanges", header=F)
          #end if
          gRange <- data[[1]]
          start <- data[[2]]
          end <- data[[3]]
          discard <- GRanges(gRange, IRanges(start, end))
        #else
          discard <- GRanges()
        #end if

        p <- readParam(pe=pe, max.frag=max_frag, dedup=ded_up, minq=min_q, forward=forward, discard=discard, BPPARAM=SerialParam())
    #else
        p <- readParam()
    #end if  
  ]]>
  </token>
  <!--readParam with windowsCount-->

  <token name="@WINDOWCOUNTS@">
    <![CDATA[
    
    bamFiles <- c()
    #for $i in $windowCounts.bam_input
        bamFiles <- c(bamFiles, '${i.bam_file}')
    #end for
    indexBam(bamFiles)

    spacing <- as.numeric("$windowCounts.spacing")
    #if str($windowCounts.width) != ''
        width <- as.numeric("$windowCounts.width")
    #else
        width <- spacing
    #end if
    #if str($windowCounts.ext_selector.ext_select) == 'integer'
        ext <- as.numeric("$windowCounts.ext_selector.ext")
    #else
        #if "$windowCounts.ext_selector.ext_list1" != ""
            ext1 <- as.numeric(unlist(strsplit("$windowCounts.ext_selector.ext_list1", ",")))
        #else
            ext1 <- NA
        #end if
        #if "$windowCounts.ext_selector.ext_list2" != ""
            ext2 <- as.numeric(unlist(strsplit("$windowCounts.ext_selector.ext_list2", ",")))
        #else
            ext2 <- NA
        #end if
        ext <- list(ext1, ext2)
    #end if
    shift <- as.numeric("$windowCounts.shift")
    filter <- as.numeric("$windowCounts.filter")
    #if str($windowCounts.bin) == "true"
        bin <- TRUE
    #else
        bin <- FALSE
    #end if

    #if str($windowCounts.readParam_select.readParam_selector) == 'yes'
        pe <- "$windowCounts.readParam_select.pe"
        max_frag <- as.numeric("$windowCounts.readParam_select.max_frag")

        #if str($windowCounts.readParam_select.dedup) == ''
            ded_up <- F
        #else
            ded_up <- T
        #end if

        #if str($windowCounts.readParam_select.minq) != ''
          min_q <- as.numeric("${windowCounts.readParam_select.minq}")
        #else
          min_q <- NA
        #end if

        #if str($windowCounts.readParam_select.forward) == 'NA'
          forward <- NA
        #else if str($windowCounts.readParam_select.forward) == 'forward'
          forward <- TRUE
        #else if str($windowCounts.readParam_select.forward) == 'reverse'
            forward <- FALSE
        #end if

        restrict <- as.character(unlist(strsplit(gsub(" ", "", "${windowCounts.readParam_select.restrict}", ","), ",")))

        #if str($windowCounts.readParam_select.discard_select.discard) == 'yes'
          #if str($windowCounts.readParam_select.discard_select.named) == "true"
            data <- read.table("$windowCounts.readParam_select.discard_select.GRanges", header=T)
          #else
            data <- read.table("$windowCounts.readParam_select.discard_select.GRanges", header=F)
          #end if
          gRange <- data[[1]]
          start <- data[[2]]
          end <- data[[3]]
          discard <- GRanges(gRange, IRanges(start, end))
        #else
          discard <- GRanges()
        #end if

        p <- readParam(pe=pe, max.frag=max_frag, dedup=ded_up, minq=min_q, forward=forward, discard=discard, BPPARAM=SerialParam())
    #else
        p <- readParam()
    #end if  

    window_counts <- windowCounts(bamFiles, spacing=spacing, width=width, ext=ext, shift=shift, filter=filter, bin=bin, param=p)

  ]]>
  </token>
  <token name="@WINDOWCOUNTS_SELECT@">
    <![CDATA[
    
    bamFiles <- c()
    #for $i in $data_select.bam_input
        bamFiles <- c(bamFiles, '${i.bam_file}')
    #end for
    indexBam(bamFiles)

    spacing <- as.numeric("$data_select.spacing")
    #if str($data_select.width) != ''
        width <- as.numeric("$data_select.width")
    #else
        width <- spacing
    #end if
    #if str($data_select.ext_selector.ext_select) == 'integer'
        ext <- as.numeric("$data_select.ext_selector.ext")
    #else
        #if "$data_select.ext_list1" != ""
            ext1 <- as.numeric(unlist(strsplit("$data_select.ext_selector.ext_list1", ",")))
        #else
            ext1 <- NA
        #end if
        #if "$data_select.ext_list2" != ""
            ext2 <- as.numeric(unlist(strsplit("$data_select.ext_selector.ext_list2", ",")))
        #else
            ext2 <- NA
        #end if
        ext <- list(ext1, ext2)
    #end if
    shift <- as.numeric("$data_select.shift")
    filter <- as.numeric("$data_select.filter")
    #if str($data_select.bin) == "true"
        bin <- TRUE
    #else
        bin <- FALSE
    #end if

    #if str($data_select.readParam_select.readParam_selector) == 'yes'
        pe <- "$data_select.readParam_select.pe"
        max_frag <- as.numeric("$data_select.readParam_select.max_frag")

        #if str($data_select.readParam_select.dedup) == ''
            ded_up <- F
        #else
            ded_up <- T
        #end if

        #if str($data_select.readParam_select.minq) != ''
            min_q <- as.numeric("${data_select.readParam_select.minq}")
        #else
          min_q <- NA
        #end if

        #if str($data_select.readParam_select.forward) == 'NA'
          forward <- NA
        #else if str($data_select.readParam_select.forward) == 'forward'
          forward <- TRUE
        #else if str($data_select.readParam_select.forward) == 'reverse'
            forward <- FALSE
        #end if

        restrict <- as.character(unlist(strsplit(gsub(" ", "", "${data_select.readParam_select.restrict}", ","), ",")))

        #if str($data_select.readParam_select.discard_select.discard) == 'yes'
          #if str($data_select.readParam_select.discard_select.named) == "true"
            data <- read.table("$data_select.readParam_select.discard_select.GRanges", header=T)
          #else
            data <- read.table("$data_select.readParam_select.discard_select.GRanges", header=F)
          #end if
          gRange <- data[[1]]
          start <- data[[2]]
          end <- data[[3]]
          discard <- GRanges(gRange, IRanges(start, end))
        #else
          discard <- GRanges()
        #end if

        p <- readParam(pe=pe, max.frag=max_frag, dedup=ded_up, minq=min_q, forward=forward, discard=discard, BPPARAM=SerialParam())
    #else
        p <- readParam()
    #end if

    window_counts <- windowCounts(bamFiles, spacing=spacing, width=width, ext=ext, shift=shift, filter=filter, bin=bin, param=p)

  ]]>
  </token>
  <token name="@REGIONCOUNTS@">
    <![CDATA[
    
    bamFiles <- c()
    #for $i in $regionCounts.bam_input
        bamFiles <- c(bamFiles, '${i.bam_file}')
    #end for
    indexBam(bamFiles)

    gRange <- as.character(unlist(strsplit(gsub(" ", "", "${regionCounts.GRanges}", ","), ",")))
    rangeData <- read.table("$regionCounts.IRanges", header=F)
    start <- c(rangeData[[1]])
    end <- c(rangeData[[2]])

    regions <- GRanges(gRange, IRanges(start, end))

    #if str($regionCounts.ext_selector.ext_select) == 'integer'
        ext <- as.numeric("$regionCounts.ext_selector.ext")
    #else
        #if "$regionCounts.ext_selector.ext1" != ""
            ext1 <- as.numeric(unlist(strsplit("$regionCounts.ext_selector.ext1", ",")))
        #else
            ext1 <- NA
        #end if
        #if "$regionCounts.ext_selector.ext2" != ""
            ext2 <- as.numeric(unlist(strsplit("$regionCounts.ext_selector.ext2", ",")))
        #else
            ext2 <- NA
        #end if
        ext <- list(ext1, ext2)
    #end if

    @READPARAM_RCS@

    region_counts <- regionCounts(bamFiles, regions, ext=ext, param=p)
  ]]>
  </token>
  <!--<token name="@REGIONCOUNTS_SELECT@">
    <![CDATA[
    
    bamFiles <- c()
    #for $i in $data_select.regionCounts.bam_input
        bamFiles <- c(bamFiles, '${i.bam_file}')
    #end for
    indexBam(bamFiles)

    #if str($data_select.named) == "true"
      data <- read.table("$data_select.GRanges", header=T)
    #else
      data <- read.table("$data_select.GRanges", header=F)
    #end if
    gRange <- data[[1]]
    start <- data[[2]]
    end <- data[[3]]
    regions <- GRanges(gRange, IRanges(start, end))

    #if str($data_select.regionCounts.ext_selector.ext_select) == 'integer'
        ext <- as.numeric("$data_select.regionCounts.ext_selector.ext")
    #else
        #if "$data_select.regionCounts.ext_selector.ext1" != ""
            ext1 <- as.numeric(unlist(strsplit("$data_select.regionCounts.ext_selector.ext1", ",")))
        #else
            ext1 <- NA
        #end if
        #if "$data_select.regionCounts.ext_selector.ext2" != ""
            ext2 <- as.numeric(unlist(strsplit("$data_select.regionCounts.ext_selector.ext2", ",")))
        #else
            ext2 <- NA
        #end if
        ext <- list(ext1, ext2)
    #end if

    @READPARAM_RCS@

    region_counts <- regionCounts(bamFiles, regions, ext=ext, param=p)
  ]]>
  </token>-->
  <token name="@REGIONCOUNTS_SELECT@">
    <![CDATA[
    
    bamFiles <- c()
    #for $i in $data_select.bam_input
        bamFiles <- c(bamFiles, '${i.bam_file}')
    #end for
    indexBam(bamFiles)

    #if str($data_select.named) == "true"
      data <- read.table("$data_select.GRanges", header=T)
    #else
      data <- read.table("$data_select.GRanges", header=F)
    #end if
    gRange <- data[[1]]
    start <- data[[2]]
    end <- data[[3]]
    regions <- GRanges(gRange, IRanges(start, end))

    #if str($data_select.ext_selector.ext_select) == 'integer'
        ext <- as.numeric("$data_select.ext_selector.ext")
    #else
        #if "$data_select.ext_selector.ext_list1" != ""
            ext1 <- as.numeric(unlist(strsplit("$data_select.ext_selector.ext_list1", ",")))
        #else
            ext1 <- NA
        #end if
        #if "$data_select.ext_selector.ext)list2" != ""
            ext2 <- as.numeric(unlist(strsplit("$data_select.ext_selector.ext_list2", ",")))
        #else
            ext2 <- NA
        #end if
        ext <- list(ext1, ext2)
    #end if

    #if str($data_select.readParam_select.readParam_selector) == 'yes'
        pe <- "$data_select.readParam_select.pe"
        max_frag <- as.numeric("$data_select.readParam_select.max_frag")

        #if str($data_select.readParam_select.dedup) == ''
            ded_up <- F
        #else
            ded_up <- T
        #end if

        #if str($data_select.readParam_select.minq) != ''
            min_q <- as.numeric("${data_select.readParam_select.minq}")
        #else
          min_q <- NA
        #end if

        #if str($data_select.readParam_select.forward) == 'NA'
          forward <- NA
        #else if str($data_select.readParam_select.forward) == 'forward'
          forward <- TRUE
        #else if str($data_select.readParam_select.forward) == 'reverse'
            forward <- FALSE
        #end if

        restrict <- as.character(unlist(strsplit(gsub(" ", "", "${data_select.readParam_select.restrict}", ","), ",")))

        #if str($data_select.readParam_select.discard_select.discard) == 'yes'
          #if str($data_select.readParam_select.discard_select.named) == "true"
            data <- read.table("$data_select.readParam_select.discard_select.GRanges", header=T)
          #else
            data <- read.table("$data_select.readParam_select.discard_select.GRanges", header=F)
          #end if
          gRange <- data[[1]]
          start <- data[[2]]
          end <- data[[3]]
          discard <- GRanges(gRange, IRanges(start, end))
        #else
          discard <- GRanges()
        #end if

        p <- readParam(pe=pe, max.frag=max_frag, dedup=ded_up, minq=min_q, forward=forward, discard=discard, BPPARAM=SerialParam())
    #else
        p <- readParam()
    #end if  

    region_counts <- regionCounts(bamFiles, regions, ext=ext, param=p)
  ]]>
  </token>
  <xml name="requirements">
    <requirements>
      <requirement type="package" version="@VERSION@">bioconductor-csaw</requirement>
    </requirements>
  </xml>
  <xml name="gRanges">
    <param name="GRanges" type="data" format="tabular" label="Regions over which reads are to be counted" help="Upload as a dataframe where the first column is the sequence names, the second column is the start position of the range, and the third column is the end position of the range." />
    <param name="named" type="boolean" truevalue="true" falsevalue="" checked="false" label="Are the columns of the dataframe named?" />
  </xml>

  <xml name="readParam_select">
    <conditional name="readParam_select">
      <param name="readParam_selector" type="select" label="Specify read loading parameters?" >
        <option value="yes">Yes</option>
        <option value="no" selected="true">No</option>
      </param>
      <when value="yes">
        <param name="pe" type="select" label="Is paired-end data present in the BAM file(s)?" help="Reads are assumed to be single-end when None is selected">
          <option value="none">None</option>
          <option value="both">Both Files</option>
          <option value="first">First File</option>
          <option value="second">Second File</option>
        </param>
        <param name="max_frag" type="integer" value="500" label="Maximum fragment length corresponding to a read pair" />
        <param name="dedup" type="boolean" truevalue="true" falsevalue="" checked="false" label="Ignore marked duplicate reads?" help="Marked duplicate reads will be removed with if yes is selected. This may be necessary when many rounds of PCR have been performed. However, it is not recommended for routine counting as it will interfere with the downstream statistical methods. Note that the duplicate field must be set beforehand in the BAM file for this argument to have any effect" />
        <param name="minq" type="integer" value="" optional="true" label="Minimum mapping quality score for an aligned read" help="Reads will be filtered by their mapping quality scores. This is generally recommended to remove low-confidence alignments. The exact threshold for minq will depend on the range of scores provided by the aligner. No filtering on the score will be performed if no value specified." />
        <param name="forward" type="select" label="How should the reads be extracted?">
          <option value="NA">Extract from all strands</option>
          <option value="forward">Extract only from forward strands</option>
          <option value="reverse">Extract only from reverse strands</option>
        </param>
        <param name="restrict" type="text" optional="true" label="Names of allowable chromosomes from which readswill be extracted" help="Reads will only be extracted for the specified chromosomes. This is useful to restrict the analysis to interesting chromosomes, e.g., no contigs/scaffolds or mitochondria."/>
        <conditional name="discard_select">
          <param name="discard" type="select" label="Discard any alignments?" help="A read will be removed if the corresponding alignment is wholly contained within the supplied ranges. This is useful for removing reads in repeat regions.">
            <option value="yes">Yes</option>
            <option value="no" selected="true">No</option>
          </param>
          <when value="yes">
            <expand macro="gRanges" />
          </when>
          <when value="no"> </when>
        </conditional>
          <!--BiocParallelParam object-->
      </when>
      <when value="no"> </when>
    </conditional>
  </xml>
  <!--Excluded because for internal use was noted
  <xml name="weight">
    <param name="weight" type="float" value="" optional="true" label="Frequency weights" help="Argument assumed to contain frequency weights of significant tests/windows. For example, a weight of 2 for a test would be equivalent to repeating that test (i.e., repeating the same window so it shows up twice in your analysis). These weights should be the same as those used during weighted FDR control to compute adjusted p-values." />
  </xml>-->
  
  <xml name="col_names">
    <param name="pval_col" type="text" optional="true" label="Specify the column of tab with the p-values" help="Enter a string or integer" >
      <sanitizer>
        <valid>
          <add value="." />
        </valid>
      </sanitizer>
    </param>
    <param name="fc_col" type="text" optional="true" label="Specify the column of tab with the log-fold changes" help="Enter a string or integer" >
      <sanitizer>
        <valid>
          <add value="." />
        </valid>
      </sanitizer>
    </param>
  </xml>


  <!--<xml name="mergeWindows_param">
    <expand macro="gRanges" />
    <param name="tol" type="float" value="" optional="true" label="Maximum distance between adjacent windows" help="A value of zero means that the windows must be contiguous whereas negative values specify minimum overlaps" />
    <conditional name="sign_select">
      <param name="sign_selector" type="select" label="Specify a positive log-FC for each window?" >
        <option value="yes">Yes</option>
        <option value="no" selected="true">No</option>
      </param>
      <when value="yes">
        <param name="sign" type="boolean" truevalue="true" falsevalue="" checked="true" label="Positive log-FC for each window?" />
      </when>
      <when value="no"> </when>
    </conditional>
    <param name="max_width" type="float" value="" optional="true" label="Maximum size of merged intervals" help="Specification prevents the formation of excessively large clusters when many adjacent regions are present. Any cluster that is wider than the max width is split into multiple subclusters of (roughly) equal size. Specifically, the cluster interval is partitioned into the smallest number of equally-sized subintervals where each subinterval is smaller than max width. Windows are then assigned to each subinterval based on the location of the window midpoints. Suggested values range from 2000 to 10000 bp, but no limits are placed on the maximum size if no value entered." />
    <param name="ignore_strand" type="boolean" truevalue="true" falsevalue="" checked="true" label="Ignore the strandedness of regions?" help="If no is selected, the entries in regions are split into their separate strands." />
  </xml>-->

  <xml name="mergeWindows_select">
    <conditional name="mergeWindows_select" >
      <param name="mergeWindows_selector" type="select" label="Additional parameters to pass to mergeWindows?" >
        <option value="yes">Yes</option>
        <option value="no" selected="true">No</option>
      </param>
     <when value="yes">
      <conditional name="sign_select">
        <param name="sign_selector" type="select" label="Specify a positive log-FC for each window?" >
          <option value="yes">Yes</option>
          <option value="no" selected="true">No</option>
        </param>
        <when value="yes">
          <param name="sign" type="data" format="tabular" label="Positive log-FC for each window" help="Upload as datafame with a column of logical values" />
        </when>
        <when value="no"> </when>
      </conditional>
          <param name="max_width" type="float" value="" optional="true" label="Maximum size of merged intervals" help="Specification prevents the formation of excessively large clusters when many adjacent regions are present. Any cluster that is wider than the max width is split into multiple subclusters of (roughly) equal size. Specifically, the cluster interval is partitioned into the smallest number of equally-sized subintervals where each subinterval is smaller than max width. Windows are then assigned to each subinterval based on the location of the window midpoints. Suggested values range from 2000 to 10000 bp, but no limits are placed on the maximum size if no value entered." />
          <param name="ignore_strand" type="boolean" truevalue="true" falsevalue="" checked="true" label="Ignore the strandedness of regions?" help="If no is selected, the entries in regions are split into their separate strands." />
      </when>
      <when value="no"> </when>
    </conditional>
  </xml>
  
  <xml name="findOverlaps">
    <!--<param name="query" type="data" format="tabular" label="Query Ranges" help="Upload as a dataframe where the first column is the start position and the second column is the end position." />
    <param name="subject" type="data" format="tabular" label="Subject Ranges" help="Upload as a dataframe where the first column is the start position and the second column is the end position." />-->
    <param name="maxgap" type="integer" value="-1" label="Maximum Gap" help="A single integer >= -1. If type is set to any, maxgap is interpreted as the maximum gap that is allowed between 2 ranges for the ranges to be considered as overlapping. The gap between 2 ranges is the number of positions that separate them. The gap between 2 adjacent ranges is 0. By convention when one range has its start or end strictly inside the other (i.e. non-disjoint ranges), the gap is considered to be -1. If type is set to anything else, maxgap has a special meaning that depends on the particular type." />
    <param name="minoverlap" type="integer" value="0" label="Minimum Overlap" help="A single non-negative integer. Only ranges with a minimum of minoverlap overlapping positions are considered to be overlapping. When type is any, at least one of maxgap and minoverlap must be set to its default value." />
    <param name="type" type="select" label="Types of overlap" help="If type is start or end, the intervals are required to have matching starts or ends, respectively. Specifying equal as the type returns the intersection of the start and end matches. If type is within, the query interval must be wholly contained within the subject interval. Note that all matches must additionally satisfy the minoverlap constraint described above." >
      <option value="any">Any</option>
      <option value="start">Start</option>
      <option value="last">Last</option>
      <option value="within">Within</option>
      <option value="equal">Equal</option>
    </param>
    <param name="select" type="select" label="Select" help="When select is all, the results are returned as a HitsList object. Otherwise the returned value depends on the drop argument. When select not all or drop, an IntegerList is returned, where each element of the result corresponds to a space in query. When select is drop, an integer vector is returned containing indices that are offset to align with the unlisted query." >
      <option value="all">All</option>
      <option value="first">First</option>
      <option value="last">Last</option>
      <option value="arbitrary">Arbitrary</option>
    </param>
  </xml>


  <xml name="windowCounts">
    <repeat name="bam_input" title="Upload indexed BAM files in sorted order" >
      <param name="bam_file" type="data" format="bam" label="BAM file" />
    </repeat>
    <param name="spacing" type="integer" value="50" label="Distance between consecutive windows" help="New windows are defined by sliding the current window to the right by the specified spacing." />
    <param name="width" type="integer" value="" optional="true" label="Width of the window" help="The value of width can be interpreted as the width of the contact area between the DNA and protein. In practical terms, it determines the spatial resolution of the analysis. Larger windows count reads over a larger region which results in larger counts. This results in greater detection power at the cost of resolution." />
    <conditional name="ext_selector">
      <param name="ext_select" type="select" label="Average length(s) of the sequenced fragments in each library" >
        <option value="integer" selected="true">Single fragment length</option>
        <option value="list">Multiple fragment lengths</option>
      </param>
      <when value="integer">
        <param name="ext" type="integer" value="100" label="Enter an integer as the average length" />
      </when>
      <when value="list">
        <param name="ext_list1" type="text" optional="true" label="Enter an integer or list" help="When multiple fragment lengths are specified, enter a list of integers followed by a comma. e.g. 100, 150, 200, 250" />
        <param name="ext_list2" type="text" optional="true" label="Enter an integer or list" help="When multiple fragment lengths are specified, enter a list of integers followed by a comma. e.g. 100, 150, 200, 250" />
      </when>
    </conditional>
      <param name="shift" type="integer" value="0" label="Specifying how much the start of each window should be shifted to the left" help="The first window on a chromosome starts at base position 1. Specifying an appropriate value to shift to the left." />
      <param name="filter" type="integer" value="10" label="Minimum count sum across libraries for each window" />
      <param name="bin" type="boolean" truevalue="true" falsevalue="" checked="false" label="Perform binning?" help="If yes is selected, settings are internally adjusted so that all reads are counted into non-overlapping adjacent bins of size width." />
      <expand macro="readParam_select" />
  </xml>


  <xml name="regionCounts">
    <repeat name="bam_input" title="Upload indexed BAM files in sorted order" >
          <param name="bam_file" type="data" format="bam" label="BAM file" />
        </repeat>
        <expand macro="gRanges" />
        <conditional name="ext_selector">
        <param name="ext_select" type="select" label="Average length(s) of the sequenced fragments in each library" >
          <option value="integer" selected="true">Enter an integer</option>
          <option value="list">Enter two integers or lists</option>
        </param>
        <when value="integer">
          <param name="ext" type="integer" value="100" label="Enter an integer as the average length" />
        </when>
        <when value="list">
          <param name="ext_list1" type="text" optional="true" label="Enter an integer or vector" />
          <param name="ext_list2" type="text" optional="true" label="Enter an integer or vector" />
        </when>
      </conditional>
      <expand macro="readParam_select" />
    </xml>
    <token name="@OVERLAPSTATS_W@">
    <![CDATA[
    #if str($output_select.o_weight_select.o_weight_selector) == "yes"
      o_weight <- scan("$output_select.o_weight_select.o_weight", what=numeric())
    #else
      o_weight <- NULL
    #end if

    #if str($output_select.i_weight_select.i_weight_selector) == "yes"
      i_weight <- scan("$output_select.i_weight_select.i_weight", what=numeric())
    #else
      i_weight <- NULL
    #end if
  ]]>
  </token>
    <xml name="overlapStats_weights">
      <conditional name="o_weight_select">
        <param name="o_weight_selector" type="select" label="Specify weights for each overlapped window?" >
          <option value="yes">Yes</option>
          <option value="no" selected="true">No</option>
        </param>
        <when value="yes">
          <param name="o_weight" type="data" format="tabular" label="Weights for each overlapped window" help="Upload a dataframe with a column of weights. This parameter refers to the weights for each region-window relationship. This allows for different weights to be assigned to the same window in different regions." />
        </when>
        <when value="no"> </when>
      </conditional>
      <conditional name="i_weight_select">
        <param name="i_weight_selector" type="select" label="Specify weights for each overlapped window?" >
          <option value="yes">Yes</option>
          <option value="no" selected="true">No</option>
        </param>
        <when value="yes">
          <param name="i_weight" type="data" format="tabular" label="Weights for each individual window" help="Upload a dataframe with a column of weights. This parameter is the weight of the window itself, and is the same regardless of the region." />
        </when>
        <when value="no"> </when>
      </conditional>
  </xml>
  <xml name="citations">
    <citations>
      <citation type="doi">10.18129/B9.bioc.csaw</citation>
    </citations>
  </xml>
</macros>
