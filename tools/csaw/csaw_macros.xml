<?xml version="1.0"?>
<macros>
  <token name="@VERSION@">1.16.0</token>
  <token name="@GRANGES@"><![CDATA[
gRange <- as.character(unlist(strsplit(gsub(" ", "", "${GRanges}", ","), ",")))
rangeData <- read.table("$IRanges", header=F)
    start <- c(rangeData[[1]])
    end <- c(rangeData[[2]])

    regions <- GRanges(gRange, IRanges(start, end))
  ]]>
  </token>
  <token name="@SEC_GRANGES@"><![CDATA[
gRange <- as.character(unlist(strsplit(gsub(" ", "", "${region.GRanges}", ","), ",")))
rangeData <- read.table("$region.IRanges", header=F)
start <- c(rangeData[[1]])
end <- c(rangeData[[2]])
regions <- GRanges(gRange, IRanges(start, end))
  ]]>
  </token>
  <token name="@COLNAMES@">
    <![CDATA[
    #if str($pval_col) != ''
        pval_col <- as.numeric(gsub("([0-9]+).*$", "\\1", "$pval_col"))
        if (is.na(pval_col)){
            pval_col <- "$pval_col"
        }
    #else
        pval_col <- NULL
    #end if
    #if str($fc_col) != ''
        fc_col <- as.numeric(gsub("([0-9]+).*$", "\\1", "$fc_col"))
        if (is.na(fc_col)){
            fc_col <- "$fc_col"
        }
    #else
        fc_col <- NA
    #end if
  ]]>
  </token>
  <token name="@DATALIST@">
    <![CDATA[
    gRangeList <- c()
    IRangeList <- list()
    #for $i in $gRange_obj
        gRangeList <- c(gRangeList, as.character(unlist(strsplit(gsub(" ", "", "${i.GRanges}", ","), ","))))
        IRangeList <- append(IRangeList, list(read.table("${i.IRanges}")))
    #end for

    dataList <- c()
    for (i in seq(gRangeList)){
        dataList <- c(dataList, GRanges(gRangeList[i], IRanges(IRangeList[[i]][[1]], IRangeList[[i]][[2]])))
    }
  ]]>
  </token>
  <token name="@RESULTLIST@">
    <![CDATA[
    resultList <- list()
    #for $i in $db
        resultList <- append(resultList, list(read.table("${i.result_list}", header=T)))
    #end for
  ]]>
  </token>
  <token name="@EQUIWEIGHT@">
    <![CDATA[
    #if str($equiweight) == 'true'
        equiweight <- TRUE
    #else
        equiweight <- FALSE
    #end if
  ]]>
  </token>
  <token name="@MAXWIDTH@">
    <![CDATA[
    #if str($max_width) != ''
        maxWidth <- as.numeric("$max_width")
    #else
        maxWidth <- NULL
    #end if
  ]]>
  </token>
  <token name="@READPARAM@">
    <![CDATA[
    #if str($readParam_select.readParam_selector) == 'yes'
        pe <- "$readParam_select.pe"
        max_frag <- as.numeric("$readParam_select.max_frag")

        #if str($readParam_select.dedup) == ''
            ded_up <- F
        #else
            ded_up <- T
        #end if

        #if str($readParam_select.minq) != ''
            min_q <- as.numeric("${readParam_select.minq}")
        #else
          min_q <- NA
        #end if

        #if str($readParam_select.forward) == 'NA'
          forward <- NA
        #else if str($readParam_select.forward) == 'forward'
          forward <- TRUE
        #else if str($readParam_select.forward) == 'reverse'
            forward <- FALSE
        #end if

        restrict <- as.character(unlist(strsplit(gsub(" ", "", "${readParam_select.restrict}", ","), ",")))
        #if str($readParam_select.discard_select) == 'yes'
          dis_gRange <- as.character(unlist(strsplit(gsub(" ", "", "${discard_select.GRanges}", ","), ",")))
          dis_b <- unlist(strsplit(gsub(" ", "", "${discard_select.IRanges}", ","), ";"))
          dis_c <- gsub("\\[|\\]", "", dis_b)
          dis_d <- lapply(dis_c, function(x){x <- as.numeric(unlist(strsplit(x, ",")))})
          dis_e <- c()
          dis_f <- c()
          for (i in seq(dis_d)){ 
            dis_e <- c(dis_e, dis_d[[i]][1])
            dis_f <- c(dis_f, dis_d[[i]][2])
          }
          discard <- GRanges(dis_gRange, IRanges(dis_e, dis_f))
        #else
          discard <- GRanges()
        #end if
        p <- readParam(pe=pe, max.frag=max_frag, dedup=ded_up, minq=min_q, forward=forward, discard=discard, BPPARAM=SerialParam())
    #else
        p <- readParam()
    #end if  
  ]]>
  </token>
  <token name="@WINDOWCOUNTS@">
    <![CDATA[
    
    bamFiles <- c()
    #for $i in $windowCounts.bam_input
        bamFiles <- c(bamFiles, '${i.bam_file}')
    #end for
    indexBam(bamFiles)

    spacing <- as.numeric("$windowCounts.spacing")
    #if str($windowCounts.width) != ''
        width <- as.numeric("$windowCounts.width")
    #else
        width <- spacing
    #end if
    #if str($windowCounts.ext_selector.ext_select) == 'integer'
        ext <- as.numeric("$windowCounts.ext")
    #else
        #if "$windowCounts.ext1" != ""
            ext1 <- as.numeric(unlist(strsplit("$windowCounts.ext1", ",")))
        #else
            ext1 <- NA
        #end if
        #if "$windowCounts.ext2" != ""
            ext2 <- as.numeric(unlist(strsplit("$windowCounts.ext2", ",")))
        #else
            ext2 <- NA
        #end if
        ext <- list(ext1, ext2)
    #end if
    shift <- as.numeric("$windowCounts.shift")
    filter <- as.numeric("$windowCounts.filter")
    #if str($windowCounts.bin) == "true"
        bin <- TRUE
    #else
        bin <- FALSE
    #end if

    @READPARAM@

    window_counts <- windowCounts(bamFiles, spacing=spacing, width=width, ext=ext, shift=shift, filter=filter, bin=bin, param=p)

  ]]>
  </token>
  <token name="@REGIONCOUNTS@">
    <![CDATA[
    
bamFiles <- c()
    #for $i in $bam_input
        bamFiles <- c(bamFiles, '${i.bam_file}')
    #end for
    indexBam(bamFiles)

    @GRANGES@

    #if str($ext_selector.ext_select) == 'integer'
        ext <- as.numeric("$ext")
    #else
        #if "$ext1" != ""
            ext1 <- as.numeric(unlist(strsplit("$ext1", ",")))
        #else
            ext1 <- NA
        #end if
        #if "$ext2" != ""
            ext2 <- as.numeric(unlist(strsplit("$ext2", ",")))
        #else
            ext2 <- NA
        #end if
        ext <- list(ext1, ext2)
    #end if

    @READPARAM@

    region_counts <- regionCounts(bamFiles, regions, ext=ext, param=p)


  ]]>
  </token>
  <token name="@OVERLAPSTATS_W@">
    <![CDATA[
    #if str($output_select.o_weight) != ''
      o_weight <- scan("$output_select.o_weight", what=numeric())
    #else
      o_weight <- NULL
    #end if
    #if str($output_select.i_weight) != ''
      i_weight <- scan("$output_select.i_weight", what=numeric())
    #else
      i_weight <- NULL
    #end if
  ]]>
  </token>
  <xml name="requirements">
    <requirements>
      <requirement type="package" version="@VERSION@">bioconductor-csaw</requirement>
    </requirements>
  </xml>
  <xml name="citations">
    <citations>
          
    </citations>
  </xml>
  <xml name="gRanges">
    <param name="GRanges" type="text" label="Sequence Names" />
    <param name="IRanges" type="data" format="tabular" label="Ranges" help="Upload as a dataframe where the first column is the start position and the second column is the end position." />
  </xml>
  <xml name="readParam">
    <param name="pe" type="select" label="Is paired-end data present in the BAM file(s)?" help="Reads are assumed to be single-end when None is selected">
      <option value="none">None</option>
      <option value="both">Both Files</option>
      <option value="first">First File</option>
      <option value="second">Second File</option>
    </param>
    <param name="max_frag" type="integer" value="500" label="Maximum fragment length corresponding to a read pair" />
    <param name="dedup" type="boolean" truevalue="true" falsevalue="" checked="false" label="Ignore marked duplicate reads?" help="Marked duplicate reads will be removed with if yes is selected. This may be necessary when many rounds of PCR have been performed. However, it is not recommended for routine counting as it will interfere with the downstream statistical methods. Note that the duplicate field must be set beforehand in the BAM file for this argument to have any effect" />
    <param name="minq" type="integer" value="" optional="true" label="Minimum mapping quality score for an aligned read" help="Reads will be filtered by their mapping quality scores. This is generally recommended to remove low-confidence alignments. The exact threshold for minq will depend on the range of scores provided by the aligner. No filtering on the score will be performed if no value specified." />
    <param name="forward" type="select" label="How should the reads be extracted?">
      <option value="NA">Extract from all strands</option>
      <option value="forward">Extract only from forward strands</option>
      <option value="reverse">Extract only from reverse strands</option>
    </param>
    <param name="restrict" type="text" optional="true" label="Names of allowable chromosomes from which readswill be extracted" help="Reads will only be extracted for the specified chromosomes. This is useful to restrict the analysis to interesting chromosomes, e.g., no contigs/scaffolds or mitochondria."/>
    <conditional name="discard_select">
      <param name="discard" type="select" label="Discard any alignments?" help="A read will be removed if the corresponding alignment is wholly contained within the supplied ranges. This is useful for removing reads in repeat regions.">
        <option value="yes">Yes</option>
        <option value="no" selected="true">No</option>
      </param>
      <when value="yes">
        <expand macro="gRanges" />
      </when>
      <when value="no"> </when>
    </conditional>
      <!--BiocParallelParam object-->
  </xml>
  <xml name="readParam_select">
    <conditional name="readParam_select">
      <param name="readParam_selector" type="select" label="Specify read loading parameters?" >
        <option value="yes">Yes</option>
        <option value="no" selected="true">No</option>
      </param>
      <when value="yes">
        <expand macro="readParam" />
      </when>
      <when value="no"> </when>
    </conditional>
  </xml>
  <xml name="weight">
    <param name="weight" type="float" value="" optional="true" label="Frequency weights" help="Argument assumed to contain frequency weights of significant tests/windows. For example, a weight of 2 for a test would be equivalent to repeating that test (i.e., repeating the same window so it shows up twice in your analysis). These weights should be the same as those used during weighted FDR control to compute adjusted p-values." />
  </xml>
  <!--<xml name="grid_param">
    <conditional name="grid_param_select">
      <param name="grid_param" type="select" label="Tune grid search settings?" help="At each iteration, the grid point with the closest cluster-level FDR to target is chosen and the grid is recentered around that point. The size of the grid is also scaled down to provide greater resolution.">
        <option value="yes">Yes</option>
        <option value="no" selected="true">No</option>
      </param>
      <when value="yes">
        <param name="length" type="integer" value="21" optional="true" label="Length of the grid" />
        <param name="range" type="float" value="20" optional="true" label="Range of the grid in logit units" />
        <param name="iter" type="integer" value="" optional="true" label="Number of iterations of the grid search" />
        <param name="scale" type="float" value="" optional="true" label="How much should the range of the grid be downscaled at each iteration?" />
      </when>
      <when value="no"> </when>
    </conditional>
  </xml>-->
  <xml name="grid">
    <param name="grid_length" type="integer" value="21" label="Specify the number of points to use in the grid search" />
    <param name="iterations" type="integer" value="4" label="Specify the number of iterations of the grid search" />
  </xml>
  <xml name="col_names">
    <param name="pval_col" type="text" optional="true" label="Specify the column of tab with the p-values" help="Enter a string or integer" >
      <sanitizer>
        <valid>
          <add value="." />
        </valid>
      </sanitizer>
    </param>
    <param name="fc_col" type="text" optional="true" label="Specify the column of tab with the log-fold changes" help="Enter a string or integer" >
      <sanitizer>
        <valid>
          <add value="." />
        </valid>
      </sanitizer>
    </param>
  </xml>
  <xml name="clusterWindows_param">
    <expand macro="gRanges" />
    <param name="tab" type="data" format="tabular" label="Dataframe of results with a PValue field for each window" />
    <param name="target" type="float" value="" label="Desired cluster-level FDR" />
    <macro expand="col_names" />
    <param name="tol" type="float" value="" optional="true" label="Maximum distance between adjacent windows"/>
  </xml>
  <xml name="combineTest_param">
    <param name="ids" type="data" format="tabular" label="Cluster ID for each test" help="Upload as a dataframe where each row is an integer." />
    <param name="tab" type="data" format="tabular" label="Dataframe of results with PValue and at least one logFC field for each test" />
    <param name="weight" type="data" format="tabular" optional="true" label="Weights for each window" help="Upload as a dataframe where each row is a numeric value. If none specified, the weight defaults to 1 for each test. Supplying different relative weight values may be useful for downweighting low-confidence tests, e.g., those in repeat regions. In Simes’ procedure, weights are interpreted as relative frequencies of the tests in each cluster." />
    <expand macro="col_names" />
  </xml>
  <xml name="consolidate_param">
    <repeat name="gRange_obj" title="Enter GRanges objects">
      <expand macro="gRanges" />
    </repeat>
    <repeat name="db" title="Upload dataframes containing the DB test results for each entry of data">
      <param name="result_list" type="data" format="tabular" label="DB test results" />
    </repeat>
    <param name="equiweight" type="boolean" truevalue="true" falsevalue="" checked="true" label="Enforce equal weighting from each analysis?" help="Some effort is required to equalize the contribution of the results from each analysis. This is done by setting selecting yes, where the weight of each window is inversely proportional to the number of windows from that analysis." />
    <param name="tol" type="float" value="" label="Maximum distance between adjacent windows"/>
  </xml>
  <xml name="mergeWindows_param">
    <expand macro="gRanges" />
    <param name="tol" type="float" value="" optional="true" label="Maximum distance between adjacent windows" help="A value of zero means that the windows must be contiguous whereas negative values specify minimum overlaps" />
    <conditional name="sign_select">
      <param name="sign_selector" type="select" label="Specify a positive log-FC for each window?" >
        <option value="yes">Yes</option>
        <option value="no" selected="true">No</option>
      </param>
      <when value="yes">
        <param name="sign" type="boolean" truevalue="true" falsevalue="" checked="true" label="Positive log-FC for each window?" />
      </when>
      <when value="no"> </when>
    </conditional>
    <param name="max_width" type="float" value="" optional="true" label="Maximum size of merged intervals" help="Specification prevents the formation of excessively large clusters when many adjacent regions are present. Any cluster that is wider than the max width is split into multiple subclusters of (roughly) equal size. Specifically, the cluster interval is partitioned into the smallest number of equally-sized subintervals where each subinterval is smaller than max width. Windows are then assigned to each subinterval based on the location of the window midpoints. Suggested values range from 2000 to 10000 bp, but no limits are placed on the maximum size if no value entered." />
    <param name="ignore_strand" type="boolean" truevalue="true" falsevalue="" checked="true" label="Ignore the strandedness of regions?" help="If no is selected, the entries in regions are split into their separate strands." />
  </xml>
  <xml name="findOverlaps">
    <param name="query" type="data" format="tabular" label="Ranges" help="Upload as a dataframe where the first column is the start position and the second column is the end position." />
    <param name="subject" type="data" format="tabular" label="Ranges" help="Upload as a dataframe where the first column is the start position and the second column is the end position." />
    <param name="maxgap" type="integer" value="-1" label="Maximum Gap" help="A single integer >= -1. If type is set to any, maxgap is interpreted as the maximum gap that is allowed between 2 ranges for the ranges to be considered as overlapping. The gap between 2 ranges is the number of positions that separate them. The gap between 2 adjacent ranges is 0. By convention when one range has its start or end strictly inside the other (i.e. non-disjoint ranges), the gap is considered to be -1. If type is set to anything else, maxgap has a special meaning that depends on the particular type." />
    <param name="minoverlap" type="integer" value="0" label="Minimum Overlap" help="A single non-negative integer. Only ranges with a minimum of minoverlap overlapping positions are considered to be overlapping. When type is any, at least one of maxgap and minoverlap must be set to its default value." />
    <param name="type" type="select" label="Types of overlap" help="If type is start or end, the intervals are required to have matching starts or ends, respectively. Specifying equal as the type returns the intersection of the start and end matches. If type is within, the query interval must be wholly contained within the subject interval. Note that all matches must additionally satisfy the minoverlap constraint described above." >
      <option value="any">Any</option>
      <option value="start">Start</option>
      <option value="last">Last</option>
      <option value="within">Within</option>
      <option value="equal">Equal</option>
    </param>
    <param name="select" type="select" label="Select" help="When select is all, the results are returned as a HitsList object. Otherwise the returned value depends on the drop argument. When select not all or drop, an IntegerList is returned, where each element of the result corresponds to a space in query. When select is drop, an integer vector is returned containing indices that are offset to align with the unlisted query." >
      <option value="all">All</option>
      <option value="first">First</option>
      <option value="last">Last</option>
      <option value="arbitrary">Arbitrary</option>
    </param>
  </xml>
  <xml name="windowCounts">
    <repeat name="bam_input" title="Upload indexed BAM files in sorted order" >
      <param name="bam_file" type="data" format="bam" label="BAM file" />
    </repeat>
    <param name="spacing" type="integer" value="50" label="Distance between consecutive windows" help="New windows are defined by sliding the current window to the right by the specified spacing." />
    <param name="width" type="integer" value="" optional="true" label="Width of the window" help="The value of width can be interpreted as the width of the contact area between the DNA and protein. In practical terms, it determines the spatial resolution of the analysis. Larger windows count reads over a larger region which results in larger counts. This results in greater detection power at the cost of resolution." />
    <conditional name="ext_selector">
      <param name="ext_select" type="select" label="Average length(s) of the sequenced fragments in each library" >
        <option value="integer" selected="true">Enter an integer</option>
        <option value="list">Enter two integers or lists</option>
      </param>
      <when value="integer">
        <param name="ext" type="integer" value="100" label="Enter an integer as the average length" />
      </when>
      <when value="list">
        <param name="ext_list1" type="text" optional="true" label="Enter an integer or vector" />
        <param name="ext_list2" type="text" optional="true" label="Enter an integer or vector" />
      </when>
    </conditional>
      <param name="shift" type="integer" value="0" label="Specifying how much the start of each window should be shifted to the left" help="The first window on a chromosome starts at base position 1. Specifying an appropriate value to shift to the left." />
      <param name="filter" type="integer" value="10" label="minimum count sum across libraries for each window" />
      <param name="bin" type="boolean" truevalue="true" falsevalue="" checked="false" label="Perform binning?" help="If yes is selected, settings are internally adjusted so that all reads are counted into non-overlapping adjacent bins of size width." />
      <expand macro="readParam_select" />
  </xml>
  <xml name="regionCounts">
    <repeat name="bam_input" title="Upload indexed BAM files in sorted order" >
          <param name="bam_file" type="data" format="bam" label="BAM file" />
        </repeat>
        <expand macro="gRanges" />
        <conditional name="ext_selector">
        <param name="ext_select" type="select" label="Average length(s) of the sequenced fragments in each library" >
          <option value="integer" selected="true">Enter an integer</option>
          <option value="list">Enter two integers or lists</option>
        </param>
        <when value="integer">
          <param name="ext" type="integer" value="100" label="Enter an integer as the average length" />
        </when>
        <when value="list">
          <param name="ext_list1" type="text" optional="true" label="Enter an integer or vector" />
          <param name="ext_list2" type="text" optional="true" label="Enter an integer or vector" />
        </when>
      </conditional>
      <expand macro="readParam_select" />
    </xml>
    <xml name="overlapStats_weights">
      <param name="o_weight" type="data" format="tabular" optinoal="true" label="Specify weights for each overlapped window" help="Upload a dataframe with a column of weights. This parameter refers to the weights for each region-window relationship. This allows for different weights to be assigned to the same window in different regions." />
      <param name="i_weight" type="data" format="tabular" optional="true" label="Specify weights for each individual window" help="Upload a dataframe with a column of weights. This parameter is the weight of the window itself, and is the same regardless of the region." />
  </xml>
  <xml name="citations">
    <citations>
      <citation type="doi">10.18129/B9.bioc.csaw</citation>
    </citations>
  </xml>
</macros>
