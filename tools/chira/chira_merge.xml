<tool id="chira_merge" name="ChiRA merge" version="@WRAPPER_VERSION@0">
    <description>merge aligned positions</description>
    <macros>
        <import>macros.xml</import>
    </macros>
    <expand macro="requirements" />
    <command><![CDATA[
        chira_merge.py
        -b '$alignments'
        #if str($annotation.choice) == "yes":
            -g '$annotation.gtf'
        #end if
        -so '$segment_overlap'
        #if str($merge.mode) == "blockbuster":
            -bb
            -d '$merge.distance'
            -mc '$merge.min_cluster_height'
            -mb '$merge.min_block_height'
            -sc '$merge.scale'
        #else:
            -ao '$merge.alignment_overlap'
        #end if
        #if str($reference.ref_type) == "split":
            -f1 '$reference.ref_fasta1'
            -f2 '$reference.ref_fasta2'
        #end if
        $chimeric_only
        -o ./
    ]]></command>

    <inputs>
        <param format="bed" name="alignments" type="data" label="Input BED file of alignments"/>
        <conditional name="annotation">
            <param name="choice" type="select" label="Do you have an annotation in GTF format?">
                <option value="yes">Yes</option>
                <option value="no">No</option>
            </param>
            <when value="yes">
                <param format="gtf,gff" name="gtf" type="data" label="Annotations in GTF format"/>
            </when>
            <when value="no">
                <!-- Do nothing -->
            </when>
        </conditional>
        <param name="segment_overlap" type="float" value="0.7" label="Overlap fraction for merging mapped read positions to segments" min="0" max="1"
            help="Matching read positions with greater than this fraction overlap are merged into a segment"/>
        <conditional name="merge">
            <param name="mode" type="select" label="Select the mode of merging">
                <option value="overlap">Overlap based</option>
                <option value="blockbuster">Gaussian based (blockbuster)</option>
            </param>
            <when value="overlap">
                <param name="alignment_overlap" type="float" value="0.7" label="Overlap fraction for merging alignments" min="0" max="1"
                    help="Minimum fraction of BED entries that must overlap inorder to merge"/>
            </when>
            <when value="blockbuster">
                <param name="distance" type="integer" value="30" label="Blockbuster parameter distance"
                    help="Minimum distance between two clusters"/>
                <param name="min_cluster_height" type="float" value="10" label="Blockbuster parameter minClusterHeight"
                    help="minimum height (readno) of a cluster"/>
                <param name="min_block_height" type="float" value="1" label="Blockbuster parameter minBlockHeight"
                    help="minimum height (readno) of a block"/>
                <param name="scale" type="float" value="0.4" label="Blockbuster parameter scale" min="0" max="1"
                    help="scale stddev for a single read"/>
            </when>
        </conditional>
        <conditional name="reference">
            <param name="ref_type" type="select" label="Did you use single or split reference for alignment?">
                <option value="single">Single reference</option>
                <option value="split">Split reference</option>
            </param>
            <when value="split">
                <param format="fasta" name="ref_fasta1" type="data" label="Reference FASTA file"
                       help="Reference fasta file"/>
                <param format="fasta" name="ref_fasta2" type="data" label="Second reference FASTA file"
                       help="Second reference fasta file."/>
            </when>
            <when value="single">
                <!-- no need to provide a fasta file -->
            </when>
        </conditional>
        <param name="chimeric_only" type="boolean" truevalue="-c" falsevalue="" checked="false" />
    </inputs>
    <outputs>
        <data format="bed" name="segments_bed" from_work_dir="segments.bed" label="ChiRA aligned read segments on ${on_string}"/>
        <data format="tabular" name="merged_bed" from_work_dir="merged.bed" label="ChiRA merged alignments on ${on_string}"/>
    </outputs>

    <tests>
        <!-- Test: Merge without annotation -->
        <test expect_num_outputs="2">
            <param name="alignments" value="alignments.bed"/>
            <param name="choice" value="no" />
            <param name="ref_type" value="split"/>
            <param name="ref_fasta1" value="ref1.fasta"/>
            <param name="ref_fasta2" value="ref2.fasta"/>
            <output name="segments_bed" >
                <assert_contents>
                    <has_text_matching expression="ENSMUST00000146006\t6703\t6718\t10\|2\|3,ENSMUST00000146006,6703,6718,\+,24S15M16S\t1\t\+" />
                </assert_contents>
            </output>
            <output name="merged_bed" >
                <assert_contents>
                    <has_text_matching expression="ENSMUST00000182010\t408\t477\t\+" />
                    <has_text_matching expression="mmu-miR-9-5p\t0\t23\t\+" />
                </assert_contents>
            </output>
        </test>
        <!-- Test: Merge with annotation -->
        <test expect_num_outputs="2">
            <param name="alignments" value="alignments.bed" />
            <param name="choice" value="yes" />
            <param name="gtf" value="annotation.gtf" />
            <param name="ref_type" value="split"/>
            <param name="ref_fasta1" value="ref1.fasta"/>
            <param name="ref_fasta2" value="ref2.fasta"/>
            <output name="segments_bed" >
                <assert_contents>
                    <has_text_matching expression="2\t31033086\t31033109\t38\|2\|2,ENSMUST00000113555,1676,1699,\+,32S23M\t1\t-" />
                    <has_text_matching expression="7\t83738820\t83738843\t38\|2\|1,mmu-miR-9-5p,0,23,\+,5S23M27S\t1\t\+" />
                </assert_contents>
            </output>
            <output name="merged_bed" >
                <assert_contents>
                    <has_text_matching expression="2\t31033086\t31033109\t-" />
                    <has_text_matching expression="7\t83738820\t83738843\t\+" />
                </assert_contents>
            </output>
        </test>
        <!-- Test: Merge using blockbuster -->
        <test expect_num_outputs="2">
            <param name="alignments" value="alignments.bed" />
            <param name="choice" value="yes" />
            <param name="gtf" value="annotation.gtf" />
            <param name="mode" value="blockbuster" />
            <param name="min_cluster_height" value="5" />
            <param name="ref_type" value="split"/>
            <param name="ref_fasta1" value="ref1.fasta"/>
            <param name="ref_fasta2" value="ref2.fasta"/>
            <output name="segments_bed" >
                <assert_contents>
                    <has_text_matching expression="2\t31033086\t31033109\t38\|2\|2,ENSMUST00000113555,1676,1699,\+,32S23M\t1\t-" />
                    <has_text_matching expression="7\t83738820\t83738843\t38\|2\|1,mmu-miR-9-5p,0,23,\+,5S23M27S\t1\t\+" />
                </assert_contents>
            </output>
            <output name="merged_bed" >
                <assert_contents>
                    <has_text_matching expression="7\t83738820\t83738843\t\+" />
                </assert_contents>
            </output>
        </test>
        <!-- Test: Chimeric only without annotation -->
        <test expect_num_outputs="2">
            <param name="alignments" value="alignments.bed"/>
            <param name="choice" value="no" />
            <param name="ref_type" value="split"/>
            <param name="ref_fasta1" value="ref1.fasta"/>
            <param name="ref_fasta2" value="ref2.fasta"/>
            <param name="chimeric_only" value="true"/>
            <output name="segments_bed" >
                <assert_contents>
                    <has_text_matching expression="mmu-miR-9-5p\t0\t23\t38\|2\|1,mmu-miR-9-5p,0,23,\+,5S23M27S\t1\t\+" />
                    <has_text_matching expression="ENSMUST00000113555\t1676\t1699\t38\|2\|2,ENSMUST00000113555,1676,1699,\+,32S23M\t1\t\+" />
                </assert_contents>
            </output>
            <output name="merged_bed" >
                <assert_contents>
                    <has_text_matching expression="ENSMUST00000113555\t1676\t1699\t\+" />
                    <has_text_matching expression="mmu-miR-9-5p\t0\t23\t\+" />
                </assert_contents>
            </output>
        </test>
    </tests>

    <help>

.. class:: infomark

**What it does**

This tool merges the overlapping aligned positions to define the read concentrated loci. If an annotation GTF file produced, the transcriptomic alignment positions are first converted to their corresponding genomic positions.

**Inputs**

* Alignments in BED format
* An annotation GTF file contaning reference genomic positions.

**Output**

* BED file containing the alignments with reads categorized into segments depending on which part of the read is aligned.
* Tabular file containing merged alignments. 4th column contains all the alignments merged into that location.

    </help>
    <expand macro="citations" />
</tool>
