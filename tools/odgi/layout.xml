<tool id="odgi_layout" name="odgi layout" version="@TOOL_VERSION@+galaxy@VERSION_SUFFIX@" profile="24.1">
    <description>compute 2D path-guided layouts</description>
    <macros>
        <import>macros.xml</import>
    </macros>
    <expand macro="requirements"/>
    <command detect_errors="exit_code"><![CDATA[
odgi layout
--idx '$idx'
--out '$layout_output'
#if $tsv
    $tsv '$layout_tsv'
#end if
#if str($path_index)
    --path-index '$path_index'
#end if
#if str($path_sgd_use_paths)
    --path-sgd-use-paths '$path_sgd_use_paths'
#end if
#if str($layout_initialization)
    --layout-initialization '$layout_initialization'
#end if
#if str($path_sgd_min_term_updates_paths)
    --path-sgd-min-term-updates-paths $path_sgd_min_term_updates_paths
#end if
#if str($path_sgd_min_term_updates_nodes)
    --path-sgd-min-term-updates-nodes $path_sgd_min_term_updates_nodes
#end if
#if str($path_sgd_delta)
    --path-sgd-delta $path_sgd_delta
#end if
#if str($path_sgd_eta)
    --path-sgd-eta $path_sgd_eta
#end if
#if str($path_sgd_eta_max)
    --path-sgd-eta-max $path_sgd_eta_max
#end if
#if str($path_sgd_iter_max)
    --path-sgd-iter-max $path_sgd_iter_max
#end if
#if str($path_sgd_iteration_max_learning_rate)
    --path-sgd-iteration-max-learning-rate $path_sgd_iteration_max_learning_rate
#end if
#if str($path_sgd_zipf_theta)
    --path-sgd-zipf-theta $path_sgd_zipf_theta
#end if
#if str($path_sgd_zipf_space)
    --path-sgd-zipf-space $path_sgd_zipf_space
#end if
#if str($path_sgd_zipf_space_max)
    --path-sgd-zipf-space-max $path_sgd_zipf_space_max
#end if
#if str($path_sgd_zipf_space_quantization_step)
    --path-sgd-zipf-space-quantization-step $path_sgd_zipf_space_quantization_step
#end if
#if str($path_sgd_snapshot)
    --path-sgd-snapshot '$path_sgd_snapshot'
#end if
@THREADS@
    ]]></command>
    <inputs>
        <expand macro="graph_input_param"/>
        <param argument="--tsv" type="boolean" truevalue="--tsv" falsevalue="" checked="false" label="Export TSV layout alongside binary layout"/>
        <param argument="--path-index" type="data" format="txt" optional="true" label="Precomputed path index (.xp)"/>
        <param argument="--path-sgd-use-paths" type="data" format="txt" optional="true" label="Paths to sample for PG-SGD"/>
        <param argument="--layout-initialization" type="select" optional="true" label="Layout initialization mode">
            <option value="d" selected="true">Node rank in X, Gaussian noise in Y (default)</option>
            <option value="r">Uniform noise in X and Y</option>
            <option value="u">Node rank in X, uniform noise in Y</option>
            <option value="g">Gaussian noise in X and Y</option>
            <option value="h">Hilbert curve initialization</option>
        </param>
        <param argument="--path-sgd-min-term-updates-paths" type="float" optional="true" min="0" label="Minimum term updates (paths multiple)"/>
        <param argument="--path-sgd-min-term-updates-nodes" type="float" optional="true" min="0" label="Minimum term updates (nodes multiple)"/>
        <param argument="--path-sgd-delta" type="float" optional="true" min="0" label="Maximum displacement threshold (bp)"/>
        <param argument="--path-sgd-eta" type="float" optional="true" min="0" label="Final learning rate"/>
        <param argument="--path-sgd-eta-max" type="float" optional="true" min="0" label="Initial learning rate"/>
        <param argument="--path-sgd-iter-max" type="integer" optional="true" min="1" label="Maximum PG-SGD iterations"/>
        <param argument="--path-sgd-iteration-max-learning-rate" type="integer" optional="true" min="0" label="Iteration where learning rate peaks"/>
        <param argument="--path-sgd-zipf-theta" type="float" optional="true" label="Zipf theta"/>
        <param argument="--path-sgd-zipf-space" type="integer" optional="true" min="1" label="Zipf space size"/>
        <param argument="--path-sgd-zipf-space-max" type="integer" optional="true" min="1" label="Zipf space max before quantization"/>
        <param argument="--path-sgd-zipf-space-quantization-step" type="integer" optional="true" min="1" label="Zipf quantization step size"/>
        <param argument="--path-sgd-snapshot" type="text" optional="true" label="Snapshot prefix for intermediate layouts"/>
    </inputs>
    <outputs>
        <data name="layout_output" format="binary" label="${tool.name} on ${on_string}"/>
        <data name="layout_tsv" format="tabular" label="${tool.name} on ${on_string}: coordinates">
            <filter>tsv</filter>
        </data>
    </outputs>
    <tests/>
    <help format="markdown"><![CDATA[
@HELP_HEADER@

`odgi layout` computes 2D coordinates for ODGI graphs using path-guided stochastic gradient descent (PG-SGD).
The binary `.lay` output can be fed into visualization or downstream statistics; optionally export a TSV table of node coordinates.

### Inputs

- **Input odgi graph**: Sorted, id-compacted graph to lay out.
- **Export TSV layout alongside binary layout**: Produce a human-readable coordinate table as well as the binary `.lay`.
- **Precomputed path index**: Reuse a `.xp` index to accelerate layout.
- **Layout initialization mode**: Choose how the initial coordinates are seeded.
- **PG-SGD parameters**: Min term updates, learning rates, iteration cap, and Zipf sampling controls fine-tune convergence.
- **Snapshot prefix**: Write intermediate layouts for debugging or animation.

### Outputs

- **Binary**: Primary `.lay` file containing node coordinates.
- **coordinates**: Optional TSV with node ID, X, Y triples.
    ]]></help>
    <expand macro="citations"/>
</tool>
