<tool id="scanpy_remove_confounders" name="Remove confounders with scanpy" version="@version@">
    <description></description>
    <macros>
        <import>macros.xml</import>
        <xml name="score_genes_params">
            <param argument="n_bins" type="integer" value="25" label="Number of expression level bins for sampling" help=""/>
            <param argument="random_state" type="integer" value="0" label="Random seed for sampling" help=""/>
            <expand macro="param_use_raw"/>
        </xml>
        <token name="@CMD_score_genes_inputs@"><![CDATA[
    n_bins=$method.n_bins,
    random_state=$method.random_state,
    use_raw=$method.use_raw,
    copy=False
        ]]></token>
    </macros>
    <expand macro="requirements"/>
    <command detect_errors="exit_code"><![CDATA[
@CMD@
      ]]></command>
    <configfiles>
        <configfile name="script_file"><![CDATA[
@CMD_imports@
@CMD_read_inputs@

#if $method.method == "pp.regress_out"
sc.pp.regress_out(
   adata=adata,
   #set $keys = [str(x.strip()) for x in str($method.reg_keys).split(',')]
   keys=$keys,
   copy=False)

#else if $method.method == "pp.mnn_correct"
    #for i, filepath in enumerate($methods.extra_adata)
adata_$i = ad.read('$filepath')
    #end for

sc.pp.mnn_correct(
    adata,
    #for i, filepath in enumerate($methods.extra_adata)
    adata_$i,
    #end for
    #if str($methods.var_subset) != ''
    #set $var_subset=([x.strip() for x in str($method.var_subset).split(',')])
    var_subset=$var_subset,
    #end if
    batch_key='$method.batch_key',
    index_unique='$method.index_unique'
    #if str($methods.batch_categories) != ''
    #set $batch_categories=([x.strip() for x in str($method.batch_categories).split(',')])
    batch_categories=$batch_categories,
    #end if
    k=$method.k,
    sigma=$method.sigma,
    cos_norm_in=$method.cos_norm_in,
    cos_norm_out=$method.cos_norm_out,
    svd_dim=$method.svd_dim,
    var_adj=$method.var_adj,
    compute_angle=$method.compute_angle,
    mnn_order='$method.mnn_order',
    svd_mode='$method.svd_mode',
    do_concatenate=True,
    save_raw=True,
    n_jobs=\${GALAXY_SLOTS:-4})

#else if $method.method == "pp.calculate_qc_metrics"
sc.pp.calculate_qc_metrics(
    adata=adata,
    expr_type='$method.expr_type',
    var_type='$method.var_type',
    #if str($method.qc_vars) != ''
        #set $qc_vars = [str(x.strip()) for x in str($method.qc_vars).split(',')]
        qc_vars=$qc_vars,
    #end if
    #if str($method.percent_top) != ''
        #set $percent_top = [int(x.strip()) for x in str($method.percent_top).split(',')]
        percent_top=$method.percent_top,
    #end if
    inplace=True)
adata.obs.to_csv('$obs', sep='\t')

#else if $method.method == "tl.score_genes"
sc.tl.score_genes(
    adata=adata,
    #set $gene_list = [str(x.strip()) for x in str($method.gene_list).split(',')]
    gene_list=$gene_list,
    ctrl_size=$method.ctrl_size,
    score_name='$method.score_name',
    #if $method.gene_pool
        #set $gene_pool = [str(x.strip()) for x in $method.gene_pool.split(',')]
    gene_pool=$gene_pool,
    #end if
    @CMD_score_genes_inputs@)

#else if $method.method == "tl.score_genes_cell_cycle"
    #if str($method.s_genes.format) == 'file'
with open('$method.s_genes.file', 'r') as s_genes_f:
    s_genes = [str(x.strip()) for x in s_genes_f.readlines()]
print(s_genes)
    #end if

    #if str($method.g2m_genes.format) == 'file'
with open('$method.g2m_genes.file', 'r') as g2m_genes_f:
    g2m_genes = [str(x.strip()) for x in g2m_genes_f.readlines()]
print(g2m_genes)
    #end if

sc.tl.score_genes_cell_cycle(
    adata=adata,
    #if str($method.s_genes.format) == 'text'
        #set $s_genes = [str(x.strip()) for x in $method.s_genes.text.split(',')]
    s_genes=$s_genes,
    #else if str($method.s_genes.format) == 'file'
    s_genes=s_genes,
    #end if
    #if str($method.g2m_genes.format) == 'text'
        #set $g2m_genes = [str(x.strip()) for x in $method.g2m_genes.text.split(',')]
    g2m_genes=$g2m_genes,
    #else if str($method.g2m_genes.format) == 'file'
    g2m_genes=g2m_genes,
    #end if
    @CMD_score_genes_inputs@)
#end if

@CMD_anndata_write_outputs@
]]></configfile>
    </configfiles>
    <inputs>
        <expand macro="inputs_anndata"/>
        <conditional name="method">
            <param argument="method" type="select" label="Method used for plotting">
                <option value="pp.regress_out">Regress out unwanted sources of variation, using `pp.regress_out`</option>
                <option value="pp.mnn_correct">Correct batch effects by matching mutual nearest neighbors, using `pp.mnn_correct`</option>
                <!--<option value="pp.dca">, using `pp.mnn_correct`</option>!-->
                <!--<option value="pp.magic">, using `pp.magic`</option>!-->
                <!--<option value="tl.sim">, using `tl.sim`</option>!-->
                <option value="pp.calculate_qc_metrics">Calculate quality control metrics, using `pp.calculate_qc_metrics`</option>
                <option value="tl.score_genes">Score a set of genes, using `tl.score_genes`</option>
                <option value="tl.score_genes_cell_cycle">Score cell cycle genes, using `tl.score_genes_cell_cycle`</option>
                <!--<option value="tl.cyclone">, using `tl.cyclone`</option>!-->
                <!--<option value="tl.andbag">, using `tl.andbag`</option>!-->
            </param>
            <when value="pp.regress_out">
                <param argument="reg_keys" type="text" value="" label="Keys for observation annotation on which to regress on" help="Keys separated by a comma"/>
            </when>
            <when value="pp.mnn_correct">
                <param name="extra_adata" type="data" multiple="true" optional="true" format="h5ad" label="Extra annotated data matrix" help="They should have same number of variables."/>
                <param argument="var_subset" type="text" value="" optional="true" label="The subset of vars to be used when performing MNN correction" help="List of comma-separated key from `.var_names`. If not set, all vars are used"/>
                <param argument="batch_key" type="text" value="batch" label="Batch key for the concatenate"/>
                <param name="index_unique" type="select" label="Separator to join the existing index names with the batch category" help="Leave it empty to keep existing indices">
                    <option value="-">-</option>
                    <option value="_">_</option>
                    <option value=" "> </option>
                    <option value="/">/</option>
                </param>
                <param argument="batch_categories" type="text" value="" optional="true" label="Batch categories for the concatenate" help="List of comma-separated key"/>
                <param argument="k" type="integer" value="20" label="Number of mutual nearest neighbors"/>
                <param argument="sigma" type="float" value="1" label="The bandwidth of the Gaussian smoothing kernel used to compute the correction vectors"/>
                <param argument="cos_norm_in" type="boolean" truevalue="True" falsevalue="False" checked="true" label="Should cosine normalization be performed on the input data prior to calculating distances between cells?"/>
                <param argument="cos_norm_out" type="boolean" truevalue="True" falsevalue="False" checked="true" label="Should cosine normalization be performed prior to computing corrected expression values?"/>
                <param argument="svd_dim" type="integer" value="" optional="true" label="Number of dimensions to use for summarizing biological substructure within each batch" help="If not set, biological components will not be removed from the correction vectors."/>
                <param argument="var_adj" type="boolean" truevalue="True" falsevalue="False" checked="true" label="Adjust variance of the correction vectors?" help="This step takes most computing time."/>
                <param argument="compute_angle" type="boolean" truevalue="True" falsevalue="False" checked="false" label="compute the angle between each cellâ€™s correction vector and the biological subspace of the reference batch?"/>
                <param argument="mnn_order" type="text" value="" optional="true" label="The order in which batches are to be corrected" help="List of comma-separated key. If not set, datas are corrected sequentially"/>
                <param name="svd_mode" type="select" label="SVD mode">
                    <option value="svd">svd: SVD using a non-randomized SVD-via-ID algorithm</option>
                    <option value="rsvd" selected="true">rsvd: SVD using a randomized SVD-via-ID algorithm</option>
                    <option value="irlb">irlb: truncated SVD by implicitly restarted Lanczos bidiagonalization</option>
                </param>
            </when>
            <when value="pp.calculate_qc_metrics">
                <param argument="expr_type" type="text" value="counts" label="Name of kind of values in X"/>
                <param argument="var_type" type="text" value="genes" label="The kind of thing the variables are"/>
                <param argument="qc_vars" type="text" value="" label="Keys for boolean columns of `.var` which identify variables you could want to control for" 
                    help="Keys separated by a comma"/>
                <param argument="percent_top" type="text" value="" label="Which proportions of top genes to cover." 
                    help=" Values (integers) are considered 1-indexed, `50` finds cumulative proportion to the 50th most expressed genes. Values separated by a comma. 
                    If empty don't calculate"/>
            </when>
            <when value="tl.score_genes">
                <param argument="gene_list" type="text" value="" label="The list of gene names used for score calculation" help="Genes separated by a comma"/>
                <param argument="ctrl_size" type="integer" value="50" label="Number of reference genes to be sampled"
                    help="If `len(gene_list)` is not too low, you can set `ctrl_size=len(gene_list)`."/>
                <param argument="gene_pool" type="text" value="" optional="true" label="Genes for sampling the reference set"
                    help="Default is all genes. Genes separated by a comma"/>
                <expand macro="score_genes_params"/>
                <param argument="score_name" type="text" value="score" label="Name of the field to be added in `.obs`" help=""/>
            </when>
            <when value="tl.score_genes_cell_cycle">
                <conditional name='s_genes'>
                    <param name="format" type="select" label="Format for the list of genes associated with S phase">
                        <option value="file">File</option>
                        <option value="text" selected="true">Text</option>
                    </param>
                    <when value="text">
                        <param name="text" type="text" value="" label="List of genes associated with S phase" help="Genes separated by a comma"/>
                    </when>
                    <when value="file">
                        <param name="file" type="data" format="txt" label="File with the list of genes associated with S phase" help="One gene per line"/>
                    </when>
                </conditional>
                <conditional name='g2m_genes'>
                    <param name="format" type="select" label="Format for the list of genes associated with G2M phase">
                        <option value="file">File</option>
                        <option value="text" selected="true">Text</option>
                    </param>
                    <when value="text">
                        <param name="text" type="text" value="" label="List of genes associated with G2M phase" help="Genes separated by a comma"/>
                    </when>
                    <when value="file">
                        <param name="file" type="data" format="txt" label="File with the list of genes associated with G2M phase" help="One gene per line"/>
                    </when>
                </conditional>
                <expand macro="score_genes_params"/>
            </when>
        </conditional>
    </inputs>
    <outputs>
        <expand macro="anndata_outputs"/>
    </outputs>
    <tests>
        <test>
            <param name="adata" value="krumsiek11.h5ad" />
            <conditional name="method">
                <param name="method" value="pp.regress_out"/>
                <param name="reg_keys" value="cell_type"/>
            </conditional>
            <assert_stdout>
                <has_text_matching expression="sc.pp.regress_out"/>
                <has_text_matching expression="keys='cell_type'"/>
            </assert_stdout>
            <output name="anndata_out" file="pp.regress_out.krumsiek11.h5ad" ftype="h5ad" compare="sim_size"/>
        </test>
        <test>
            <param name="adata" value="krumsiek11.h5ad" />
            <conditional name="method">
                <param name="method" value="pp.mnn_correct"/>
                <param name="reg_keys" value="cell_type"/>
            </conditional>
            <assert_stdout>
                <has_text_matching expression="sc.pp.mnn_correct"/>
                <has_text_matching expression="keys='cell_type'"/>
            </assert_stdout>
            <output name="anndata_out" file="pp.mnn_correct.krumsiek11.h5ad" ftype="h5ad" compare="sim_size"/>
        </test>
        <test>
            <param name="adata" value="krumsiek11.h5ad" />
            <conditional name="method">
                <param name="method" value="pp.calculate_qc_metrics"/>
                <param name="expr_type" value="counts"/>
                <param name="var_type" value="genes"/>
                <param name="qc_vars" value="mito"/>
                <param name="percent_top" value=""/>
            </conditional>
            <assert_stdout>
                <has_text_matching expression="sc.pp.calculate_qc_metrics" />
                <has_text_matching expression="expr_type='counts'" />
                <has_text_matching expression="var_type='genes'" />
                <has_text_matching expression="qc_vars=\['qc_vars'\]" />
                <has_text_matching expression="percent_top=\[\]'" />
            </assert_stdout>
            <output name="anndata_out" file="pp.calculate_qc_metrics.krumsiek11.h5ad" ftype="h5ad" compare="sim_size"/>
        </test>
        <test>
            <param name="adata" value="krumsiek11.h5ad" />
            <conditional name="method">
                <param name="method" value="tl.score_genes"/>
                <param name="gene_list" value="Gata2, Fog1"/>
                <param name="ctrl_size" value="2"/>
                <param name="n_bins" value="2"/>
                <param name="random_state" value="2"/>
                <param name="use_raw" value="False"/>
                <param name="score_name" value="score"/>
            </conditional>
            <assert_stdout>
                <has_text_matching expression="sc.tl.score_genes" />
                <has_text_matching expression="gene_list=\['Gata2', 'Fog1'\]" />
                <has_text_matching expression="ctrl_size=2" />
                <has_text_matching expression="score_name='score'" />
                <has_text_matching expression="n_bins=2" />
                <has_text_matching expression="random_state=2" />
                <has_text_matching expression="use_raw=False" />
                <has_text_matching expression="copy=False" />
            </assert_stdout>
            <output name="anndata_out" file="tl.score_genes.krumsiek11.h5ad" ftype="h5ad" compare="sim_size"/>
        </test>
        <test>
            <param name="adata" value="krumsiek11.h5ad" />
            <conditional name="method">
                <param name="method" value="tl.score_genes_cell_cycle"/>
                <param name="s_genes" value="Gata2, Fog1, EgrNab"/>
                <param name="g2m_genes" value="Gata2, Fog1, EgrNab"/>
                <param name="n_bins" value="2"/>
                <param name="random_state" value="1"/>
                <param name="use_raw" value="False"/>
            </conditional>
            <assert_stdout>
                <has_text_matching expression="sc.tl.score_genes_cell_cycle"/>
                <has_text_matching expression="s_genes=\['Gata2', 'Fog1', 'EgrNab'\]"/>
                <has_text_matching expression="g2m_genes=\['Gata2', 'Fog1', 'EgrNab'\]"/>
                <has_text_matching expression="n_bins=2"/>
                <has_text_matching expression="random_state=1"/>
                <has_text_matching expression="use_raw=False"/>
            </assert_stdout>
            <output name="anndata_out" file="tl.score_genes_cell_cycle.krumsiek11.h5ad" ftype="h5ad" compare="sim_size"/>
        </test>
    </tests>
    <help><![CDATA[
Regress out unwanted sources of variation, using `pp.regress_out`
=================================================================

Regress out unwanted sources of variation, using simple linear regression. This is 
inspired by Seurat's `regressOut` function in R.

More details on the `scanpy documentation
<https://icb-scanpy.readthedocs-hosted.com/en/stable/api/scanpy.pp.regress_out.html>`__

Correct batch effects by matching mutual nearest neighbors, using `pp.mnn_correct`
==================================================================================

This uses the implementation of mnnpy. Depending on do_concatenate, it returns AnnData objects in the 
original order containing corrected expression values or a concatenated matrix or AnnData object.

Be reminded that it is not advised to use the corrected data matrices for differential expression testing.

More details on the `scanpy documentation
<https://icb-scanpy.readthedocs-hosted.com/en/stable/api/scanpy.api.pp.mnn_correct.html>`__

Calculate quality control metrics., using `pp.calculate_qc_metrics`
===================================================================

Calculates a number of qc metrics for an AnnData object, largely based on calculateQCMetrics from scater. 
Currently is most efficient on a sparse CSR or dense matrix.

It updates the observation level metrics:

- total_{var_type}_by_{expr_type} (e.g. "total_genes_by_counts", number of genes with positive counts in a cell)
- total_{expr_type} (e.g. "total_counts", total number of counts for a cell)
- pct_{expr_type}_in_top_{n}_{var_type} (e.g. "pct_counts_in_top_50_genes", cumulative percentage of counts for 50 most expressed genes in a cell)
- total_{expr_type}_{qc_var} (e.g. "total_counts_mito", total number of counts for variabes in qc_vars )
- pct_{expr_type}_{qc_var} (e.g. "pct_counts_mito", proportion of total counts for a cell which are mitochondrial)

And also the variable level metrics:

- total_{expr_type} (e.g. "total_counts", sum of counts for a gene)
- mean_{expr_type} (e.g. "mean counts", mean expression over all cells.
- n_cells_by_{expr_type} (e.g. "n_cells_by_counts", number of cells this expression is measured in)
- pct_dropout_by_{expr_type} (e.g. "pct_dropout_by_counts", percentage of cells this feature does not appear in)

More details on the `scanpy documentation
<https://icb-scanpy.readthedocs-hosted.com/en/stable/api/scanpy.pp.calculate_qc_metrics.html>`__

Score a set of genes, using `tl.score_genes`
============================================

The score is the average expression of a set of genes subtracted with the
average expression of a reference set of genes. The reference set is
randomly sampled from the `gene_pool` for each binned expression value.

This reproduces the approach in Seurat (Satija et al, 2015) and has been implemented
for Scanpy by Davide Cittaro.

More details on the `scanpy documentation
<https://icb-scanpy.readthedocs-hosted.com/en/stable/api/scanpy.tl.score_genes.html>`__

Score cell cycle genes, using `tl.score_genes_cell_cycle`
=========================================================

Given two lists of genes associated to S phase and G2M phase, calculates
scores and assigns a cell cycle phase (G1, S or G2M). See
`score_genes` for more explanation.

More details on the `scanpy documentation
<https://icb-scanpy.readthedocs-hosted.com/en/stable/api/scanpy.tl.score_genes_cell_cycle.html>`__
    ]]></help>
    <expand macro="citations"/>
</tool>
