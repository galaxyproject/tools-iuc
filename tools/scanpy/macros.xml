<macros>
    <token name="@TOOL_VERSION@">1.11.5</token>
    <token name="@VERSION_SUFFIX@">0</token>
    <token name="@PROFILE@">21.09</token>
    <xml name="requirements">
        <requirements>
            <requirement type="package" version="@TOOL_VERSION@">scanpy</requirement>
            <requirement type="package" version="0.4">fa2_modified</requirement>
            <yield />
        </requirements>
    </xml>
    <xml name="bio_tools">
        <xrefs>
            <xref type="bio.tools">scanpy</xref>
        </xrefs>
    </xml>
    <xml name="creators">
        <creator>
            <organization name="European Galaxy Team" url="https://galaxyproject.org/eu/"/>
        </creator>
    </xml>
    <xml name="citations">
        <citations>
            <citation type="doi">10.1186/s13059-017-1382-0</citation>
            <citation type="doi">10.1016/j.xgen.2025.101005</citation>
            <citation type="doi">10.1093/gigascience/giaa102</citation>
        </citations>
    </xml>


    <!-- param macros -->
    <xml name="sanitize_query" token_validinitial="string.printable">
        <sanitizer>
            <valid initial="@VALIDINITIAL@">
                <remove value="&apos;"/>
            </valid>
       </sanitizer>
    </xml>
    <xml name="sanitize_vectors" token_validinitial="string.digits">
        <sanitizer>
            <valid initial="@VALIDINITIAL@">
                <add value=","/>
            </valid>
        </sanitizer>
    </xml>
    <xml name="inputs_anndata">
        <param name="adata" type="data" format="h5ad" label="Annotated data matrix"/>
    </xml>
    <xml name="inputs_common_advanced">
        <section name="advanced_common" title="Advanced Options" expanded="false">
            <param name="show_log" type="boolean" checked="false" label="Output Log?"/>
            <yield />
        </section>
    </xml>
    <xml name="anndata_outputs">
        <data name="anndata_out" format="h5ad" from_work_dir="anndata.h5ad" label="${tool.name} (${method.method}) on ${on_string}: Annotated data matrix">
            <yield />
        </data>
        <data name="hidden_output" format="txt" label="Log file" >
            <filter>advanced_common['show_log']</filter>
        </data>
    </xml>
    <xml name="param_use_rep">
        <param argument="use_rep" type="text" value="" optional="true" label="Use the indicated representation" help="If not set, the representation is chosen automatically: for n_vars below 50, X is used, otherwise X_pca (uns) is used. If X_pca is not present, it's computed with default parameter">
                <expand macro="sanitize_query"/>
        </param>
    </xml>
    <xml name="svd_solver">
        <param name="svd_solver" type="select" optional="true" label="SVD solver to use">
            <option value="auto">Automatically chosen depending on the size of the problem</option>
            <option value="arpack">ARPACK wrapper in SciPy</option>
            <option value="randomized">Randomized algorithm due to Halko (2009)</option>
            <option value="lobpcg">An alternative SciPy solver. Not available with dask arrays.</option>
            <option value="tsqr">Only available with dask arrays. “tsqr” algorithm from Benson et. al. (2013).</option>
        </param>
    </xml>
    <xml name="pca_random_state">
        <param name="random_state" type="integer" value="0" label="Initial states for the optimization"/>
    </xml>
    <xml name="param_plot_format">
        <param name="format" type="select" label="Format for saving figures">
            <option value="png" selected="true">png</option>
            <option value="pdf">pdf</option>
            <option value="svg">svg</option>
        </param>
    </xml>
    <xml name="numeric_distance_metric_options">
    	<option value="euclidean" selected="true">euclidean</option>
        <option value="braycurtis">braycurtis</option>
        <option value="canberra">canberra</option>
        <option value="chebyshev">chebyshev</option>
        <option value="cityblock">cityblock</option>
        <option value="correlation">correlation</option>
        <option value="cosine">cosine</option>
        <option value="mahalanobis">mahalanobis</option>
        <option value="matching">matching</option>
        <option value="minkowski">minkowski</option>
        <option value="seuclidean">seuclidean</option>
        <option value="sqeuclidean">sqeuclidean</option>
        <option value="wminkowski">wminkowski</option>
    </xml>
    <xml name="boolean_distance_metric_options">
        <option value="dice">dice</option>
        <option value="hamming">hamming</option>
        <option value="jaccard">jaccard</option>
        <option value="kulsinski">kulsinski</option>
        <option value="rogerstanimoto">rogerstanimoto</option>
        <option value="russellrao">russellrao</option>
        <option value="sokalmichener">sokalmichener</option>
        <option value="sokalsneath">sokalsneath</option>
        <option value="yule">yule</option>
    </xml>
    <xml name="distance_metric_options">
        <expand macro="numeric_distance_metric_options"/>
        <expand macro="boolean_distance_metric_options"/>
    </xml>
    <xml name="seaborn_color_palette_options">
        <option value="Accent">Accent</option>
        <option value="Accent_r">Accent_r</option>
        <option value="Blues">Blues</option>
        <option value="Blues_r">Blues_r</option>
        <option value="BrBG">BrBG</option>
        <option value="BrBG_r">BrBG_r</option>
        <option value="BuGn">BuGn</option>
        <option value="BuGn_r">BuGn_r</option>
        <option value="BuPu">BuPu</option>
        <option value="BuPu_r">BuPu_r</option>
        <option value="CMRmap">CMRmap</option>
        <option value="CMRmap_r">CMRmap_r</option>
        <option value="Dark2">Dark2</option>
        <option value="Dark2_r">Dark2_r</option>
        <option value="GnBu">GnBu</option>
        <option value="GnBu_r">GnBu_r</option>
        <option value="Greens">Greens</option>
        <option value="Greens_r">Greens_r</option>
        <option value="Greys">Greys</option>
        <option value="Greys_r">Greys_r</option>
        <option value="OrRd">OrRd</option>
        <option value="OrRd_r">OrRd_r</option>
        <option value="Oranges">Oranges</option>
        <option value="Oranges_r">Oranges_r</option>
        <option value="PRGn">PRGn</option>
        <option value="PRGn_r">PRGn_r</option>
        <option value="Paired">Paired</option>
        <option value="Paired_r">Paired_r</option>
        <option value="Pastel1">Pastel1</option>
        <option value="Pastel1_r">Pastel1_r</option>
        <option value="Pastel2">Pastel2</option>
        <option value="Pastel2_r">Pastel2_r</option>
        <option value="PiYG">PiYG</option>
        <option value="PiYG_r">PiYG_r</option>
        <option value="PuBu">PuBu</option>
        <option value="PuBuGn">PuBuGn</option>
        <option value="PuBuGn_r">PuBuGn_r</option>
        <option value="PuBu_r">PuBu_r</option>
        <option value="PuOr">PuOr</option>
        <option value="PuOr_r">PuOr_r</option>
        <option value="PuRd">PuRd</option>
        <option value="PuRd_r">PuRd_r</option>
        <option value="Purples">Purples</option>
        <option value="Purples_r">Purples_r</option>
        <option value="RdBu">RdBu</option>
        <option value="RdBu_r">RdBu_r</option>
        <option value="RdGy">RdGy</option>
        <option value="RdPu">RdPu</option>
        <option value="RdPu_r">RdPu_r</option>
        <option value="RdYlBu">RdYlBu</option>
        <option value="RdYlBu_r">RdYlBu_r</option>
        <option value="RdYlGn">RdYlGn</option>
        <option value="RdYlGn_r">RdYlGn_r</option>
        <option value="Reds">Reds</option>
        <option value="Reds_r">Reds_r</option>
        <option value="Set1">Set1</option>
        <option value="Set1_r">Set1_r</option>
        <option value="Set2">Set2</option>
        <option value="Set2_r">Set2_r</option>
        <option value="Set3">Set3</option>
        <option value="Set3_r">Set3_r</option>
        <option value="Spectral">Spectral</option>
        <option value="Spectral_r">Spectral_r</option>
        <option value="Wistia">Wistia</option>
        <option value="Wistia_r">Wistia_r</option>
        <option value="YlGn">YlGn</option>
        <option value="YlGn_r">YlGn_r</option>
        <option value="YlGnBu">YlGnBu</option>
        <option value="YlGnBu_r">YlGnBu_r</option>
        <option value="YlOrBr">YlOrBr</option>
        <option value="YlOrBr_r">YlOrBr_r</option>
        <option value="YlOrRd">YlOrRd</option>
        <option value="YlOrRd_r">YlOrRd_r</option>
        <option value="afmhot">afmhot</option>
        <option value="afmhot_r">afmhot_r</option>
        <option value="autumn">autumn</option>
        <option value="autumn_r">autumn_r</option>
        <option value="binary">binary</option>
        <option value="binary_r">binary_r</option>
        <option value="bone">bone</option>
        <option value="bone_r">bone_r</option>
        <option value="brg">brg</option>
        <option value="brg_r">brg_r</option>
        <option value="bwr">bwr</option>
        <option value="bwr_r">bwr_r</option>
        <option value="cividis">cividis</option>
        <option value="cividis_r">cividis_r</option>
        <option value="cool">cool</option>
        <option value="cool_r">cool_r</option>
        <option value="coolwarm">coolwarm</option>
        <option value="coolwarm_r">coolwarm_r</option>
        <option value="copper">copper</option>
        <option value="copper_r">copper_r</option>
        <option value="cubehelix">cubehelix</option>
        <option value="cubehelix_r">cubehelix_r</option>
        <option value="flag">flag</option>
        <option value="flag_r">flag_r</option>
        <option value="gist_earth">gist_earth</option>
        <option value="gist_earth_r">gist_earth_r</option>
        <option value="gist_gray">gist_gray</option>
        <option value="gist_gray_r">gist_gray_r</option>
        <option value="gist_heat">gist_heat</option>
        <option value="gist_heat_r">gist_heat_r</option>
        <option value="gist_ncar">gist_ncar</option>
        <option value="gist_ncar_r">gist_ncar_r</option>
        <option value="gist_rainbow">gist_rainbow</option>
        <option value="gist_rainbow_r">gist_rainbow_r</option>
        <option value="gist_stern">gist_stern</option>
        <option value="gist_stern_r">gist_stern_r</option>
        <option value="gist_yarg">gist_yarg</option>
        <option value="gist_yarg_r">gist_yarg_r</option>
        <option value="gnuplot">gnuplot</option>
        <option value="gnuplot_r">gnuplot_r</option>
        <option value="gnuplot2">gnuplot2</option>
        <option value="gnuplot2_r">gnuplot2_r</option>
        <option value="gray">gray</option>
        <option value="gray_r">gray_r</option>
        <option value="hot">hot</option>
        <option value="hot_r">hot_r</option>
        <option value="hsv">hsv</option>
        <option value="hsv_r">hsv_r</option>
        <option value="icefire">icefire</option>
        <option value="icefire_r">icefire_r</option>
        <option value="inferno">inferno</option>
        <option value="inferno_r">inferno_r</option>
        <option value="jet">jet</option>
        <option value="jet_r">jet_r</option>
        <option value="magma">magma</option>
        <option value="magma_r">magma_r</option>
        <option value="mako">mako</option>
        <option value="mako_r">mako_r</option>
        <option value="nipy_spectral">nipy_spectral</option>
        <option value="nipy_spectral_r">nipy_spectral_r</option>
        <option value="ocean">ocean</option>
        <option value="ocean_r">ocean_r</option>
        <option value="pink">pink</option>
        <option value="pink_r">pink_r</option>
        <option value="plasma">plasma</option>
        <option value="plasma_r">plasma_r</option>
        <option value="prism">prism</option>
        <option value="prism_r">prism_r</option>
        <option value="rainbow">rainbow</option>
        <option value="rainbow_r">rainbow_r</option>
        <option value="rocket">rocket</option>
        <option value="rocket_r">rocket_r</option>
        <option value="seismic">seismic</option>
        <option value="seismic_r">seismic_r</option>
        <option value="spring">spring</option>
        <option value="spring_r">spring_r</option>
        <option value="summer">summer</option>
        <option value="summer_r">summer_r</option>
        <option value="tab10">tab10</option>
        <option value="tab10_r">tab10_r</option>
        <option value="tab20">tab20</option>
        <option value="tab20_r">tab20_r</option>
        <option value="tab20b">tab20b</option>
        <option value="tab20b_r">tab20b_r</option>
        <option value="tab20c">tab20c</option>
        <option value="tab20c_r">tab20c_r</option>
        <option value="terrain">terrain</option>
        <option value="terrain_r">terrain_r</option>
        <option value="twilight">twilight</option>
        <option value="twilight_r">twilight_r</option>
        <option value="twilight_shifted">twilight_shifted</option>
        <option value="twilight_shifted_r">twilight_shifted_r</option>
        <option value="viridis">viridis</option>
        <option value="viridis_r">viridis_r</option>
        <option value="vlag">vlag</option>
        <option value="vlag_r">vlag_r</option>
        <option value="winter">winter</option>
        <option value="winter_r">winter_r</option>
    </xml>
    <xml name="matplotlib_pyplot_colormap">
        <option value="viridis">viridis (Perceptually Uniform Sequential)</option>
        <option value="plasma">plasma (Perceptually Uniform Sequential)</option>
        <option value="inferno">inferno (Perceptually Uniform Sequential)</option>
        <option value="magma">magma (Perceptually Uniform Sequential)</option>
        <option value="cividis">cividis (Perceptually Uniform Sequential)</option>
        <option value="Greys">Greys (Sequential)</option>
        <option value="Purples">Purples (Sequential)</option>
        <option value="Blues">Blues (Sequential)</option>
        <option value="Greens">Greens (Sequential)</option>
        <option value="Oranges">Oranges (Sequential)</option>
        <option value="Reds">Reds (Sequential)</option>
        <option value="YlOrBr">YlOrBr (Sequential)</option>
        <option value="YlOrRd">YlOrRd (Sequential)</option>
        <option value="OrRd">OrRd (Sequential)</option>
        <option value="PuRd">PuRd (Sequential)</option>
        <option value="RdPu">RdPu (Sequential)</option>
        <option value="BuPu">BuPu (Sequential)</option>
        <option value="GnBu">GnBu (Sequential)</option>
        <option value="PuBu">PuBu (Sequential)</option>
        <option value="YlGnBu">YlGnBu (Sequential)</option>
        <option value="PuBuGn">PuBuGn (Sequential)</option>
        <option value="BuGn">BuGn (Sequential)</option>
        <option value="YlGn">YlGn (Sequential)</option>
        <option value="binary">binary (Sequential 2)</option>
        <option value="gist_yarg">gist_yarg (Sequential 2)</option>
        <option value="gist_gray">gist_gray (Sequential 2)</option>
        <option value="gray">gray (Sequential 2)</option>
        <option value="bone">bone (Sequential 2)</option>
        <option value="pink">pink (Sequential 2)</option>
        <option value="spring">spring (Sequential 2)</option>
        <option value="summer">summer (Sequential 2)</option>
        <option value="autumn">autumn (Sequential 2)</option>
        <option value="winter">winter (Sequential 2)</option>
        <option value="cool">cool (Sequential 2)</option>
        <option value="Wistia">Wistia (Sequential 2)</option>
        <option value="hot">hot (Sequential 2)</option>
        <option value="afmhot">afmhot (Sequential 2)</option>
        <option value="gist_heat">gist_heat (Sequential 2)</option>
        <option value="copper">copper (Sequential 2)</option>
        <option value="PiYG">PiYG (Diverging)</option>
        <option value="PRGn">PRGn (Diverging)</option>
        <option value="BrBG">BrBG (Diverging)</option>
        <option value="PuOr">PuOr (Diverging)</option>
        <option value="RdGy">RdGy (Diverging)</option>
        <option value="RdBu">RdBu (Diverging)</option>
        <option value="RdYlBu">RdYlBu (Diverging)</option>
        <option value="RdYlGn">RdYlGn (Diverging)</option>
        <option value="Spectral">Spectral (Diverging)</option>
        <option value="coolwarm">coolwarm (Diverging)</option>
        <option value="bwr">bwr (Diverging)</option>
        <option value="seismic">seismic (Diverging)</option>
        <option value="twilight">twilight (Cyclic)</option>
        <option value="twilight_shifted">twilight_shifted (Cyclic)</option>
        <option value="hsv">hsv (Cyclic)</option>
        <option value="Pastel1">Pastel1 (Qualitative)</option>
        <option value="Pastel2">Pastel2 (Qualitative)</option>
        <option value="Paired">Paired (Qualitative)</option>
        <option value="Accent">Accent (Qualitative)</option>
        <option value="Dark2">Dark2 (Qualitative)</option>
        <option value="Set1">Set1 (Qualitative)</option>
        <option value="Set2">Set2 (Qualitative)</option>
        <option value="Set3">Set3 (Qualitative)</option>
        <option value="tab10">tab10 (Qualitative)</option>
        <option value="tab20">tab20 (Qualitative)</option>
        <option value="tab20b">tab20b (Qualitative)</option>
        <option value="tab20c">tab20c (Qualitative)</option>
        <option value="flag">flag (Miscellaneous)</option>
        <option value="prism">prism (Miscellaneous)</option>
        <option value="ocean">ocean (Miscellaneous)</option>
        <option value="gist_earth">gist_earth (Miscellaneous)</option>
        <option value="terrain">terrain (Miscellaneous)</option>
        <option value="gist_stern">gist_stern (Miscellaneous)</option>
        <option value="gnuplot">gnuplot (Miscellaneous)</option>
        <option value="gnuplot2">gnuplot2 (Miscellaneous)</option>
        <option value="CMRmap">CMRmap (Miscellaneous)</option>
        <option value="cubehelix">cubehelix (Miscellaneous)</option>
        <option value="brg">brg (Miscellaneous)</option>
        <option value="gist_rainbow">gist_rainbow (Miscellaneous)</option>
        <option value="rainbow">rainbow (Miscellaneous)</option>
        <option value="jet">jet (Miscellaneous)</option>
        <option value="nipy_spectral">nipy_spectral (Miscellaneous)</option>
        <option value="gist_ncar">gist_ncar (Miscellaneous)</option>
    </xml>
    <xml name="matplotlib_color">
        <option value="AliceBlue">AliceBlue</option>
        <option value="AntiqueWhite">AntiqueWhite</option>
        <option value="Aqua">Aqua</option>
        <option value="Aquamarine">Aquamarine</option>
        <option value="Azure">Azure</option>
        <option value="Beige">Beige</option>
        <option value="Bisque">Bisque</option>
        <option value="Black">Black</option>
        <option value="BlanchedAlmond">BlanchedAlmond</option>
        <option value="Blue">Blue</option>
        <option value="BlueViolet">BlueViolet</option>
        <option value="Brown">Brown</option>
        <option value="BurlyWood">BurlyWood</option>
        <option value="CadetBlue">CadetBlue</option>
        <option value="Chartreuse">Chartreuse</option>
        <option value="Chocolate">Chocolate</option>
        <option value="Coral">Coral</option>
        <option value="CornflowerBlue">CornflowerBlue</option>
        <option value="Cornsilk">Cornsilk</option>
        <option value="Crimson">Crimson</option>
        <option value="Cyan">Cyan</option>
        <option value="DarkBlue">DarkBlue</option>
        <option value="DarkCyan">DarkCyan</option>
        <option value="DarkGoldenRod">DarkGoldenRod</option>
        <option value="DarkGray">DarkGray</option>
        <option value="DarkGrey">DarkGrey</option>
        <option value="DarkGreen">DarkGreen</option>
        <option value="DarkKhaki">DarkKhaki</option>
        <option value="DarkMagenta">DarkMagenta</option>
        <option value="DarkOliveGreen">DarkOliveGreen</option>
        <option value="DarkOrange">DarkOrange</option>
        <option value="DarkOrchid">DarkOrchid</option>
        <option value="DarkRed">DarkRed</option>
        <option value="DarkSalmon">DarkSalmon</option>
        <option value="DarkSeaGreen">DarkSeaGreen</option>
        <option value="DarkSlateBlue">DarkSlateBlue</option>
        <option value="DarkSlateGray">DarkSlateGray</option>
        <option value="DarkSlateGrey">DarkSlateGrey</option>
        <option value="DarkTurquoise">DarkTurquoise</option>
        <option value="DarkViolet">DarkViolet</option>
        <option value="DeepPink">DeepPink</option>
        <option value="DeepSkyBlue">DeepSkyBlue</option>
        <option value="DimGray">DimGray</option>
        <option value="DimGrey">DimGrey</option>
        <option value="DodgerBlue">DodgerBlue</option>
        <option value="FireBrick">FireBrick</option>
        <option value="FloralWhite">FloralWhite</option>
        <option value="ForestGreen">ForestGreen</option>
        <option value="Fuchsia">Fuchsia</option>
        <option value="Gainsboro">Gainsboro</option>
        <option value="GhostWhite">GhostWhite</option>
        <option value="Gold">Gold</option>
        <option value="GoldenRod">GoldenRod</option>
        <option value="Gray">Gray</option>
        <option value="Grey">Grey</option>
        <option value="Green">Green</option>
        <option value="GreenYellow">GreenYellow</option>
        <option value="HoneyDew">HoneyDew</option>
        <option value="HotPink">HotPink</option>
        <option value="IndianRed">IndianRed</option>
        <option value="Indigo">Indigo</option>
        <option value="Ivory">Ivory</option>
        <option value="Khaki">Khaki</option>
        <option value="Lavender">Lavender</option>
        <option value="LavenderBlush">LavenderBlush</option>
        <option value="LawnGreen">LawnGreen</option>
        <option value="LemonChiffon">LemonChiffon</option>
        <option value="LightBlue">LightBlue</option>
        <option value="LightCoral">LightCoral</option>
        <option value="LightCyan">LightCyan</option>
        <option value="LightGoldenRodYellow">LightGoldenRodYellow</option>
        <option value="LightGray">LightGray</option>
        <option value="LightGrey">LightGrey</option>
        <option value="LightGreen">LightGreen</option>
        <option value="LightPink">LightPink</option>
        <option value="LightSalmon">LightSalmon</option>
        <option value="LightSeaGreen">LightSeaGreen</option>
        <option value="LightSkyBlue">LightSkyBlue</option>
        <option value="LightSlateGray">LightSlateGray</option>
        <option value="LightSlateGrey">LightSlateGrey</option>
        <option value="LightSteelBlue">LightSteelBlue</option>
        <option value="LightYellow">LightYellow</option>
        <option value="Lime">Lime</option>
        <option value="LimeGreen">LimeGreen</option>
        <option value="Linen">Linen</option>
        <option value="Magenta">Magenta</option>
        <option value="Maroon">Maroon</option>
        <option value="MediumAquaMarine">MediumAquaMarine</option>
        <option value="MediumBlue">MediumBlue</option>
        <option value="MediumOrchid">MediumOrchid</option>
        <option value="MediumPurple">MediumPurple</option>
        <option value="MediumSeaGreen">MediumSeaGreen</option>
        <option value="MediumSlateBlue">MediumSlateBlue</option>
        <option value="MediumSpringGreen">MediumSpringGreen</option>
        <option value="MediumTurquoise">MediumTurquoise</option>
        <option value="MediumVioletRed">MediumVioletRed</option>
        <option value="MidnightBlue">MidnightBlue</option>
        <option value="MintCream">MintCream</option>
        <option value="MistyRose">MistyRose</option>
        <option value="Moccasin">Moccasin</option>
        <option value="NavajoWhite">NavajoWhite</option>
        <option value="Navy">Navy</option>
        <option value="OldLace">OldLace</option>
        <option value="Olive">Olive</option>
        <option value="OliveDrab">OliveDrab</option>
        <option value="Orange">Orange</option>
        <option value="OrangeRed">OrangeRed</option>
        <option value="Orchid">Orchid</option>
        <option value="PaleGoldenRod">PaleGoldenRod</option>
        <option value="PaleGreen">PaleGreen</option>
        <option value="PaleTurquoise">PaleTurquoise</option>
        <option value="PaleVioletRed">PaleVioletRed</option>
        <option value="PapayaWhip">PapayaWhip</option>
        <option value="PeachPuff">PeachPuff</option>
        <option value="Peru">Peru</option>
        <option value="Pink">Pink</option>
        <option value="Plum">Plum</option>
        <option value="PowderBlue">PowderBlue</option>
        <option value="Purple">Purple</option>
        <option value="RebeccaPurple">RebeccaPurple</option>
        <option value="Red">Red</option>
        <option value="RosyBrown">RosyBrown</option>
        <option value="RoyalBlue">RoyalBlue</option>
        <option value="SaddleBrown">SaddleBrown</option>
        <option value="Salmon">Salmon</option>
        <option value="SandyBrown">SandyBrown</option>
        <option value="SeaGreen">SeaGreen</option>
        <option value="SeaShell">SeaShell</option>
        <option value="Sienna">Sienna</option>
        <option value="Silver">Silver</option>
        <option value="SkyBlue">SkyBlue</option>
        <option value="SlateBlue">SlateBlue</option>
        <option value="SlateGray">SlateGray</option>
        <option value="SlateGrey">SlateGrey</option>
        <option value="Snow">Snow</option>
        <option value="SpringGreen">SpringGreen</option>
        <option value="SteelBlue">SteelBlue</option>
        <option value="Tan">Tan</option>
        <option value="Teal">Teal</option>
        <option value="Thistle">Thistle</option>
        <option value="Tomato">Tomato</option>
        <option value="Turquoise">Turquoise</option>
        <option value="Violet">Violet</option>
        <option value="Wheat">Wheat</option>
        <option value="White">White</option>
        <option value="WhiteSmoke">WhiteSmoke</option>
        <option value="Yellow">Yellow</option>
        <option value="YellowGreen">YellowGreen</option>
    </xml>
    <xml name="param_matplotlib_pyplot_edgecolors">
        <param argument="edgecolors" type="select" optional="true" label="Edge color of the marker">
            <option value="face">The edge color will always be the same as the face color</option>
            <expand macro="matplotlib_color"/>
        </param>
    </xml>
    <xml name="param_swap_axes">
        <param argument="swap_axes" type="boolean" truevalue="True" falsevalue="False" checked="false" label="Swap axes?" help="By default, the x axis contains 'var_names' (e.g. genes) and the y axis the 'groupby' categories (if any). By setting 'swap_axes' then x are the 'groupby' categories and y the 'var_names'."/>
    </xml>
    <xml name="param_cmap">
        <param argument="cmap" type="select" optional="true" label="Colors to use for plotting categorical annotation groups">
            <expand macro="matplotlib_pyplot_colormap"/>
        </param>
    </xml>
    <xml name="param_sort_order">
        <param argument="sort_order" type="boolean" truevalue="True" falsevalue="False" checked="true" label="Sort order?" help="For continuous annotations used as color parameter, plot data points with higher values on top of others."/>
    </xml>
    <xml name="param_arrows">
        <param argument="arrows" type="boolean" truevalue="True" falsevalue="False" checked="false" label="Show arrows?" help="It requires to run 'tl.rna_velocity' before."/>
    </xml>
    <!-- param macros -->



    <!-- command macros -->
    <xml name="version_command">
        <version_command><![CDATA[python -c "import scanpy as sc;print('scanpy version: %s' % sc.__version__)"]]></version_command>
    </xml>
    <token name="@CMD_PRETTIFY_STDOUT@"><![CDATA[
| sed -r '1 s|AnnData object with (.+) = (.*)\s*|\1: \2|g' | sed "s|'||g"  | sed -r 's|^\s*(.*):\s(.*)|[\1]\n-    \2|g' | sed 's|, |\n-    |g'
    ]]>
    </token>
    <token name="@CMD_READ_INPUTS@"><![CDATA[
adata = sc.read_h5ad('anndata.h5ad')
    ]]>
    </token>
    <!-- ln -s doesn't work here because the output is overwritten to the same file -->
    <token name="@CMD@"><![CDATA[
cp '$adata' 'anndata.h5ad' &&
cat '$script_file' > '$hidden_output' &&
python '$script_file' >> '$hidden_output' &&
ls . >> '$hidden_output' &&
touch 'anndata_info.txt' &&
cat 'anndata_info.txt' @CMD_PRETTIFY_STDOUT@
    ]]>
    </token>
    <token name="@CMD_IMPORTS@"><![CDATA[
import scanpy as sc
import pandas as pd
import numpy as np
    ]]>
    </token>
    <token name="@CMD_ANNDATA_WRITE_OUTPUTS@"><![CDATA[
adata.write_h5ad('anndata.h5ad', compression='gzip')
with open('anndata_info.txt','w', encoding='utf-8') as ainfo:
    print(adata, file=ainfo)
    ]]>
    </token>
    <token name="@CMD_PARAM_PLOT_INPUTS@"><![CDATA[
    adata,
    save='.$format',
    ]]>
    </token>
    <token name="@CMD_SHOW_NONE@"><![CDATA[
    show=None
        ]]>
    </token>
    <token name="@CMD_VAR_NAMES_HEADER_CHECK@"><![CDATA[
header='infer'
#if $method.var_names.type == 'customfile' and $method.var_names.header == 'not_included' :
header=None
#end if
    ]]>
    </token>
    <token name="@CMD_PARAMS_VIOLIN_PLOTS@"><![CDATA[
    @CMD_CONDITIONAL_STRIPPLOT@
    multi_panel=$method.violin_plot.multi_panel.multi_panel,
#if $method.multi_panel.violin_plot.multi_panel == "True" and str($method.violin_plot.multi_panel.width) != '' and str($method.violin_plot.multi_panel.height) != ''
    figsize=($method.violin_plot.multi_panel.width, $method.violin_plot.multi_panel.height)
#end if
    density_norm='$method.violin_plot.density_norm',
    ]]>
    </token>
    <!-- command macros -->



    <!-- param and cmd macros -->
    <xml name="param_standard_scale">
        <param argument="standard_scale" type="select" label="Standardize a dimension between 0 and 1" help="Each variable or observation is subtracted by the minimum and divided each by its maximum.">
            <option value="None" selected="true">No standardization</option>
            <option value="var">Standardization on variable</option>
            <option value="obs">Standardization on observation</option>
        </param>
    </xml>
    <token name="@CMD_STANDARD_SCALE@"><![CDATA[
    #if str($method.standard_scale) != 'None':
    standard_scale='$method.standard_scale',
    #end if
    ]]>
    </token>

    <xml name="param_layer" token_optional="true" token_label="If provided, use adata.layers[layer] for expression values instead of adata.X." token_help="">
        <param argument="layer" type="text" value="" optional="@OPTIONAL@" label="@LABEL@">
            <expand macro="sanitize_query"/>
        </param>
    </xml>
    <token name="@CMD_PARAM_LAYER@"><![CDATA[
    #if str($method.layer) != '':
    layer='$method.layer',
    #end if
    ]]>
    </token>

    <xml name="param_neighbors_key">
        <param argument="neighbors_key" type="text" value="" label="Key to look for neighbors settings and connectivities" help="If not specified, looks .uns[‘neighbors’] for neighbors settings and .obsp[‘connectivities’] for connectivities (default storage places for pp.neighbors).">
            <expand macro="sanitize_query"/>
        </param>
    </xml>
    <token name="@CMD_PARAM_NEIGHBORS_KEY@"><![CDATA[
    #if $method.neighbors_key != ''
    neighbors_key='$method.neighbors_key',
    #end if
    ]]>
    </token>

    <xml name="pl_var_names">
        <conditional name="var_names">
            <param name="type" type="select" label="Variables to plot (columns of the heatmaps)" >
                <option value="all" selected="true">All variables in 'adata.var_names'</option>
                <option value="custom">Subset of variables in 'adata.var_names'</option>
                <option value="customfile">Subset of variables as a tabular file</option>
            </param>
            <when value="all"/>
            <when value="custom">
                <param argument="var_names" type="text" value="" label="List of variables to plot" help="They should be a valid subset of 'adata.var_names', and separated by comma">
                    <expand macro="sanitize_query"/>
                </param>
            </when>
            <when value="customfile">
                <param argument="var_names" type="data" format="tabular" label="List of variables to plot" help="This should be a tsv where row = group (e.g. celltypes) and columns = variables."></param>
                <param name="header" type="boolean" truevalue="included" falsevalue="not_included" checked="true" label="Header is included in the list of markers?"/>
            </when>
        </conditional>
    </xml>
    <xml name="param_groupby">
        <param argument="groupby" type="text" value="" optional="true" label="The key of the observation grouping to consider" help="If it is given, the plot is ordered by the respective group. It is expected that to be a categorical. If it is not a categorical observation, it would be subdivided into 'num_categories'.">
            <expand macro="sanitize_query"/>
        </param>
    </xml>
    <xml name="param_num_categories">
        <param argument="num_categories" type="integer" min="0" value="7" label="Number of categories" help="It is only used if groupby observation is not categorical. This value determines the number of groups into which the groupby observation should be subdivided."/>
    </xml>

    <xml name="params_inputs">
        <expand macro="pl_var_names"/>
        <expand macro="param_groupby"/>
        <expand macro="param_num_categories"/>
    </xml>
    <token name="@CMD_PARAMS_INPUTS@"><![CDATA[
    #if str($method.var_names.type) == 'custom':
    #set $var_names = ([x.strip() for x in str($method.var_names.var_names).split(',')])
    var_names=$var_names,
    #else if str($method.var_names.type) == 'customfile':
    var_names={key: [v for v in list(value.values()) if pd.notna(v)] for key, value in pd.read_csv('$var_names', sep='\t', index_col=0, header=header).to_dict(orient='index').items()},
    #else
    var_names=adata.var_names,
    #end if
    #if str($method.groupby) != '':
    groupby='$method.groupby',
    #end if
    num_categories=$method.num_categories,
    ]]>
    </token>

    <xml name="pl_figsize">
        <conditional name="figsize">
            <param name="custom" type="select" label="Custom figure size" >
                <option value="no" selected="true">No: the figure width is set based on the number of variable names and the height is set to 10.</option>
                <option value="yes">Yes</option>
            </param>
            <when value="yes">
                <param argument="width" type="integer" min="0" value="10" label="Figure width"/>
                <param argument="height" type="integer" min="0" value="10" label="Figure height"/>
            </when>
            <when value="no"/>
        </conditional>
    </xml>
    <token name="@CMD_PARAMS_FIGSIZE@"><![CDATA[
    #if $method.figsize.custom == 'yes':
        figsize=($method.figsize.width, $method.figsize.height),
    #end if
    ]]>
    </token>

    <xml name="param_log" token_checked="false">
        <param argument="log" type="boolean" truevalue="True" falsevalue="False" checked="@CHECKED@" label="Use the log of the values?"/>
    </xml>
    <xml name="param_use_raw" token_falsevalue="False">
        <param argument="use_raw" type="boolean" truevalue="True" falsevalue="@FALSEVALUE@" checked="false" label="Use 'raw' attribute of input if present"/>
    </xml>
    <xml name="param_dendrogram">
        <param argument="dendrogram" type="boolean" truevalue="True" falsevalue="False" checked="false" label="Compute and plot a dendrogram?" help="groupby categories are reordered accoring to the dendrogram order. If groups of var_names are set and those groups correspond to the groupby categories, those groups are also reordered. The ‘person’ method is used to compute the pairwise correlation between categories using all var_names in raw if use_raw is None, otherwise all adata.var_names are used. The linkage method used is complete."/>
    </xml>
    <xml name="pl_var_group_positions">
        <repeat name="var_group_positions" title="Group of variables to highlight" help="This will draw a 'bracket' on top of the plot between the given start and end positions. If a label is given, it will be added on top of the bracket. ">
            <param name="start" type="integer" min="0" value="" label="Start"/>
            <param name="end" type="integer" min="0" value="" label="End"/>
            <param argument="label" type="text" value="" label="Label">
                <expand macro="sanitize_query"/>
            </param>
        </repeat>
    </xml>
    <xml name="param_var_group_rotation">
        <param argument="var_group_rotation" type="float" value="" optional="true" label="Label rotation degrees" help="By default, labels larger than 4 characters are rotated 90 degrees"/>
    </xml>
    <xml name="params_plots">
        <expand macro="param_log"/>
        <expand macro="param_use_raw" falsevalue="None"/>
        <expand macro="param_dendrogram"/>
        <expand macro="pl_var_group_positions"/>
        <expand macro="param_var_group_rotation"/>
        <expand macro="pl_figsize"/>
        <expand macro="param_layer" optional="true" label="Name of the AnnData object layer that wants to be plotted" help="By default 'adata.raw.X' is plotted. If 'use_raw=False' is set, then 'adata.X' is plotted. If layer is set to a valid layer name, then the layer is plotted. layer takes precedence over 'use_raw'."/>
    </xml>
    <token name="@CMD_PARAMS_PLOTS@"><![CDATA[
    log=$method.log,
    use_raw=$method.use_raw,
    dendrogram=$method.dendrogram,
    #if len($method.var_group_positions) > 0:
        #set $var_group_positions=[]
        #set $var_group_labels=[]
        #for $i, $s in enumerate($method.var_group_positions)
            #silent $var_group_positions.append((int($s.start), int($s.end)))
            #silent $var_group_labels.append(str($s.label))
        #end for
    var_group_positions=$var_group_positions,
    var_group_labels=$var_group_labels,
    #end if
    #if str($method.var_group_rotation) != '':
        var_group_rotation=$method.var_group_rotation,
    #end if
    @CMD_PARAMS_FIGSIZE@
    @CMD_PARAM_LAYER@
    ]]>
    </token>

    <xml name="param_alpha">
        <param argument="alpha" type="float" value="" min="0" max="1" optional="true" label="Alpha blending value" help="Between 0 (transparent) and 1 (opaque)"/>
    </xml>
    <xml name="param_vmin" token_label="Minimum value to normalize luminance data" token_help="If not set, it is inferred from the data and other keyword arguments">
        <param argument="vmin" type="float" value="" optional="true" label="@LABEL@" help="@HELP@"/>
    </xml>
    <xml name="param_vmax" token_label="Maximum value to normalize luminance data" token_help="If not set, it is inferred from the data and other keyword arguments">
        <param argument="vmax" type="float" value="" optional="true" label="@LABEL@" help="@HELP@"/>
    </xml>
    <xml name="param_vcenter">
        <param argument="vcenter" type="float" value="" optional="true" label="The value representing the center of the color scale" help="Useful for diverging colormaps."/>
    </xml>
    <xml name="section_matplotlib_pyplot_scatter">
        <section name="matplotlib_pyplot_scatter" title="Parameters for matplotlib.pyplot.scatter">
            <expand macro="param_alpha"/>
            <expand macro="param_vmin"/>
            <expand macro="param_vmax"/>
            <param argument="linewidths" type="float" value="0" label="Linewidth of the marker edges"/>
            <expand macro="param_matplotlib_pyplot_edgecolors"/>
        </section>
    </xml>
    <token name="@CMD_SECTION_MATPLOTLIB_PYPLOT_SCATTER@"><![CDATA[
    #if str($method.matplotlib_pyplot_scatter.vmin) != '':
    vmin=$method.matplotlib_pyplot_scatter.vmin,
    #end if
    #if str($method.matplotlib_pyplot_scatter.vmax) != '':
    vmax=$method.matplotlib_pyplot_scatter.vmax,
    #end if
    #if str($method.matplotlib_pyplot_scatter.alpha) != '':
    alpha=$method.matplotlib_pyplot_scatter.alpha,
    #end if
    linewidth=$method.matplotlib_pyplot_scatter.linewidths,
    #if $method.matplotlib_pyplot_scatter.edgecolors:
    edgecolor='$method.matplotlib_pyplot_scatter.edgecolors',
    #end if
    ]]>
    </token>

    <xml name="params_pl_heatmap">
        <expand macro="param_swap_axes"/>
        <param argument="show_gene_labels" type="boolean" truevalue="True" falsevalue="False" checked="false" label="Show gene labels?" help="By default gene labels are shown when there are 50 or less genes. Otherwise the labels are removed."/>
        <expand macro="param_standard_scale"/>
        <section name="matplotlib_pyplot_imshow" title="Parameters for matplotlib.pyplot.imshow">
            <expand macro="param_cmap"/>
            <param name="interpolation" type="select" label="Interpolation method">
                <option value="None" selected="true">none</option>
                <option value="nearest">nearest</option>
                <option value="bilinear">bilinear</option>
                <option value="bicubic">bicubic</option>
                <option value="spline16">spline16</option>
                <option value="spline36">spline36</option>
                <option value="hanning">hanning</option>
                <option value="hamming">hamming</option>
                <option value="hermite">hermite</option>
                <option value="kaiser">kaiser</option>
                <option value="quadric">quadric</option>
                <option value="catrom">catrom</option>
                <option value="gaussian">gaussian</option>
                <option value="bessel">bessel</option>
                <option value="sinc">sinc</option>
                <option value="mitchell">mitchell</option>
                <option value="lanczos">lanczos</option>
            </param>
            <expand macro="param_alpha"/>
            <expand macro="param_vmin"/>
            <expand macro="param_vmax"/>
            <param name="origin" type="select" label="Place the [0,0] index of the array in the upper left or lower left corner of the axes" help=" The convention 'upper' is typically used for matrices and images.">
                <option value="upper" selected="true">Upper</option>
                <option value="lower">Lower</option>
            </param>
        </section>
    </xml>
    <token name="@CMD_PARAMS_PL_HEATMAP@"><![CDATA[
    swap_axes=$method.swap_axes,
    show_gene_labels=$method.show_gene_labels,
    @CMD_STANDARD_SCALE@
    #if $method.matplotlib_pyplot_imshow.cmap:
    cmap='$method.matplotlib_pyplot_imshow.cmap',
    #end if
    #if str($method.matplotlib_pyplot_imshow.interpolation) != 'None':
    interpolation='$method.matplotlib_pyplot_imshow.interpolation',
    #end if
    #if str($method.matplotlib_pyplot_imshow.alpha) != '':
    alpha=$method.matplotlib_pyplot_imshow.alpha,
    #end if
    #if str($method.matplotlib_pyplot_imshow.vmin) != '':
    vmin=$method.matplotlib_pyplot_imshow.vmin,
    #end if
    #if str($method.matplotlib_pyplot_imshow.vmax) != '':
    vmax=$method.matplotlib_pyplot_imshow.vmax,
    #end if
    origin='$method.matplotlib_pyplot_imshow.origin',
    ]]>
    </token>

    <xml name="params_pl_matrixplot">
        <expand macro="param_swap_axes"/>
        <section name="matplotlib_pyplot_pcolor" title="Parameters for matplotlib.pyplot.pcolor">
            <param argument="cmap" type="select" optional="true" label="Color palette">
                <expand macro="seaborn_color_palette_options"/>
            </param>
            <expand macro="param_matplotlib_pyplot_edgecolors"/>
            <expand macro="param_alpha"/>
            <param argument="snap" type="boolean" truevalue="True" falsevalue="False" checked="false" label="Snap the mesh to pixel boundaries?"/>
        </section>
        <expand macro="param_standard_scale"/>
        <expand macro="param_vmin" label="The value representing the lower limit of the color scale" help="Values smaller than vmin are plotted with the same color as vmin."/>
        <expand macro="param_vmax" label="The value representing the upper limit of the color scale" help="Values larger than vmax are plotted with the same color as vmax."/>
        <expand macro="param_vcenter"/>
    </xml>
    <token name="@CMD_PARAMS_PL_MATRIXPLOT@"><![CDATA[
    swap_axes=$method.swap_axes,
    #if $method.matplotlib_pyplot_pcolor.cmap:
    cmap='$method.matplotlib_pyplot_pcolor.cmap',
    #end if
    #if $method.matplotlib_pyplot_pcolor.edgecolors:
    edgecolor='$method.matplotlib_pyplot_pcolor.edgecolors',
    #end if
    #if str($method.matplotlib_pyplot_pcolor.alpha) != '':
    alpha=$method.matplotlib_pyplot_pcolor.alpha,
    #end if
    snap=$method.matplotlib_pyplot_pcolor.snap,
    #if str($method.vmin) != '':
    vmin=$method.vmin,
    #end if
    #if str($method.vmax) != '':
    vmax=$method.vmax,
    #end if
    #if str($method.vcenter) != '':
    vcenter=$method.vcenter,
    #end if
    @CMD_STANDARD_SCALE@
    ]]>
    </token>

    <xml name="conditional_stripplot">
        <conditional name="stripplot">
            <param argument="stripplot" type="select" label="Add a stripplot on top of the violin plot">
                <option value="True" selected="true">Yes</option>
                <option value="False">No</option>
            </param>
            <when value="True">
                <conditional name="jitter">
                    <param argument="jitter" type="select" label="Add a jitter to the stripplot">
                        <option value="True" selected="true">Yes</option>
                        <option value="False">No</option>
                    </param>
                    <when value="True">
                        <param argument="size" type="float" min="0" value="1" label="Size of the jitter points"/>
                    </when>
                    <when value="False"/>
                </conditional>
            </when>
            <when value="False"/>
        </conditional>
    </xml>
    <token name="@CMD_CONDITIONAL_STRIPPLOT@"><![CDATA[
    stripplot=$method.violin_plot.stripplot.stripplot,
#if str($method.violin_plot.stripplot.stripplot) == 'True':
    jitter=$method.violin_plot.stripplot.jitter.jitter,
    #if str($method.violin_plot.stripplot.jitter.jitter) == 'True':
    size=$method.violin_plot.stripplot.jitter.size,
    #end if
#end if
    ]]>
    </token>

    <xml name="params_seaborn_violinplot">
        <section name="seaborn_violinplot" title="Parameters for seaborn.violinplot">
            <param argument="bw_method" type="select" label="Name of a reference rule when computing the kernel bandwidth">
                <option value="scott" selected="true">scott</option>
                <option value="silverman">silverman</option>
            </param>
            <param argument="bw_adjust" type="float" value="1" label="Factor that scales the bandwidth to use more or less smoothing."/>
            <param argument="orient" type="select" optional="true" label="Orientation of the plot">
                <option value="v">vertical</option>
                <option value="h">horizontal</option>
            </param>
            <param argument="linewidth" type="float" value="" optional="true" label="Width of the gray lines that frame the plot elements"/>
            <param argument="color" type="select" optional="true" label="Color for all of the elements">
                <expand macro="matplotlib_color"/>
            </param>
            <param argument="saturation" type="float" value="0.75" min="0" max="1" label="Proportion of the original saturation to draw colors at"/>
        </section>
    </xml>
    <token name="@CMD_PARAMS_SEABORN_VIOLINPLOT@"><![CDATA[
    bw_method='$method.seaborn_violinplot.bw_method',
    bw_adjust=$method.seaborn_violinplot.bw_adjust,
    #if $method.seaborn_violinplot.orient:
    orient='$method.seaborn_violinplot.orient',
    #end if
    #if str($method.seaborn_violinplot.linewidth) != '':
    linewidth=$method.seaborn_violinplot.linewidth,
    #end if
    #if $method.seaborn_violinplot.color:
    color='$method.seaborn_violinplot.color',
    #end if
    saturation=$method.seaborn_violinplot.saturation,
    ]]></token>

    <xml name="param_color">
        <param argument="color" type="text" value="" optional="true" label="Keys for annotations of observations/cells or variables/genes" help="One or a list of comma-separated index or key from either '.obs' or '.var'">
            <expand macro="sanitize_query"/>
        </param>
    </xml>
    <token name="@CMD_PARAM_COLOR@"><![CDATA[
#if str($method.color) != '':
    #set $color = ([x.strip() for x in str($method.color).split(',')])
    color=$color,
#end if
    ]]>
    </token>

    <xml name="param_groups">
        <param argument="groups" type="text" value="" optional="true" label="Categorical observation annotations to plot" help="Comma-separated">
            <expand macro="sanitize_query"/>
        </param>
    </xml>
    <token name="@CMD_PARAM_GROUPS@"><![CDATA[
#if str($method.groups) != '':
    #set $groups=([x.strip() for x in str($method.groups).split(',')])
    groups=$groups,
#end if
    ]]>
    </token>


    <xml name="param_pl_components">
        <repeat name="components" title="Component">
            <param argument="axis1" type="text" value="1" label="X-Axis">
                <expand macro="sanitize_query"/>
            </param>
            <param argument="axis2" type="text" value="2" label="Y-Axis">
                <expand macro="sanitize_query"/>
            </param>
        </repeat>
    </xml>
    <token name="@CMD_PARAM_PL_COMPONENTS@"><![CDATA[
#if len($method.plot.components) > 0:
    #set $components=[]
    #for $i, $s in enumerate($method.plot.components)
        #silent $components.append(str($s.axis1) + ',' + str($s.axis2))
    #end for
    components=$components,
#end if
    ]]>
    </token>

    <xml name="param_legend_fontsize">
        <param argument="legend_fontsize" type="integer" optional="true" value="" label="Legend font size"/>
    </xml>
    <token name="@CMD_PARAM_LEGEND_FONTSIZE@"><![CDATA[
    #if str($method.plot.legend_fontsize) != '':
    legend_fontsize=$method.plot.legend_fontsize,
    #end if
    ]]>
    </token>

    <xml name="param_size">
        <param argument="size" type="float" optional="true" value="" label="Point size"/>
    </xml>
    <token name="@CMD_PARAM_SIZE@"><![CDATA[
    #if str($method.plot.size) != '':
    size=$method.plot.size,
    #end if
    ]]>
    </token>

    <xml name="param_title">
        <param argument="title" type="text" value="" optional="true" label="Title for panels" help="Titles must be separated by a comma">
            <expand macro="sanitize_query"/>
        </param>
    </xml>
    <token name="@CMD_PARAM_TITLE@"><![CDATA[
    #if str($method.plot.title) != '':
    title='$method.plot.title',
    #end if
    ]]>
    </token>

    <xml name="param_projection">
        <param argument="projection" type="select" label="Projection of plot">
            <option value="2d" selected="true">2d</option>
            <option value="3d">3d</option>
        </param>
    </xml>
    <xml name="param_legend_loc">
        <param argument="legend_loc" type="select" label="Location of legend">
            <yield />
            <option value="none">none</option>
            <option value="on data export">on data export</option>
            <option value="best">best</option>
            <option value="upper right">upper right</option>
            <option value="upper left">upper left</option>
            <option value="lower left">lower left</option>
            <option value="lower right">lower right</option>
            <option value="right">right</option>
            <option value="center left">center left</option>
            <option value="center right">center right</option>
            <option value="lower center">lower center</option>
            <option value="upper center">upper center</option>
            <option value="center">center</option>
        </param>
    </xml>
    <xml name="param_legend_fontweight">
        <param argument="legend_fontweight" type="select" label="Legend font weight">
            <option value="bold" selected="true">bold</option>
            <option value="normal">normal</option>
            <option value="light">light</option>
            <option value="medium">medium</option>
            <option value="semibold">semibold</option>
            <option value="heavy">heavy</option>
            <option value="black">black</option>
        </param>
    </xml>
    <xml name="param_color_map">
        <param argument="color_map" type="select" optional="true" label="Color map to use for continous variables">
            <expand macro="matplotlib_pyplot_colormap"/>
        </param>
    </xml>
    <xml name="param_palette">
        <param argument="palette" type="select" optional="true" label="Colors to use for plotting categorical annotation groups">
            <expand macro="matplotlib_pyplot_colormap"/>
        </param>
    </xml>
    <xml name="param_frameon">
        <param argument="frameon" type="boolean" truevalue="True" falsevalue="False" checked="true" label="Draw a frame around the scatter plot?"/>
    </xml>
    <xml name="param_ncols">
        <param argument="ncols" type="integer" min="0" value="4" label="Number of panels per row"/>
    </xml>
    <xml name="param_wspace">
        <param argument="wspace" type="float" min="0" value="0.1" label="Width of the space between multiple panels"/>
    </xml>
    <xml name="param_hspace">
        <param argument="hspace" type="float" min="0" value="0.25" label="Height of the space between multiple panels"/>
    </xml>

    <xml name="params_pl_attribute_section">
        <section name="plot" title="Plot attributes">
            <expand macro="param_pl_components"/>
            <expand macro="param_projection"/>
            <expand macro="param_legend_loc">
                <option value="right margin">right margin</option>
                <option value="on data">on data</option>
            </expand>
            <expand macro="param_legend_fontsize"/>
            <expand macro="param_legend_fontweight"/>
            <expand macro="param_size"/>
            <expand macro="param_color_map"/>
            <expand macro="param_palette"/>
            <expand macro="param_frameon"/>
            <expand macro="param_ncols"/>
            <expand macro="param_wspace"/>
            <expand macro="param_hspace"/>
            <expand macro="param_title"/>
        </section>
    </xml>
    <token name="@CMD_PARAMS_PL_ATTRIBUTE_SECTION@"><![CDATA[
    @CMD_PARAM_PL_COMPONENTS@
    projection='$method.plot.projection',
    #if str($method.plot.legend_loc) != '':
    legend_loc='$method.plot.legend_loc',
    #end if
    @CMD_PARAM_LEGEND_FONTSIZE@
    legend_fontweight='$method.plot.legend_fontweight',
    @CMD_PARAM_SIZE@
    #if $method.plot.color_map:
    color_map='$method.plot.color_map',
    #end if
    #if $method.plot.palette:
    palette='$method.plot.palette',
    #end if
    frameon=$method.plot.frameon,
    ncols=$method.plot.ncols,
    wspace=$method.plot.wspace,
    hspace=$method.plot.hspace,
    @CMD_PARAM_TITLE@
    ]]>
    </token>

    <xml name="pl_edges">
        <conditional name="edges">
            <param argument="edges" type="select" label="Show edges?">
            	<option value="False" selected="true">No</option>
                <option value="True">Yes</option>
            </param>
            <when value="True">
                <param argument="edges_width" type="float" min="0" value="0.1" label="Width of edges"/>
                <param argument="edges_color" type="select" optional="true" label="Color of edges">
                    <expand macro="matplotlib_color"/>
                </param>
            </when>
            <when value="False"/>
        </conditional>
    </xml>
    <token name="@CMD_PL_EDGES@"><![CDATA[
#if str($method.edges.edges) == 'True':
    edges=True,
    edges_width=$method.edges.edges_width,
    #if $method.edges.edges_color:
    edges_color='$method.edges.edges_color',
    #end if
#else
    edges=False,
#end if
    ]]>
    </token>


    <xml name="options_layout">
    	<option value="fa" selected="true">fa: ForceAtlas2</option>
        <option value="drl">drl: Distributed Recursive Layout, pretty fast</option>
        <option value="fr">fr: Fruchterman-Reingold</option>
        <option value="grid_fr">grid_fr: Grid Fruchterman Reingold, faster than "fr"</option>
        <option value="kk">kk: Kamadi Kawai’, slower than "fr"</option>
        <option value="lgl">Large Graph, very fast</option>
        <option value="rt">rt: Reingold Tilford tree layout</option>
        <option value="rt_circular">rt_circular: Reingold Tilford tree circular</option>
    </xml>
    <xml name="param_layout">
        <param argument="layout" type="select" label="Plotting layout" optional="false">
            <expand macro="options_layout"/>
        </param>
    </xml>
    <xml name="params_pl_paga">
        <param argument="threshold" type="float" min="0" value="" optional="true" label="Threshold to draw edges" help="Do not draw edges for weights below this threshold. Set to 0 if you want all edges. Discarding low-connectivity edges helps in getting a much clearer picture of the graph."/>
        <param argument="labels" type="text" value="" optional="true" label="The node labels" help="This defaults to the group labels stored in the categorical for which paga() has been computed">
            <expand macro="sanitize_query"/>
        </param>
        <param argument="color" type="text" value="" label="The node colors" help="Gene name or obs. annotation, and also plots the degree of the abstracted graph when passing 'degree_dashed', 'degree_solid'.">
            <expand macro="sanitize_query"/>
        </param>
        <param argument="pos" type="data" format="tabular,csv,tsv" optional="true" label="Two-column tabular file storing the x and y coordinates for drawing"/>
        <expand macro="param_layout"/>
        <param argument="init_pos" type="data" format="tabular,csv,tsv" optional="true" label="Two-column tabular file storing the x and y coordinates for initializing the layout"/>
        <param argument="random_state" type="integer" value="0" label="For layouts with random initialization like 'fr', change this to use different intial states for the optimization. If 'None', the initial state is not reproducible."/>
        <param argument="root" type="text" value="0" label="Comma-separated roots" help="If choosing a tree layout, this is the index of the root node or a list of root node indices. If this is a non-empty vector then the supplied node IDs are used as the roots of the trees (or a single tree if the graph is connected). If this is 'None' or an empty list, the root vertices are automatically calculated based on topological sorting.">
            <expand macro="sanitize_query"/>
        </param>
        <param argument="transitions" type="text" value="" label="Key corresponding to the matrix storing the arrows" help="Key for '.uns['paga']', e.g. 'transistions_confidence'">
            <expand macro="sanitize_query"/>
        </param>
        <param argument="solid_edges" type="text" value="connectivities" label="Key corresponding to the matrix storing the edges to be drawn solid black" help="Key for uns/paga">
            <expand macro="sanitize_query"/>
        </param>
        <param argument="dashed_edges" type="text" value="" optional="true" label="Key corresponding to the matrix storing the edges to be drawn dashed grey" help="Key for uns/paga. If not set, no dashed edges are drawn.">
            <expand macro="sanitize_query"/>
        </param>
        <param argument="single_component" type="boolean" truevalue="True" falsevalue="False" checked="false" label="Restrict to largest connected component?"/>
        <param argument="fontsize" type="integer" min="0" value="" optional="true" label="Font size for node labels"/>
        <param argument="node_size_scale" type="float" min="0" value="1.0" label="Size of the nodes"/>
        <param argument="node_size_power" type="float" min="0" value="0.5" label="Power with which groups sizes influence the radius of the nodes"/>
        <param argument="edge_width_scale" type="float" min="0" value="1.0" label="Scale for edge width"/>
        <param argument="min_edge_width" type="float" min="0" value="" optional="true" label="Min width of solid edges"/>
        <param argument="max_edge_width" type="float" min="0" value="" optional="true" label="Max width of solid and dashed edges"/>
        <param argument="arrowsize" type="integer" min="0" value="30" label="Arrow size" help="For directed graphs, choose the size of the arrow head head's length and width."/>
        <param argument="normalize_to_color" type="boolean" truevalue="True" falsevalue="False" checked="false" label="Normalize categorical plots to color or the underlying grouping?"/>
        <expand macro="param_cmap"/>
        <expand macro="param_title"/>
        <expand macro="param_frameon"/>
    </xml>
    <token name="@CMD_PARAMS_PL_PAGA@"><![CDATA[
        #if str($method.threshold) != '':
    threshold=$method.threshold,
        #end if
        #if str($method.labels) != '':
            #set $labels=([x.strip() for x in str($method.labels).split(',')])
    labels=$labels,
        #end if
        #if str($method.color) != '':
            #set $color=([x.strip() for x in str($method.color).split(',')])
    color=$color,
        #end if
        #if $method.pos:
    pos=np.fromfile($method.pos, dtype=dt),
        #end if
    layout='$method.layout',
        #if $method.init_pos:
    init_pos=np.fromfile($method.init_pos, dtype=dt),
        #end if
    random_state=$method.random_state,
        #if str($method.root) != '':
            #set $root=([int(x.strip()) for x in str($method.root).split(',')])
    root=$root,
        #end if
        #if str($method.transitions) != '':
    transitions='$method.transitions',
        #end if
    solid_edges='$method.solid_edges',
        #if str($method.dashed_edges) != '':
    dashed_edges='$method.dashed_edges',
        #end if
    single_component=$method.single_component,
        #if str($method.fontsize) != '':
    fontsize=$method.fontsize,
        #end if
    node_size_scale=$method.node_size_scale,
    node_size_power=$method.node_size_power,
    edge_width_scale=$method.edge_width_scale,
        #if str($method.min_edge_width) != '':
    min_edge_width=$method.min_edge_width,
        #end if
        #if str($method.max_edge_width) != '':
    max_edge_width=$method.max_edge_width,
        #end if
    arrowsize=$method.arrowsize,
    normalize_to_color=$method.normalize_to_color,
    #if $method.cmap:
    cmap='$method.cmap',
    #end if
        #if str($method.title) != '':
    title='$method.title',
        #end if
    frameon=$method.frameon,
    ]]>
    </token>

    <xml name="param_gene_symbols" token_label="Key for field in '.var' that stores gene symbols" token_help="By default 'var_names' refer to the index column of the '.var' DataFrame">
        <param argument="gene_symbols" type="text" value="" optional="true" label="@LABEL@" help="@HELP@">
            <expand macro="sanitize_query"/>
        </param>
    </xml>
    <token name="@CMD_PARAM_GENE_SYMBOLS@"><![CDATA[
    #if str($method.gene_symbols) != '':
    gene_symbols='$method.gene_symbols',
    #end if
    ]]>
    </token>

    <xml name="params_pl_dotplot">
        <param argument="color_map" type="select" optional="true" label="Color palette">
            <expand macro="matplotlib_pyplot_colormap"/>
        </param>
        <param argument="dot_max" type="float" value="" min="0" max="1" optional="true" label="Maximum dot size" help="If none, the maximum dot size is set to the maximum fraction value found (e.g. 0.6). If given, the value should be a number between 0 and 1. All fractions larger than dot_max are clipped to this value."/>
        <param argument="dot_min" type="float" value="" min="0" max="1" optional="true" label="Minimum dot size" help="If none, the minimum dot size is set to 0. If given, the value should be a number between 0 and 1. All fractions smaller than dot_min are clipped to this value."/>
        <expand macro="param_standard_scale"/>
        <param argument="expression_cutoff" type="float" min="0.0" value="0.0" label="Expression cutoff that is used for binarizing the gene expression and determining the fraction of cells expressing given genes" help="A gene is expressed only if the expression value is greater than this threshold."/>
        <param argument="mean_only_expressed" type="boolean" truevalue="True" falsevalue="False" checked="false" label="average the gene expression only over the cells expressing the given genes"/>
        <expand macro="section_matplotlib_pyplot_scatter"/>
    </xml>
    <token name="@CMD_PL_DOTPLOT@"><![CDATA[
    #if $method.color_map:
    color_map='$method.color_map',
    #end if
    #if str($method.dot_max) != '':
    dot_max=$method.dot_max,
    #end if
    #if str($method.dot_min) != '':
    dot_min=$method.dot_min,
    #end if
    @CMD_STANDARD_SCALE@
    expression_cutoff=$method.expression_cutoff,
    mean_only_expressed=$method.mean_only_expressed,
    @CMD_SECTION_MATPLOTLIB_PYPLOT_SCATTER@
    ]]>
    </token>

    <xml name="values_to_plot">
        <param argument="values_to_plot" type="select" optional="true" label="Values to plot" help="Defualt: plots mean expression. When plotting logfoldchanges a divergent colormap is recommended.">
            <option value="scores">Scores</option>
            <option value="logfoldchanges">Log foldchanges</option>
            <option value="pvals">P-values</option>
            <option value="pvals_adj">Adjusted p-values</option>
            <option value="log10_pvals">log10 of p-values</option>
            <option value="log10_pvals_adj">log10 of adjusted p-values</option>
        </param>
    </xml>
    <token name="@CMD_VALUES_TO_PLOT@"><![CDATA[
    #if $method.values_to_plot:
    values_to_plot='$method.values_to_plot',
    colorbar_title='$method.values_to_plot',
    #end if
    ]]>
    </token>


    <xml name="param_n_genes" token_value="">
        <param argument="n_genes" type="integer" min="0" value="@VALUE@" optional="true" label="Number of genes to show" help="It is only used if you are not specifying certain variable names"/>
    </xml>
    <xml name="param_key">
        <param argument="key" type="text" value="" label="Key used to store the ranking results in 'uns'">
            <expand macro="sanitize_query"/>
        </param>
    </xml>

    <xml name="pl_rank_genes_groups_ext">
        <expand macro="pl_var_names"/>
        <expand macro="param_groups"/>
        <expand macro="param_n_genes" value=""/>
        <expand macro="param_key"/>
        <param argument="min_logfoldchange" type="integer" optional="true" value="" label="Value to filter genes in groups if their logfoldchange is less than this value"/>
    </xml>
    <token name="@CMD_PL_RANK_GENES_GROUPS_EXT@"><![CDATA[
    #if str($method.var_names.type) == 'custom':
    #set $var_names = ([x.strip() for x in str($method.var_names.var_names).split(',')])
    var_names=$var_names,
    #else if str($method.var_names.type) == 'customfile':
    var_names={key: [v for v in list(value.values()) if pd.notna(v)] for key, value in pd.read_csv('$var_names', sep='\t', index_col=0, header=header).to_dict(orient='index').items()},
    #end if
    @CMD_PARAM_GROUPS@
    #if str($method.n_genes) != '':
    n_genes=$method.n_genes,
    #end if
    #if str($method.key) != '':
    key='$method.key',
    #end if
    #if str($method.min_logfoldchange) != '':
    min_logfoldchange=$method.min_logfoldchange,
    #end if
    ]]>
    </token>

    <xml name="param_density_norm">
        <param argument="density_norm" type="select" label="Method used to scale the width of each violin">
        	<option value="area" selected="true">area: each violin will have the same area</option>
            <option value="width">width: each violin will have the same width</option>
            <option value="count">count: the width of the violins will be scaled by the number of observations in that bin</option>
        </param>
    </xml>
    <xml name="params_pl_stacked_violin">
        <expand macro="param_swap_axes"/>
        <section name="violin_plot" title="Violin plot attributes">
            <expand macro="conditional_stripplot"/>
            <expand macro="param_density_norm"/>
        </section>
        <param argument="row_palette" type="select" optional="true" label="Colors to use in each of the stacked violin plots">
            <option value="muted">muted</option>
            <expand macro="seaborn_color_palette_options"/>
        </param>
        <expand macro="param_standard_scale"/>
        <expand macro="params_seaborn_violinplot"/>
        <param argument="yticklabels" type="boolean" truevalue="True" falsevalue="False" checked="false" label="Set to view the y tick labels"/>
        <expand macro="param_vmin" label="The value representing the lower limit of the color scale" help="Values smaller than vmin are plotted with the same color as vmin."/>
        <expand macro="param_vmax" label="The value representing the upper limit of the color scale" help="Values larger than vmax are plotted with the same color as vmax."/>
        <expand macro="param_vcenter"/>
    </xml>
    <token name="@CMD_PARAMS_PL_STACKED_VIOLIN@"><![CDATA[
    swap_axes=$method.swap_axes,
    @CMD_CONDITIONAL_STRIPPLOT@
    density_norm='$method.violin_plot.density_norm',
    #if $method.row_palette:
    row_palette='$method.row_palette',
    #end if
    @CMD_STANDARD_SCALE@
    @CMD_PARAMS_SEABORN_VIOLINPLOT@
    yticklabels=$method.yticklabels,
    #if str($method.vmin) != '':
    vmin=$method.vmin,
    #end if
    #if str($method.vmax) != '':
    vmax=$method.vmax,
    #end if
    #if str($method.vcenter) != '':
    vcenter=$method.vcenter,
    #end if
    ]]>
    </token>

    <xml name="params_scatter_outine">
        <param argument="add_outline" type="boolean" truevalue="True" falsevalue="False" checked="false" label="Add a thin border around groups of dots" help="In some situations this can enhance the aesthetics of the resulting image"/>
        <param name="outline_color_border" type="select" optional="true" label="Border color around the scatter dot" help="Default: black">
            <expand macro="matplotlib_color"/>
        </param>
        <param name="outline_color_gap" type="select" optional="true" label="Gap color between the border color and the scatter dot" help="Default: white">
            <expand macro="matplotlib_color"/>
        </param>
        <param argument="outline_width_border" type="float" value="0.3" optional="true" label=" width of the border color as a fraction of the scatter dot size "/>
        <param argument="outline_width_gap" type="float" value="0.05" optional="true" label="The width of the gap color"/>
    </xml>
    <token name="@CMD_SCATTER_OUTINE@"><![CDATA[
    add_outline=$method.add_outline,
    #if $method.outline_color_border and $method.outline_color_gap:
    outline_color=($method.outline_color_border, $method.outline_color_gap),
    #end if
    outline_width=($method.outline_width_border, $method.outline_width_gap),
    ]]>
    </token>

    <xml name="param_interactive_plot">
        <param name="interactive_plot" type="boolean" checked="false" label="Make an interactive plot?" help="Creates a vitessce configuration file using easy_vitessce for interactive visualization"/>
    </xml>

    <token name="@VITESSCE_ACTIVATE@"><![CDATA[
import easy_vitessce as ev
ev.configure_plots(enable_plots=["pca", "umap", "tsne", "diffmap", "violin", "embedding", "dotplot", "heatmap"])
ev.config.update({ 'data.anndata_format': 'h5ad' })
ev.register_data_path(adata, 'anndata.h5ad')
    ]]>
    </token>
    <token name="@VITESSCE_CONFIG@"><![CDATA[
import json
## while testing locally check galaxy_infrastructure_url is whether http://localhost:8080 or http://127.0.0.1:8080
## use the correct URL to access datasets via Galaxy API
galaxy_url = "${__app__.config.galaxy_infrastructure_url}"
anndata_out_id = "${__app__.security.encode_id($anndata_out.id)}"
anndata_config_id = "${__app__.security.encode_id($anndata_config.id)}"

config_dict = widget.config.to_dict(base_url="")

for dataset in config_dict.get('datasets', []):
    for file in dataset.get('files', []):
        if 'url' in file:
            file['url'] = f"{galaxy_url}/api/datasets/{anndata_out_id}/display"
        if 'options' in file and 'refSpecUrl' in file['options']:
            file['options']['refSpecUrl'] = f"{galaxy_url}/api/datasets/{anndata_config_id}/display"

config_js_content = f"""
export const config = {json.dumps(config_dict, indent=2)};
"""

with open("config.js", "w") as f:
    f.write(config_js_content)

with open("config.json", "w") as f:
    json.dump(config_dict, f, indent=2)
]]>
    </token>
    <!-- unused macros -->
    <!-- <xml name="param_right_margin">
        <param argument="right_margin" type="float" value="1" label="Width of the space right of each plotting panel"/>
    </xml>
    <xml name="param_left_margin">
        <param argument="left_margin" type="float" value="1" label="Width of the space left of each plotting panel"/>
    </xml> -->
</macros>
