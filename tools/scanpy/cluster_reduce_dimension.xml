<tool id="scanpy_cluster_reduce_dimension" name="Cluster," version="@galaxy_version@" profile="@profile@">
    <description>infer trajectories and embed with scanpy</description>
    <macros>
        <import>macros.xml</import>
        <xml name="pca_inputs">
            <param argument="n_comps" type="integer" min="0" value="50" label="Number of principal components to compute" help=""/>
            <param argument="dtype" type="text" value="float32" label="Numpy data type string to which to convert the result" help=""/>
            <conditional name="pca">
                <param argument="chunked" type="select" label="Type of PCA?">
                    <option value="True">Incremental PCA on segments (incremental PCA automatically zero centers and ignores settings of `random_seed` and `svd_solver`)</option>
                    <option value="False" selected="true">Full PCA</option>
                </param>
                <when value="True">
                    <param argument="chunk_size" type="integer" min="0" value="" label="chunk_size" help="Number of observations to include in each chunk"/>
                </when>
                <when value="False">
                    <param argument="zero_center" type="boolean" truevalue="True" falsevalue="False" checked="true"
                        label="Compute standard PCA from covariance matrix?"
                        help="If not, it omits zero-centering variables (uses *TruncatedSVD* from scikit-learn), which allows to handle sparse input efficiently."/>
                    <expand macro="svd_solver"/> 
                    <param argument="random_state" type="integer" value="0" label="Initial states for the optimization" help=""/>
                </when>
            </conditional>
            <param argument="use_highly_variable" type="boolean" truevalue="True" falsevalue="False" checked="false" label="Use highly variable genes only?" help="They should be use if they have been determined beforehand."/>
        </xml>
        <xml name="param_random_state">
            <param argument="random_state" type="integer" value="0" label="Random state" help="Change the initialization of the optimization."/>
        </xml>
        <xml name="param_use_weights">
            <param argument="use_weights" type="boolean" truevalue="True" falsevalue="False" checked="false" label="Use weights from knn graph?"/>
        </xml>
        <token name="@CMD_pca_help@"><![CDATA[
The PCA is computed using the implementation of *scikit-learn*.

The returned AnnData object contains:

- PCA coordinates in the multi-dimensional observation annotation (obsm)
- Principal components containing the loadings in the multi-dimensional variable annotation (varm)
- The variance decomposition in the unstructured annotation (uns)
    - Ratio of explained variance for PCA (variance)
    - Explained variance, equivalent to the eigenvalues of the covariance matrix

This data is accessible using the inspect tool for AnnData
]]></token>
        <token name="@CMD_pca_params@"><![CDATA[
    data=adata,
    n_comps=$method.n_comps,
    dtype='$method.dtype',
    copy=False,
    chunked=$method.pca.chunked,
#if $method.pca.chunked == 'True'
    chunk_size=$method.pca.chunk_size,
#else
    zero_center=$method.pca.zero_center,
    svd_solver='$method.pca.svd_solver',
    random_state=$method.pca.random_state,
#end if
    use_highly_variable=$method.use_highly_variable
]]></token>
    </macros>
    <expand macro="requirements">
        <requirement type="package" version="0.6.1">louvain</requirement>
    </expand>
    <expand macro="version_command"/>
    <command detect_errors="exit_code"><![CDATA[
@CMD@
      ]]></command>
    <configfiles>
        <configfile name="script_file"><![CDATA[
@CMD_imports@
@CMD_read_inputs@

#if $method.method == 'tl.louvain'
sc.tl.louvain(
    adata=adata,
    flavor = '$method.flavor.flavor',
    #if $method.flavor.flavor == 'vtraag' and $method.flavor.resolution
    resolution=$method.flavor.resolution,
    #end if
    random_state=$method.random_state,
    key_added='$method.key_added',
    directed=$method.directed,
    use_weights=$method.use_weights,
    copy=False)

#else if $method.method == 'tl.leiden'
sc.tl.leiden(
    adata=adata,
    resolution=$method.resolution,
    random_state=$method.random_state,
    key_added='$method.key_added',
    use_weights=$method.use_weights,
    n_iterations=$method.n_iterations,
    copy=False)

#else if $method.method == 'pp.pca'
sc.pp.pca(@CMD_pca_params@)

#else if $method.method == 'tl.pca'
sc.tl.pca(@CMD_pca_params@)

#else if $method.method == 'tl.diffmap'
sc.tl.diffmap(
    adata=adata,
    n_comps=$method.n_comps,
    copy =False)

#else if $method.method == 'tl.tsne'
sc.tl.tsne(
    adata=adata,
    #if $method.n_pcs
    n_pcs=$method.n_pcs,
    #end if
    perplexity=$method.perplexity,
    early_exaggeration=$method.early_exaggeration,
    learning_rate=$method.learning_rate,
    random_state=$method.random_state,
    use_fast_tsne=$method.use_fast_tsne,
    copy=False)

#else if $method.method == 'tl.umap'
sc.tl.umap(
    adata=adata,
    min_dist=$method.min_dist,
    spread=$method.spread,
    n_components=$method.n_components,
    #if $method.maxiter
    maxiter=$method.maxiter,
    #end if
    alpha=$method.alpha,
    gamma=$method.gamma,
    negative_sample_rate=$method.negative_sample_rate,
    init_pos='$method.init_pos',
    random_state=$method.random_state,
    copy=False)

#else if $method.method == 'tl.draw_graph'

    #if str($method.adjacency) != 'None'
from scipy import io
adjacency = io.mmread('$method.adjacency')
    #end if

sc.tl.draw_graph(
    adata=adata,
    layout='$method.layout',
#if str($method.root) != ''
    #set $root=([int(x.strip()) for x in str($method.root).split(',')])
    root=$root,
#end if
    random_state=$method.random_state,
    #if str($method.init_pos) != ''
    init_pos='$method.init_pos',
    #end if
    #if str($method.adjacency) != 'None'
    adjacency=adjacency,
    #end if
    #if str($method.key_ext) != ''
    key_ext='$method.key_ext',
    #end if
    copy=False)

#else if $method.method == "tl.paga"
sc.tl.paga(
    adata=adata,
    groups='$method.groups',
    use_rna_velocity=$method.use_rna_velocity,
    model='$method.model',
    copy=False)

#else if $method.method == "tl.dpt"
sc.tl.dpt(
    adata=adata,
    n_dcs=$method.n_dcs,
    n_branchings=$method.n_branchings,
    min_group_size=$method.min_group_size,
    allow_kendall_tau_shift=$method.allow_kendall_tau_shift,
    copy=False)
#end if

@CMD_anndata_write_outputs@
]]></configfile>
    </configfiles>
    <inputs>
        <expand macro="inputs_anndata"/>
        <conditional name="method">
            <param argument="method" type="select" label="Method used for plotting">
                <option value="tl.louvain">Cluster cells into subgroups, using `tl.louvain`</option>
                <option value="tl.leiden">Cluster cells into subgroups, using `tl.leiden`</option>
                <option value="pp.pca">Computes PCA (principal component analysis) coordinates, loadings and variance decomposition, using `pp.pca`</option>
                <option value="tl.pca">Computes PCA (principal component analysis) coordinates, loadings and variance decomposition, using `tl.pca`</option>
                <option value="tl.diffmap">Diffusion Maps, using `tl.diffmap`</option>
                <option value="tl.tsne">t-distributed stochastic neighborhood embedding (tSNE), using `tl.tsne`</option>
                <option value="tl.umap">Embed the neighborhood graph using UMAP, using `tl.umap`</option>
                <option value="tl.draw_graph">Force-directed graph drawing, using `tl.draw_graph`</option>
                <option value="tl.dpt">Infer progression of cells through geodesic distance along the graph, using `tl.dpt`</option>
                <option value="tl.paga">Generate cellular maps of differentiation manifolds with complex topologies, using `tl.paga`</option>
            </param>
            <when value="tl.louvain">
                <conditional name="flavor">
                    <param argument="flavor" type="select" label="Flavor for the clustering" help="">
                        <option value="vtraag">vtraag (much more powerful)</option>
                        <option value="igraph">igraph</option>
                    </param>
                    <when value="vtraag">
                        <param argument="resolution" type="float" value="" optional="true"
                            label="Resolution"
                            help="Higher resolution means finding more and smaller clusters, which defaults to 1.0. See “Time as a resolution parameter” in Lambiotte et al, 2009"/>
                    </when>
                    <when value="igraph"/>
                </conditional>
                <expand macro="param_random_state"/>
                <param argument="key_added" type="text" value="louvain" optional="true" label="Key under which to add the cluster labels" help=""/>
                <param argument="directed" type="boolean" truevalue="True" falsevalue="False" checked="true" label="Interpret the adjacency matrix as directed graph?"/>
                <expand macro="param_use_weights"/>
            </when>
            <when value="tl.leiden">
                <param argument="resolution" type="float" value="1" label="Coarseness of the clusterin" help="Higher values lead to more clusters"/>
                <expand macro="param_random_state"/>
                <param argument="key_added" type="text" value="leiden" label="Key under which to add the cluster labels" help=""/>
                <expand macro="param_use_weights"/>
                <param argument="n_iterations" type="integer" value="-1" label="How many iterations of the Leiden clustering algorithm to perform." help="Positive values above 2 define the total number of iterations to perform, -1 has the algorithm run until it reaches its optimal clustering."/>
            </when>
            <when value="pp.pca">
                <expand macro="pca_inputs"/>
            </when>
            <when value="tl.pca">
                <expand macro="pca_inputs"/>
            </when>
            <when value="tl.diffmap">
                <param argument="n_comps" type="integer" min="0" value="15" optional="true" label="Number of dimensions of the representation" help=""/>
            </when>
            <when value="tl.tsne">
                <param name="n_pcs" type="integer" min="0" value="" optional="true" label="Number of PCs to use" help=""/>
                <param name="perplexity" type="float" value="30" label="Perplexity" help="The perplexity is related to the number of nearest neighbors that is used in other manifold learning algorithms. Larger datasets usually require a larger perplexity. Consider selecting a value between 5 and 50. The choice is not extremely critical since t-SNE is quite insensitive to this parameter."/>
                <param name="early_exaggeration" type="float" value="12.0" label="Early exaggeration" help="Controls how tight natural clusters in the original space are in the embedded space and how much space will be between them. For larger values, the space between natural clusters will be larger in the embedded space. Again, the choice of this parameter is not very critical. If the cost function increases during initial optimization, the early exaggeration factor or the learning rate might be too high."/>
                <param name="learning_rate" type="float" value="1000" label="Learning rate" help="The learning rate can be a critical parameter. It should be between 100 and 1000. If the cost function increases during initial optimization, the early exaggeration factor or the learning rate might be too high. If the cost function gets stuck in a bad local minimum increasing the learning rate helps sometimes."/>
                <param name="random_state" type="integer" value="0" label="Random state" help="Change this to use different intial states for the optimization"/>
                <param argument="use_fast_tsne" type="boolean" truevalue="True" falsevalue="False" checked="true" label="Use the MulticoreTSNE package if possible?"/>
            </when>
            <when value="tl.umap">
                <param argument="min_dist" type="float" value="0.5" label="Effective minimum distance between embedded points" help="Smaller values will result in a more clustered/clumped embedding where nearby points on the manifold are drawn closer together, while larger values will result on a more even dispersal of points. The value should be set relative to the `spread` value, which determines the scale at which embedded points will be spread out. The default of in the `umap-learn` package is 0.1."/>
                <param argument="spread" type="float" value="1.0" label="Effective scale of embedded points" help="In combination with `min_dist` this determines how clustered/clumped the embedded points are."/>
                <param argument="n_components" type="integer" min="0" value="2" label="Number of dimensions of the embedding" help=""/>
                <param argument="maxiter" type="integer" min="0" value="" optional="true" label="Number of iterations (epochs) of the optimization" help="Called `n_epochs` in the original UMAP."/>
                <param argument="alpha" type="float" value="1.0" label="Initial learning rate for the embedding optimization" help=""/>
                <param argument="gamma" type="float" value="1.0" label="Weighting applied to negative samples in low dimensional embedding optimization" help="Values higher than one will result in greater weight being given to negative samples."/>
                <param argument="negative_sample_rate" type="integer" min="0" value="5" label="The number of negative edge/1-simplex samples to use per positive edge/1-simplex sample in optimizing the low dimensional embedding" help=""/>
                <param argument="init_pos" type="select" label="How to initialize the low dimensional embedding" help="Called `init` in the original UMAP">
                    <option value="paga">Position from paga</option>
                    <option value="spectral" selected="true">Spectral embedding of the graph</option>
                    <option value="random">Initial embedding positions at random</option>
                </param>
                <expand macro="param_random_state"/>
            </when>
            <when value="tl.draw_graph">
                <expand macro="param_layout"/>
                <expand macro="param_root"/>
                <expand macro="param_random_state"/>
                <param argument="init_pos" type="text" optional="true" value="" label="Precomputed coordinates for initialization" help="It should be a valid 2d observation (e.g. paga)"/>
                <param argument="adjacency" type="data" format="mtx" optional="true" label="Sparse adjacency matrix of the graph" help="If not set, it uses the unstructured annotation (uns) / neighbors / connectivities"/>
                <param argument="key_ext" type="text" optional="true" value="" label="External key" help="If not set, it appends `layout`"/>
            </when>
            <when value="tl.dpt">
                <param argument="n_dcs" type="integer" min="0" value="10" label="Number of diffusion components to use" help=""/>
                <param argument="n_branchings" type="integer" min="0" value="0" label="Number of branchings to detect" help=""/>
                <param argument="min_group_size" type="float" min="0" value="0.01" label="Min group size" help="During recursive splitting of branches ('dpt groups') for `n_branchings` &gt; 1, do not consider groups that contain less than `min_group_size` data points. If a float, `min_group_size` refers to a fraction of the total number of data points."/>
                <param argument="allow_kendall_tau_shift" type="boolean" truevalue="True" falsevalue="False" checked="true" label="Allow Kendal tau shift?" help="If a very small branch is detected upon splitting, shift away from maximum correlation in Kendall tau criterion of Haghverdi et al (2016) to stabilize the splitting."/>
            </when>
            <when value="tl.paga">
                <param argument="groups" type="text" value="louvain" label="Key for categorical in the input" help="You can pass your predefined groups by choosing any categorical annotation of observations (`adata.obs`)."/>
                <param argument="use_rna_velocity" type="boolean" truevalue="False" falsevalue="False" checked="false" label="Use RNA velocity to orient edges in the abstracted graph and estimate transitions?" help="Requires that `adata.uns` contains a directed single-cell graph with key `['velocyto_transitions']`. This feature might be subject to change in the future."/>
                <param argument="model" type="select" label="PAGA connectivity model" help="">
                    <option value="v1.2">v1.2</option>
                    <option value="v1.0">v1.0</option>
                </param>
            </when>
        </conditional>            
    </inputs>
    <outputs>
        <expand macro="anndata_outputs"/>
    </outputs>
    <tests>
        <test>
            <!-- test 1 -->
            <param name="adata" value="pp.neighbors_gauss_braycurtis.recipe_weinreb17.paul15_subsample.h5ad" />
            <conditional name="method">
                <param name="method" value="tl.louvain"/>
                <conditional name="flavor">
                    <param name="flavor" value="vtraag"/>
                    <param name="resolution" value="1.0"/>
                </conditional>
                <param name="random_state" value="10"/>
                <param name="key_added" value="louvain"/>
                <param name="directed" value="true"/>
                <param name="use_weights" value="false"/>
            </conditional>
            <assert_stdout>
                <has_text_matching expression="sc.tl.louvain"/>
                <has_text_matching expression="adata=adata"/>
                <has_text_matching expression="flavor = 'vtraag'"/>
                <has_text_matching expression="resolution=1.0"/>
                <has_text_matching expression="random_state=10"/>
                <has_text_matching expression="key_added='louvain'"/>
                <has_text_matching expression="directed=True"/>
                <has_text_matching expression="use_weights=False"/>
            </assert_stdout>
            <output name="anndata_out" file="tl.louvain.neighbors_gauss_braycurtis.recipe_weinreb17.paul15_subsample.h5ad" ftype="h5ad" compare="sim_size"/>
        </test>
        <test>
            <!-- test 2 -->
            <param name="adata" value="pp.neighbors_gauss_braycurtis.recipe_weinreb17.paul15_subsample.h5ad" />
            <conditional name="method">
                <param name="method" value="tl.leiden"/>
                <param name="random_state" value="1"/>
                <param name="random_state" value="10"/>
                <param name="key_added" value="leiden"/>
                <param name="use_weights" value="false"/>
                <param name="n_iterations" value="-1"/>
            </conditional>
            <assert_stdout>
                <has_text_matching expression="sc.tl.leiden"/>
                <has_text_matching expression="resolution=1"/>
                <has_text_matching expression="random_state=10"/>
                <has_text_matching expression="key_added='leiden'"/>
                <has_text_matching expression="use_weights=False"/>
                <has_text_matching expression="n_iterations=-1"/>
            </assert_stdout>
            <output name="anndata_out" file="tl.leiden.neighbors_gauss_braycurtis.recipe_weinreb17.paul15_subsample.h5ad" ftype="h5ad" compare="sim_size"/>
        </test>
        <test>
            <!-- test 2 -->
            <param name="adata" value="krumsiek11.h5ad" />
            <conditional name="method">
                <param name="method" value="pp.pca"/>
                <param name="n_comps" value="50"/>
                <param name="dtype" value="float32"/>
                <conditional name="pca">
                    <param name="chunked" value="False"/>
                    <param name="zero_center" value="true"/>
                    <param name="svd_solver" value="auto"/>
                    <param name="random_state" value="0"/>
                </conditional>
                <param name="use_highly_variable" value="false"/>
            </conditional>
            <assert_stdout>
                <has_text_matching expression="sc.pp.pca"/>
                <has_text_matching expression="n_comps=50"/>
                <has_text_matching expression="dtype='float32'"/>
                <has_text_matching expression="copy=False"/>
                <has_text_matching expression="chunked=False"/>
                <has_text_matching expression="zero_center=True"/>
                <has_text_matching expression="svd_solver='auto'"/>
                <has_text_matching expression="random_state=0"/>
                <has_text_matching expression="use_highly_variable=False"/>
            </assert_stdout>
            <output name="anndata_out" file="pp.pca.krumsiek11.h5ad" ftype="h5ad" compare="sim_size"/>
        </test>
        <!--<test>
            < test 3 >
            <param name="adata" value="krumsiek11.h5ad" />
            <conditional name="method">
                <param name="method" value="pp.pca"/>
                <param name="n_comps" value="20"/>
                <param name="dtype" value="float32"/>
                <conditional name="pca">
                    <param name="chunked" value="True"/>
                    <param name="chunk_size" value="50"/>
                </conditional>
                <param name="use_highly_variable" value="false"/>
            </conditional>
            <assert_stdout>
                <has_text_matching expression="sc.pp.pca"/>
                <has_text_matching expression="data=adata"/>
                <has_text_matching expression="n_comps=20"/>
                <has_text_matching expression="dtype='float32'"/>
                <has_text_matching expression="copy=False"/>
                <has_text_matching expression="chunked=True"/>
                <has_text_matching expression="chunk_size=50"/>
                <has_text_matching expression="use_highly_variable=False"/>
            </assert_stdout>
            <output name="anndata_out" file="pp.pca.krumsiek11_chunk.h5ad" ftype="h5ad" compare="sim_size"/>
        </test>
        -->
        <test>
            <!-- test 3 -->
            <param name="adata" value="krumsiek11.h5ad" />
            <conditional name="method">
                <param name="method" value="tl.pca"/>
                <param name="n_comps" value="50"/>
                <param name="dtype" value="float32"/>
                <conditional name="pca">
                    <param name="chunked" value="False"/>
                    <param name="zero_center" value="True"/>
                    <param name="svd_solver" value="auto"/>
                    <param name="random_state" value="0"/>
                </conditional>
                <param name="use_highly_variable" value="false"/>
            </conditional>
            <assert_stdout>
                <has_text_matching expression="sc.tl.pca"/>
                <has_text_matching expression="n_comps=50"/>
                <has_text_matching expression="dtype='float32'"/>
                <has_text_matching expression="copy=False"/>
                <has_text_matching expression="chunked=False"/>
                <has_text_matching expression="zero_center=True"/>
                <has_text_matching expression="svd_solver='auto'"/>
                <has_text_matching expression="use_highly_variable=False"/>
            </assert_stdout>
            <output name="anndata_out" file="tl.pca.krumsiek11.h5ad" ftype="h5ad" compare="sim_size"/>
        </test>
        <test>
            <!-- test 4 -->
            <param name="adata" value="pp.neighbors_gauss_braycurtis.recipe_weinreb17.paul15_subsample.h5ad" />
            <conditional name="method">
                <param name="method" value="tl.diffmap"/>
                <param name="n_comps" value="15"/>
            </conditional>
            <assert_stdout>
                <has_text_matching expression="sc.tl.diffmap"/>
                <has_text_matching expression="n_comps=15"/>
            </assert_stdout>
            <output name="anndata_out" file="tl.diffmap.neighbors_gauss_braycurtis.recipe_weinreb17.paul15_subsample.h5ad" ftype="h5ad" compare="sim_size"/>
        </test>
        <test>
            <!-- test 5 -->
            <param name="adata" value="krumsiek11.h5ad" />
            <conditional name="method">
                <param name="method" value="tl.tsne"/>
                <param name="n_pcs" value="10"/>
                <param name="perplexity" value="30"/>
                <param name="early_exaggeration" value="12.0"/>
                <param name="learning_rate" value="1000"/>
                <param name="random_state" value="0"/>
                <param name="use_fast_tsne" value="true"/>
            </conditional>
            <assert_stdout>
                <has_text_matching expression="sc.tl.tsne"/>
                <has_text_matching expression="n_pcs=10"/>
                <has_text_matching expression="perplexity=30.0"/>
                <has_text_matching expression="early_exaggeration=12.0"/>
                <has_text_matching expression="learning_rate=1000.0"/>
                <has_text_matching expression="random_state=0"/>
                <has_text_matching expression="use_fast_tsne=True"/>
            </assert_stdout>
            <output name="anndata_out" file="tl.tsne.krumsiek11.h5ad" ftype="h5ad" compare="sim_size"/>
        </test>
        <test>
            <!-- test 6 -->
            <param name="adata" value="pp.neighbors_umap_euclidean.recipe_weinreb17.paul15_subsample.h5ad" />
            <conditional name="method">
                <param name="method" value="tl.umap"/>
                <param name="min_dist" value="0.5"/>
                <param name="spread" value="1.0"/>
                <param name="n_components" value="2"/>
                <param name="maxiter" value="2"/>
                <param name="alpha" value="1.0"/>
                <param name="gamma" value="1.0"/>
                <param name="negative_sample_rate" value="5"/>
                <param name="init_pos" value="spectral"/>
                <param name="random_state" value="0"/>
            </conditional>
            <assert_stdout>
                <has_text_matching expression="sc.tl.umap"/>
                <has_text_matching expression="min_dist=0.5"/>
                <has_text_matching expression="spread=1.0"/>
                <has_text_matching expression="n_components=2"/>
                <has_text_matching expression="maxiter=2"/>
                <has_text_matching expression="alpha=1.0"/>
                <has_text_matching expression="gamma=1.0"/>
                <has_text_matching expression="negative_sample_rate=5"/>
                <has_text_matching expression="init_pos='spectral'"/>
                <has_text_matching expression="random_state=0"/>
            </assert_stdout>
            <output name="anndata_out" file="tl.umap.neighbors_umap_euclidean.recipe_weinreb17.paul15_subsample.h5ad" ftype="h5ad" compare="sim_size">
                <assert_contents>
                    <has_h5_keys keys="X, obs, obsm, uns, var" />
                </assert_contents>
            </output>
        </test>
        <test>
            <!-- test 7 -->
            <param name="adata" value="pp.neighbors_umap_euclidean.recipe_weinreb17.paul15_subsample.h5ad"/>
            <conditional name="method">
                <param name="method" value="tl.draw_graph"/>
                <param name="layout" value="fa"/>
                <param name="random_state" value="0"/>
            </conditional>
            <assert_stdout>
                <has_text_matching expression="sc.tl.draw_graph"/>
                <has_text_matching expression="layout='fa'"/>
                <has_text_matching expression="random_state=0"/>
            </assert_stdout>
            <output name="anndata_out" file="tl.draw_graph.pp.neighbors_umap_euclidean.recipe_weinreb17.paul15_subsample.h5ad" ftype="h5ad" compare="sim_size"/>
        </test>
        <test>
            <!-- test 8 -->
            <param name="adata" value="pp.neighbors_gauss_braycurtis.recipe_weinreb17.paul15_subsample.h5ad"/>
            <conditional name="method">
                <param name="method" value="tl.paga"/>
                <param name="groups" value="paul15_clusters"/>
                <param name="use_rna_velocity" value="False"/>
                <param name="model" value="v1.2"/>
            </conditional>
            <assert_stdout>
                <has_text_matching expression="sc.tl.paga"/>
                <has_text_matching expression="groups='paul15_clusters'"/>
                <has_text_matching expression="use_rna_velocity=False"/>
                <has_text_matching expression="model='v1.2'"/>
            </assert_stdout>
            <output name="anndata_out" file="tl.paga.neighbors_gauss_braycurtis.recipe_weinreb17.paul15_subsample.h5ad" ftype="h5ad" compare="sim_size"/>
        </test>
        <test>
            <!-- test 9 -->
            <param name="adata" value="tl.diffmap.neighbors_gauss_braycurtis.recipe_weinreb17.paul15_subsample.h5ad" />
            <conditional name="method">
                <param name="method" value="tl.dpt"/>
                <param name="n_dcs" value="15"/>
                <param name="n_branchings" value="1"/>
                <param name="min_group_size" value="0.01"/>
                <param name="allow_kendall_tau_shift" value="True"/>
            </conditional>
            <assert_stdout>
                <has_text_matching expression="sc.tl.dpt"/>
                <has_text_matching expression="n_dcs=15"/>
                <has_text_matching expression="n_branchings=1"/>
                <has_text_matching expression="min_group_size=0.01"/>
                <has_text_matching expression="allow_kendall_tau_shift=True"/>
            </assert_stdout>
            <output name="anndata_out" file="tl.dpt.diffmap.neighbors_gauss_braycurtis.recipe_weinreb17.paul15_subsample.h5ad" ftype="h5ad" compare="sim_size"/>
        </test>
    </tests>
    <help><![CDATA[
Cluster cells into subgroups (`tl.louvain`)
===========================================

Cluster cells using the Louvain algorithm (Blondel et al, 2008) in the implementation
of Traag et al,2017. The Louvain algorithm has been proposed for single-cell
analysis by Levine et al, 2015.

This requires to run `pp.neighbors`, first.

More details on the `scanpy documentation
<https://icb-scanpy.readthedocs-hosted.com/en/stable/api/scanpy.tl.louvain.html>`_

Cluster cells into subgroups (`tl.leiden`)
==========================================

Cluster cells using the Leiden algorithm (Traag et al, 2018), an improved version of the Louvain algorithm (Blondel et al, 2008).

The Louvain algorithm has been proposed for single-cell analysis by Levine et al, 2015.

More details on the `scanpy documentation
<https://icb-scanpy.readthedocs-hosted.com/en/stable/api/scanpy.tl.leiden.html>`_

Computes PCA (principal component analysis) coordinates, loadings and variance decomposition, using `pp.pca`
============================================================================================================

@CMD_pca_outputs@

More details on the `scanpy documentation
<https://icb-scanpy.readthedocs-hosted.com/en/stable/api/scanpy.pp.pca.html>`__

Computes PCA (principal component analysis) coordinates, loadings and variance decomposition, using `tl.pca`
============================================================================================================

@CMD_pca_outputs@

More details on the `scanpy documentation
<https://icb-scanpy.readthedocs-hosted.com/en/stable/api/scanpy.tl.pca.html>`__

Diffusion Maps, using `tl.diffmap`
==================================

Diffusion maps (Coifman et al  2005) has been proposed for visualizing single-cell
data by Haghverdi et al (2015). The tool uses the adapted Gaussian kernel suggested
by Haghverdi et al (2016) in the implementation of Wolf et al (2017).

The width ("sigma") of the connectivity kernel is implicitly determined by
the number of neighbors used to compute the single-cell graph in
`pp.neighbors`. To reproduce the original implementation
using a Gaussian kernel, use `method=='gauss'` in
`pp.neighbors`. To use an exponential kernel, use the default
`method=='umap'`. Differences between these options shouldn't usually be
dramatic.

The diffusion map representation of data are added to the return AnnData in the multi-dimensional 
observations annotation (obsm). It is the right eigen basis of the transition matrix with eigenvectors 
as colum. It can be accessed using the inspect tool for AnnData

More details on the `scanpy documentation
<https://icb-scanpy.readthedocs-hosted.com/en/stable/api/scanpy.tl.diffmap.html>`__

t-distributed stochastic neighborhood embedding (tSNE), using `tl.tsne`
=======================================================================

t-distributed stochastic neighborhood embedding (tSNE) (Maaten et al, 2008) has been
proposed for visualizating single-cell data by (Amir et al, 2013). Here, by default,
we use the implementation of *scikit-learn* (Pedregosa et al, 2011). 

It returns `X_tsne`, tSNE coordinates of data.

More details on the `scanpy documentation
<https://icb-scanpy.readthedocs-hosted.com/en/stable/api/scanpy.tl.tsne.html>`__

Embed the neighborhood graph using UMAP, using `tl.umap`
========================================================

UMAP (Uniform Manifold Approximation and Projection) is a manifold learning
technique suitable for visualizing high-dimensional data. Besides tending to
be faster than tSNE, it optimizes the embedding such that it best reflects
the topology of the data, which we represent throughout Scanpy using a
neighborhood graph. tSNE, by contrast, optimizes the distribution of
nearest-neighbor distances in the embedding such that these best match the
distribution of distances in the high-dimensional space.  We use the
implementation of `umap-learn <https://github.com/lmcinnes/umap>`__
(McInnes et al, 2018). For a few comparisons of UMAP with tSNE, see this `preprint
<https://doi.org/10.1101/298430>`__.

The UMAP coordinates of data are added to the return AnnData in the multi-dimensional 
observations annotation (obsm). This data is accessible using the inspect tool for AnnData

More details on the `scanpy documentation
<https://icb-scanpy.readthedocs-hosted.com/en/stable/api/scanpy.tl.umap.html>`__

Force-directed graph drawing, using `tl.draw_graph`
===================================================

Force-directed graph drawing describes a class of long-established algorithms for visualizing graphs. 
It has been suggested for visualizing single-cell data by Islam et al, 11. 
Many other layouts as implemented in igraph are available. Similar approaches have been used by 
Zunder et al, 2015 or Weinreb et al, 2016.

This is an alternative to tSNE that often preserves the topology of the data better. 
This requires to run `pp.neighbors`, first.

The default layout (ForceAtlas2) uses the package fa2.

The coordinates of graph layout are added to the return AnnData in the multi-dimensional 
observations annotation (obsm). This data is accessible using the inspect tool for AnnData.

More details on the `scanpy documentation
<https://icb-scanpy.readthedocs-hosted.com/en/stable/api/scanpy.tl.draw_graph.html>`__

Infer progression of cells through geodesic distance along the graph (`tl.dpt`)
===============================================================================

Reconstruct the progression of a biological process from snapshot
data. `Diffusion Pseudotime` has been introduced by Haghverdi et al (2016) and
implemented within Scanpy (Wolf et al, 2017). Here, we use a further developed
version, which is able to deal with disconnected graphs (Wolf et al, 2017) and can
be run in a `hierarchical` mode by setting the parameter
`n_branchings>1`. We recommend, however, to only use
`tl.dpt` for computing pseudotime (`n_branchings=0`) and
to detect branchings via `paga`. For pseudotime, you need
to annotate your data with a root cell. 

This requires to run `pp.neighbors`, first. In order to
reproduce the original implementation of DPT, use `method=='gauss'` in
this. Using the default `method=='umap'` only leads to minor quantitative
differences, though.


If `n_branchings==0`, no field `dpt_groups` will be written.

- dpt_pseudotime : Array of dim (number of samples) that stores the pseudotime of each cell, that is, the DPT distance with respect to the root cell.
- dpt_groups : Array of dim (number of samples) that stores the subgroup id ('0','1', ...) for each cell. The groups  typically correspond to 'progenitor cells', 'undecided cells' or 'branches' of a process.

The tool is similar to the R package `destiny` of Angerer et al (2016).

More details on the `tl.dpt scanpy documentation
<https://icb-scanpy.readthedocs-hosted.com/en/stable/api/scanpy.tl.dpt.html>`_


Generate cellular maps of differentiation manifolds with complex topologies (`tl.paga`)
=======================================================================================

By quantifying the connectivity of partitions (groups, clusters) of the
single-cell graph, partition-based graph abstraction (PAGA) generates a much
simpler abstracted graph (*PAGA graph*) of partitions, in which edge weights
represent confidence in the presence of connections. By tresholding this
confidence in `paga`, a much simpler representation of data
can be obtained.

The confidence can be interpreted as the ratio of the actual versus the
expected value of connetions under the null model of randomly connecting
partitions. We do not provide a p-value as this null model does not
precisely capture what one would consider "connected" in real data, hence it
strongly overestimates the expected value. See an extensive discussion of
this in Wolf et al (2017).

Together with a random walk-based distance measure, this generates a partial
coordinatization of data useful for exploring and explaining its variation.

The returned AnnData object contains:

- Full adjacency matrix of the abstracted graph, weights correspond to confidence in the connectivities of partition (connectivities)
- Adjacency matrix of the tree-like subgraph that best explains the topology (connectivities_tree)

These datasets are stored in the unstructured annotation (uns) and can be accessed using the inspect tool for AnnData objects

More details on the `tl.paga scanpy documentation
<https://icb-scanpy.readthedocs-hosted.com/en/stable/api/scanpy.tl.paga.html>`_
    ]]></help>
    <expand macro="citations"/>
</tool>
