<tool id="scanpy_cluster_reduce_dimension" name="Cluster and reduce dimension with scanpy" version="@galaxy_version@">
    <description></description>
    <macros>
        <import>macros.xml</import>
        <xml name="pca_inputs">
            <param name="n_comps" type="integer" min="0" value="50" label="Number of principal components to compute" help=""/>
            <param name="dtype" type="text" value="float32" label="Numpy data type string to which to convert the result" help=""/>
            <conditional name="pca">
                <param name="chunked" type="select" label="Type of PCA?">
                    <option value="True">Incremental PCA on segments (incremental PCA automatically zero centers and ignores settings of `random_seed` and `svd_solver`)</option>
                    <option value="False" selected="true">Full PCA</option>
                </param>
                <when value="True">
                    <param name="chunk_size" type="integer" min="0" value="" label="chunk_size" help="Number of observations to include in each chunk"/>
                </when>
                <when value="False">
                    <param name="zero_center" type="boolean" truevalue="True" falsevalue="False" checked="true"
                        label="Compute standard PCA from covariance matrix?"
                        help="If not, it omits zero-centering variables (uses *TruncatedSVD* from scikit-learn), which allows to handle sparse input efficiently."/>
                    <expand macro="svd_solver"/> 
                    <param name="random_state" type="integer" value="0" label="Initial states for the optimization" help=""/>
                </when>
            </conditional>
        </xml>
        <token name="@CMD_pca_help@"><![CDATA[
The PCA is computed using the implementation of *scikit-learn*.

The returned AnnData object contains:

- PCA coordinates in the multi-dimensional observation annotation (obsm)
- Principal components containing the loadings in the multi-dimensional variable annotation (varm)
- The variance decomposition in the unstructured annotation (uns)
    - Ratio of explained variance for PCA (variance)
    - Explained variance, equivalent to the eigenvalues of the covariance matrix

This data is accessible using the inspect tool for AnnData
]]></token>
        <token name="@CMD_pca_params@"><![CDATA[
    data=adata,
    n_comps=$method.n_comps,
    dtype='$method.dtype',
    copy=False,
    chunked=$method.pca.chunked,
#if $method.pca.chunked == 'True'
    chunk_size=$method.pca.chunk_size
#else
    zero_center='$method.pca.zero_center',
    svd_solver='$method.pca.svd_solver',
    random_state=$method.pca.random_state
#end if
]]></token>
        <xml name="penalty">
            <param argument="penalty" type="select" label="Norm used in the penalization" help="">
                <option value="l1">l1</option>
                <option value="l2">l2</option>
                <option value="customized">customized</option>
            </param>
        </xml>
        <xml name="custom_penalty">
            <param argument="pen" type="text" value="" label="Norm used in the penalization" help=""/>
        </xml>
        <xml name="fit_intercept">
            <param argument="fit_intercept" type="boolean" truevalue="True" falsevalue="False" checked="true"
                label="Should a constant (a.k.a. bias or intercept) be added to the decision function?" help=""/>
        </xml>
        <xml name="random_state">
            <param argument="random_state" type="integer" value="" optional="true"
                label="The seed of the pseudo random number generator to use when shuffling the data" help=""/>
        </xml>
        <xml name="max_iter">
            <param argument="max_iter" type="integer" min="0" value="100" label="Maximum number of iterations taken for the solvers to converge" help=""/>
        </xml>
        <xml name="multi_class">
            <param argument="multi_class" type="select" label="Multi class" help="">
                <option value="ovr">ovr: a binary problem is fit for each label</option>
                <option value="multinomial">multinomial: the multinomial loss fit across the entire probability distribution, even when the data is binary</option>
                <option value="auto">auto: selects ‘ovr’ if the data is binary and otherwise selects ‘multinomial’</option>
            </param>
        </xml>
    </macros>
    <expand macro="requirements"/>
    <expand macro="version_command"/>
    <command detect_errors="exit_code"><![CDATA[
@CMD@
      ]]></command>
    <configfiles>
        <configfile name="script_file"><![CDATA[
@CMD_imports@
@CMD_read_inputs@

#if $method.method == 'tl.louvain'
sc.tl.louvain(
    adata=adata,
    flavor = '$method.flavor.flavor',
    #if $method.flavor.flavor == 'vtraag' and $method.flavor.resolution
    resolution=$method.flavor.resolution,
    #end if
    random_state=$method.random_state,
    key_added='$method.key_added',
    copy=False)

#else if $method.method == 'pp.pca'
sc.pp.pca(@CMD_pca_params@)

#else if $method.method == 'tl.pca'
sc.tl.pca(@CMD_pca_params@)

#else if $method.method == 'tl.diffmap'
sc.tl.diffmap(
    adata=adata,
    n_comps=$method.n_comps,
    copy =False)

#else if $method.method == 'tl.tsne'
sc.tl.tsne(
    adata=adata,
    #if $method.n_pcs
    n_pcs=$method.n_pcs,
    #end if
    perplexity=$method.perplexity,
    early_exaggeration=$method.early_exaggeration,
    learning_rate=$method.learning_rate,
    random_state=$method.random_state,
    copy=False)
np.savetxt('$X_tsne', adata.obsm['X_tsne'], delimiter='\t') 

#else if $method.method == 'tl.umap'
sc.tl.umap(
    adata=adata,
    min_dist=$method.min_dist,
    spread=$method.spread,
    n_components=$method.n_components,
    #if $method.maxiter
    maxiter=$method.maxiter,
    #end if
    alpha=$method.alpha,
    gamma=$method.gamma,
    negative_sample_rate=$method.negative_sample_rate,
    init_pos='$method.init_pos',
    random_state=$method.random_state,
    copy=False)

#else if $method.method == 'tl.draw_graph'

    #if str($method.adjacency) != 'None'
from scipy import io
adjacency = io.mmread('$method.adjacency')
    #end if

sc.tl.draw_graph(
    adata=adata,
    layout='$method.layout',
#if str($method.root) != ''
    #set $root=([int(x.strip()) for x in str($method.root).split(',')])
    root=$root,
#end if
    random_state=$method.random_state,
    #if str($method.init_pos) != ''
    init_pos='$method.init_pos',
    #end if
    #if str($method.adjacency) != 'None'
    adjacency=adjacency,
    #end if
    #if str($method.key_ext) != ''
    key_ext='$method.key_ext',
    #end if
    copy=False)

#else if $method.method == 'pp.neighbors'
sc.pp.neighbors(
    adata=adata,
    n_neighbors=$method.n_neighbors,
    #if str($method.n_pcs) != ''
    n_pcs=$method.n_pcs,
    #end if
    #if str($method.use_rep) != ''
    use_rep='$method.use_rep',
    #end if
    knn=$method.knn,
    random_state=$method.random_state,
    method='$method.pp_neighbors_method',
    metric='$method.metric',
    copy=False)

#else if $method.method == 'tl.rank_genes_groups'
sc.tl.rank_genes_groups(
    adata=adata,
    groupby='$method.groupby',
    use_raw=$method.use_raw,
    #if str($method.groups) != ''
    #set $group=[x.strip() for x in str($method.groups).split(',')]
    groups=$group,
    #end if
    #if $method.ref.rest == 'rest'
    reference='$method.ref.rest',
    #else
    reference='$method.ref.reference',
    #end if
    n_genes=$method.n_genes,
    method='$method.tl_rank_genes_groups_method.method',
    #if $method.tl_rank_genes_groups_method.method == 'logreg'
    solver='$method.tl_rank_genes_groups_method.solver.solver',
        #if $method.tl_rank_genes_groups_method.solver.solver == 'newton-cg'
    penalty='l2',
    fit_intercept=$method.tl_rank_genes_groups_method.solver.fit_intercept,
    max_iter=$method.tl_rank_genes_groups_method.solver.max_iter,
    multi_class='$method.tl_rank_genes_groups_method.solver.multi_class',
        #else if $method.tl_rank_genes_groups_method.solver.solver == 'lbfgs'
    penalty='l2',
    fit_intercept=$method.tl_rank_genes_groups_method.solver.fit_intercept,
    max_iter=$method.tl_rank_genes_groups_method.solver.max_iter,
    multi_class='$method.tl_rank_genes_groups_method.solver.multi_class',
        #else if $method.tl_rank_genes_groups_method.solver.solver == 'liblinear'
            #if $method.tl_rank_genes_groups_method.solver.penalty.penalty == 'l1'
    penalty='l1',
            #else if $method.tl_rank_genes_groups_method.solver.penalty.penalty == 'l2'
    penalty='l2',
    dual=$method.tl_rank_genes_groups_method.solver.penalty.dual,
            #else
    penalty='$method.tl_rank_genes_groups_method.solver.penalty.pen',
            #end if
    fit_intercept=$method.tl_rank_genes_groups_method.solver.intercept_scaling.fit_intercept,
            #if $method.tl_rank_genes_groups_method.solver.intercept_scaling.fit_intercept == 'True'
    intercept_scaling=$method.tl_rank_genes_groups_method.solver.intercept_scaling.intercept_scaling,
            #end if
            #if $method.tl_rank_genes_groups_method.solver.random_state
    random_state=$method.tl_rank_genes_groups_method.solver.random_state,
            #end if
        #else if $method.tl_rank_genes_groups_method.solver.solver == 'sag'
    penalty='l2',
    fit_intercept=$method.tl_rank_genes_groups_method.solver.fit_intercept,
            #if $method.tl_rank_genes_groups_method.solver.random_state
    random_state=$method.tl_rank_genes_groups_method.solver.random_state,
            #end if
    max_iter=$method.tl_rank_genes_groups_method.solver.max_iter,
    multi_class='$method.tl_rank_genes_groups_method.solver.multi_class',
        #else if $method.tl_rank_genes_groups_method.solver.solver == 'saga'
            #if $method.tl_rank_genes_groups_method.solver.penalty.penalty == 'l1'
    penalty='l1',
            #else if $method.tl_rank_genes_groups_method.solver.penalty.penalty == 'l2'
    penalty='l2',
            #else
    penalty='$method.tl_rank_genes_groups_method.solver.penalty.pen',
            #end if
    fit_intercept=$method.tl_rank_genes_groups_method.solver.fit_intercept,
    multi_class='$method.tl_rank_genes_groups_method.solver.multi_class',
        #end if
    tol=$method.tl_rank_genes_groups_method.tol,
    C=$method.tl_rank_genes_groups_method.c,
    #end if
    only_positive=$method.only_positive)
#end if

@CMD_anndata_write_outputs@
]]></configfile>
    </configfiles>
    <inputs>
        <expand macro="inputs_anndata"/>
        <conditional name="method">
            <param argument="method" type="select" label="Method used for plotting">
                <!--<option value="tl.leiden">, using `tl.leiden`</option>!-->
                <option value="tl.louvain">Cluster cells into subgroups, using `tl.louvain`</option>
                <option value="pp.pca">Computes PCA (principal component analysis) coordinates, loadings and variance decomposition, using `pp.pca`</option>
                <option value="tl.pca">Computes PCA (principal component analysis) coordinates, loadings and variance decomposition, using `tl.pca`</option>
                <option value="tl.diffmap">Diffusion Maps, using `tl.diffmap`</option>
                <option value="tl.tsne">t-distributed stochastic neighborhood embedding (tSNE), using `tl.tsne`</option>
                <option value="tl.umap">Embed the neighborhood graph using UMAP, using `tl.umap`</option>
                <option value="tl.draw_graph">Force-directed graph drawing, using `tl.draw_graph`</option>
                <!--<option value="tl.phate">, using `tl.phate`</option>!-->
                <option value="pp.neighbors">Compute a neighborhood graph of observations, using `pp.neighbors`</option>
                <option value="tl.rank_genes_groups">Rank genes for characterizing groups, using `tl.rank_genes_groups`</option>
            </param>
            <when value="tl.louvain">
                <conditional name="flavor">
                    <param argument="flavor" type="select" label="Flavor for the clustering" help="">
                        <option value="vtraag">vtraag (much more powerful)</option>
                        <option value="igraph">igraph</option>
                    </param>
                    <when value="vtraag">
                        <param argument="resolution" type="float" value="" optional="true"
                            label="Resolution"
                            help="Higher resolution means finding more and smaller clusters, which defaults to 1.0. See “Time as a resolution parameter” in Lambiotte et al, 2009"/>
                    </when>
                    <when value="igraph"/>
                </conditional>
                <param argument="random_state" type="integer" value="0" label="Random state" help="Change the initialization of the optimization."/>
                <param argument="key_added" type="text" value="louvain" optional="true" label="Key under which to add the cluster labels" help=""/>
            </when>
            <when value="pp.pca">
                <expand macro="pca_inputs"/>
            </when>
            <when value="tl.pca">
                <expand macro="pca_inputs"/>
            </when>
            <when value="tl.diffmap">
                <param argument="n_comps" type="integer" min="0" value="15" optional="true" label="Number of dimensions of the representation" help=""/>
            </when>
            <when value="tl.tsne">
                <param name="n_pcs" type="integer" min="0" value="" optional="true" label="Number of PCs to use" help=""/>
                <param name="perplexity" type="float" value="30" label="Perplexity" help="The perplexity is related to the number of nearest neighbors that is used in other manifold learning algorithms. Larger datasets usually require a larger perplexity. Consider selecting a value between 5 and 50. The choice is not extremely critical since t-SNE is quite insensitive to this parameter."/>
                <param name="early_exaggeration" type="float" value="12.0" label="Early exaggeration" help="Controls how tight natural clusters in the original space are in the embedded space and how much space will be between them. For larger values, the space between natural clusters will be larger in the embedded space. Again, the choice of this parameter is not very critical. If the cost function increases during initial optimization, the early exaggeration factor or the learning rate might be too high."/>
                <param name="learning_rate" type="float" value="1000" label="Learning rate" help="The learning rate can be a critical parameter. It should be between 100 and 1000. If the cost function increases during initial optimization, the early exaggeration factor or the learning rate might be too high. If the cost function gets stuck in a bad local minimum increasing the learning rate helps sometimes."/>
                <param name="random_state" type="integer" value="0" label="Random state" help="Change this to use different intial states for the optimization"/>
            </when>
            <when value="tl.umap">
                <param argument="min_dist" type="float" value="0.5" label="Effective minimum distance between embedded points" help="Smaller values will result in a more clustered/clumped embedding where nearby points on the manifold are drawn closer together, while larger values will result on a more even dispersal of points. The value should be set relative to the `spread` value, which determines the scale at which embedded points will be spread out. The default of in the `umap-learn` package is 0.1."/>
                <param argument="spread" type="float" value="1.0" label="Effective scale of embedded points" help="In combination with `min_dist` this determines how clustered/clumped the embedded points are."/>
                <param argument="n_components" type="integer" min="0" value="2" label="Number of dimensions of the embedding" help=""/>
                <param argument="maxiter" type="integer" min="0" value="" optional="true" label="Number of iterations (epochs) of the optimization" help="Called `n_epochs` in the original UMAP."/>
                <param argument="alpha" type="float" value="1.0" label="Initial learning rate for the embedding optimization" help=""/>
                <param argument="gamma" type="float" value="1.0" label="Weighting applied to negative samples in low dimensional embedding optimization" help="Values higher than one will result in greater weight being given to negative samples."/>
                <param argument="negative_sample_rate" type="integer" min="0" value="5" label="The number of negative edge/1-simplex samples to use per positive edge/1-simplex sample in optimizing the low dimensional embedding" help=""/>
                <param argument="init_pos" type="select" label="How to initialize the low dimensional embedding" help="Called `init` in the original UMAP">
                    <option value="paga">Position from paga</option>
                    <option value="spectral" selected="true">Spectral embedding of the graph</option>
                    <option value="random">Initial embedding positions at random</option>
                </param>
                <expand macro="param_random_state"/>
            </when>
            <when value="tl.draw_graph">
                <expand macro="param_layout"/>
                <expand macro="param_root"/>
                <expand macro="param_random_state"/>
                <param argument="init_pos" type="text" optional="true" value="" label="Precomputed coordinates for initialization" help="It should be a valid 2d observation (e.g. paga)"/>
                <param argument="adjacency" type="data" format="mtx" optional="true" label="Sparse adjacency matrix of the graph" help="If not set, it uses the unstructured annotation (uns) / neighbors / connectivities"/>
                <param argument="key_ext" type="text" optional="true" value="" label="External key" help="If not set, it appends `layout`"/>
            </when>
            <when value="pp.neighbors">
                <param argument="n_neighbors" type="integer" min="0" value="15" label="The size of local neighborhood (in terms of number of neighboring data points) used for manifold approximation" help="Larger values result in more global views of the manifold, while smaller values result in more local data being preserved. In general values should be in the range 2 to 100. If `knn` is `True`, number of nearest neighbors to be searched. If `knn` is `False`, a Gaussian kernel width is set to the distance of the `n_neighbors` neighbor."/>
                <param argument="n_pcs" type="integer" min="0" value="" optional="true" label="Number of PCs to use" help=""/>
                <param argument="use_rep" type="text" value="" optional="true" label="Indicated representation to use" help="If not set, the representation is chosen automatically: for n_vars below 50, X is used, otherwise X_pca (uns) is used. If X_pca is not present, it's computed with default parameter"/>
                <param argument="knn" type="boolean" truevalue="True" falsevalue="False" checked="true" label="Use a hard threshold to restrict the number of neighbors to n_neighbors?" help="If true, it considers a knn graph. Otherwise, it uses a Gaussian Kernel to assign low weights to neighbors more distant than the `n_neighbors` nearest neighbor."/>
                <param argument="random_state" type="integer" value="0" label="Numpy random seed" help=""/>
                <param name="pp_neighbors_method" argument="method" type="select" label="Method for computing connectivities" help="">
                    <option value="umap">umap (McInnes et al, 2018)</option>
                    <option value="gauss">gauss: Gauss kernel following (Coifman et al 2005) with adaptive width (Haghverdi et al 2016)</option>
                </param>
                <param argument="metric" type="select" label="Distance metric" help="">
                    <expand macro="distance_metric_options"/>
                </param>
            </when>
            <when value="tl.rank_genes_groups">
                <param argument="groupby" type="text" value="" label="The key of the observations grouping to consider" help=""/>
                <expand macro="param_use_raw"/>
                <param argument="groups" type="text" value="" label="Subset of groups to which comparison shall be restricted" help="e.g. ['g1', 'g2', 'g3']. If not passed, a ranking will be generated for all groups."/>
                <conditional name="ref">
                    <param name="rest" type="select" label="Comparison">
                        <option value="rest">Compare each group to the union of the rest of the group</option>
                        <option value="group_id">Compare with respect to a specific group</option>
                    </param>
                    <when value="rest"/>
                    <when value="group_id">
                        <param argument="reference" type="text" value="" label="Group identifier with respect to which compare"/>
                    </when>
                </conditional>
                <param argument="n_genes" type="integer" min="0" value="100" label="The number of genes that appear in the returned tables" help=""/>
                <conditional name="tl_rank_genes_groups_method">
                    <param argument="method" type="select" label="Method">
                        <option value="t-test">t-test</option>
                        <option value="wilcoxon">Wilcoxon-Rank-Sum</option>
                        <option value="t-test_overestim_var" selected="true">t-test with overestimate of variance of each group</option>
                        <option value="logreg">Logistic regression</option>
                    </param>
                    <when value="t-test"/>
                    <when value="wilcoxon"/>
                    <when value="t-test_overestim_var"/>
                    <when value="logreg">
                        <conditional name="solver">
                            <param argument="solver" type="select" label="Algorithm to use in the optimization problem" help="For small datasets, ‘liblinear’ is a good choice, whereas ‘sag’ and ‘saga’ are faster for large ones. For multiclass problems, only ‘newton-cg’, ‘sag’, ‘saga’ and ‘lbfgs’ handle multinomial loss; ‘liblinear’ is limited to one-versus-rest schemes. ‘newton-cg’, ‘lbfgs’ and ‘sag’ only handle L2 penalty, whereas ‘liblinear’ and ‘saga’ handle L1 penalty.">
                                <option value="newton-cg">newton-cg</option>
                                <option value="lbfgs">lbfgs</option>
                                <option value="liblinear">liblinear</option>
                                <option value="sag">sag</option>
                                <option value="saga">saga</option>
                            </param>
                            <when value="newton-cg">
                                <expand macro="fit_intercept"/>
                                <expand macro="max_iter"/>
                                <expand macro="multi_class"/>
                            </when>
                            <when value="lbfgs">
                                <expand macro="fit_intercept"/>
                                <expand macro="max_iter"/>
                                <expand macro="multi_class"/>
                            </when>
                            <when value="liblinear">
                                <conditional name="penalty">
                                    <expand macro="penalty"/>
                                    <when value="l1"/>
                                    <when value="l2">
                                        <param argument="dual" type="boolean" truevalue="True" falsevalue="False" checked="false"
                                            label="Dual (not primal) formulation?" help="Prefer primal when n_samples > n_features"/>
                                    </when>
                                    <when value="customized">
                                        <expand macro="custom_penalty"/>
                                    </when>
                                </conditional>
                                <conditional name="intercept_scaling">
                                    <param argument="fit_intercept" type="select"
                                        label="Should a constant (a.k.a. bias or intercept) be added to the decision function?" help="">
                                        <option value="True">Yes</option>
                                        <option value="False">No</option>
                                    </param>
                                    <when value="True">
                                        <param argument="intercept_scaling" type="float" value="1.0"
                                            label="Intercept scaling"
                                            help="x becomes [x, self.intercept_scaling], i.e. a 'synthetic' feature with constant value equal to intercept_scaling is appended to the instance vector. The intercept becomes intercept_scaling * synthetic_feature_weight."/>
                                    </when>
                                    <when value="False"/>
                                </conditional>
                                <expand macro="random_state"/>
                            </when>
                            <when value="sag">
                                <expand macro="fit_intercept"/>
                                <expand macro="random_state"/>
                                <expand macro="max_iter"/>
                                <expand macro="multi_class"/>
                            </when>
                            <when value="saga">
                                <conditional name="penalty">
                                    <expand macro="penalty"/>
                                    <when value="l1"/>
                                    <when value="l2"/>
                                    <when value="customized">
                                        <expand macro="custom_penalty"/>
                                    </when>
                                </conditional>
                                <expand macro="fit_intercept"/>
                                <expand macro="multi_class"/>
                            </when>
                        </conditional>
                        <param argument="tol" type="float" value="1e-4" label="Tolerance for stopping criteria" help=""/>
                        <param argument="c" type="float" value="1.0" label="Inverse of regularization strength"
                            help="It must be a positive float. Like in support vector machines, smaller values specify stronger regularization."/>
                    </when>
                </conditional>
                <param argument="only_positive" type="boolean" truevalue="True" falsevalue="False" checked="true"
                    label="Only consider positive differences?" help=""/>
            </when>
        </conditional>
    </inputs>
    <outputs>
        <expand macro="anndata_outputs"/>
        <data name="X_tsne" format="tabular" label="${tool.name} on ${on_string}: tSNE coordinates">
            <filter>method['method'] == 'tl.tsne'</filter>
        </data>
    </outputs>
    <tests>
        <test expect_num_outputs="1">
            <param name="adata" value="pp.neighbors_gauss_braycurtis.recipe_weinreb17.paul15_subsample.h5ad" />
            <conditional name="method">
                <param name="method" value="tl.louvain"/>
                <conditional name="flavor">
                    <param name="flavor" value="vtraag"/>
                    <param name="resolution" value="1.0"/>
                </conditional>
                <param name="random_state" value="10"/>
                <param name="key_added" value="louvain"/>
            </conditional>
            <assert_stdout>
                <has_text_matching expression="sc.tl.louvain"/>
                <has_text_matching expression="adata=adata"/>
                <has_text_matching expression="flavor = 'vtraag'"/>
                <has_text_matching expression="resolution=1.0"/>
                <has_text_matching expression="random_state=10"/>
                <has_text_matching expression="key_added='louvain'"/>
            </assert_stdout>
            <output name="anndata_out" file="tl.louvain.neighbors_gauss_braycurtis.recipe_weinreb17.paul15_subsample.h5ad" ftype="h5ad" compare="sim_size"/>
        </test>
        <test expect_num_outputs="1">
            <param name="adata" value="krumsiek11.h5ad" />
            <conditional name="method">
                <param name="method" value="pp.pca"/>
                <param name="n_comps" value="50"/>
                <param name="dtype" value="float32"/>
                <conditional name="pca">
                    <param name="chunked" value="False"/>
                    <param name="zero_center" value="True"/>
                    <param name="svd_solver" value="auto"/>
                    <param name="random_state" value="0"/>
                </conditional>
            </conditional>
            <assert_stdout>
                <has_text_matching expression="sc.pp.pca"/>
                <has_text_matching expression="n_comps=50"/>
                <has_text_matching expression="dtype='float32'"/>
                <has_text_matching expression="copy=False"/>
                <has_text_matching expression="chunked=False"/>
                <has_text_matching expression="zero_center='True'"/>
                <has_text_matching expression="svd_solver='auto'"/>
                <has_text_matching expression="random_state=0"/>
            </assert_stdout>
            <output name="anndata_out" file="pp.pca.krumsiek11.h5ad" ftype="h5ad" compare="sim_size"/>
        </test>
        <test expect_num_outputs="1">
            <param name="adata" value="krumsiek11.h5ad" />
            <conditional name="method">
                <param name="method" value="pp.pca"/>
                <param name="n_comps" value="20"/>
                <param name="dtype" value="float32"/>
                <conditional name="pca">
                    <param name="chunked" value="True"/>
                    <param name="chunk_size" value="50"/>
                </conditional>
            </conditional>
            <assert_stdout>
                <has_text_matching expression="sc.pp.pca"/>
                <has_text_matching expression="data=adata"/>
                <has_text_matching expression="n_comps=20"/>
                <has_text_matching expression="dtype='float32'"/>
                <has_text_matching expression="copy=False"/>
                <has_text_matching expression="chunked=True"/>
                <has_text_matching expression="chunk_size=50"/>
            </assert_stdout>
            <output name="anndata_out" file="pp.pca.krumsiek11_chunk.h5ad" ftype="h5ad" compare="sim_size"/>
        </test>
        <test expect_num_outputs="1">
            <param name="adata" value="krumsiek11.h5ad" />
            <conditional name="method">
                <param name="method" value="tl.pca"/>
                <param name="n_comps" value="50"/>
                <param name="dtype" value="float32"/>
                <conditional name="pca">
                    <param name="chunked" value="False"/>
                    <param name="zero_center" value="True"/>
                    <param name="svd_solver" value="auto"/>
                    <param name="random_state" value="0"/>
                </conditional>
            </conditional>
            <assert_stdout>
                <has_text_matching expression="sc.tl.pca"/>
                <has_text_matching expression="n_comps=50"/>
                <has_text_matching expression="dtype='float32'"/>
                <has_text_matching expression="copy=False"/>
                <has_text_matching expression="chunked=False"/>
                <has_text_matching expression="zero_center='True'"/>
                <has_text_matching expression="svd_solver='auto'"/>
            </assert_stdout>
            <output name="anndata_out" file="tl.pca.krumsiek11.h5ad" ftype="h5ad" compare="sim_size"/>
        </test>
        <test expect_num_outputs="1">
            <param name="adata" value="pp.neighbors_gauss_braycurtis.recipe_weinreb17.paul15_subsample.h5ad" />
            <conditional name="method">
                <param name="method" value="tl.diffmap"/>
                <param name="n_comps" value="15"/>
            </conditional>
            <assert_stdout>
                <has_text_matching expression="sc.tl.diffmap"/>
                <has_text_matching expression="n_comps=15"/>
            </assert_stdout>
            <output name="anndata_out" file="tl.diffmap.neighbors_gauss_braycurtis.recipe_weinreb17.paul15_subsample.h5ad" ftype="h5ad" compare="sim_size"/>
        </test>
        <test expect_num_outputs="2">
            <param name="adata" value="krumsiek11.h5ad" />
            <conditional name="method">
                <param name="method" value="tl.tsne"/>
                <param name="n_pcs" value="10"/>
                <param name="perplexity" value="30"/>
                <param name="early_exaggeration" value="12.0"/>
                <param name="learning_rate" value="1000"/>
                <param name="random_state" value="0"/>
            </conditional>
            <assert_stdout>
                <has_text_matching expression="sc.tl.tsne"/>
                <has_text_matching expression="n_pcs=10"/>
                <has_text_matching expression="perplexity=30.0"/>
                <has_text_matching expression="early_exaggeration=12.0"/>
                <has_text_matching expression="learning_rate=1000.0"/>
                <has_text_matching expression="random_state=0"/>
            </assert_stdout>
            <output name="anndata_out" file="tl.tsne.krumsiek11.h5ad" ftype="h5ad" compare="sim_size"/>
            <output name="X_tsne" file="tl.tsne.krumsiek11_X_tsne.tabular"/>
        </test>
        <test expect_num_outputs="2" >
            <param name="adata" value="pp.neighbors_umap_euclidean.recipe_weinreb17.paul15_subsample.h5ad" />
            <conditional name="method">
                <param name="method" value="tl.umap"/>
                <param name="min_dist" value="0.5"/>
                <param name="spread" value="1.0"/>
                <param name="n_components" value="2"/>
                <param name="maxiter" value="2"/>
                <param name="alpha" value="1.0"/>
                <param name="gamma" value="1.0"/>
                <param name="negative_sample_rate" value="5"/>
                <param name="init_pos" value="spectral"/>
                <param name="random_state" value="0"/>
            </conditional>
            <assert_stdout>
                <has_text_matching expression="sc.tl.umap"/>
                <has_text_matching expression="min_dist=0.5"/>
                <has_text_matching expression="spread=1.0"/>
                <has_text_matching expression="n_components=2"/>
                <has_text_matching expression="maxiter=2"/>
                <has_text_matching expression="alpha=1.0"/>
                <has_text_matching expression="gamma=1.0"/>
                <has_text_matching expression="negative_sample_rate=5"/>
                <has_text_matching expression="init_pos='spectral'"/>
                <has_text_matching expression="random_state=0"/>
            </assert_stdout>
            <output name="anndata_out" file="tl.umap.neighbors_umap_euclidean.recipe_weinreb17.paul15_subsample.h5ad" ftype="h5ad" compare="sim_size">
                <assert_contents>
                    <has_h5_keys keys="X, obs, obsm, uns, var" />
                </assert_contents>
            </output>
        </test>
        <test expect_num_outputs="1" >
            <param name="adata" value="" />
            <conditional name="method">
                <param name="method" value="tl.draw_graph"/>
                <param name="layout" value="fa"/>
                <param name="random_state" value="0"/>
            </conditional>
            <assert_stdout>
                <has_text_matching expression="sc.tl.draw_graph"/>
                <has_text_matching expression="layout=fa"/>
                <has_text_matching expression="random_state=0"/>
            </assert_stdout>
            <output name="anndata_out" file="tl.draw_graph." ftype="h5ad" compare="sim_size"/>
        </test>
        <test expect_num_outputs="1">
            <param name="adata" value="pp.recipe_weinreb17.paul15_subsample.h5ad" />
            <conditional name="method">
                <param name="method" value="pp.neighbors"/>
                <param name="n_neighbors" value="15"/>
                <param name="knn" value="True"/>
                <param name="random_state" value="0"/>
                <param name="pp_neighbors_method" value="umap"/>
                <param name="metric" value="euclidean"/>
            </conditional>
            <assert_stdout>
                <has_text_matching expression="sc.pp.neighbors"/>
                <has_text_matching expression="n_neighbors=15"/>
                <has_text_matching expression="knn=True"/>
                <has_text_matching expression="random_state=0"/>
                <has_text_matching expression="method='umap'"/>
                <has_text_matching expression="metric='euclidean'"/>
            </assert_stdout>
            <output name="anndata_out" file="pp.neighbors_umap_euclidean.recipe_weinreb17.paul15_subsample.h5ad" ftype="h5ad" compare="sim_size">
                <assert_contents>
                    <has_h5_keys keys="X, obs, obsm, uns, var" />
                </assert_contents>
            </output>
        </test>
        <test expect_num_outputs="1">
            <param name="adata" value="pp.recipe_weinreb17.paul15_subsample.h5ad" />
            <conditional name="method">
                <param name="method" value="pp.neighbors"/>
                <param name="n_neighbors" value="15"/>
                <param name="knn" value="True"/>
                <param name="pp_neighbors_method" value="gauss"/>
                <param name="metric" value="braycurtis"/>
            </conditional>
            <assert_stdout>
                <has_text_matching expression="sc.pp.neighbors"/>
                <has_text_matching expression="n_neighbors=15"/>
                <has_text_matching expression="knn=True"/>
                <has_text_matching expression="random_state=0"/>
                <has_text_matching expression="method='gauss'"/>
                <has_text_matching expression="metric='braycurtis'"/>
            </assert_stdout>
            <output name="anndata_out" file="pp.neighbors_gauss_braycurtis.recipe_weinreb17.paul15_subsample.h5ad" ftype="h5ad" compare="sim_size"/>
        </test>
        <test>
            <param name="adata" value="krumsiek11.h5ad" />
            <conditional name="method">
                <param name="method" value="tl.rank_genes_groups"/>
                <param name="groupby" value="cell_type"/>
                <param name="use_raw" value="True"/>
                <conditional name="ref">
                    <param name="rest" value="rest"/>
                </conditional>
                <param name="n_genes" value="100"/>
                <conditional name="tl_rank_genes_groups_method">
                    <param name="method" value="t-test_overestim_var"/>
                </conditional>
                <param name="only_positive" value="True"/>
            </conditional>
            <assert_stdout>
                <has_text_matching expression="sc.tl.rank_genes_groups"/>
                <has_text_matching expression="groupby='cell_type'"/>
                <has_text_matching expression="use_raw=True"/>
                <has_text_matching expression="reference='rest'"/>
                <has_text_matching expression="n_genes=100"/>
                <has_text_matching expression="method='t-test_overestim_var'"/>
                <has_text_matching expression="only_positive=True"/>
            </assert_stdout>
            <output name="anndata_out" file="tl.rank_genes_groups.krumsiek11.h5ad" ftype="h5ad" compare="sim_size"/>
        </test>
        <test>
            <param name="adata" value="pbmc68k_reduced.h5ad" />
            <conditional name="method">
                <param name="method" value="tl.rank_genes_groups"/>
                <param name="groupby" value="louvain"/>
                <param name="use_raw" value="True"/>
                <conditional name="ref">
                    <param name="rest" value="rest"/>
                </conditional>
                <param name="n_genes" value="100"/>
                <conditional name="tl_rank_genes_groups_method">
                    <param name="method" value="logreg"/>
                    <conditional name="solver">
                        <param name="solver" value="newton-cg"/>
                        <param name="fit_intercept" value="True"/>
                        <param name="max_iter" value="100"/>
                        <param name="multi_class" value="auto"/>
                    </conditional>
                    <param name="tol" value="1e-4"/>
                    <param name="c" value="1.0"/>
                </conditional>
                <param name="only_positive" value="True"/>
            </conditional>
            <assert_stdout>
                <has_text_matching expression="sc.tl.rank_genes_groups"/>
                <has_text_matching expression="groupby='louvain'"/>
                <has_text_matching expression="use_raw=True"/>
                <has_text_matching expression="reference='rest'"/>
                <has_text_matching expression="n_genes=100"/>
                <has_text_matching expression="method='logreg'"/>
                <has_text_matching expression="solver='newton-cg'"/>
                <has_text_matching expression="penalty='l2'"/>
                <has_text_matching expression="fit_intercept=True"/>
                <has_text_matching expression="max_iter=100"/>
                <has_text_matching expression="multi_class='auto'"/>
                <has_text_matching expression="tol=0.0001"/>
                <has_text_matching expression="C=1.0"/>
                <has_text_matching expression="only_positive=True"/>
            </assert_stdout>
            <output name="anndata_out" ftype="h5ad">
                <assert_contents>
                    <has_h5_keys keys="X, obs, obsm, raw.X, raw.var, uns, var" />
                </assert_contents>
            </output>
        </test>
        <test>
            <param name="adata" value="pbmc68k_reduced.h5ad" />
            <conditional name="method">
                <param name="method" value="tl.rank_genes_groups"/>
                <param name="groupby" value="louvain"/>
                <param name="use_raw" value="True"/>
                <conditional name="ref">
                    <param name="rest" value="rest"/>
                </conditional>
                <param name="n_genes" value="100"/>
                <conditional name="tl_rank_genes_groups_method">
                    <param name="method" value="logreg"/>
                    <conditional name="solver">
                        <param name="solver" value="liblinear"/>
                        <conditional name="penalty">
                            <param name="penalty" value="l2"/>
                            <param name="dual" value="False"/>
                            <conditional name="intercept_scaling">
                                <param name="fit_intercept" value="True"/>
                                <param name="intercept_scaling" value="1.0" />
                            </conditional>
                            <param name="random_state" value="1"/>
                        </conditional>
                    </conditional>
                    <param name="tol" value="1e-4"/>
                    <param name="c" value="1.0"/>
                </conditional>
                <param name="only_positive" value="True"/>
            </conditional>
            <assert_stdout>
                <has_text_matching expression="sc.tl.rank_genes_groups"/>
                <has_text_matching expression="groupby='louvain'"/>
                <has_text_matching expression="use_raw=True"/>
                <has_text_matching expression="reference='rest'"/>
                <has_text_matching expression="n_genes=100"/>
                <has_text_matching expression="method='logreg'"/>
                <has_text_matching expression="solver='liblinear'"/>
                <has_text_matching expression="penalty='l2'"/>
                <has_text_matching expression="dual=False"/>
                <has_text_matching expression="fit_intercept=True"/>
                <has_text_matching expression="intercept_scaling=1.0"/>
                <has_text_matching expression="tol=0.0001"/>
                <has_text_matching expression="C=1.0"/>
                <has_text_matching expression="only_positive=True"/>
            </assert_stdout>
            <output name="anndata_out" ftype="h5ad">
                <assert_contents>
                    <has_h5_keys keys="X, obs, obsm, raw.X, raw.var, uns, var" />
                </assert_contents>
            </output>
        </test>
    </tests>
    <help><![CDATA[
Cluster cells into subgroups, using `tl.louvain`
================================================

Cluster cells using the Louvain algorithm (Blondel et al, 2008) in the implementation
of Traag et al,2017. The Louvain algorithm has been proposed for single-cell
analysis by Levine et al, 2015.

This requires to run `pp.neighbors`, first.

More details on the `scanpy documentation
<https://scanpy.readthedocs.io/en/latest/api/scanpy.api.tl.louvain.html#scanpy.api.tl.louvain>`_

Computes PCA (principal component analysis) coordinates, loadings and variance decomposition, using `pp.pca`
============================================================================================================

@CMD_pca_outputs@

More details on the `scanpy documentation
<https://scanpy.readthedocs.io/en/latest/api/scanpy.api.pp.pca.html#scanpy.api.pp.pca>`__

Computes PCA (principal component analysis) coordinates, loadings and variance decomposition, using `tl.pca`
============================================================================================================

@CMD_pca_outputs@

More details on the `scanpy documentation
<https://scanpy.readthedocs.io/en/latest/api/scanpy.api.tl.pca.html#scanpy.api.tl.pca>`__

Diffusion Maps, using `tl.diffmap`
==================================

Diffusion maps (Coifman et al  2005) has been proposed for visualizing single-cell
data by Haghverdi et al (2015). The tool uses the adapted Gaussian kernel suggested
by Haghverdi et al (2016) in the implementation of Wolf et al (2017).

The width ("sigma") of the connectivity kernel is implicitly determined by
the number of neighbors used to compute the single-cell graph in
`pp.neighbors`. To reproduce the original implementation
using a Gaussian kernel, use `method=='gauss'` in
`pp.neighbors`. To use an exponential kernel, use the default
`method=='umap'`. Differences between these options shouldn't usually be
dramatic.

The diffusion map representation of data are added to the return AnnData in the multi-dimensional 
observations annotation (obsm). It is the right eigen basis of the transition matrix with eigenvectors 
as colum. It can be accessed using the inspect tool for AnnData

More details on the `scanpy documentation
<https://scanpy.readthedocs.io/en/latest/api/scanpy.api.tl.diffmap.html#scanpy.api.tl.diffmap>`__

t-distributed stochastic neighborhood embedding (tSNE), using `tl.tsne`
=======================================================================

t-distributed stochastic neighborhood embedding (tSNE) (Maaten et al, 2008) has been
proposed for visualizating single-cell data by (Amir et al, 2013). Here, by default,
we use the implementation of *scikit-learn* (Pedregosa et al, 2011). 

It returns `X_tsne`, tSNE coordinates of data.

More details on the `scanpy documentation
<https://scanpy.readthedocs.io/en/latest/api/scanpy.api.tl.tsne.html#scanpy.api.tl.tsne>`__

Embed the neighborhood graph using UMAP, using `tl.umap`
========================================================

UMAP (Uniform Manifold Approximation and Projection) is a manifold learning
technique suitable for visualizing high-dimensional data. Besides tending to
be faster than tSNE, it optimizes the embedding such that it best reflects
the topology of the data, which we represent throughout Scanpy using a
neighborhood graph. tSNE, by contrast, optimizes the distribution of
nearest-neighbor distances in the embedding such that these best match the
distribution of distances in the high-dimensional space.  We use the
implementation of `umap-learn <https://github.com/lmcinnes/umap>`__
(McInnes et al, 2018). For a few comparisons of UMAP with tSNE, see this `preprint
<https://doi.org/10.1101/298430>`__.

The UMAP coordinates of data are added to the return AnnData in the multi-dimensional 
observations annotation (obsm). This data is accessible using the inspect tool for AnnData

More details on the `scanpy documentation
<https://scanpy.readthedocs.io/en/latest/api/scanpy.api.tl.umap.html#scanpy.api.tl.umap>`__

Force-directed graph drawing, using `tl.draw_graph`
===================================================

Force-directed graph drawing describes a class of long-established algorithms for visualizing graphs. 
It has been suggested for visualizing single-cell data by Islam et al, 11. 
Many other layouts as implemented in igraph are available. Similar approaches have been used by 
Zunder et al, 2015 or Weinreb et al, 2016.

This is an alternative to tSNE that often preserves the topology of the data better. 
This requires to run `pp.neighbors`, first.

The default layout (ForceAtlas2) uses the package fa2.

The coordinates of graph layout are added to the return AnnData in the multi-dimensional 
observations annotation (obsm). This data is accessible using the inspect tool for AnnData.

More details on the `scanpy documentation
<https://scanpy.readthedocs.io/en/latest/api/scanpy.api.tl.draw_graph.html>`__

Compute a neighborhood graph of observations, using `pp.neighbors`
==================================================================

The neighbor search efficiency of this heavily relies on UMAP (McInnes et al, 2018),
which also provides a method for estimating connectivities of data points -
the connectivity of the manifold (`method=='umap'`). If `method=='diffmap'`,
connectivities are computed according to Coifman et al (2005), in the adaption of
Haghverdi et al (2016).

The returned AnnData object contains:

- Weighted adjacency matrix of the neighborhood graph of data points (connectivities). Weights should be interpreted as connectivities.
- Distances for each pair of neighbors (distances)

This data are stored in the unstructured annotation (uns) and can be accessed using the inspect tool for AnnData objects

More details on the `scanpy documentation
<https://scanpy.readthedocs.io/en/latest/api/scanpy.api.pp.neighbors.html#scanpy.api.pp.neighbors>`__

Rank genes for characterizing groups, using `tl.rank_genes_groups`
==================================================================

The returned AnnData object contains:

- Gene names, ordered according to scores
- Z-score underlying the computation of a p-value for each gene for each group, prdered according to scores
- Log2 fold change for each gene for each group, ordered according to scores. It is only provided if method is ‘t-test’ like. This is an approximation calculated from mean-log values.
- P-values
- Ajusted p-values

This data are stored in the unstructured annotation (uns) and can be accessed using the inspect tool for AnnData objects

More details on the `scanpy documentation
<https://scanpy.readthedocs.io/en/latest/api/scanpy.api.tl.rank_genes_groups.html#scanpy.api.tl.rank_genes_groups>`__

    ]]></help>
    <expand macro="citations"/>
</tool>
