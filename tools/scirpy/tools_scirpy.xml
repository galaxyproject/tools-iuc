<tool id="tools_scirpy" name="Define, Analyze, Process and Query Clonotypes and Clonal Diversity with Scirpy" version="0.1.0">
    <requirements>
        <requirement type="package" version="1.7.0">scanpy</requirement>
        <requirement type="package" version="0.11.2">scirpy</requirement>
    </requirements>
    <command detect_errors="exit_code"><![CDATA[
        python '$script_file'
]]></command>
    <configfiles>
        <configfile name="script_file"><![CDATA[import scanpy as sc
import scirpy as ir
#if $method.method == 'tl_group_abundance'
adata = sc.read_h5ad('$method.tl_group_abundance_adata')
adata.uns['scirpy_version'] = '0.7'

summary = ir.tl.group_abundance(
    adata,
    groupby='$method.tl_group_abundance_groupby',
    target_col='$method.tl_group_abundance_target_col',
    fraction=None,
    sort='$method.tl_group_abundance_sort'
)
adata.write('tl_adata_out.h5ad')

#else if $method.method == 'tl_chain_qc'
adata = sc.read_h5ad('$method.tl_chain_qc_adata')
receptor_type = '$method.tl_chain_qc_receptor_type'
receptor_subtype = '$method.tl_chain_qc_receptor_subtype'
chain_pairing = '$method.tl_chain_qc_chain_pairing'
key_added = (receptor_type, receptor_subtype, chain_pairing)

ir.tl.chain_qc(
    adata,
    key_added=key_added
)
adata.write('tl_adata_out.h5ad')

#else if $method.method == 'tl_define_clonotypes'
adata = sc.read_h5ad('$method.tl_define_clonotypes_adata')
ir.tl.define_clonotypes(
    adata,
    receptor_arms='$method.tl_define_clonotypes_receptor_arms',
    dual_ir='$method.tl_define_clonotypes_dual_ir',
    within_group='$method.tl_define_clonotypes_within_group',
    key_added='$method.tl_define_clonotypes_key_added'
)
adata.write('tl_adata_out.h5ad')

#else if $method.method == 'tl_define_clonotype_clusters'
adata = sc.read_h5ad('$method.tl_define_clonotype_clusters_adata')

ir.tl.define_clonotype_clusters(
    adata,
    sequence='$method.tl_define_clonotype_clusters_sequence',
    metric='$method.tl_define_clonotype_clusters_metric',
    receptor_arms='$method.tl_define_clonotype_clusters_receptor_arms',
    dual_ir='$method.tl_define_clonotype_clusters_dual_ir',
    same_v_gene=$method.tl_define_clonotype_clusters_same_v_gene,
    within_group='$method.tl_define_clonotype_clusters_within_group',
    key_added='$method.tl_define_clonotype_clusters_key_added',
    partitions='$method.tl_define_clonotype_clusters_partitions',
    resolution=$method.tl_define_clonotype_clusters_resolution,
    n_iterations=$method.tl_define_clonotype_clusters_n_iterations,
    distance_key='$method.tl_define_clonotype_clusters_distance_key'
)
adata.write('tl_adata_out.h5ad')

#else if $method.method == 'tl_clonotype_convergence'
adata = sc.read_h5ad('$method.tl_clonotype_convergence_adata')

ir.tl.clonotype_convergence(
    adata,
    key_coarse='$method.tl_clonotype_convergence_key_coarse',
    key_fine='$method.tl_clonotype_convergence_key_fine',
    key_added='$method.tl_clonotype_convergence_key_added'
)
adata.write('tl_adata_out.h5ad')

#else if $method.method == 'tl_clonotype_network'
adata = sc.read_h5ad('$method.tl_clonotype_network_adata')

ir.tl.clonotype_network(
    adata,
    sequence='$method.tl_clonotype_network_sequence',
    metric='$method.tl_clonotype_network_metric',
    min_cells=$method.tl_clonotype_network_min_cells,
    min_nodes=$method.tl_clonotype_network_min_nodes,
    layout='$method.tl_clonotype_network_layout',
    size_aware='$method.tl_clonotype_network_size_aware',
    size_power=$method.tl_clonotype_network_size_power,
    key_added='$method.tl_clonotype_network_key_added'
)
adata.write('tl_adata_out.h5ad')

#else if $method.method == 'tl_clonotype_network_igraph'
adata = sc.read_h5ad('$method.tl_clonotype_network_igraph_adata')
igraph, layout_obj = ir.tl.clonotype_network_igraph(
    adata,
    basis='$method.tl_clonotype_network_igraph_basis'
)
adata.write('tl_adata_out.h5ad')

#else if $method.method == 'tl_clonal_expansion'
adata = sc.read_h5ad('$method.tl_clonal_expansion_adata')

ir.tl.clonal_expansion(
    adata,
    target_col='$method.tl_clonal_expansion_target_col',
    clip_at=$method.tl_clonal_expansion_clip_at,
    key_added='$method.tl_clonal_expansion_key_added'
)
adata.write('tl_adata_out.h5ad')

#else if $method.method == 'tl_summarize_clonal_expansion'
adata = sc.read_h5ad('$method.tl_summarize_clonal_expansion_adata')

ir.tl.summarize_clonal_expansion(
    adata,
    groupby='$method.tl_summarize_clonal_expansion_group_by',
    target_col='$method.tl_summarize_clonal_expansion_target_col',
    summarize_by='$method.tl_summarize_clonal_expansion_summarize_by',
    normalize=$method.tl_summarize_clonal_expansion_normalize
)
adata.write('tl_adata_out.h5ad')

#else if $method.method == 'tl_alpha_diversity'
adata = sc.read_h5ad('$method.tl_alpha_diversity_adata')

ir.tl.alpha_diversity(
    adata,
    groupby='$method.tl_alpha_diversity_group_by',
    target_col='$method.tl_alpha_diversity_target_col',
    metric='$method.tl_alpha_diversity_metric',
    key_added='$method.tl_alpha_diversity_key_added'
)
adata.write('tl_adata_out.h5ad')

#else if $method.method == 'tl_repertoire_overlap'
adata = sc.read_h5ad('$method.tl_repertoire_overlap_adata')

ir.tl.repertoire_overlap(
    adata,
    groupby='$method.tl_repertoire_overlap_group_by',
    target_col='$method.tl_repertoire_overlap_target_col',
    overlap_measure='$method.tl_repertoire_overlap_overlap_measure',
    fraction=$method.tl_repertoire_overlap_fraction,
    added_key='$method.tl_repertoire_overlap_added_key'
)
adata.write('tl_adata_out.h5ad')

#else if $method.method == 'tl_clonotype_modularity'
adata = sc.read_h5ad('$method.tl_clonotype_modularity_adata')

ir.tl.clonotype_modularity(
    adata,
    target_col='$method.tl_clonotype_modularity_target_col',
    connectivity_key='$method.tl_clonotype_modularity_connectivity_key',
    permutation_test='$method.tl_clonotype_modularity_permutation_test',
    n_permutations=$method.tl_clonotype_modularity_n_permutations,
    key_added='$method.tl_clonotype_modularity_key_added',
    fdr_correction=$method.tl_clonotype_modularity_fdr_correction,
    random_state=$method.tl_clonotype_modularity_random_state
)
adata.write('tl_adata_out.h5ad')

#else if $method.method == 'tl_clonotype_imbalance'
adata = sc.read_h5ad('$method.tl_clonotype_imbalance_adata')

freq, stat = ir.tl.clonotype_imbalance(
    adata,
    replicate_col="$method.tl_clonotype_imbalance_replicate_col",
    groupby="$method.tl_clonotype_imbalance_groupby",
    case_label="$method.tl_clonotype_imbalance_case_label",
    control_label="$method.tl_clonotype_imbalance_control_label",
    inplace=False,
)
adata.write('tl_adata_out.h5ad')


#else if $method.method == 'tl_ir_query'
adata = sc.read_h5ad('$method.tl_ir_query_adata')
query_reference = sc.read_h5ad('$method.tl_ir_query_reference')

ir.tl.ir_query(
    adata,
    query_reference,
    sequence='$method.tl_ir_query_sequence',
    metric='$method.tl_ir_query_metric',
    receptor_arms='$method.tl_ir_query_receptor_arms',
    dual_ir='$method.tl_ir_query_dual_ir',
    same_v_gene=$method.tl_ir_query_same_v_gene,
    match_columns=None,
    key_added='$method.tl_ir_query_key_added',
    distance_key='$method.tl_ir_query_distance_key'
)
adata.write('tl_adata_out.h5ad')

#else if $method.method == 'tl_ir_query_annotate'
adata = sc.read_h5ad('$method.tl_ir_query_annotate_adata')
query_reference = sc.read_h5ad('$method.tl_ir_query_annotate_reference')

ir.tl.ir_query_annotate(
    adata,
    query_reference,
    sequence='$method.tl_ir_query_annotate_sequence',
    metric='$method.tl_ir_query_annotate_metric',
    strategy='$method.tl_ir_query_annotate_strategy',
    include_ref_cols=None,
    query_key=None,
    suffix='$method.tl_ir_query_annotate_suffix'
)
adata.write('tl_adata_out.h5ad')

#else if $method.method == 'tl_ir_query_annotate_df'
adata = sc.read_h5ad('$method.tl_ir_query_annotate_df_adata')
query_reference = sc.read_h5ad('$method.tl_ir_query_annotate_df_reference')

ir.tl.ir_query_annotate_df(
    adata,
    query_reference,
    sequence='$method.tl_ir_query_annotate_df_sequence',
    metric='$method.tl_ir_query_annotate_df_metric',
    include_ref_cols=None,
    include_query_cols=(),
    query_key=None,
    suffix='$method.tl_ir_query_annotate_df_suffix'
)
adata.write('tl_adata_out.h5ad')

#else if $method.method == 'tl_spectratype'
adata = sc.read_h5ad('$method.tl_spectratype_adata')

ir.tl.spectratype(
    adata,
    groupby='$method.tl_spectratype_groupby',
    target_col='$method.tl_spectratype_target_col',
    fraction=$method.tl_spectratype_fraction
)
adata.write('tl_adata_out.h5ad')

#end if
]]></configfile>
    </configfiles>
    <inputs>
        <conditional name="method">
            <param argument="method" type="select" label="Method to use from 'scirpy.tl'">
                <option value="tl_group_abundance">Generic: Summarize the number/fraction of cells of a certain category by a certain group, using 'tl.group_abundance'</option>
                <option value="tl_chain_qc">Quality control: Perform quality control based on the receptor-chain pairing configuration, using 'tl.chain_qc'</option>
                <option value="tl_define_clonotypes">Define and visualize clonotypes: Define clonotypes based on CDR3 nucleic acid sequence identity, using 'tl.define_clonotypes'</option>
                <option value="tl_define_clonotype_clusters">Define and visualize clonotypes: Define clonotype clusters, using 'tl.define_clonotype_clusters'</option>
                <option value="tl_clonotype_convergence">Define and visualize clonotypes: Find evidence for Convergent evolution of clonotypes, using 'tl.clonotype_convergence'</option>
                <option value="tl_clonotype_network">Define and visualize clonotypes: Compute the layout of the clonotype network, using 'tl.clonotype_network'</option>
                <option value="tl_clonotype_network_igraph">Define and visualize clonotypes: Get an igraph object representing the clonotype network, using 'tl.clonotype_network_igraph'</option>
                <option value="tl_clonal_expansion">Analyze clonal diversity: Record which clonotypes are expanded, using 'tl.clonal_expansion'</option>
                <option value="tl_summarize_clonal_expansion">Analyze clonal diversity: Summarize clonal expansion by a grouping variable, using 'tl.summarize_clonal_expansion'</option>
                <option value="tl_alpha_diversity">Analyze clonal diversity: Compute the alpha diversity of clonotypes within a group, using 'tl.alpha_diversity'</option>
                <option value="tl_repertoire_overlap">Analyze clonal diversity: Compute distance between cell groups based on clonotype overlap, using 'tl.repertoire_overlap'</option>
                <option value="tl_clonotype_modularity">Analyze clonal diversity: Identify clonotypes or clonotype clusters consisting of cells that are more transcriptionally related than expected by chance by computing the Clonotype modularity, using 'tl.clonotype_modularity'</option>
                <option value="tl_clonotype_imbalance">Analyze clonal diversity: Compute clonotype imbalance, using 'tl.clonotype_imbalance'</option>
                <option value="tl_ir_query">Query reference database: Query a referece database for matching immune cell receptors, using 'tl.ir_query'</option>
                <option value="tl_ir_query_annotate">Query reference database: Annotate cells based on the result of ir_query(), using 'ir_query_annotate'</option>
                <option value="tl_ir_query_annotate_df">Query reference database: Returns the inner join of adata.obs with matching entries from reference.obs based on the result of ir_query(), using 'tl.ir_query_annotate_df'</option>
                <option value="tl_spectratype">V(D)J gene usage: Summarize the distribution of CDR3 region lengths, using 'tl.spectratype'</option>
            </param>
            <when value="tl_group_abundance">
                <param name="tl_group_abundance_adata" type="data" format="h5ad" label="Annotated data matrix file"/>
                <param name="tl_group_abundance_groupby" type="text" value="sample" label="Group by this column from obs" help="(groupby)"/>
                <param name="tl_group_abundance_target_col" type="text" value="has_ir" help="(target_col)" label="Categorical variable from .obs according to which the abundance/fractions will be computed."/>
<!--                <param name="tl_group_abundance_fraction" type="select" help="(fraction)" label="Compute fractions of abundances relative to the groupby column, rather than report abosolute numbers?">-->
<!--                    <option value="True">Yes</option>-->
<!--                    <option value="False">No</option>-->
<!--                    <option value="None" selected="true">None (NA for dataset)</option>-->
<!--                </param>-->
                <param name="tl_group_abundance_sort" type="select" help="(sort)" label="Arrange columns by:">
                    <option value="count" selected="true">Category count (count)</option>
                    <option value="alphabetical">Alphabetical (alphabetical)</option>
                </param>
            </when>
            <when value="tl_chain_qc">
                <param name="tl_chain_qc_adata" type="data" format="h5ad" label="Annotated data matrix file"/>
                <param name="tl_chain_qc_receptor_type" type="select" help="(receptor_type)" label="Receptor type to categorize cells into">
                    <option value="TCR" selected="true">TCR: all cells that contain any combination of TRA/TRB/TRG/TRD chains, but no IGH/IGK/IGL chains</option>
                    <option value="BCR">BCR: all cells that contain any combination of IGH/IGK/IGL chains, but no TCR chain</option>
                    <option value="ambiguous">Ambiguous: all cells that contain both BCR and TCR chains</option>
                    <option value="multichain">Multichain: all cells with more than two VJ or more than two VDJ chains</option>
                    <option value="no IR">No IR: all cells without any detected immune receptor</option>
                    <option value="receptor_type" selected="true">Default ('receptor_type')</option>
                </param>
                <param name="tl_chain_qc_receptor_subtype" type="select" help="(receptor_subtype)" label="Receptor subtype to categorize cells into">
                    <option value="TRA+TRB">TRA + TRB: all cells that have only TRA and/or TRB chains</option>
                    <option value="TRG+TRD">TRG + TRD: all cells that have only TRG and/or TRD chains</option>
                    <option value="IGH">IGH: all cells that have only IGH chains, but no IGL or IGK</option>
                    <option value="IGH+IGL">IGH + IGL: all cells that have only IGH and IGL chains</option>
                    <option value="IGH+IGK">IGH + IGK: all cells that have only IGH and IGK chains</option>
                    <option value="multichain">Multichain: all cells with more than two VJ or more than two VDJ chains</option>
                    <option value="ambiguous">Ambiguous: all cells that are none of the above, e.g. TRA+TRD, TRA+IGH or, IGH+IGK as the primary and IGH+IGL as the secondary receptor</option>
                    <option value="no IR">No IR: all cells without any detected immune receptor</option>
                    <option value="receptor_subtype" selected="true">Default ('receptor_subtype')</option>
                </param>
                <param name="tl_chain_qc_chain_pairing" type="select" help="(chain_pairing)" label="Chain pairing">
                    <option value="single pair">Single pair: all cells that have exactely one matched VJ and VDJ chain</option>
                    <option value="orphan VJ">Orphan VJ: all cells that have only one VJ chain</option>
                    <option value="orphan VDJ">Orphan VDJ: all cells that have only one VDJ chain</option>
                    <option value="extra VJ">Extra VJ: all cells that have a matched pair of VJ and VDJ chains plus an additional VJ-chain</option>
                    <option value="extra VDJ">Extra VDJ: all cells that have a matched pair of VJ and VDJ chains plus an additional VDJ-chain</option>
                    <option value="two full chains">Two full chains: all cells that have two matched pairs of VJ and VDJ chains</option>
                    <option value="ambiguous">Ambiguous: all cells that have unmatched chains, i.e. that have been classified as an ambiguous receptor_subtype</option>
                    <option value="multichain">Multichain: all cells with more than two VJ or more than two VDJ chains</option>
                    <option value="no IR">No IR: all chains with not immune receptor chains)</option>
                    <option value="chain_pairing" selected="true">Default ('chain_pairing')</option>
                </param>
            </when>
            <when value="tl_define_clonotypes">
                <param name="tl_define_clonotypes_adata" type="data" format="h5ad" label="Annotated data matrix file" help="(Requires running tl.chain_qc() on it first)"/>
                <param name="tl_define_clonotypes_receptor_arms" type="select" label="Receptor arms" help="(receptor_arms)">
                    <option value="VJ" selected="true">VJ: only consider VJ sequences</option>
                    <option value="VDJ">VDJ: only consider VDJ sequences</option>
                    <option value="all">All: both VJ and VDJ need to match (all)</option>
                    <option value="any">Any: either VJ or VDJ need to match (any)</option>
                </param>
                <param name="tl_define_clonotypes_dual_ir" type="select" label="Dual IR" help="(dual_ir)">
                    <option value="primary_only" selected="true">Primary only: only consider most abundant pair of VJ/VDJ chains</option>
                    <option value="any">Consider both pairs of VJ/VDJ sequences. Distance must be below cutoff for any of the chains (any)</option>
                    <option value="all">Consider both pairs of VJ/VDJ sequences. Distance must be below cutoff for all of the chains (all)</option>
                </param>
                <param name="tl_define_clonotypes_within_group" type="text" value="receptor_type" help="(within_group)" label="Variable to enforce clonotypes to have the same group defined by"/>
                <param name="tl_define_clonotypes_key_added" type="text" value="clone_id" help="(key_added)" label="Column name under which clonotype clusters and cluster sizes will be stored in adata.obs"/>
            </when>
            <when value="tl_define_clonotype_clusters">
                <param name="tl_define_clonotype_clusters_adata" type="data" format="h5ad" label="Annotated data matrix file" help="(Requires running tl.chain_qc() and ir_dist() with same 'sequence' and 'metric' on it first)"/>
                <param name="tl_define_clonotype_clusters_sequence" type="select" label="Sequence Type (as used when running pp.ir_dust())" help="(sequence)">
                    <option value="aa" selected="true">Amino acid ('aa')</option>
                    <option value="nt" selected="true">Nucleotide ('nt')</option>
                </param>
                <param name="tl_define_clonotype_clusters_metric" type="select" label="Metric (as used when running pp.ir_dist())" help="(metric)">
                    <option value="identity">identity</option>
                    <option value="alignment">alignment</option>
                    <option value="levenshtein">levenshtein</option>
                    <option value="hamming">hamming</option>
                </param>
                <param name="tl_define_clonotype_clusters_receptor_arms" type="select" label="Receptor arms" help="(receptor_arms)">
                    <option value="VJ" selected="true">VJ: only consider VJ sequences</option>
                    <option value="VDJ">VDJ: only consider VDJ sequences</option>
                    <option value="all">All: both VJ and VDJ need to match (all)</option>
                    <option value="any">Any: either VJ or VDJ need to match (any)</option>
                </param>
                <param name="tl_define_clonotype_clusters_dual_ir" type="select" label="Dual IR" help="(dual_ir)">
                    <option value="primary_only" selected="true">Primary only: only consider most abundant pair of VJ/VDJ chains</option>
                    <option value="any">Consider both pairs of VJ/VDJ sequences. Distance must be below cutoff for any of the chains (any)</option>
                    <option value="all">Consider both pairs of VJ/VDJ sequences. Distance must be below cutoff for all of the chains (all)</option>
                </param>
                <param name="tl_define_clonotype_clusters_same_v_gene" type="select" label="Enforce clonotypes to have the same V-genes?" help="(same_v_gene)">
                    <option value="True">Yes (True)</option>
                    <option value="False" selected="true">No (False)</option>
                </param>
                <param name="tl_define_clonotype_clusters_within_group" type="text" value="receptor_type" help="(within_group)" label="Variable to enforce clonotypes to have the same group under"/>
                <param name="tl_define_clonotype_clusters_key_added" type="text" value="cc_aa_alignment" help="(key_added)" label="Key under which to add clonotype clusters and sizes in adata.obs"/>
                <param name="tl_define_clonotype_clusters_partitions" type="select" help="(partitions)" label="Partitions">
                    <option value="leiden">leiden</option>
                    <option value="connected">connected (find fully-connected sub-graphs)</option>
                </param>
                <param name="tl_define_clonotype_clusters_resolution" type="integer" value="1" help="(resolution)" label="Resolution parameter for the leiden algorithm"/>
                <param name="tl_define_clonotype_clusters_n_iterations" type="integer" value="5" help="(n_iterations)" label="Number of iterations parameter for the leiden algorithm"/>
                <param name="tl_define_clonotype_clusters_distance_key" type="text" value="ir_dist_alignment" help="(distance_key)" label="Key in adata.uns where the sequence distances are stored"/>
            </when>
            <when value="tl_clonotype_convergence">
                <param name="tl_clonotype_convergence_adata" type="data" format="h5ad" label="Annotated data matrix file"/>
                <param name="tl_clonotype_convergence_key_coarse" type="text" value="cc_aa_alignment" help="(key_coarse)" label="Key in adata.obs with course clonotype cluster definition"/>
                <param name="tl_clonotype_convergence_key_fine" type="text" value="clone_id" help="(key_fine)" label="Key in adata.obs with fine clonotype/clonotype cluster definition"/>
                <param name="tl_clonotype_convergence_key_added" type="text" value="is_convergent" help="(key_added)" label="Key under which results are stored in adata.obs"/>
            </when>
            <when value="tl_clonotype_network">
                <param name="tl_clonotype_network_adata" type="data" format="h5ad" label="Annotated data matrix file" help="Requires runnning tl.define_clonotypes() or tl.define_clonotype_clusters() first"/>
                <param name="tl_clonotype_network_sequence" type="select" label="Sequence Type (as used when running tl.define_clonotypes())" help="(sequence)">
                    <option value="aa" selected="true">Amino acid ('aa')</option>
                    <option value="nt" selected="true">Nucleotide ('nt')</option>
                </param>
                <param name="tl_clonotype_network_metric" type="select" label="Metric (as used when running tl.define_clonotypes())" help="(metric)">
                    <option value="identity">Identity</option>
                    <option value="alignment">Alignment</option>
                    <option value="levenshtein">Levenshtein</option>
                    <option value="hamming">Hamming</option>
                </param>
                <param name="tl_clonotype_network_min_cells" type="integer" value="1" help="(min_cells)" label="Minimum number of cells to show clonotypes"/>
                <param name="tl_clonotype_network_min_nodes" type="integer" value="1" help="(min_nodes)" label="Minimum number of nodes to show clonotypes"/>
                <param name="tl_clonotype_network_layout" type="text" value="components" help="(layout)" label="Layout algorithm to use"/>
                <param name="tl_clonotype_network_size_aware" type="select" help="(layout)" label="Use node size-aware layouting algorithm? (Only use if layout = 'components)">
                    <option value="True">Yes (True)</option>
                    <option value="False" selected="true">No (False)</option>
                </param>
                <param name="tl_clonotype_network_size_power" type="float" value="1" help="(size_power)" label="Sizes raised to power of this value e.g. 0.5 to dampen point size"/>
                <param name="tl_clonotype_network_key_added" type="text" value="clonotype_network" help="(key_added)" label="Key under which the layout coordinates will be stored in adata.obsm and parameters stored in adata.uns"/>
            </when>
            <when value="tl_clonotype_network_igraph">
                <param name="tl_clonotype_network_igraph_adata" type="data" format="h5ad" label="Annotated data matrix file (result of running tl.clonotype_network())" help="Requires runnning tl.clonotype_network() first"/>
                <param name="tl_clonotype_network_igraph_basis" type="text" value="clonotype_network" help="(basis)" label="Key in adata.obs where network layout is stored"/>
            </when>
            <when value="tl_clonal_expansion">
                <param name="tl_clonal_expansion_adata" type="data" format="h5ad" label="Annotated data matrix file"/>
                <param name="tl_clonal_expansion_target_col" type="text" value="clone_id" help="(target_col)" label="Column containing the clonotype annotation"/>
                <param name="tl_clonal_expansion_clip_at" type="integer" value="3" help="(clip_at)" label="All clonotypes with more than this value will be summarized into a single category"/>
                <param name="tl_clonal_expansion_key_added" type="text" value="clonal_expansion" help="(key_added)" label="Key under which results will be added to obs"/>
            </when>
            <when value="tl_summarize_clonal_expansion">
                <param name="tl_summarize_clonal_expansion_adata" type="data" format="h5ad" label="Annotated data matrix file"/>
                <param name="tl_summarize_clonal_expansion_group_by" type="text" value="sample" help="(group_by)" label="Column in adata.obs to summarize by"/>
                <param name="tl_summarize_clonal_expansion_target_col" type="text" value="clone_id" help="(target_col)" label="Column in obs which holds the clonotype information"/>
                <param name="tl_summarize_clonal_expansion_summarize_by" type="select" help="(summarize_by)" label="What to summarize by">
                    <option value="cell" selected="true">Count cells belonging to a clonotype ('cell')</option>
                    <option value="clone_id">Count clonotypes ('clone_id')</option>
                </param>
                <param name="tl_summarize_clonal_expansion_normalize" type="select" help="(normalize)" label="Normalize cell count groups?">
                    <option value="True">Scale each group to 1 (True)</option>
                    <option value="False">Plot absolute cell counts (False)</option>
                </param>
            </when>
            <when value="tl_alpha_diversity">
                <param name="tl_alpha_diversity_adata" type="data" format="h5ad" label="Annotated data matrix file"/>
                <param name="tl_alpha_diversity_group_by" type="text" value="sample" help="(group_by)" label="Column in adata.obs by which the grouping will be performed"/>
                <param name="tl_alpha_diversity_target_col" type="text" value="clone_id" help="(target_col)" label="Column on which to compute the alpha diversity"/>
                <param name="tl_alpha_diversity_metric" type="select" help="(metric)" label="Metric to use for diversity estimation">
                    <option value="normalized_shannon_entropy" selected="true">Normalized Shannon entropy</option>
                    <option value="D50">D50</option>
                    <option value="DXX">DXX</option>
                </param>
                <param name="tl_alpha_diversity_key_added" type="text" value="alpha_diversity_clone_id" help="(key_added)" label="Key under which alpha diversity will be stored"/>
            </when>
            <when value="tl_repertoire_overlap">
                <param name="tl_repertoire_overlap_adata" type="data" format="h5ad" label="Annotated data matrix file"/>
                <param name="tl_repertoire_overlap_group_by" type="text" value="sample" help="(groupby)" label="Column with group labels"/>
                <param name="tl_repertoire_overlap_target_col" type="text" value="clone_id" help="(target_col)" label="Category that overlaps among groups"/>
                <param name="tl_repertoire_overlap_overlap_measure" type="text" value="jaccard" help="(overlap_measure)" label="Any distance measure accepted by 'scipy.spatial.distance'"/>
                <param name="tl_repertoire_overlap_fraction" type="select" help="(fraction)" label="Compute fractions of abundances relative to groupby?">
                    <option value="True">Compute fractions of abundances relative to 'groupby' (True)</option>
                    <option value="False" selected="true">Report absolute numbers (False)</option>
                </param>
                <param name="tl_repertoire_overlap_added_key" type="text" value="repertoire_overlap" help="(added_key)" label="Key under which to add results to in uns"/>
            </when>
            <when value="tl_clonotype_modularity">
                <param name="tl_clonotype_modularity_adata" type="data" format="h5ad" label="Annotated data matrix file"/>
                <param name="tl_clonotype_modularity_target_col" type="text" value="cc_aa_alignment" help="(target_col)" label="Column in adata.obs containing the clontype annotation"/>
                <param name="tl_clonotype_modularity_connectivity_key" type="text" value="connectivities" help="(connectivity_key)" label="Key in adata.obsp containing the transcriptomics neighborhood grpah connectivity matrix"/>
                <param name="tl_clonotype_modularity_permutation_test" type="select" help="(permutation_test)" label="Perform approximate or exact permutation test">
                    <option value="approx" selected="true">Approximate (approx)</option>
                    <option value="exact">Exact (exact)</option>
                </param>
                <param name="tl_clonotype_modularity_n_permutations" type="integer" value="1000" help="(n_permutations)" label="Number of permutations used for the permutations test"/>
                <param name="tl_clonotype_modularity_key_added" type="text" value="clonotype_modularity" help="(key_added)" label="Key under which the result will be stored in adata.obs"/>
                <param name="tl_clonotype_modularity_fdr_correction" type="select" help="(fdr_correction)" label="Adjust the p-values for multiple testing using false-discovery-rate (FDR) correction?">
                    <option value="True" selected="true">True</option>
                    <option value="False">False</option>
                </param>
                <param name="tl_clonotype_modularity_random_state" type="integer" value="0" help="(random_state)" label="Random seed for permutation test"/>
            </when>
            <when value="tl_clonotype_imbalance">
                <param name="tl_clonotype_imbalance_adata" type="data" format="h5ad" label="Annotated data matrix file"/>
                <param name="tl_clonotype_imbalance_replicate_col" type="text" value="sample" label="Replicate column" help="(replicate_col)"/>
                <param name="tl_clonotype_imbalance_groupby" type="text" value="cluster" label="Group by" help="(groupby)"/>
                <param name="tl_clonotype_imbalance_case_label" type="text" value="CD8_Teff" label="Case label" help="(case_label)"/>
                <param name="tl_clonotype_imbalance_control_label" type="text" value="CD8_Trm" label="Control label" help="(control_label)"/>
            </when>
            <when value="tl_ir_query">
                <param name="tl_ir_query_adata" type="data" format="h5ad" label="Annotated data matrix file"/>
                <param name="tl_ir_query_reference" type="data" format="h5ad" help="(reference)" label="Another AnnData file, either a second dataset with IR information or a epitope database (must be the same object used for running ir.pp.ir_dist())"/>
                <param name="tl_ir_query_sequence" type="select" help="(sequence)" label="Sequence (same as that used when running pp.ir_dist())">
                    <option value="nt">Nucleotide ('nt')</option>
                    <option value="aa" selected="true">Amino Acid ('aa')</option>
                </param>
                <param name="tl_ir_query_metric" type="select" help="(metric)" label="Metric (same as used when running pp.ir_dist())">
                    <option value="alignment">alignment</option>
                    <option value="identity" selected="true">identity</option>
                    <option value="levenshtein">levenshtein</option>
                    <option value="hamming">hamming</option>
                </param>
                <param name="tl_ir_query_receptor_arms" type="select" help="(receptor_arms)" label="Receptor Arms">
                    <option value="VJ">Only consider VJ sequences ('VJ')</option>
                    <option value="VDJ">Only consider VDJ sequences ('VDJ')</option>
                    <option value="all">Both VJ and VDJ need to match ('all')</option>
                    <option value="any" selected="true">Either VJ or VDJ need to match ('any')</option>
                </param>
                <param name="tl_ir_query_dual_ir" type="select" help="(dual_ir)" label="Dual IR">
                    <option value="primary_only">Only consider most abundant pair of VJ/VDJ chains ('primary_only')</option>
                    <option value="all">Consider both pairs of VJ/VDJ sequences. Distance must be below cutoff for all of the chains ('all')</option>
                    <option value="any" selected="true">Consider both pairs of VJ/VDJ sequences. Distance must be below cutoff for any of the chains ('any')</option>
                </param>
                <param name="tl_ir_query_same_v_gene" type="select" help="(same_v_gene)" label="Enforce clonotypes to have the same V-genes (useful as the CDR1 and CDR2 regions are fully encoded in this gene)">
                    <option value="True">True</option>
                    <option value="False" selected="true">False</option>
                </param>
                <param name="tl_ir_query_key_added" value="ir_query_custom_nt_identity" type="text" help="(key_added)" label="Key under which the resulting distance matrix will be stored in adata.uns"/>
                <param name="tl_ir_query_distance_key" value="ir_dist_identity" type="text" help="(distance_key)" label="Key in adata.uns where the results of ir_dist() are stored"/>
            </when>
            <when value="tl_ir_query_annotate">
                <param name="tl_ir_query_annotate_adata" type="data" format="h5ad" label="Annotated data matrix file"/>
                <param name="tl_ir_query_annotate_reference" type="data" format="h5ad" help="(reference)" label="Another AnnData file, either a second dataset with IR information or a epitope database (must be the same object used for running ir.pp.ir_dist())"/>
                <param name="tl_ir_query_annotate_sequence" type="select" help="(sequence)" label="Sequence (same as that used when running pp.ir_dist())">
                    <option value="nt"> ('nt')</option>
                    <option value="aa" selected="true">Amino Acid ('aa')</option>
                </param>
                <param name="tl_ir_query_annotate_metric" type="select" help="(metric)" label="Metric (same as used when running pp.ir_dist())">
                    <option value="alignment">alignment</option>
                    <option value="identity" selected="true">identity</option>
                    <option value="levenshtein">levenshtein</option>
                    <option value="hamming">hamming</option>
                </param>
                <param name="tl_ir_query_annotate_strategy" type="select" help="(strategy)" label="Strategy to deal with non-unique values">
                    <option value="json">JSON ('json')</option>
                    <option value="unique-only" selected="true">Unique-only ('unique-only')</option>
                    <option value="most-frequent">Most frequent ('most-frequent')</option>
                </param>
                <param name="tl_ir_query_annotate_suffix" value="" type="text" help="(suffix)" label="Suffix appended to columns from reference.obs in case their names are conflicting with those in adata.obs"/>
            </when>
            <when value="tl_ir_query_annotate_df">
                <param name="tl_ir_query_annotate_df_adata" type="data" format="h5ad" label="Query dataset"/>
                <param name="tl_ir_query_annotate_df_reference" type="data" format="h5ad" help="(reference)" label="Reference dataset"/>
                <param name="tl_ir_query_annotate_df_sequence" type="select" help="(sequence)" label="Sequence (same as that used when running pp.ir_dist())">
                    <option value="nt">Nucleotide ('nt')</option>
                    <option value="aa" selected="true">Amino Acid ('aa')</option>
                </param>
                <param name="tl_ir_query_annotate_df_metric" type="select" help="(metric)" label="Metric (same as used when running pp.ir_dist())">
                    <option value="alignment">alignment</option>
                    <option value="identity" selected="true">identity</option>
                    <option value="levenshtein">levenshtein</option>
                    <option value="hamming">hamming</option>
                </param>
                <param name="tl_ir_query_annotate_df_suffix" value="" type="text" help="(suffix)" label="Suffix appended to columns from reference.obs in case their names are conflicting with those in adata.obs"/>
            </when>
            <when value="tl_spectratype">
                <param name="tl_spectratype_adata" type="data" format="h5ad" label="Annotated data matrix file"/>
                <param name="tl_spectratype_groupby" type="text" value="IR_VJ_1_junction_aa" help="(groupby)" label="Column containing CDR3 sequences"/>
                <param name="tl_spectratype_target_col" type="text" value="sample_name" help="(target_col)" label="Color by this column from obs"/>
                <param name="tl_spectratype_fraction" type="select" help="(fraction)" label="Compute fractions of abundances relative to the groupby column?">
                    <option value="True" selected="true">Compute fractions of abundances relative to groupby column (True)</option>
                    <option value="False">Report absolute numbers (False)</option>
                </param>
            </when>
        </conditional>
    </inputs>
    <outputs>
        <data name="tl_adata_out" format="h5ad" label="${tool.name} (${method.method}) on ${on_string}" from_work_dir="tl_adata_out.h5ad"/>
    </outputs>
    <tests>
        <test>
            <!--Test 1: tl.group_abundance test-->
            <conditional name="method">
                <param name="method" value="tl_group_abundance"/>
                <param name="tl_group_abundance_adata" value="tl_group_abundance_adata.h5ad"/>
                <param name="tl_group_abundance_groupby" value="sample"/>
                <param name="tl_group_abundance_target_col" value="has_ir"/>
<!--                <param name="tl_group_abundance_fraction" value="None"/>-->
                <param name="tl_group_abundance_sort" value="count"/>
            </conditional>
            <output name="tl_adata_out" file="tl_group_abundance_out.h5ad"/>
        </test>
        <test>
            <!--Test 2: tl.chain_qc test-->
            <conditional name="method">
                <param name="method" value="tl_chain_qc"/>
                <param name="tl_chain_qc_adata" value="tl_chain_qc_adata.h5ad"/>
                <param name="tl_chain_qc_receptor_type" value="TCR"/>
                <param name="tl_chain_qc_receptor_subtype" value="TRA+TRB"/>
                <param name="tl_chain_qc_chain_pairing" value="ambiguous"/>
            </conditional>
            <output name="tl_adata_out" file="tl_chain_qc_out.h5ad"/>
        </test>
        <test>
            <!--Test 3: tl.define_clonotypes test-->
            <conditional name="method">
                <param name="method" value="tl_define_clonotypes"/>
                <param name="tl_define_clonotypes_adata" value="tl_define_clonotypes_adata.h5ad"/>
                <param name="tl_define_clonotypes_receptor_arms" value="any"/>
                <param name="tl_define_clonotypes_dual_ir" value="any"/>
                <param name="tl_define_clonotypes_within_group" value="receptor_type"/>
                <param name="tl_define_clonotypes_key_added" value="clone_id"/>
            </conditional>
            <output name="tl_adata_out" file="tl_define_clonotypes_out.h5ad"/>
        </test>
         <test>
            <!--Test 4: tl.define_clonotype_clusters test-->
            <conditional name="method">
                <param name="method" value="tl_define_clonotype_clusters"/>
                <param name="tl_define_clonotype_clusters_adata" value="tl_define_clonotype_clusters_adata.h5ad"/>
                <param name="tl_define_clonotype_clusters_sequence" value="aa"/>
                <param name="tl_define_clonotype_clusters_metric" value="alignment"/>
                <param name="tl_define_clonotype_clusters_receptor_arms" value="all"/>
                <param name="tl_define_clonotype_clusters_dual_ir" value="any"/>
                <param name="tl_define_clonotype_clusters_same_v_gene" value="False"/>
                <param name="tl_define_clonotype_clusters_within_group" value="receptor_type"/>
                <param name="tl_define_clonotype_clusters_key_added" value="cc_aa_alignment"/>
                <param name="tl_define_clonotype_clusters_partitions" value="connected"/>
                <param name="tl_define_clonotype_clusters_resolution" value="1"/>
                <param name="tl_define_clonotype_clusters_n_iterations" value="5"/>
                <param name="tl_define_clonotype_clusters_distance_key" value="ir_dist_aa_alignment"/>
            </conditional>
            <output name="tl_adata_out" file="tl_define_clonotype_clusters_out.h5ad"/>
        </test>
        <test>
            <!--Test 5: tl.clonotype_convergence test-->
            <conditional name="method">
                <param name="method" value="tl_clonotype_convergence"/>
                <param name="tl_clonotype_convergence_adata" value="tl_clonotype_convergence_adata.h5ad"/>
                <param name="tl_clonotype_convergence_key_coarse" value="cc_aa_alignment"/>
                <param name="tl_clonotype_convergence_key_fine" value="clone_id"/>
                <param name="tl_clonotype_convergence_key_added" value="is_convergent"/>
            </conditional>
            <output name="tl_adata_out" file="tl_clonotype_convergence_out.h5ad"/>
        </test>
        <test>
            <!--Test 6: tl.clonotype_network test-->
            <conditional name="method">
                <param name="method" value="tl_clonotype_network"/>
                <param name="tl_clonotype_network_adata" value="tl_clonotype_network_adata.h5ad"/>
                <param name="tl_clonotype_network_sequence" value="aa"/>
                <param name="tl_clonotype_network_metric" value="alignment"/>
                <param name="tl_clonotype_network_min_cells" value="1"/>
                <param name="tl_clonotype_network_min_nodes" value="1"/>
                <param name="tl_clonotype_network_layout" value="components"/>
                <param name="tl_clonotype_network_size_aware" value="True"/>
                <param name="tl_clonotype_network_size_power" value="1"/>
                <param name="tl_clonotype_network_key_added" value="clonotype_network"/>
            </conditional>
            <output name="tl_adata_out" file="tl_clonotype_network_out.h5ad"/>
        </test>
         <test>
            <!--Test 7: tl.clonotype_network_igraph test-->
    <!--TODO: Output the tuple (igraph, layout) as a file-->
            <conditional name="method">
                <param name="method" value="tl_clonotype_network_igraph"/>
                <param name="tl_clonotype_network_igraph_adata" value="tl_clonotype_network_igraph_adata.h5ad"/>
                <param name="tl_clonotype_network_igraph_basis" value="clonotype_network"/>
            </conditional>
            <output name="tl_adata_out" file="tl_clonotype_network_igraph_out.h5ad"/>
        </test>
        <test>
            <!--Test 8: tl.clonal_expansion test-->
            <conditional name="method">
                <param name="method" value="tl_clonal_expansion"/>
                <param name="tl_clonal_expansion_adata" value="tl_clonal_expansion_adata.h5ad"/>
                <param name="tl_clonal_expansion_target_col" value="clone_id"/>
                <param name="tl_clonal_expansion_clip_at" value="3"/>
                <param name="tl_clonal_expansion_key_added" value="clonal_expansion"/>
            </conditional>
            <output name="tl_adata_out" file="tl_clonal_expansion_out.h5ad"/>
        </test>
        <test>
            <!--Test 9: tl.summarize_clonal_expansion test-->
            <conditional name="method">
                <param name="method" value="tl_summarize_clonal_expansion"/>
                <param name="tl_summarize_clonal_expansion_adata" value="tl_summarize_clonal_expansion_adata.h5ad"/>
                <param name="tl_summarize_clonal_expansion_group_by" value="sample"/>
                <param name="tl_summarize_clonal_expansion_summarize_by" value="clone_id"/>
                <param name="tl_summarize_clonal_expansion_normalize_by" value="False"/>
            </conditional>
            <output name="tl_adata_out" file="tl_summarize_clonal_expansion_out.h5ad"/>
        </test>
        <test>
            <!--Test 10: tl.alpha_diversity test-->
            <conditional name="method">
                <param name="method" value="tl_alpha_diversity"/>
                <param name="tl_alpha_diversity_adata" value="tl_alpha_diversity_adata.h5ad"/>
                <param name="tl_alpha_diversity_group_by" value="sample"/>
                <param name="tl_alpha_diversity_target_col" value="clone_id"/>
                <param name="tl_alpha_diversity_metric" value="normalized_shannon_entropy"/>
                <param name="tl_alpha_diversity_key_added" value="alpha_diversity_clone_id"/>
            </conditional>
            <output name="tl_adata_out" file="tl_alpha_diversity_out.h5ad"/>
        </test>
        <test>
            <!--Test 11: tl.repertoire_overlap test-->
            <conditional name="method">
                <param name="method" value="tl_repertoire_overlap"/>
                <param name="tl_repertoire_overlap_adata" value="tl_repertoire_overlap_adata.h5ad"/>
                <param name="tl_repertoire_overlap_group_by" value="sample"/>
                <param name="tl_repertoire_overlap_target_col" value="clone_id"/>
                <param name="tl_repertoire_overlap_overlap_measure" value="jaccard"/>
                <param name="tl_repertoire_overlap_fraction" value="False"/>
                <param name="tl_repertoire_overlap_added_key" value="repertoire_overlap"/>
            </conditional>
            <output name="tl_adata_out" file="tl_repertoire_overlap_out.h5ad"/>
        </test>
        <test>
            <!--Test 12: tl.clonotype_modularity test-->
            <!--TODO: Resolve issue with connectivity_key=connectivities-->
            <conditional name="method">
                <param name="method" value="tl_clonotype_modularity"/>
                <param name="tl_clonotype_modularity_adata" value="tl_clonotype_modularity_adata.h5ad"/>
                <param name="tl_clonotype_modularity_target_col" value="cc_aa_alignment"/>
                <param name="tl_clonotype_modularity_connectivity_key" value="connectivities"/>
                <param name="tl_clonotype_modularity_permutation_test" value="approx"/>
                <param name="tl_clonotype_modularity_n_permutations" value="1000"/>
                <param name="tl_clonotype_modularity_key_added" value="clonotype_modularity"/>
                <param name="tl_clonotype_modularity_fdr_correction" value="True"/>
                <param name="tl_clonotype_modularity_random_state" value="0"/>
            </conditional>
            <output name="tl_adata_out" file="tl_clonotype_modularity_out.h5ad"/>
        </test>
        <test>
            <!--Test 13: tl.clonotype_imbalance test-->
            <conditional name="method">
                <param name="method" value="tl_clonotype_imbalance"/>
                <param name="tl_clonotype_imbalance_adata" value="tl_clonotype_imbalance_adata.h5ad"/>
                <param name="tl_clonotype_imbalance_replicate_col" value="sample" />
                <param name="tl_clonotype_imbalance_groupby" value="cluster"/>
                <param name="tl_clonotype_imbalance_case_label" value="CD8_Teff"/>
                <param name="tl_clonotype_imbalance_control_label" value="CD8_Trm"/>
            </conditional>
            <output name="tl_adata_out" file="tl_clonotype_imbalance_out.h5ad"/>
        </test>
        <test>
            <!--Test 14: tl.ir_query test-->
            <conditional name="method">
                <param name="method" value="tl_ir_query"/>
                <param name="tl_ir_query_adata" value="tl_ir_query_adata.h5ad"/>
                <param name="tl_ir_query_reference" value="tl_ir_query_reference_ref.h5ad"/>
                <param name="tl_ir_query_sequence" value="nt"/>
                <param name="tl_ir_query_metric" value="identity"/>
                <param name="tl_ir_query_receptor_arms" value="any"/>
                <param name="tl_ir_query_dual_ir" value="any"/>
                <param name="tl_ir_query_same_v_gene" value="False"/>
                <param name="tl_ir_query_key_added" value="ir_query_custom_nt_identity"/>
                <param name="tl_ir_query_distance_key" value="ir_dist_identity"/>
            </conditional>
            <output name="tl_adata_out" file="tl_ir_query_out.h5ad"/>
        </test>
        <test>
            <!--Test 15: tl.ir_query_annotate test-->
            <conditional name="method">
                <param name="method" value="tl_ir_query_annotate"/>
                <param name="tl_ir_query_annotate_adata" value="tl_ir_query_annotate_adata.h5ad"/>
                <param name="tl_ir_query_annotate_reference" value="tl_ir_query_annotate_ref.h5ad"/>
                <param name="tl_ir_query_annotate_sequence" value="nt"/>
                <param name="tl_ir_query_annotate_metric" value="identity"/>
                <param name="tl_ir_query_annotate_strategy" value="unique-only"/>
                <param name="tl_ir_query_annotate_suffix" value="vdjdb"/>
            </conditional>
            <output name="tl_adata_out" file="tl_ir_query_annotate_out.h5ad"/>
        </test>
        <test>
            <!--Test 16: tl.ir_query_annotate_df test-->
            <conditional name="method">
                <param name="method" value="tl_ir_query_annotate_df"/>
                <param name="tl_ir_query_annotate_df_adata" value="tl_ir_query_annotate_df_adata.h5ad"/>
                <param name="tl_ir_query_annotate_df_reference" value="tl_ir_query_annotate_df_ref.h5ad"/>
                <param name="tl_ir_query_annotate_df_sequence" value="nt"/>
                <param name="tl_ir_query_annotate_df_metric" value="identity"/>
                <param name="tl_ir_query_annotate_df_suffix" value="vdjdb"/>
            </conditional>
            <output name="tl_adata_out" file="tl_ir_query_annotate_df_out.h5ad"/>
        </test>
        <test>
            <!--Test 16: tl.spectratype test-->
            <conditional name="method">
                <param name="method" value="tl_spectratype"/>
                <param name="tl_spectratype_adata" value="tl_ir_spectratype_adata.h5ad"/>
                <param name="tl_spectratype_groupby" value="IR_VJ_1_junction_aa"/>
                <param name="tl_spectratype_target_col" value="sample_name"/>
                <param name="tl_spectratype_fraction" value="True"/>
            </conditional>
            <output name="tl_adata_out" file="tl_spectratype_out.h5ad"/>
        </test>
    </tests>
    <help><![CDATA[
Merge adaptive immune receptor (IR) data with transcriptomics data into a single AnnData object. (`pp.merge_with_ir`)
==============================================s=======================================================================
Reading in IR data results in an AnnData object with IR information stored in obs.
Use this function to merge it with another AnnData containing transcriptomics data.
More details on the `scirpy documentation
<https://scverse.org/scirpy/latest/generated/scirpy.pp.merge_with_ir.html>`__
    ]]></help>
    <citations>
        <citation type="bibtex">
}</citation>
    </citations>
</tool>