<tool id="neat_read_simulator" name="NEAT Read-simulator" version="@TOOL_VERSION@+galaxy@VERSION_SUFFIX@" profile="@PROFILE@">
    <macros>
        <import>macros.xml</import>
    </macros>
    <expand macro="requirements" />
    <command detect_errors="exit_code"><![CDATA[
        neat --log-name neat read-simulator -c $neat_config -o neat
    ]]></command>
    <configfiles>
        <configfile name="neat_config">
            <!-- ## Template for gen_reads parallel -->
            <!-- ## Any parameter that is not required but has a default value will use the -->
            <!-- ## default value even if the variable is not included in the config. For -->
            <!-- ## required items, they must be included in the config and the must be given a value. -->
            <!-- ## All other items can be present or not. If present and the value is set to a single -->
            <!-- ## period, the variable will be treated as though it had been omitted. -->

            <!-- # Absolute path to input reference fasta file -->
            <!-- # type = string | required: yes -->
            reference: '${reference}'

            <!-- # Read length of the reads in the fastq output. Only required if @produce_fastq is set to true -->
            <!-- # type = int | required: no | default = 101 -->
            read_len: ${read_len}

            <!-- # Average Coverage for the entire genome. -->
            <!-- # type = float | required: no | default = 10.0 -->
            coverage: ${coverage}

            <!-- # Absolute path to file with sequencing error model -->
            <!-- # type = string | required: no | default: <NEAT_DIR>/neat/models/defaults/default_error_model.pickle.gz -->
            #if $error_model:    
            error_model: '${error_model}'
            #else:
            error_model: .
            #end if

            <!-- # Average sequencing error rate for the sequencing machine -->
            <!-- # type = float | required = no | must be between 0.0 and 0.3 -->
            #if $avg_seq_error:
            avg_seq_error: ${avg_seq_error}
            #else:
            avg_seq_error: .
            #end if

            <!-- # This scales the quality scores to match the desired average sequencing error rate -->
            <!-- # specified by avg_seq_error. -->
            <!-- # type: boolean | required = no | default = false -->
            rescale_qualities: ${rescale_qualities}

            <!-- # This is the factor to add to the quality scores to get the ascii text version of the -->
            <!-- # score. The default follows the sanger quality offset -->
            <!-- # type: int | required = no | default = 33 -->
            quality_offset: ${quality_offset}

            <!-- # Desired ploidy -->
            <!-- # type = int | required = no | default = 2 -->
            ploidy: ${ploidy}

            <!-- # Absolute path to vcf file containing variants that will always be included, regardless -->
            <!-- # of genotype and filter. You can pre-filter your vcf for these fields before inputting it -->
            <!-- # if this is not the desired behavior. -->
            <!-- # type: string | required = no -->
            #if $include_vcf:
            include_vcf: '${include_vcf}'
            #else:
            include_vcf: .
            #end if

            <!-- # Absolute path to bed file containing reference regions that the simulation -->
            <!-- # should target. -->
            <!-- # type = string | required = no -->
            #if $target_bed:
            target_bed: '${target_bed}'
            #else:
            target_bed: .
            #end if

            <!-- # Scalar value for coverage in regions outside the targeted bed. Example 0.5 -->
            <!-- # would get you roughly half the coverage as the on target areas. Default is -->
            <!-- # 0 coverage in off-target regions. Number should be a float in decimal. -->
            <!-- # type: float | required = no | default = 0.00 -->
            off_target_scalar: ${off_target_scalar}

            <!-- # Absolute path to bed file containing reference regions that the simulation -->
            <!-- # should discard. -->
            <!-- # type = string | required = no -->
            #if $discard_bed:
            discard_bed: '${discard_bed}'
            #else:
            discard_bed: .
            #end if

            <!-- # Absolute path to the mutation model pickle file. Omitting this value will cause -->
            <!-- # NEAT to use the default model, with some standard parameters, and generally uniform biases. -->
            <!-- # type: string | required = no -->
            #if $mutation_model:
            mutation_model: '${mutation_model}'
            #else:
            mutation_model: .
            #end if

            <!-- # Average mutation rate per base pair. Overall average is 0.001, or model default -->
            <!-- # Use either this value to override the mutation rate for the default or input model. -->
            <!-- # type: float | required = no | must be between 0.0 and 0.3 -->
            #if $mutation_rate:
            mutation_rate: ${mutation_rate}
            #else:
            mutation_rate: .
            #end if

            <!-- # Absolute path to a bed file with mutation rates by region. -->
            <!-- # Rates must be in the fourth column and be of the form "mut_rate=x.xx" -->
            <!-- # Rates must be between 0.00 and 0.03 -->
            <!-- # type: string | required = no -->
            #if $mutation_bed:
            mutation_bed: '${mutation_bed}'
            #else:
            mutation_bed: .
            #end if

            <!-- # Whether the output should be paired ended. For certain conditions (i.e., vcf only or -->
            <!-- # fasta only), this will be ignored. If this is true, then there must be an included fragment -->
            <!-- # length model output from runner.py or a mean and standard deviation -->
            <!-- # by declaring values for @fragment_mean and @fragment_std_dev. -->
            <!-- # type: boolean | required = no | default = false -->
            paired_ended: ${paired_ended}

            <!-- # Absolute path to a pickle file containing the fragment length model output -->
            <!-- # from runner.py. -->
            <!-- # type: string | required = no | default: <NEAT_DIR>/neat/models/defaults/default_fraglen_model.pickle.gz -->
            #if $fragment_model:
            fragment_model: '${fragment_model}'
            #else:
            fragment_model: .
            #end if

            <!-- # Mean for the paired end fragment length. This only applies if paired-ended is set to true. -->
            <!-- # This number will form the mean for the sample distribution of the fragment lengths in the simulation -->
            <!-- # Note: This number is REQUIRED if paired_ended is set to true, unless a fragment length model is used. -->
            <!-- # type: float | required: no (unless paired-ended) -->
            #if $fragment_mean:
            fragment_mean: ${fragment_mean}
            #else:
            fragment_mean: .
            #end if

            <!-- # Standard deviation for the paired end fragment length. This only applies if paired-ended is set to true. -->
            <!-- # This number will form the standard deviation about the mean specified above for the sample distribution -->
            <!-- # of the fragment lengths in the simulation. -->
            <!-- # Note: This number is REQUIRED if paired_ended is set to true, unless a fragment length model is used. -->
            <!-- # type: float | required: no (unless paired-ended) -->
            #if $fragment_st_dev:
            fragment_st_dev: ${fragment_st_dev}
            #else:
            fragment_st_dev: .
            #end if

            <!-- # Whether to produce the golden bam file. This file will contain the reads -->
            <!-- # aligned with the exact region of the genome -->
            <!-- # type: boolean | required = no | default = false -->
            produce_bam: ${produce_bam}

            <!-- # Whether to produce a vcf file containing all the mutation errors added -->
            <!-- # by NEAT. -->
            <!-- # type: boolean | required = no | default = false -->
            produce_vcf: ${produce_vcf}

            <!-- # Whether to output the fastq(s) of the reads. This is the default output. NEAT -->
            <!-- # will produce 1 fastq for single ended reads or 2 fastqs for paired ended. -->
            <!-- # type: boolean | required = no | default = true -->
            produce_fastq: ${produce_fastq}

            <!-- # If set to true, this will ignore statistical models and force coverage to be -->
            <!-- # constant across the genome. This is considered a debugging feature. -->
            <!-- # type: boolean | required = no | default = false -->
            no_coverage_bias: ${no_coverage_bias}

            <!-- # Set an RNG seed value. Runs using identical RNG values should produce identical results -->
            <!-- # so things like read locations, variant positions, error positions, etc. should be the same. -->
            <!-- # Useful for debugging. -->
            <!-- # type: int | required = no -->
            #if $rng_seed:
            rng_seed: ${rng_seed}
            #else:
            rng_seed: .
            #end if

            <!-- # Set an absolute minimum number of mutations. The program always adds at least 1 mutation. -->
            <!-- # Useful for very small datasets. -->
            <!-- # type: int | required = no -->
            #if $min_mutations:
            min_mutations: ${min_mutations}
            #else:
            min_mutations: .
            #end if
        </configfile>
    </configfiles>
    <inputs>
        <param name="reference" type="data" format="fasta" label="Reference genome" help="Reference fasta file"/>
        <section name="advanced" title="Advanced options">
            <param name="read_len" type="integer" label="Read length" value="101" help="Read length of the reads in the fastq output." />
            <param name="coverage" type="float" label="Coverage" value="10.0" help="Average Coverage for the entire genome."/>
            <param name="error_model" type="data" format="pickle,pickle.gz" label="Error model" optional="true" help="file with sequencing error model"/>
            <param name="avg_seq_error" type="float" label="Average sequencing error rate" min="0.0" max="0.3" optional="true" help="Average sequencing error rate for the sequencing machine"/>
            <param name="rescale_qualities" type="boolean" label="Rescale qualities" checked="false" help="Scale the quality scores to match the desired average sequencing error rate specified by Average sequencing error rate"/>
            <param name="quality_offset" type="select" label="Quality offset" help="The factor to add to the quality scores to get the ascii text version of the score. The default follows the sanger quality offset.">
                <option value="33">33</option>
                <option value="64">64</option>
            </param>
            <param name="ploidy" type="integer" label="Ploidy" value="2" help="Desired ploidy"/>
            <param name="include_vcf" type="data" format="vcf" label="Input variants" optional="true" help="the vcf file containing variants that will always be included, regardless of genotype and filter."/>
            <param name="target_bed" type="data" format="bed" label="Target bed" optional="true" help="The bed file containing reference regions that the simulation should target."/>
            <param name="off_target_scalar" type="float" label="Off target scalar" value="0.0" help="Scalar value for coverage in regions outside the targeted bed."/>
            <param name="discard_bed" type="data" format="bed" label="Discard bed" optional="true" help="The bed file containing reference regions that the simulation should discard."/>
            <param name="mutation_model" type="data" format="pickle" label="Mutation model" optional="true" help="The mutation model pickle file."/>
            <param name="mutation_rate" type="float" label="Mutation rate" min="0.0" max="0.3" optional="true" help="Average mutation rate per base pair." />
            <param name="mutation_bed" type="data" format="bed" label="Mutation bed" optional="true" help="The bed file with mutation rates by region."/>
            <param name="paired_ended" type="boolean" label="Paired ended" checked="false" help="Paired-ended output?"/>
            <param name="fragment_model" type="data" format="pickle" label="Fragment model" optional="true" help="The pickle file containing the fragment length model output from 'NeatGenerate fragment length model'"/>
            <param name="fragment_mean" type="float" label="Fragment mean" optional="true" help="Mean for the paired end fragment length."/>
            <param name="fragment_st_dev" type="float" label="Fragment standard deviation" optional="true" help="Standard deviation for the paired end fragment length."/>
            <param name="no_coverage_bias" type="boolean" label="No coverage bias" checked="false" help="Ignore statistical models and force coverage to be constant across the genome?"/>
            <param name="rng_seed" type="integer" label="RNG seed" optional="true" help="Set an RNG seed value."/>
            <param name="min_mutations" type="integer" label="Min mutation" optional="true" help="Set an absolute minimum number of mutations. The program always adds at least 1 mutation."/>
        </section>
        <section name="output" title="Output options">
            <param name="produce_bam" type="boolean" label="Produce BAM" checked="false" help="Produce the golden bam file containing the reads aligned with the exact region of the genome?"/>
            <param name="produce_vcf" type="boolean" label="Produce VCF" checked="false" help="Produce a vcf file containing all the mutation errors added by NEAT?"/>
            <param name="produce_fastq" type="boolean" label="Produce FASTQ" checked="true" help="Produce fastq(s) of the reads?"/>
            <param name="output_log" type="boolean" label="Output Log?" checked="false"/>
        </section>
    </inputs>
    <outputs>
        <data format="fastq.gz" name="fastq" from_work_dir="neat.fastq.gz" label="${tool.name} on ${on_string}: fastq file">
            <filter>advanced['paired_ended']==False and advanced['produce_fastq']</filter>
        </data>
        <data format="fastq.gz" name="fastq_r1" from_work_dir="neat_r1.fastq.gz" label="${tool.name} on ${on_string}: fastq_r1 file">
            <filter>advanced['paired_ended']</filter>
        </data>
        <data format="fastq.gz" name="fastq_r2" from_work_dir="neat_r2.fastq.gz" label="${tool.name} on ${on_string}: fastq_r2 file">
            <filter>advanced['paired_ended']</filter>
        </data>
        <data format="bam" name="bam" from_work_dir="neat_golden.bam" label="${tool.name} on ${on_string}: bam file">
            <filter>output['produce_bam']</filter>
        </data>
        <data format="tabular.gz" name="vcf" from_work_dir="neat_golden.vcf.gz" label="${tool.name} on ${on_string}: vcf file">
            <filter>output['produce_vcf']</filter>
        </data>
        <data format="txt" name="log" from_work_dir="neat.log" label="${tool.name} on ${on_string}: log file">
            <filter>output['output_log']</filter>
        </data>
    </outputs>
    <tests>
        <test expect_exit_code="0" expect_num_outputs="3">
            <param name="reference" value="H1N1.fa"/>
            <param name="paired_ended" value="true"/>
            <param name="fragment_mean" value="300"/>
            <param name="fragment_st_dev" value="30"/>
            <param name="output_log" value="true"/>
            <assert_stdout>
                <has_text text="command finished successfully"/>
            </assert_stdout>
            <output name="fastq_r1" file="neat_r1.fastq.gz" compare="sim_size" />
            <output name="fastq_r2" file="neat_r2.fastq.gz" compare="sim_size" />
            <output name="log" file="neat.log" compare="sim_size" />
        </test>
        <test expect_exit_code="0" expect_num_outputs="3">
            <param name="reference" value="H1N1.fa"/>
            <param name="produce_bam" value="true"/>
            <param name="produce_vcf" value="true"/>
            <assert_stdout>
                <has_text text="command finished successfully"/>
            </assert_stdout>
            <output name="bam" file="neat_golden.bam" compare="sim_size"/>
            <output name="vcf" file="neat_golden.vcf.gz" compare="sim_size"/>
            <output name="fastq" file="neat.fastq.gz" compare="sim_size"/>
        </test>
    </tests>
    <help>
NEAT produces simulated sequencing datasets. It creates FASTQ files with reads sampled from a provided reference genome, using sequencing error rates and mutation rates learned from real sequencing data. The strength of NEAT lies in the ability for the user to customize many sequencing parameters, produce 'golden,' true positive datasets. We are working on expanding the functionality even further to model more species, generate larger variants, model tumor/normal data and more!

.. image:: https://github.com/ncsa/NEAT/raw/f33455695d57146852017a7eef7cded1ea6cc58e/docs/NEATNEAT.png
    :width: 800
    :height: 320
    
-----

.. class:: infomark

The 'Read length' is only required if 'Produce FASTQ' is set to true.

.. class:: infomark

Scalar value is for coverage in regions outside the targeted bed. For example value 0.5 would get you roughly half the coverage as the on target areas. Default is 0 coverage in off-target regions.

.. class:: infomark

Mutation rates in the 'Mutation bed file' must be in the fourth column and be of the form "mut_rate=x.xx". Rates must be between 0.00 and 0.03.

.. class:: infomark

The 'Fragment mean' and 'Fragment standard deviation' are required if 'Paired ended' is set to true, unless a fragment length model is used.

.. class:: infomark

The 'RNG seed' is useful for debugging. Runs using identical RNG values should produce identical results so things like read locations, variant positions, error positions, etc. should be the same.

.. class:: infomark

The 'Min mutation' is useful for very small datasets. The program always adds at least 1 mutation.
    </help>
    <expand macro="citations" />
</tool>