<tool id="neat_read_simulator" name="NEAT Read-simulator" version="@TOOL_VERSION@+galaxy@VERSION_SUFFIX@" profile="@PROFILE@">
    <description>Generate a Dataset of simulated NGS reads</description>
    <macros>
        <import>macros.xml</import>
    </macros>
    <expand macro="requirements" />
    <command detect_errors="exit_code"><![CDATA[
        #if str($utility.gen_model) == "produce_fraglen_model":
            neat --log-name neat_fraglen model-fraglen -i '$input_fraglen' --min_reads $min_reads -o neat_fraglen &&
        #end if
        #if str($utility.gen_model) == "produce_mutation_model":
            #if $trinuc:
                neat --log-name neat_mut_trinuc gen-mut-model '${reference}' '$mutations' 
                #if $bed:
                    --b '$bed'
                #end if
                 $human_sample $skip_common --save-trinuc -o neat_mut &&
                neat --log-name neat_mut gen-mut-model '${reference}' '$mutations' $skip_common --outcounts 'neat_mut.trinuc.pickle.gz' --overwrite -o neat_mut &&
            #else:
                neat --log-name neat_mut gen-mut-model '${reference}' '$mutations'
                #if $bed:
                --b '$bed'
                #end if
                $human_sample $skip_common -o neat_mut &&
            #end if
        #end if
        #if str($utility.gen_model) == "produce_error_model":
            neat --log-name neat_seq model-seq-err -i '${input_error}' -q $q -Q $Q
            #if $m:
                -m $m
            #end if
            -o neat_seq &&
        #end if
        neat --log-name neat read-simulator -c '$neat_config' -o neat
    ]]></command>
    <configfiles>
        <configfile name="neat_config">
            <!-- ## Template for gen_reads parallel -->
            <!-- ## Any parameter that is not required but has a default value will use the -->
            <!-- ## default value even if the variable is not included in the config. For -->
            <!-- ## required items, they must be included in the config and the must be given a value. -->
            <!-- ## All other items can be present or not. If present and the value is set to a single -->
            <!-- ## period, the variable will be treated as though it had been omitted. -->

            <!-- # Absolute path to input reference fasta file -->
            <!-- # type = string | required: yes -->
            reference: '${reference}'

            <!-- # Read length of the reads in the fastq output. Only required if @produce_fastq is set to true -->
            <!-- # type = int | required: no | default = 101 -->
            read_len: ${read_len}

            <!-- # Average Coverage for the entire genome. -->
            <!-- # type = float | required: no | default = 10.0 -->
            coverage: ${coverage}

            <!-- # Absolute path to file with sequencing error model -->
            <!-- # type = string | required: no | default: <NEAT_DIR>/neat/models/defaults/default_error_model.pickle.gz -->
            #if str($utility.gen_model) == "produce_error_model": 
            error_model: 'neat_seq.p.gz'
            #else:
            error_model: .
            #end if

            <!-- # Average sequencing error rate for the sequencing machine -->
            <!-- # type = float | required = no | must be between 0.0 and 0.3 -->
            #if $avg_seq_error:
            avg_seq_error: ${avg_seq_error}
            #else:
            avg_seq_error: .
            #end if

            <!-- # This scales the quality scores to match the desired average sequencing error rate -->
            <!-- # specified by avg_seq_error. -->
            <!-- # type: boolean | required = no | default = false -->
            rescale_qualities: ${rescale_qualities}

            <!-- # This is the factor to add to the quality scores to get the ascii text version of the -->
            <!-- # score. The default follows the sanger quality offset -->
            <!-- # type: int | required = no | default = 33 -->
            quality_offset: ${quality_offset}

            <!-- # Desired ploidy -->
            <!-- # type = int | required = no | default = 2 -->
            ploidy: ${ploidy}

            <!-- # Absolute path to vcf file containing variants that will always be included, regardless -->
            <!-- # of genotype and filter. You can pre-filter your vcf for these fields before inputting it -->
            <!-- # if this is not the desired behavior. -->
            <!-- # type: string | required = no -->
            #if $include_vcf:
            include_vcf: '${include_vcf}'
            #else:
            include_vcf: .
            #end if

            <!-- # Absolute path to bed file containing reference regions that the simulation -->
            <!-- # should target. -->
            <!-- # type = string | required = no -->
            #if $target_bed:
            target_bed: '${target_bed}'
            #else:
            target_bed: .
            #end if

            <!-- # Scalar value for coverage in regions outside the targeted bed. Example 0.5 -->
            <!-- # would get you roughly half the coverage as the on target areas. Default is -->
            <!-- # 0 coverage in off-target regions. Number should be a float in decimal. -->
            <!-- # type: float | required = no | default = 0.00 -->
            off_target_scalar: ${off_target_scalar}

            <!-- # Absolute path to bed file containing reference regions that the simulation -->
            <!-- # should discard. -->
            <!-- # type = string | required = no -->
            #if $discard_bed:
            discard_bed: '${discard_bed}'
            #else:
            discard_bed: .
            #end if

            <!-- # Absolute path to the mutation model pickle file. Omitting this value will cause -->
            <!-- # NEAT to use the default model, with some standard parameters, and generally uniform biases. -->
            <!-- # type: string | required = no -->
            #if str($utility.gen_model) == "produce_mutation_model":
            mutation_model: 'neat_mut.pickle.gz'
            #else:
            mutation_model: .
            #end if

            <!-- # Average mutation rate per base pair. Overall average is 0.001, or model default -->
            <!-- # Use either this value to override the mutation rate for the default or input model. -->
            <!-- # type: float | required = no | must be between 0.0 and 0.3 -->
            #if $mutation_rate:
            mutation_rate: ${mutation_rate}
            #else:
            mutation_rate: .
            #end if

            <!-- # Absolute path to a bed file with mutation rates by region. -->
            <!-- # Rates must be in the fourth column and be of the form "mut_rate=x.xx" -->
            <!-- # Rates must be between 0.00 and 0.03 -->
            <!-- # type: string | required = no -->
            #if $mutation_bed:
            mutation_bed: '${mutation_bed}'
            #else:
            mutation_bed: .
            #end if

            <!-- # Whether the output should be paired ended. For certain conditions (i.e., vcf only or -->
            <!-- # fasta only), this will be ignored. If this is true, then there must be an included fragment -->
            <!-- # length model output from runner.py or a mean and standard deviation -->
            <!-- # by declaring values for @fragment_mean and @fragment_std_dev. -->
            <!-- # type: boolean | required = no | default = false -->
            paired_ended: ${paired_ended}

            <!-- # Absolute path to a pickle file containing the fragment length model output -->
            <!-- # from runner.py. -->
            <!-- # type: string | required = no | default: <NEAT_DIR>/neat/models/defaults/default_fraglen_model.pickle.gz -->
            #if str($utility.gen_model) == "produce_fraglen_model":
            fragment_model: 'neat_fraglen.pickle.gz'
            #else:
            fragment_model: .
            #end if

            <!-- # Mean for the paired end fragment length. This only applies if paired-ended is set to true. -->
            <!-- # This number will form the mean for the sample distribution of the fragment lengths in the simulation -->
            <!-- # Note: This number is REQUIRED if paired_ended is set to true, unless a fragment length model is used. -->
            <!-- # type: float | required: no (unless paired-ended) -->
            #if $fragment_mean:
            fragment_mean: ${fragment_mean}
            #else:
            fragment_mean: .
            #end if

            <!-- # Standard deviation for the paired end fragment length. This only applies if paired-ended is set to true. -->
            <!-- # This number will form the standard deviation about the mean specified above for the sample distribution -->
            <!-- # of the fragment lengths in the simulation. -->
            <!-- # Note: This number is REQUIRED if paired_ended is set to true, unless a fragment length model is used. -->
            <!-- # type: float | required: no (unless paired-ended) -->
            #if $fragment_st_dev:
            fragment_st_dev: ${fragment_st_dev}
            #else:
            fragment_st_dev: .
            #end if

            <!-- # Whether to produce the golden bam file. This file will contain the reads -->
            <!-- # aligned with the exact region of the genome -->
            <!-- # type: boolean | required = no | default = false -->
            produce_bam: ${produce_bam}

            <!-- # Whether to produce a vcf file containing all the mutation errors added -->
            <!-- # by NEAT. -->
            <!-- # type: boolean | required = no | default = false -->
            produce_vcf: ${produce_vcf}

            <!-- # Whether to output the fastq(s) of the reads. This is the default output. NEAT -->
            <!-- # will produce 1 fastq for single ended reads or 2 fastqs for paired ended. -->
            <!-- # type: boolean | required = no | default = true -->
            produce_fastq: ${produce_fastq}

            <!-- # If set to true, this will ignore statistical models and force coverage to be -->
            <!-- # constant across the genome. This is considered a debugging feature. -->
            <!-- # type: boolean | required = no | default = false -->
            no_coverage_bias: ${no_coverage_bias}

            <!-- # Set an RNG seed value. Runs using identical RNG values should produce identical results -->
            <!-- # so things like read locations, variant positions, error positions, etc. should be the same. -->
            <!-- # Useful for debugging. -->
            <!-- # type: int | required = no -->
            #if $rng_seed:
            rng_seed: ${rng_seed}
            #else:
            rng_seed: .
            #end if

            <!-- # Set an absolute minimum number of mutations. The program always adds at least 1 mutation. -->
            <!-- # Useful for very small datasets. -->
            <!-- # type: int | required = no -->
            #if $min_mutations:
            min_mutations: ${min_mutations}
            #else:
            min_mutations: .
            #end if
        </configfile>
    </configfiles>
    <inputs>
        <param name="reference" type="data" format="fasta" label="Reference genome" help="Reference fasta file"/>
        <section name="advanced" title="Advanced options">
            <param name="read_len" type="integer" label="Read length" value="101" help="Read length of the reads in the fastq output." />
            <param name="coverage" type="float" label="Coverage" value="10.0" help="Average Coverage for the entire genome."/>
            <param name="avg_seq_error" type="float" label="Average sequencing error rate" min="0.0" max="0.3" optional="true" help="Average sequencing error rate for the sequencing machine"/>
            <param name="rescale_qualities" type="boolean" label="Rescale qualities" checked="false" help="Scale the quality scores to match the desired average sequencing error rate specified by Average sequencing error rate"/>
            <param name="quality_offset" type="select" label="Quality offset" help="The factor to add to the quality scores to get the ascii text version of the score. The default follows the sanger quality offset.">
                <option value="33">33</option>
                <option value="64">64</option>
            </param>
            <param name="ploidy" type="integer" label="Ploidy" value="2" help="Desired ploidy"/>
            <param name="include_vcf" type="data" format="vcf" label="Input variants" optional="true" help="the vcf file containing variants that will always be included, regardless of genotype and filter."/>
            <param name="target_bed" type="data" format="bed" label="Target bed" optional="true" help="The bed file containing reference regions that the simulation should target."/>
            <param name="off_target_scalar" type="float" label="Off target scalar" value="0.0" help="Scalar value for coverage in regions outside the targeted bed."/>
            <param name="discard_bed" type="data" format="bed" label="Discard bed" optional="true" help="The bed file containing reference regions that the simulation should discard."/>
            <param name="mutation_rate" type="float" label="Mutation rate" min="0.0" max="0.3" optional="true" help="Average mutation rate per base pair." />
            <param name="mutation_bed" type="data" format="bed" label="Mutation bed" optional="true" help="The bed file with mutation rates by region."/>
            <param name="paired_ended" type="boolean" label="Paired ended" checked="false" help="Paired-ended output?"/>
            <param name="fragment_mean" type="float" label="Fragment mean" optional="true" help="Mean for the paired end fragment length."/>
            <param name="fragment_st_dev" type="float" label="Fragment standard deviation" optional="true" help="Standard deviation for the paired end fragment length."/>
            <param name="no_coverage_bias" type="boolean" label="No coverage bias" checked="false" help="Ignore statistical models and force coverage to be constant across the genome?"/>
            <param name="rng_seed" type="integer" label="RNG seed" optional="true" help="Set an RNG seed value."/>
            <param name="min_mutations" type="integer" label="Min mutation" optional="true" help="Set an absolute minimum number of mutations. The program always adds at least 1 mutation."/>
        </section>
        <section name="utility" title="Neat utilities">
            <conditional name="models">
                <param name="gen_model" type="select" label="Generating models">
                    <option value="">No model</option>
                    <option value="produce_fraglen_model">model-fraglen</option>
                    <option value="produce_mutation_model">gen-mut-model</option>
                    <option value="produce_error_model">model-seq-err</option>
                </param>
                <when value="">
                </when>
                <when value="produce_fraglen_model">
                    <param name="input_fraglen" type="data" format="bam,sam" label="input" help="BAM or SAM input file"/>
                    <param argument="--min_reads" type="integer" optional="true" min="0" max="100" value="2" label="Minimum number of reads" help="Minimum number of reads for a fragment length to consider it in the model." />
                </when>
                <when value="produce_mutation_model">
                    <param name="mutations" type="data" format="vcf" label="Mutation" help="Mutation file for organism in VCF format" />
                    <param argument="--bed" type="data" format="bed" label="Regions" optional="true" help="Bed file with regions to use in the model" />
                    <param name="trinuc" type="boolean" truevalue="yes" falsevalue="no" checked="false" label="Calculate trinucleotide counts?" help="Note, this file will not be used if a bed file is also used." />
                    <param argument="--human_sample" type="boolean" truevalue="--human_sample" falsevalue="" checked="false" optional="true" label="Human sample" help="When checked true onle numbered chromosomes, X ,Y, and MT is used" />
                    <param argument="--skip_common" type="boolean" truevalue="--skip_common" falsevalue="" checked="false" optional="true" label="Include common variants?" help="Includes a list of common variants, if you want to visualize common variants with `plot_mut_model.py`" />
                </when>
                <when value="produce_error_model">
                    <param name="input_error" type="data" format="fastq,fastq.gz" multiple="true" label="input FASTQ(s)" help="Entering 1 fastq will set the modeler to single-ended mode. Use 2 FASTQs for paired ended models. To use a sam/bam input, first convert it to FASTQ using an external tool."/>
                    <param argument="-q" type="select" label="Quality offset" help="The quality score offset. The default follows the sanger quality offset.">
                        <option value="33">33</option>
                        <option value="64">64</option>
                    </param>
                    <param argument="-Q" type="text" value="2 11 25 37" label="Quality scores" help="Enter as a space separeted list for binned scores. Or enter a single maximum score for a full range (-Q 42 gives all scores from 1-42). Note that using quality score bins on an unbinned fastq will result in a binned model, at the cost of some inaccuracy.">
                        <validator type="regex">[ .0-9]+</validator>
                    </param>
                    <param argument="-m" type="integer" min="0" optional="true" label="Max read" help="Max number of reads to process." />
                </when>
            </conditional>
        </section>
        <section name="output" title="Output options">
            <param name="produce_bam" type="boolean" label="Produce BAM" checked="false" help="Produce the golden bam file containing the reads aligned with the exact region of the genome?"/>
            <param name="produce_vcf" type="boolean" label="Produce VCF" checked="false" help="Produce a vcf file containing all the mutation errors added by NEAT?"/>
            <param name="produce_fastq" type="boolean" label="Produce FASTQ" checked="true" help="Produce fastq(s) of the reads?"/>
            <param name="output_log" type="boolean" label="Output Log?" checked="false"/>
        </section>
    </inputs>
    <outputs>
        <data format="fastq.gz" name="fastq" from_work_dir="neat.fastq.gz" label="${tool.name} on ${on_string}: fastq file">
            <filter>advanced['paired_ended'] == False and advanced['produce_fastq']</filter>
        </data>
        <data format="fastq.gz" name="fastq_r1" from_work_dir="neat_r1.fastq.gz" label="${tool.name} on ${on_string}: fastq_r1 file">
            <filter>advanced['paired_ended']</filter>
        </data>
        <data format="fastq.gz" name="fastq_r2" from_work_dir="neat_r2.fastq.gz" label="${tool.name} on ${on_string}: fastq_r2 file">
            <filter>advanced['paired_ended']</filter>
        </data>
        <data format="bam" name="bam" from_work_dir="neat_golden.bam" label="${tool.name} on ${on_string}: bam file">
            <filter>output['produce_bam']</filter>
        </data>
        <data format="tabular.gz" name="vcf" from_work_dir="neat_golden.vcf.gz" label="${tool.name} on ${on_string}: vcf file">
            <filter>output['produce_vcf']</filter>
        </data>
        <data format="txt" name="log" from_work_dir="neat.log" label="${tool.name} on ${on_string}: log file">
            <filter>output['output_log']</filter>
        </data>
        <data format="txt" name="log_fraglen" from_work_dir="neat_fraglen.log" label="${tool.name} on ${on_string}: model-fraglen log file">
            <filter>output['output_log'] and utility['models']['gen_model'] == 'produce_fraglen_model'</filter>
        </data>
        <data format="txt" name="log_mut" from_work_dir="neat_mut.log" label="${tool.name} on ${on_string}: gen-mut-model log file">
            <filter>output['output_log'] and utility['models']['gen_model'] == 'produce_mutation_model'</filter>
        </data>
        <data format="txt" name="log_mut_trinuc" from_work_dir="neat_mut_tinuc.log" label="${tool.name} on ${on_string}: gen-mut-model_trinuc log file">
            <filter>output['output_log'] and utility['models']['gen_model'] == 'produce_mutation_model' and utility['models']['trinuc']</filter>
        </data>
        <data format="txt" name="log_seq" from_work_dir="neat_seq.log" label="${tool.name} on ${on_string}: model-seq-err log file">
            <filter>output['output_log'] and utility['models']['gen_model'] == 'produce_error_model'</filter>
        </data>
    </outputs>
    <tests>
        <test expect_exit_code="0" expect_num_outputs="3">
            <param name="reference" value="H1N1.fa"/>
            <param name="paired_ended" value="true"/>
            <param name="fragment_mean" value="300"/>
            <param name="fragment_st_dev" value="30"/>
            <param name="output_log" value="true"/>
            <assert_stdout>
                <has_text text="command finished successfully"/>
            </assert_stdout>
            <output name="fastq_r1" file="neat_r1.fastq.gz" compare="sim_size"/>
            <output name="fastq_r2" file="neat_r2.fastq.gz" compare="sim_size"/>
            <output name="log" file="neat.log" compare="sim_size">
                <assert_contents>
                    <has_text text="command finished successfully"/>
                </assert_contents>
            </output>
        </test>
        <test expect_exit_code="0" expect_num_outputs="3">
            <param name="reference" value="H1N1.fa"/>
            <param name="produce_bam" value="true"/>
            <param name="produce_vcf" value="true"/>
            <assert_stdout>
                <has_text text="command finished successfully"/>
            </assert_stdout>
            <output name="bam" file="neat_golden.bam" compare="sim_size"/>
            <output name="vcf" file="neat_golden.vcf.gz" compare="sim_size"/>
            <output name="fastq" file="neat.fastq.gz" compare="sim_size"/>
        </test>
        <test expect_exit_code="0" expect_num_outputs="3">
            <param name="reference" value="H1N1.fa"/>
            <conditional name="models">
                <param name="gen_model" value="produce_fraglen_model"/>
                <param name="input_fraglen" value="input_fraglen.bam"/>
            </conditional>
            <param name="output_log" value="true"/>
            <assert_stdout>
                <has_text text="command finished successfully"/>
            </assert_stdout>
            <output name="log_fraglen" file="neat_fraglen.log" compare="sim_size">
                <assert_contents>
                    <has_text text="command finished successfully"/>
                </assert_contents>
            </output>
            <output name="log" file="neat.log" compare="sim_size">
                <assert_contents>
                    <has_text text="command finished successfully"/>
                </assert_contents>
            </output>
        </test>
        <test expect_exit_code="0" expect_num_outputs="3">
            <param name="reference" value="H1N1.fa"/>
            <conditional name="models">
                <param name="gen_model" value="produce_mutation_model"/>
                <param name="mutations" value="gen_mut_input.vcf"/>
            </conditional>
            <param name="output_log" value="true"/>
            <assert_stdout>
                <has_text text="command finished successfully"/>
            </assert_stdout>
            <output name="log_mut" file="neat_mut.log" compare="sim_size">
                <assert_contents>
                    <has_text text="command finished successfully"/>
                </assert_contents>
            </output>
            <output name="log" file="neat.log" compare="sim_size">
                <assert_contents>
                    <has_text text="command finished successfully"/>
                </assert_contents>
            </output>
        </test>
        <test expect_exit_code="0" expect_num_outputs="4">
            <param name="reference" value="H1N1.fa"/>
            <conditional name="models">
                <param name="gen_model" value="produce_mutation_model"/>
                <param name="mutations" value="gen_mut_input.vcf"/>
                <param name="trinuc" value="true"/>
            </conditional>
            <param name="output_log" value="true"/>
            <assert_stdout>
                <has_text text="command finished successfully"/>
            </assert_stdout>
            <output name="log_mut" file="neat_mut.log" compare="sim_size">
                <assert_contents>
                    <has_text text="command finished successfully"/>
                </assert_contents>
            </output>
            <output name="log_mut_trinuc" file="neat_mut_tinuc.log" compare="sim_size">
                <assert_contents>
                    <has_text text="command finished successfully"/>
                </assert_contents>
            </output>
            <output name="log" file="neat.log" compare="sim_size">
                <assert_contents>
                    <has_text text="command finished successfully"/>
                </assert_contents>
            </output>
        </test>
        <test expect_exit_code="0" expect_num_outputs="3">
            <param name="reference" value="H1N1.fa"/>
            <conditional name="models">
                <param name="gen_model" value="produce_error_model"/>
                <param name="input_error" value="neat.fastq.gz"/>
            </conditional>
            <param name="output_log" value="true"/>
            <assert_stdout>
                <has_text text="command finished successfully"/>
            </assert_stdout>
            <output name="log_seq" file="neat_seq.log" compare="sim_size">
                <assert_contents>
                    <has_text text="command finished successfully"/>
                </assert_contents>
            </output>
            <output name="log" file="neat.log" compare="sim_size">
                <assert_contents>
                    <has_text text="command finished successfully"/>
                </assert_contents>
            </output>
        </test>
        <test expect_exit_code="0" expect_num_outputs="3">
            <param name="reference" value="H1N1.fa"/>
            <conditional name="models">
                <param name="gen_model" value="produce_error_model"/>
                <param name="input_error" value="neat_r1.fastq.gz,neat_r2.fastq.gz"/>
            </conditional>
            <param name="output_log" value="true"/>
            <assert_stdout>
                <has_text text="command finished successfully"/>
            </assert_stdout>
            <output name="log_seq" file="neat_seq.log" compare="sim_size">
                <assert_contents>
                    <has_text text="command finished successfully"/>
                </assert_contents>
            </output>
            <output name="log" file="neat.log" compare="sim_size">
                <assert_contents>
                    <has_text text="command finished successfully"/>
                </assert_contents>
            </output>
        </test>
    </tests>
    <help>
NEAT produces simulated sequencing datasets. It creates FASTQ files with reads sampled from a provided reference genome, using sequencing error rates and mutation rates learned from real sequencing data. The strength of NEAT lies in the ability for the user to customize many sequencing parameters, produce 'golden,' true positive datasets. We are working on expanding the functionality even further to model more species, generate larger variants, model tumor/normal data and more!

Optional outputs include:
        * a golden vcf showing all inserted true variants (i.e., not the simulated errors),
        * a golden BAM showing a fast alignment against the region where the read came from,
        * a fasta file containing the inserted variants only (no errors).

.. image:: https://github.com/ncsa/NEAT/raw/f33455695d57146852017a7eef7cded1ea6cc58e/docs/NEATNEAT.png
    :width: 800
    :height: 320
    
-----

.. class:: infomark

The 'Read length' is only required if 'Produce FASTQ' is set to true.

.. class:: infomark

Scalar value is for coverage in regions outside the targeted bed. For example value 0.5 would get you roughly half the coverage as the on target areas. Default is 0 coverage in off-target regions.

.. class:: infomark

Mutation rates in the 'Mutation bed file' must be in the fourth column and be of the form "mut_rate=x.xx". Rates must be between 0.00 and 0.03.

.. class:: infomark

The 'Fragment mean' and 'Fragment standard deviation' are required if 'Paired ended' is set to true, unless a fragment length model is used.

.. class:: infomark

The 'RNG seed' is useful for debugging. Runs using identical RNG values should produce identical results so things like read locations, variant positions, error positions, etc. should be the same.

.. class:: infomark

The 'Min mutation' is useful for very small datasets. The program always adds at least 1 mutation.

.. class:: infomark

When using model-fraglen, The defaulf `--min_reads` is set to 2, to handle smaller datasets. Set it to 0 to turn off filtering. For a larger dataset, try 100 and adjust from there.
    </help>
    <expand macro="citations" />
</tool>