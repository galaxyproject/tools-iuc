<?xml version="1.0"?>
<macros>
    <token name="@TOOL_VERSION@">5.2.10.49</token> <!-- TODO -->
    <token name="@VERSION_SUFFIX@">0</token>
    <xml name="requirements">
        <requirements>
            <requirement type="package" version="@TOOL_VERSION@">pisces</requirement>
            <requirement type="package" version="1.10">samtools</requirement> <!-- newer version throws errors -->
            <requirement type="package" version="3.0">zip</requirement>
        </requirements>
    </xml>
    <xml name="version_command">
    	<version_command><![CDATA[/home/stephan/Projects/tools/pisces/All_5.3.0.0/Pisces -v 2>&1 | grep 'Pisces' | cut -f 2 -d ' ' ]]></version_command> <!-- TODO -->
    </xml>
    <xml name="citations">
	    <citations>
	        <citation type="doi">10.1101/291641</citation>
	        <citation type="doi">10.1093/bioinformatics/bty849</citation>
	    </citations>
    </xml>

    <!-- command -->

<token name="@BAM_FILTERING@"><![CDATA[
--minbasecallquality $bfo.minbasecallquality ## --minbq
--minmapquality $bfo.minmapquality ## --minmq
$bfo.filterduplicates ## --duplicatereadfilter
$bfo.pp ## --onlyuseproperpairs
]]></token>
    <token name="@GENOMESIZE@"><![CDATA[
## process genome to create GenomeSize.xml
mkdir genome &&
ln -s '$genome' 'genome/genome.fasta' &&
/home/stephan/Projects/tools/pisces/All_5.3.0.0/CreateGenomeSizeFile ## TODO
-g 'genome/' ## folder, '/' required
-s '$genome_description' &&
    ]]></token>
<token name="@VARIANT_CALLING@"><![CDATA[
--minvq $vco.minvq ## --minvariantqscore
--mindp $vco.mindp ## -c, --mindepth, --mincoverage
--vqfilter $vco.vqfilter ## --variantqualityfilter
#if $vco.vffilter != ''
    --vffilter $vco.vffilter ## --minvariantfrequencyfilter
#end if
#if $vco.gqfilter != ''
    --gqfilter $vco.gqfilter ## --genotypequalityfilter
#end if
#if $vco.mindpfilter != ''
    --mindpfilter $vco.mindpfilter ## --mindepthfilter
#end if
$vco.ssfilter ## --enablesinglestrandfilter
#if $vco.nl != ''
    --nl $vco.nl ## --noiselevelforqmodel
#end if
--ploidy $vco.ploidy_cond.ploidy_sel
#if $vco.ploidy_cond.ploidy_sel == 'somatic'
    --minvf $vco.ploidy_cond.minvf ## --minimumvariantfrequency, --minimumfrequency
    --targetlodfrequency $vco.ploidy_cond.targetlodfrequency ## --targetvf
#elif $vco.ploidy_cond.ploidy_sel == 'diploid'
    --diploidsnvgenotypeparameters '$vco.ploidy_cond.diploidsnvgenotypeparameters'
    --diploidindelgenotypeparameters '$vco.ploidy_cond.diploidindelgenotypeparameters'
#elif $vco.ploidy_cond.ploidy_sel == 'DiploidByAdaptiveGT'
    #if $vco.ploidy_cond.adaptivegenotypeparameters_fromfile
        --adaptivegenotypeparameters_fromfile '$vco.ploidy_cond.adaptivegenotypeparameters_fromfile'
    #end if
    --adaptivegenotypeparameters_snvmodel '$vco.ploidy_cond.adaptivegenotypeparameters_snvmodel'
    --adaptivegenotypeparameters_indelmodel '$vco.ploidy_cond.adaptivegenotypeparameters_indelmodel'
    --adaptivegenotypeparameters_snvprior '$vco.ploidy_cond.adaptivegenotypeparameters_snvprior'
    --adaptivegenotypeparameters_indelprior '$vco.ploidy_cond.adaptivegenotypeparameters_indelprior'
#end if
--sbmodel $vco.sbmodel
--maxvq $vco.maxvq ## --maxvariantqscore
--mingq $vco.mingq ## --maxgenotypeqscore
--maxgq $vco.maxgq ## --maxgenotypeposteriorscore
--maxgp $vco.maxgp ## --mingenotypeqscore
--sbfilter $vco.sbfilter ## --maxacceptablestrandbiasfilter
--noisemodel $vco.noisemodel
#if $vco.gender != ''
    --gender $vco.gender
#end if
#if $vco.rmxnfilter == ''
    --rmxnfilter false
#else
    --rmxnfilter '$vco.rmxnfilter'
#end if
--ncfilter $vco.ncfilter
#if $vco.abfilter != ''
    --abfilter $vco.abfilter
#end if
]]></token>
	
    <!-- input -->    

    <xml name="abfilter">
        <param argument="--abfilter" type="float" value="" optional="true" label="Set amplicon bias filter threshold" help="By default, this filter is off. If on, the threshold has the following meaning:  If a variant shows up at Y percent on amplicon A and X percent on amplicon B, the X observation must be at least as probable as the Amplicon bias filter threshold, using the observations of Y as frequency estimate. To turn on, set to a positive float. '0.01' seems to work well."/>
    </xml>
    <xml name="bam" token_multiple="false" token_label="Select sample file" token_help="">
        <param name="bam" type="data" format="bam" multiple="@MULTIPLE@" label="@LABEL@" help="(--bam@HELP@)"/>
    </xml>
    <xml name="bamfilteringoptions">
        <section name="bfo" title="BAM filtering options" expanded="true">
            <expand macro="minbasecallquality" help="(--minbq, --minbasecallquality)"/>
            <expand macro="minmapquality" help="(--minmq, --minmapquality)"/>
            <expand macro="filterduplicates"/>
            <expand macro="pp"/>
        </section>
    </xml>
    <xml name="crushvcf">
        <param argument="--crushvcf" type="boolean" truevalue="--crushvcf true" falsevalue="" label="Crush vcf output to one line per loci?"/>
    </xml>
    <xml name="filterduplicates">
        <param name="filterduplicates" type="boolean" truevalue="--filterduplicates true" falsevalue="--filterduplicates false" checked="true" label="Filter reads marked as duplicates?" help="(--filterduplicates, --duplicatereadfilter)"/>
    </xml>
    <xml name="gender">
		<param argument="--gender" type="select" label="Select gender of the sample">
		    <option value="" selected="true">No</option>
		    <option value="true">Male</option>
		    <option value="false">Female</option>
		</param>
    </xml>
    <xml name="genome" token_help="">
        <param name="genome" type="data" format="fasta" label="Select file with genome" help="(CreateGenomeSizeFile.dll -g@HELP@)"/>
    </xml>    
    <xml name="genome_description">
        <param name="genome_description" type="text" value="Homo Sapiens (hg 19)" label="Set genome description" help="Species name and build, e.g. 'Rattus norvegicus (UCSC rn4)'. (CreateGenomeSizeFile.dll -s)"> <!-- TODO remove default value -->
            <expand macro="validator_genomename"/>
        </param>
    </xml>
    <xml name="gqfilter">
        <param name="gqfilter" type="integer" min="0" value="" optional="true" label="Set filtered genotype quality to report variant as filtered" help="(--gqfilter, --genotypequalityfilter)"/>
    </xml>
    <xml name="gvcf">
        <param argument="--gvcf" type="boolean" truevalue="--gvcf true" falsevalue="--gvcf false" checked="true" label="Create gVCF instead of VCF variant output?" help="E.g. to include reference calls."/>
    </xml>
    <xml name="maxgp">
        <param name="maxgp" type="integer" min="0" value="3000" label="Set maximum genotype posterior score to cap output genotype posteriors" help="(--maxgp, --maxgenotypeposteriorscore)"/>
    </xml>
    <xml name="maxgq">
        <param name="maxgq" type="integer" min="0" value="100" label="Set maximum genotype Q Score to cap output genotype Q scores" help="(--maxgq, --maxgenotypeqscore)"/>
    </xml>
    <xml name="maxvq">
        <param name="maxvq" type="integer" min="0" value="100" label="Set maximum variant Q Score to cap output variant Q scores" help="Must be greater than or equal to MinimumVariantQscore. (--maxvq, --maxvariantqscore)"/>
    </xml>
    <xml name="minbasecallquality" token_help="">
        <param name="minbasecallquality" type="integer" min="0" max="50" value="20" label="Set minimum basecall quality" help="@HELP@"/>
    </xml>
    <xml name="mindp">
        <param name="mindp" type="integer" value="10" label="Set minimum depth to call a variant" help="(-c, --mindp, --mindepth, --mincoverage)"/>
    </xml>
    <xml name="mindpfilter">
        <param name="mindpfilter" type="integer" value="" optional="true" label="Set filtered low depth to report variant as filtered" help="Should be above the minimum coverage depth to emit a variant. (--mindpfilter, --mindepthfilter)"/>
    </xml>
    <xml name="mingq">
        <param name="mingq" type="integer" min="0" value="0" label="Set minimum genotype Q Score to cap output genotype Q scores" help="(--mingq, --mingenotypeqscore)"/>
    </xml>
    <xml name="minmapquality" token_help="">
        <param name="minmapquality" type="integer" min="0" value="1" label="Set minimum map quality" help="@HELP@"/>
    </xml>
    <xml name="minvq">
        <param name="minvq" type="integer" value="20" label="Set minimum variant Q score to report variant" help="(--minvq, --minvariantqscore)"/>
    </xml>
    <xml name="ncfilter">
        <param argument="--ncfilter" type="float" value="0.6" label="Set no-call rate filter"/>
    </xml>
    <xml name="nl">
        <param name="nl" type="integer" value="" optional="true" label="Set noise level for Q model" help="Overrides the noise level to used by the quality model with this value. By default, this is driven by the basecall filter. (--nl, --noiselevelforqmodel)"/>
    </xml>
    <xml name="noisemodel">
        <param argument="--noisemodel" type="select" multiple="false" label="--noisemodel">
            <option value="flat" selected="true">Flat</option>
            <option value="window">Window</option>
        </param>
    </xml>
    <xml name="ploidy">
        <conditional name="ploidy_cond">
            <param name="ploidy_sel" type="select" multiple="false" label="Select ploidy type" help="To test drive the new adaptive model, try 'DiploidByAdaptiveGT' (--ploidy)">
                <option value="somatic" selected="true">somatic</option>
                <option value="diploid">diploid</option>
                <option value="DiploidByAdaptiveGT">DiploidByAdaptiveGT</option>
            </param>
            <when value="somatic">
                <param name="targetlodfrequency" type="float" min="0.0" max="1.0" value="0.01" label="Set target frequency to call a variant" help="E.g. to target a 5% allele frequency, we must call down to 2.6%, to capture that 5% allele 95% of the time. This parameter is used by the Somatic Genotyping Model. (--targetlodfrequency, --targetvf)"/>
                <param name="minvf" type="float" min="0.0" max="1.0" value="0.01" label="Set minimum frequency to call a variant" help="(--minvf, --minimumvariantfrequency, --minimumfrequency)"/>
            </when>
            <when value="diploid">
                <param argument="--diploidsnvgenotypeparameters" type="text" value="0.2,0.7,0.8" label="Set diploid SNV genotype parameters">
                    <expand macro="validator_floatlist"/>
                </param>
                <param argument="--diploidindelgenotypeparameters" type="text" value="0.2,0.7,0.8" label="Set diploid indel genotype parameters">
                    <expand macro="validator_floatlist"/>
                </param>
            </when>
            <when value="DiploidByAdaptiveGT">
                <param argument="--adaptivegenotypeparameters_fromfile" type="data" format="" optional="true" label="Select adaptive genotype parameters file"/> <!-- TODO data type -->
                <param argument="--adaptivegenotypeparameters_snvmodel" type="text" value="0.037,0.439,0.976" label="Set adaptive genotype parameters SNV model">
                    <expand macro="validator_floatlist"/>
                </param>
                <param argument="--adaptivegenotypeparameters_indelmodel" type="text" value="0.037,0.443,0.905" label="Set adaptive genotype parameters indel model">
                    <expand macro="validator_floatlist"/>
                </param>
                <param argument="--adaptivegenotypeparameters_snvprior" type="text" value="0.755,0.154,0.0919" label="Set adaptive genotype parameters SNV prior">
                    <expand macro="validator_floatlist"/>
                </param>
                <param argument="--adaptivegenotypeparameters_indelprior" type="text" value="0.962,0.0266,0.0114" label="Set adaptive genotype parameters indel prior">
                    <expand macro="validator_floatlist"/>
                </param>
            </when>
        </conditional>
    </xml>
    <xml name="pp">
        <param name="pp" type="boolean" truevalue="--pp true" falsevalue="--pp false" checked="true" label="Only use proper pairs?" help="(--pp, --onlyuseproperpairs)"/>
    </xml>
    <xml name="reportnocalls">
        <param argument="--reportnocalls" type="boolean" truevalue="--reportnocalls true" falsevalue="--reportnocalls false" label="Report no calls?"/>
    </xml>
    <xml name="reportrccounts">
        <param argument="--reportrccounts" type="boolean" truevalue="--reportrccounts true" falsevalue="--reportrccounts false" label="Report collapsed read counts?" help="When BAM files contain X1 and X2 tags, output read counts for duplex-stitched, duplex-nonstitched, simplex-stitched, and simplex-nonstitched."/>
    </xml>
    <xml name="reportsuspiciouscoveragefraction">
        <param argument="--reportsuspiciouscoveragefraction" type="boolean" truevalue="--reportsuspiciouscoveragefraction true" falsevalue="--reportsuspiciouscoveragefraction false" label="Report fraction of total coverage?" help="For spanning variants, this is start + end coverage, so up to double the reported coverage that is 'suspicious' i.e. unanchored and bearing some resemblance to an insertion at that site."/>
    </xml>
    <xml name="reporttscounts">
        <param argument="--reporttscounts" type="boolean" truevalue="--reporttscounts true" falsevalue="--reporttscounts false" label="Report collapsed read count by different template strands?" help="Conditional on ReportRcCounts, output read counts for duplex-stitched, duplex-nonstitched, simplex-forward-stitched, simplex-forward-nonstitched, simplex-reverse-stitched, simplex-reverse-nonstitched."/>
    </xml>
    <xml name="rmxnfilter">
        <param argument="--rmxnfilter" type="text" value="5,9,0.20" label="Set RMXN filter" help="M,N,F. Comma-separated list of integer, integer, float indicating the maximum length of the repeat section (M), the minimum number of repetitions of that repeat (N), to be applied if the variant frequency is less than (F). Keep empty to turn this parameter off.">
            <validator type="regex" message="Comma-separated list of integer,integer,float values.">\b(([0-9]*),([0-9]*),([0-9]*\.[0-9]*))\b</validator>
        </param>
    </xml>
    <xml name="ro">
        <section name="ro" title="Realignment options" expanded="true">
            <param argument="--maskpartialinsertion" type="boolean" truevalue="--maskpartialinsertion true" falsevalue="--maskpartialinsertion false" label="Mask partial insertion?" help="Option to softclip a partial insertion at the end of a realigned read (a complete but unanchored insertion is allowed)."/>
            <param argument="--minimumunanchoredinsertionlength" type="integer" value="0" label="Set minimum unanchored insertion length" help="Minimum length of an unanchored insertion (i.e. no flanking reference base on one side) allowed in a realigned read. Insertions shorter than the specified length will be softclipped. Default value is 0, i.e. allowing unanchored insertions of any length."/>
            <param argument="--softclipunknownindels" type="boolean" truevalue="--softclipunknownindels true" falsevalue="--softclipunknownindels false" label="Softclip out unknown indels?"/>
            <param argument="--checksoftclipsformismatches" type="boolean" truevalue="--checksoftclipsformismatches true" falsevalue="--checksoftclipsformismatches false"  label="Count mismatches in softclips toward total mismatches?"/>
            <param argument="--trackmismatches" type="boolean" truevalue="--trackmismatches true" falsevalue="--trackmismatches false" label="Track and compare mismatches when realigning?"/>
            <param argument="--categoriestorealign" type="select" multiple="true" label="Select categories to realign">
                <option value="ImperfectStitched" selected="true">ImperfectStitched</option>
                <option value="FailStitch" selected="true">FailStitch</option>
                <option value="UnstitchIndel" selected="true">UnstitchIndel</option>
                <option value="Unstitchable" selected="true">Unstitchable</option>
                <option value="Disagree" selected="true">Disagree</option>
                <option value="MessyStitched" selected="true">MessyStitched</option>
                <option value="MessySplit" selected="true">MessySplit</option>
                <option value="UnstitchImperfect" selected="true">UnstitchImperfect</option>
                <option value="LongFragment" selected="true">LongFragment</option>
                <option value="UnstitchMessy" selected="true">UnstitchMessy</option>
                <option value="UnstitchForwardMessy" selected="true">UnstitchForwardMessy</option>
                <option value="UnstitchReverseMessy" selected="true">UnstitchReverseMessy</option>
                <option value="UnstitchForwardMessyIndel" selected="true">UnstitchForwardMessyIndel</option>
                <option value="UnstitchReverseMessyIndel" selected="true">UnstitchReverseMessyIndel</option>
                <option value="UnstitchMessySuspiciousRead" selected="true">UnstitchMessySuspiciousRead</option>
                <option value="UnstitchMessyIndelSuspiciousRead" selected="true">UnstitchMessyIndelSuspiciousRead</option>
                <option value="UnstitchMessySuspiciousMd" selected="true">UnstitchMessySuspiciousMd</option>
            </param>
            <param argument="--categoriestosnowball" type="select" multiple="true" label="Select categories to snowball">            
                <option value="ImperfectStitched">ImperfectStitched</option>
                <option value="FailStitch">FailStitch</option>
                <option value="UnstitchIndel">UnstitchIndel</option>
                <option value="Unstitchable">Unstitchable</option>
                <option value="Disagree">Disagree</option>
                <option value="MessyStitched">MessyStitched</option>
                <option value="MessySplit">MessySplit</option>
                <option value="UnstitchImperfect">UnstitchImperfect</option>
                <option value="LongFragment">LongFragment</option>
                <option value="UnstitchMessy">UnstitchMessy</option>
                <option value="UnstitchForwardMessy">UnstitchForwardMessy</option>
                <option value="UnstitchReverseMessy">UnstitchReverseMessy</option>
                <option value="UnstitchForwardMessyIndel">UnstitchForwardMessyIndel</option>
                <option value="UnstitchReverseMessyIndel">UnstitchReverseMessyIndel</option>
                <option value="UnstitchMessySuspiciousRead">UnstitchMessySuspiciousRead</option>
                <option value="UnstitchMessyIndelSuspiciousRead">UnstitchMessyIndelSuspiciousRead</option>
                <option value="UnstitchMessySuspiciousMd">UnstitchMessySuspiciousMd</option>
            </param>
            <param argument="--pairawareeverything" type="boolean" truevalue="--pairawareeverything true" falsevalue="--pairawareeverything false" checked="true" label="Pass everything through pair aware realignment?" help="Or just the expected categories (Disagree, FailStitch, UnstitchIndel)?"/>
            <param argument="--forcehighlikelihoodrealigners" type="boolean" truevalue="--forcehighlikelihoodrealigners true" falsevalue="--forcehighlikelihoodrealigners false" label="Force high likelihood realigners?" help="Force realignment in high-likelihood categories even if the neighborhood would not have been eligible for realignment."/>
        </section>
        <section name="rbo" title="Realignment bins options" expanded="true">
            <param argument="--messysitethreshold" type="integer" value="1" label="Set messy site threshold" help="Minimum (raw) number of messy-type reads that must be present in a neighborhood for it to be considered messy and a potential realignable neighborhood. Must also meet the frequency thresholds."/>
            <param argument="--messysitewidth" type="integer" value="500" label="Set messy site width" help="Neighborhood width to use when binning realignment eligibility signals."/>
            <param argument="--collectdepth" type="boolean" truevalue="--collectdepth true" falsevalue="--collectdepth false" checked="true" label="Collect depth to gauge frequency information?"/>            
            <param argument="--imperfectfreqthreshold" type="float" min="0.0" max="1.0" value="0.03" label="Set imperfect frequency threshold" help="Proportion of imperfect reads in bin below which we should not bother to realign. Should be proportional to detection limit and bin width."/>
            <param argument="--indelregionfreqthreshold" type="float" min="0.0" max="1.0" value="0.01" label="Set indel region frequency threshold" help="Proportion of imperfect reads in bin below which we should not bother to realign. Should be proportional to detection limit and bin width."/>
            <param argument="--regiondepththreshold" type="integer" value="5" label="Set region depth threshold" help="When collecting realignment eligibility signals and depth, minimum total number of reads in a neighborhood below which the neighborhood would be ineligible for realignment."/>
            <param argument="--recalculateusablesitesaftersnowball" type="boolean" truevalue="--recalculateusablesitesaftersnowball true" falsevalue="--recalculateusablesitesaftersnowball false" checked="true" label="Recalculate site usability after snowballing?"/>
        </section>
    </xml>
    <xml name="sbfilter">
        <param name="sbfilter" type="float" min="0.0" value="0.5" label="Set strand bias cutoff" help="(--sbfilter, --maxacceptablestrandbiasfilter)"/>
    </xml>
    <xml name="sbmodel">
        <param argument="--sbmodel" type="select" label="Select strand bias model">
            <option value="extended" selected="true">Extended</option>
            <option value="poisson">Poisson</option>
        </param>
    </xml>
        <xml name="so">
        <section name="so" title="Stitching options" expanded="true">
            <expand macro="minbasecallquality" value="20" help="Cutoff for which, in case of a stitching conflict, bases with qscore less than this value will automatically be disregarded in favor of the mate's bases."/> <!-- default value from GeminiMultiOptions.used.json -->
            <param argument="--nifydisagreement" type="boolean" truevalue="--nifydisagreement true" falsevalue="--nifydisagreement false" label="Turn high-quality disagreeing overlap bases to Ns?"/>
            <param argument="--maxreadlength" type="integer" value="1024" label="Set maximum read length" help="Maximum expected length of individual reads, used to determine the maximum expected stitched read length (2*len - 1). For optimal performance, set as low as appropriate (i.e. the actual single-read length + max deletion length you expect to stitch) for your data."/>
            <param argument="--dontstitchrepeatoverlap" type="boolean" truevalue="--dontstitchrepeatoverlap true" falsevalue="--dontstitchrepeatoverlap false" checked="true" label="Stitch read pairs whose only overlap is a repeating sequence?"/>
            <param argument="--ignorereadsabovemaxlength" type="boolean" truevalue="--ignorereadsabovemaxlength true" falsevalue="--ignorereadsabovemaxlength false" label="Ignore reads above maximum length?" help="Whether to passively ignore read pairs that would be above the max stitched length (e.g. extremely long deletions)."/>
            <param argument="--countnstowarddisagreeingbases" type="boolean" truevalue="--countnstowarddisagreeingbases true" falsevalue="--countnstowarddisagreeingbases false" label="Count Ns toward disagreeing bases?" help="Whether to count overlapping-base disagreements where one of the mates reports an 'N' as a full-force disagreement (i.e. Nify the base if configured to do so, and count toward the number of disagreements in determining whether the stitching result should be rejected)."/>
            <param argument="--maxnumdisagreeingstitchedbases" type="integer" value="2147483647" label="Set maximum number of stitched bases" help="That can disagree between the two reads before a stitched read is rejected."/>
            <param argument="--stringtagstokeepfromr1" type="text" value="" optional="true" label="Set tags to keep from R1" help="Comma-delimited list of string tags to retain from first read when stitching.">
                <expand macro="validator_stringlist"/>
            </param>
        </section>
    </xml>
    <xml name="ssfilter">
        <param name="ssfilter" type="boolean" truevalue="--ssfilter true" falsevalue="--ssfilter false" label="Flag variants as filtered if coverage limited to one strand?" help="(--ssfilter, --enablesinglestrandfilter)"/>
    </xml>
    <xml name="variantcallingoptions">
        <section name="vco" title="Variant calling options" expanded="true">
            <expand macro="minvq"/>
            <expand macro="mindp"/>
            <expand macro="vqfilter"/>
            <expand macro="vffilter"/>
            <expand macro="gqfilter"/>
            <expand macro="mindpfilter"/>
            <expand macro="ssfilter"/>
            <expand macro="nl"/>
            <expand macro="ploidy"/>
            <expand macro="sbmodel"/>
            <expand macro="maxvq"/>
            <expand macro="maxgq"/>
            <expand macro="maxgp"/>
            <expand macro="mingq"/>
            <expand macro="sbfilter"/>
            <expand macro="noisemodel"/>
            <expand macro="gender"/>
            <expand macro="rmxnfilter"/>
            <expand macro="ncfilter"/>
            <expand macro="abfilter"/>
        </section>
    </xml>
    <xml name="vcf">
        <param argument="--vcf" type="data" format="vcf" label="Select variant file"/>
    </xml>
    <xml name="vffilter">
        <param name="vffilter" type="float" min="0.0" max="1.0" value="" optional="true" label="Set filtered variant frequency to report variant as filtered" help="(--vffilter, --minvariantfrequencyfilter)"/> <!-- TODO default -->
    </xml>
    <xml name="vqfilter">
        <param name="vqfilter" type="integer" value="30" label="Set filtered variant Q score to report variant as filtered" help="(--vqfilter, --variantqualityfilter)"/>
    </xml>

    <!-- validator TODO ^ and $ required ?, should replace \b ? skip \b? add all validators here -->

    <xml name="validator_floatlist">
        <validator type="regex" message="Comma-separated list of 3 float values.">\b(([0-9]*\.[0-9]*),([0-9]*\.[0-9]*),([0-9]*\.[0-9]*))\b</validator>
    </xml>
    <xml name="validator_stringlist">
        <validator type="regex" message="Comma separated list">\b^[a-zA-Z0-9]+(?:,[a-zA-Z0-9]+)*$\b</validator>
    </xml>
    <xml name="validator_genomename">
        <validator type="regex" message="Whitespaces between genus, species, source and build are important, e.g. 'Rattus norvegicus (UCSC rn4)'. The length of a split by whitespace must be >= 3.">^[a-zA-Z0-9]* [a-zA-Z0-9]* \([a-zA-Z0-9]* [a-zA-Z0-9]*\)$</validator>
    </xml>

    <!-- output -->

    <xml name="out_ao" token_tool="">
        <data name="out_ao" format="json" from_work_dir="results/@TOOL@Logs/@TOOL@Options.used.json" label="${tool.name} on ${on_string}: Applied options">
            <filter>'ao' in oo['out']</filter>
        </data>
    </xml>
    <xml name="out_l" token_tool="">
        <data name="out_l" format="txt" from_work_dir="results/@TOOL@Logs/@TOOL@Log.txt" label="${tool.name} on ${on_string}: Log">
            <filter>'l' in oo['out']</filter>
        </data>
    </xml>
    <xml name="out_gs" token_filter="">
        <data name="out_gs" format="xml" from_work_dir="genome/GenomeSize.xml" label="${tool.name} on ${on_string}: GenomeSize">
            <filter>'gs' in oo['out']@FILTER@</filter>
        </data>
    </xml>

    <!-- help -->




    <token name="@REFERENCES@"><![CDATA[
More information are available on `GitHub <https://github.com/Illumina/Pisces/>`_ and in the `wiki <https://github.com/Illumina/Pisces/wiki>`_.
    ]]></token>
    <token name="@WID@"><![CDATA[
Pisces is a tool suite for somatic and germline variant calling on amplicon data.
    ]]></token>

    <!-- TODO -->
    <token name="@HELP_AGP@"><![CDATA[
- Adaptive genotype parameters (JSON), e.g.

    ::

        ...
    ]]></token>
    <token name="@HELP_AO@"><![CDATA[
- Applied options (JSON), e.g.

    ::

        {
            "LogFileName": "VennVcfLog.txt",
            "InputFiles": [
                "a.vcf",
                "b.vcf"
            ],
            ...
        }
    ]]></token>
    <token name="@HELP_BAM@"><![CDATA[
- Sample (BAM), whereas alignment reads should be sorted by mapped reference position and positions in BAM files are expected to use 0-based coordinate system.
    ]]></token>
    <token name="@HELP_GENOME@"><![CDATA[
- Reference genome (FASTA)
    ]]></token>
    <token name="@HELP_GS@"><![CDATA[
- GenomeSize (XML)
    ]]></token>
    <token name="@HELP_L@"><![CDATA[
- Log (TXT)
    ]]></token>
</macros>