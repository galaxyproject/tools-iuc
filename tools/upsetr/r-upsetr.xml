<tool id="r-upsetr" name="UpSetR" version="@VERSION@.0">
    <description>visualize set intersections</description>
     <macros>
        <token name="@VERSION@">1.3.3</token>
    </macros>

    <requirements>
        <requirement type="package" version="@VERSION@">r-upsetr</requirement>
    </requirements>

    <command detect_errors="exit_code"><![CDATA[
        Rscript '$script'
    ]]></command>

    <configfiles>
        <configfile name="script"><![CDATA[
## Setup R error handling to go to stderr
options(show.error.messages=F, error=function(){cat(geterrmessage(),file=stderr());q("no",1,F)})
loc <- Sys.setlocale("LC_MESSAGES", "en_US.UTF-8")

## Import library
library("UpSetR")

## File Input
#if str($input_type.input_type_selector) == 'file'
    input <- read.csv('$input_type.inputFile', header=T, sep=";")
#end if


## List Input
#if str($input_type.input_type_selector) == 'list'
    listInput <- list()
    #for $i in $input_type.lists
        listInput <- append(listInput, strsplit("${i.listInput}", ":"))
    #end for

    listNames <- list()
    listElements <- list()
    for(i in seq(listInput)){
        listNames <- append(listNames, listInput[[i]][1])
        listElements <- append(listElements, listInput[[i]][2])
    }

    listElements <- lapply(listElements, function(x){x <- as.numeric(unlist(strsplit(x, ",")))})
    names(listElements) <- listNames
    input <- fromList(listElements)
#end if

## Expression Input
#if str($input_type.input_type_selector) == 'expression'
    expressionInput <- as.list(unlist(strsplit("$input_type.expressionInput", ",")))
    expressionInput <- lapply(expressionInput, function(x){x <- unlist(strsplit(x, "="))})
    expressionName <- list()
    expression <-list()

    for(i in seq(expressionInput)){
        expressionName <- append(expressionName, expressionInput[[i]][1])
        expression <- append(expression, expressionInput[[i]][2])
    }

    expression <- lapply(expression, as.numeric)
    names(expression) <- expressionName
    input <- fromExpression(expression)   
#end if

## UpSet Plot Parameters
#if str($text_scale_select.text_scale_selector) == 'universal'
    text_scale <- as.numeric("${text_scale_select.text_scale}")
#else if str($text_scale_select.text_scale_selector) == 'individual'
    text_scale <- as.numeric(unlist(strsplit("${text_scale_select.text_scale}", ",")))
#end if

#if str($sets) != ''
    set <- as.character(unlist(strsplit(gsub(" ", "", "${sets}"), ",")))
#else if str($sets) == ''
    set <- NULL
#end if

mb_ratio <- as.numeric(unlist(strsplit("${mb_ratio}", ",")))

#if str($order_by) == 'freq' or str($order_by) == 'degree'
    order <- "${order_by}"
#else if str($order_by) == 'freq_degree' 
    order <- c("freq", "degree") 
#else if str($order_by) == 'degree_freq'
    order <- c("degree", "freq")
#end if

#if str($keep_order) == 'true'
    keep_order <- T
#else if str($keep_order) == ''
    keep_order <- F
#end if

#if str($nintersects_select.nintersects_selector) == 'yes'
    ninters <- NA
#else if str($nintersects_select.nintersects_selector) == 'no'
    ninters <- "${nintersects_select.nintersects}"
#end if

#if str($cutoff) != ''
    cut_off <- as.numeric("${cutoff}")
#else if str($cutoff) == ''
    cut_off <- NULL
#end if

#if str($empty_intersections) == 'true'
    empty_inters <- "on"
#else if str($empty_intersections) == ''
    empty_inters <- NULL
#end if

#if str($matrix_color) != ''
    matrix_color <- "${matrix_color}"
#else if str($matrix_color) == ''
    matrix_color <- "gray23"
#end if

#if str($main_bar_color) != ''
    bar_color <- "${main_bar_color}"
#else if str($main_bar_color) == ''
    bar_color <- "gray23"
#end if

#if str($mainbar_y_max) != ''
    y_max <- "${mainbar_y_max}"
#else if str($mainbar_y_max) == ''
    y_max <- NULL
#end if

#if str($sets_bar_color) != ''
    sets_bar_color <- "${sets_bar_color}"
#else if str($sets_bar_color) == ''
    sets_bar_color <- "gray23"
#end if

#if str($att_color) != ''
    att_color <- "${att_color}"
#else if str($att_color) == ''
    att_color <- bar_color
#end if

#if str($decreasing) == 'decr'
    decr <- T
#else if str($decreasing) == 'incr'
    decr <- F
#else if str($decreasing) == 'decr_incr' 
    decr <- c(T, F) 
#else if str($decreasing) == 'incr_decr'
    decr <- c(F, T)
#end if

#if str($show_numbers) == 'true'
    show_numbers <- "yes"
#else if str($show_numbers) == ''
    show_numbers <- "no"
#end if

#if str($shade_color) != ''
    shade_color <- "${shade_color}"
#else if str($shade_color) == ''
    shade_color <- "gray88"
#end if

#if str($boxplot_summary) != ''
    boxplot_summary <- as.character(unlist(strsplit(gsub(" ", "", "${boxplot_summary}"), ",")))
#else if str($boxplot_summary) == ''
    boxplot_summary <- NULL
#end if

## Query

#if str($query_select.query_selector) == 'yes'
    query <- list()
    params <- list()
    color <- list()
    active <- list()
    #for $i in $query_select.queries
        query <- append(query, "${i.query}")
        params <- append(params, "${i.params}")
        color <- append(color, "${i.color}")
        active <- append(active, "${i.active}")
    #end for

y <- query
a <- params
z <- color
w <- active

## QUERY

y <- lapply(y, function(x) strsplit(x, " "))

for (i in seq(y)){
  names(y[[i]]) <- c("query")}

## PARAMS

g <- lapply(a, function(x) as.numeric(unlist(regmatches(x,gregexpr("(?>-)*[[:digit:]]+\\.*[[:digit:]]*", x, perl=TRUE)))))

b <- gsub("\\b\\d+\\b", "", a)
c <- gsub("[.]", "", b)
d <- gsub("-", "", c)
e <- strsplit(d, ",")
f <- lapply(e, function(x) gsub(" ", "", x))


len <- c()
for (i in seq(f)){
  len <- c(len, length(f[[i]]))
}

max_len <- max(len) 

for (i in seq(f)){
  for (j in 1:max_len){
    if (!is.na(f[[i]][j]) == TRUE && f[[i]][j] == ""){
      f[[i]][j] <- NA
    }
  }
}

f <- lapply(f, function(x) x[!is.na(x)])

## Split list elements (in double list)
p <- lapply(f, function(x) as.list(x))
m <- lapply(g, function(x) as.list(x))

## Name the lists
for (i in seq(p)){
  p[[i]] <- list(params = p[[i]])}

## Append to triple list
j <- list()
for (i in seq(p)){
  j <- append(j, p[i])
}

for (i in seq(p)){
  j[[i]][[1]] <- append(j[[i]][[1]], m[[i]])
  
}

## APPEND PARAMS TO QUERY

for (i in seq(y)){
  y[[i]] <- append(y[[i]], j[[i]])
}


## COLOR

for (i in seq(z)){
  if (z[[i]] != ""){
    names(z[[i]]) <- c("color")
  }
}

## APPEND COLOR TO QUERY, PARAMS

for (i in seq(y)){
  if (z[[i]] != ""){
    y[[i]] <- append(y[[i]], z[[i]])
  }
}

## ACTIVE

for (i in seq(w)){
  if (w[[i]] == "true"){
    w[[i]] <- T
  }
  else if(w[[i]] == "false"){
    w[[i]] <- F
  }
  names(w[[i]]) <- c("active")
}

## APPEND ACTIVE TO QUERY, PARAMS, COLOR

for (i in seq(y)){ 
  y[[i]] <- append(y[[i]], w[[i]])
}

## CONVERT STRING TO FUNCTION

for (i in seq(y)){
  if (y[[i]][[1]] == "intersects"){
    y[[i]][[1]] <- intersects
  }
  else if (y[[i]][[1]] == "elements"){
    y[[i]][[1]] <- elements
  }
}

q <- y

#else if str($query_select.query_selector) == 'no'

q <- NULL

#end if

## UpSet Plot
png("$output")

upset(input, nsets = "${nsets}", nintersects = ninters, sets = set, keep.order = keep_order, matrix.color = matrix_color, 
    main.bar.color = bar_color, mainbar.y.label = "${mainbar_y_label}", mainbar.y.max = y_max, sets.bar.color = sets_bar_color, sets.x.label = "${sets_x_label}", point.size = as.numeric("${point_size}"), line.size = as.numeric("${line_size}"), mb.ratio = mb_ratio, att.pos = "${att_pos}", att.color = att_color, order.by = order, decreasing = decr, show.numbers = show_numbers,  number.angles = "${number_angles}", group.by = "${group_by}", cutoff = cut_off, queries = q, query.legend = "${query_legend}", shade.alpha = as.numeric("${shade_alpha}"), matrix.dot.alpha = as.numeric("${matrix_dot_alpha}"), empty.intersections = empty_inters, color.pal = as.numeric("${color_pal}"), boxplot.summary = boxplot_summary, scale.intersections = "${scale_intersections}", scale.sets = "${scale_sets}", text.scale = text_scale, set_size.angles = as.numeric("${set_size_angles}"))

dev.off()



        ]]></configfile>
    </configfiles>

    <inputs>
        <conditional name="input_type">
            <param name="input_type_selector" type="select" label="Input Options" >
                <option value="file">File</option>
                <option value="list">List</option>
                <option value="expression">Expression</option>
            </param>
            <when value="file">
                <param name="inputFile" type="data" format="txt" label="Input File" />
            </when>
            <when value="list">
                <repeat name="lists" title="List of named vectors to be converted to a data frame" >
                    <param name="listInput" type="text" label="Named list" help="The list name is followed by a colon and the elements are seperated are by a comma, e.g. List1: 1, 2, 3, 4, 5" />
                </repeat>
            </when>
            <when value="expression">
                <param name="expressionInput" type="text" label="An vector (expression) to be converted to an input" help="The elements of the expression vector are the names of the sets in an intersection, seperated by an amerpsand (&#38;), and the number elements in that intersection." >
                    <sanitizer invalid_char="">
                        <valid initial="string.ascii_letters,string.digits">
                            <add value="&#38;" />
                            <add value="=" />
                            <add value="," />
                        </valid>
                    </sanitizer>   
                </param>
            </when>
        </conditional>

        <param name="nsets" type="integer" value="5" label="Number of sets to look at" help="Selects the n largest sets from the data when not specifying specific sets" />

        <param name="number_angles" type="integer" value="0" label="The angle of the numbers atop the intersection size bars" help="Determines the angle (in degrees) of the numbers above the intersection size bars" />
        <param name="point_size" type="float" value="2.2" label="Size of points in matrix plot" help="changes the size of the circles in the matrix" />
        <param name="line_size" type="float" value="0.7" label="Width of lines in matrix plot" help="changes the size of the lines connecting the circles in the matrix" />
        <param name="mainbar_y_label" type="text" value="Intersection Size" label="The y-axis label of the intersection size bar plot" />
        <param name="sets_x_label" type="text" value="Set Size" label="The x-axis label of the set size bar plot" />
        <conditional name="text_scale_select">
            <param name="text_scale_selector" type="select" label="Text Scale" help="Allows scaling of all axis titles, tick labels, and numbers above the intersection size bars. Can be a universal scale, or a vector containing individual scales in the following order: intersection size title, intersection size tick labels, set size title, set size tick labels, set names, numbers above bars">
                <option value="universal">Universal Scale</option>
                <option value="individual">Individual Scale</option>
            </param>
            <when value="universal">
                <param name="text_scale" type="integer" value="1" label="Universal Scale" />
            </when>
            <when value="individual">
                <param name="text_scale" type="text" label="Individual Scale" />
            </when>
        </conditional>

        <param name="sets" type="text" optional="true" label="Specific sets to look at" help="Include as combinations. e.g. Name1, Name2" />

        <param name="mb_ratio" type="text" value="0.7, 0.3" label="Ratio between matrix and intersection size bar plot" help="Enter as percentages in hundreths" />

        <param name="order_by" type="select" label="How the intersections in the matrix should be ordered by" >
            <option value="degree">Degree</option>
            <option value="freq">Frequency</option>
            <option value="freq_degree" selected="true">Degree then frequency</option>
            <option value="degree_freq">Frequency then Degree</option>
        </param>

        <param name="decreasing" type="select" label="How the variables should be ordered" help="decreasing is greatest to least" >
            <option value="decr">Decreasing</option>
            <option value="incr">Increasing</option>
            <option value="decr_incr" selected="true">Increasing then decreasing</option>
            <option value="incr_decr">Decreasing then increasing</option>
        </param>

        <param name="keep_order" type="boolean" truevalue="true" falsevalue="" checked="false" label="Keep sets in the order entered using the sets parameter?" help="Select no to order the sets by their sizes" />
 
        <conditional name="nintersects_select">
            <param name="nintersects_selector" type="select" label="Plot all intersections?" >
                <option value="yes">Yes</option>
                <option value="no" selected="true">No</option>
            </param>
            <when value="yes"> </when>
            <when value="no">
                <param name="nintersects" type="integer" value="40" label="Number of intersections to plot" />
            </when>
        </conditional>

        <param name="group_by" type="select" label="Group data by" >
            <option value="degree">Degree</option>
            <option value="sets">Sets</option>
        </param>

        <param name="cutoff" type="integer" value="" optional="true" label="The number of intersections from each set (to cut off at) when aggregating by sets" />

        <param name="empty_intersections" type="boolean" truevalue="true" falsevalue="" checked="false" label="Additionally display empty intersections?" help="An intersection may not be present in the matrix due to not showing enough intersections or the intersection contains no elements" />

        <param name="matrix_color" type="text" optional="true" label="Color of the intersection points" />

        <param name="main_bar_color" type="text" optional="true" label="Color of the main bar plot" />

        <param name="mainbar_y_max" type="integer" value="" optional="true" label="The maximum y value of the intersection size bar plot scale" help="May be useful when aligning multiple plots horizontally" />

        <param name="sets_bar_color" type="text" optional="true" label="Color of set size bar plot" />

        <param name="show_numbers" type="boolean" truevalue="true" falsevalue="" checked="true" label="Show numbers of intersection sizes above bars" />

        <param name="shade_color" type="text" optional="true" label="Color of row shading in matrix" />

        <param name="shade_alpha" type="float" value="0.25" label="Transparency of shading in matrix" help="Enter as percentages in hundreths" />   

        <param name="matrix_dot_alpha" type="float" value="0.5" label="Transparency of the empty intersections points in the matrix" />

        <param name="scale_intersections" type="select" label="The scale to be used for the intersection sizes">
            <option value="identity">Identity</option>
            <option value="log10">Log10</option>
            <option value="log2">Log2</option>
        </param>

        <param name="scale_sets" type="select" label="The scale to be used for the set sizes">
            <option value="identity">Identity</option>
            <option value="log10">Log10</option>
            <option value="log2">Log2</option>
        </param>

        <param name="set_size_angles" type="integer" value="0" label="Angle to rotate the set size plot x-axis text" />


        <!--Queries-->

        <conditional name="query_select">
            <param name="query_selector" type="select" label="Query data?">
                <option value="yes">Yes</option>
                <option value="no" selected="true">No</option>
            </param>
            <when value="yes">
                <repeat name="queries" title="Unified querie of intersections, elements, and custom row functions" >
                    <param name="query" type="select" label="Type of query" >
                        <option value="intersects">Intersects</option>
                        <option value="elements">Elements</option>
                        <option value="custom">Custom</option>
                    </param>

                    <param name="params" type="text" label="Parameters of the query" />

                    <param name="color" type="text" optional="true" label="Color that will represent the query on the plot" help="If no color is selected one will be provided automatically" />

                    <param name="active" type="boolean" truevalue="true" falsevalue="" checked="true" label="Represent the query by overlaying the intersection size bar?" help="Select no then a tick mark will be placed on the intersection size bar" />
                </repeat>

                    
            </when>
            <when value="no"> </when>
        </conditional>

<param name="query_legend" type="select" label="Position query legend on top or bottom of UpSet plot?" help="Select none for no legend" >
                    <option value="none">None</option>
                    <option value="bottom">Bottom</option>
                    <option value="top">Top</option>
                </param>  

        <!--Attribute Plots-->

        <param name="att_pos" type="select" label="Position of attribute plot on top or bottom of UpSet plot?" >
            <option value="bottom">Bottom</option>
            <option value="top">Top</option>
        </param>

        <param name="att_color" type="text" optional="true" label="Color of attribute histogram bins or scatterplot points for unqueried data represented by main bars" />

        <param name="color_pal" type="select" label="Color palette for attribute plots" >
            <option value="1">Color Palette 1</option>
            <option value="2">Color Palette 2</option>
        </param>

        <param name="boxplot_summary" type="text" optional="true" label="Boxplots representing the distribution of a selected attribute for each intersection" help="Select attributes by entering attribute names e.g. Name1, Name2. The maximum number of attributes that can be entered is 2." />

<!--TO DO-->

    <!--set.metadata
        intersections
        expression
        queries
        attribute.plots-->

            
    </inputs>

    <outputs>
        
        <data name="output" format="png" label="${tool.name} on ${on_string}: Plot" />
    </outputs>

    <tests>
        <test>
            <conditional name="input_type">
                <param name="input_type_selector" value="list" />
                <repeat name="lists">
                    <param name="listInput" value="one: 1, 2, 3, 5, 7, 8, 11, 12, 13" />
                </repeat>
                <repeat name="lists">
                    <param name="listInput" value="two: 1, 2, 4, 5, 10" />
                </repeat>
                <repeat name="lists">
                    <param name="listInput" value="three: 1, 5, 6, 7, 8, 9, 10, 12, 13" />
                </repeat>
            </conditional>
        </test>

        <test>
            <param name="sets" value="Action, Adventure, Comedy, Drama, Mystery, Thriller, Romance, War, Western" />
            <param name="mb_ratio" value="0.55, 0.45" />
            <param name="boxplot_summary" value="AvgRating, ReleaseDate" />
        </test>
    </tests>

    <help><![CDATA[
        UpSetR generates static UpSet plots. The UpSet technique visualizes set intersections in a matrix layout and introduces aggregates based on groupings and queries. The matrix layout enables the effective representation of associated data, such as the number of elements in the aggregates and intersections, as well as additional summary statistics derived from subset or element attributes.
    ]]></help>

    <citations>
          <citation type="doi">/10.1093/bioinformatics/btx364</citation>
    </citations>

</tool>