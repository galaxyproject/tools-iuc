<macros>
    <token name="@TOOL_VERSION@">3.15.3</token>
    <token name="@VERSION_SUFFIX@">0</token>
    <xml name="requirements">
        <requirements>
            <requirement type="package" version="@TOOL_VERSION@">spades</requirement>
            <requirement type="package" version="3.0">zip</requirement>
            <yield/>
        </requirements>
    </xml>
    <xml name="stdio">
        <stdio>
            <exit_code range="1:"/>
            <regex match="Cannot allocate memory"
               source="stdout"
               level="fatal_oom"
               description="Out of memory error occurred"/>
            <regex match="The reads contain too many k-mers to fit into available memory"
               source="stdout"
               level="fatal_oom"
               description="Out of memory error occurred"/>
        </stdio>
    </xml>
    <xml name="version_command">
        <version_command><![CDATA[spades.py --version 2>&1 | awk -F 'v' '{print $2}']]></version_command>
    </xml>
    <token name="@INTYPES@">
        fasta,fasta.gz,fastq,fastq.gz
    </token>
    <xml name="citations">
        <citations>
            <citation type="doi">10.1093/bioinformatics/btv688</citation>
            <citation type="doi">10.1093/bioinformatics/btu266</citation>
            <citation type="doi">10.1093/bioinformatics/btv337</citation>
            <yield/>
          </citations>
    </xml>
    <xml name="operation_mode">
        <param name="operation_mode" type="select" label="Operation mode">
            <option value="">Assembly and error correction</option>
            <option value="--only-assembler">Only assembler (--only-assembler)</option>
            <option value="--only-error-correction">Only error correction (--only-error-correction)</option>
        </param>
    </xml>
    

<!-- PREPARE INPUT FILES-->

<token name="@PREPROCESS_INPUT_FILES@"><![CDATA[
#if $singlePaired.sPaired == "single"
    mkdir -p single_reads &&
    #set file_paths = []
    #for $input_file in $singlePaired.input1
        #set $fname = $input_file.element_identifier.replace("fastqsanger","fastq")
        #set $file_path = 'single_reads/' + str($fname)
        ln -s '$input_file' $file_path &&
        $file_paths.append($file_path)
    #end for
#else if $singlePaired.sPaired == "paired"
    mkdir -p paired_reads &&
    #set fw_reads = []
    #for $input_file in $singlePaired.input1
        #set fname = $input_file.element_identifier.replace("fastqsanger","fastq")
        #set $file_path = 'paired_reads/' + str($fname)
        ln -s '$input_file' $file_path &&
        $fw_reads.append($file_path)
    #end for
    #set rv_reads = []
    #for $input_file in $singlePaired.input2
        #set fname = $input_file.element_identifier.replace("fastqsanger","fastq")
        #set $file_path = 'paired_reads/' + str($fname)
        ln -s '$input_file' $file_path &&
        $rv_reads.append($file_path)
    #end for
    #silent $fw_reads.sort()
    #silent $rv_reads.sort()
#else if $singlePaired.sPaired == "paired_interlaced"
    mkdir -p interlaced_reads &&
    #set file_paths = []
    #for $input_file in $singlePaired.input1
        #set $fname = $input_file.element_identifier.replace("fastqsanger","fastq")
        #set $file_path = 'interlaced_reads/' + str($fname)
        ln -s '$input_file' $file_path &&
        $file_paths.append($file_path)
    #end for
#else
    mkdir -p paired_reads &&
    #set fw_reads = []
    #set rv_reads = []
    #for $i, $input_file in enumerate($singlePaired.input)
        #set $ext = $input_file.forward.ext.replace('fastqsanger', 'fastq')
        #set $file_path = 'paired_reads/fw' + str($i) + '.' + $ext
        ln -s '$input_file.forward' $file_path &&
        $fw_reads.append($file_path)
        #set $file_path = 'paired_reads/rv' + str($i) + '.' + $ext
        ln -s '$input_file.reverse' $file_path &&
        $rv_reads.append($file_path)
    #end for
#end if
]]></token>

<!-- COMMANDS -->

<token name="@RESOURCES@"><![CDATA[
-t \${GALAXY_SLOTS:-4}
-m \${GALAXY_MEMORY_GB:-8}
]]></token>

<token name="@INPUT_READS@"><![CDATA[
#if $singlePaired.sPaired == "single"
    #for $i, $read in enumerate($file_paths, 1)
        --s ${i} '${read}'
    #end for
#else if  $singlePaired.sPaired == "paired"
    #for $i, $read in enumerate($fw_reads, 1)
        --pe-1 ${i} '${read}'
    #end for
    #for $i, $read in enumerate($rv_reads, 1)
        --pe-2 ${i} '${read}'
    #end for
#else if $singlePaired.sPaired == "paired_interlaced"
    #for $i, $read in enumerate($file_paths, 1)
        --pe-12 ${i} '${read}'
    #end for
#else
    #for $i, $read in enumerate($fw_reads, 1)
        --pe-1 ${i} '${read}'
    #end for
    #for $i, $read in enumerate($rv_reads, 1)
        --pe-2 ${i} '${read}'
    #end for
#end if
]]></token>

<token name="@PIPELINE_OPTIONS@"><![CDATA[
#for $i in $mode_sel
    $i
#end for
]]></token>

<token name="@KMER@"><![CDATA[
#if $kmer_cond.kmer_sel != 'auto'
    -k '$kmer_cond.manual'
#end if
]]></token>

<token name="@PHREDOFFSET@"><![CDATA[
#if $phred_offset != 'auto'
    --phred-offset $phred_offset
#end if
]]></token>

<!-- ADDITIONAL INPUTS-->

<token name="@CORRECTED@"><![CDATA[
#if 'corrected' in $optional_output
    && test -d 'output/corrected' && zip -q -r 'corrected.zip' 'output/corrected/*.fastq.gz' || echo 'No output files for corrected reads.'
#end if
]]></token>

<token name="@NANOPORE@"><![CDATA[
#for $read in $arf.nanopore
    #if $read
        --nanopore $read.datatype.file_ext.replace('fastqsanger', 'fastq')
    #end if
#end for
]]></token>

<token name="@PACBIO@"><![CDATA[
#for $read in $arf.pacbio
    #if $read
        --pacbio $read.datatype.file_ext.replace('fastqsanger', 'fastq')
    #end if
#end for
]]></token>

<token name="@SANGER@"><![CDATA[
#for $read in $arf.sanger
    #if $read
        --sanger $read.datatype.file_ext.replace('fastqsanger', 'fastq')
    #end if
#end for
]]></token>

<token name="@TRUSTEDCONTIGS@"><![CDATA[
#for $read in $arf.trustedcontigs
    #if $read
        --trustedcontigs $read.datatype.file_ext.replace('fastqsanger', 'fastq')
    #end if
#end for
]]></token>
<token name="@TSLR@"><![CDATA[
#for $read in $arf.tslr
    #if $read
        --tslr $read.datatype.file_ext.replace('fastqsanger', 'fastq')
    #end if
#end for
]]></token>
<token name="@UNTRUSTEDCONTIGS@"><![CDATA[
#for $read in $arf.untrustedcontigs
    #if $read
        --untrustedcontigs $read.datatype.file_ext.replace('fastqsanger', 'fastq')
    #end if
#end for
]]></token>


<!-- POSTPROCESSING -->

<token name="@STATS@"><![CDATA[
#if 'cs' in $optional_output
    && test -f 'output/contigs.fasta' && python '$__tool_directory__/write_tsv_script.py' < 'output/contigs.fasta' > '$out_cs' || echo 'No contigs.fasta.'
#end if
#if 'ss' in $optional_output
    && test -f 'output/scaffolds.fasta' && python '$__tool_directory__/write_tsv_script.py' < 'output/scaffolds.fasta' > '$out_ss' || echo 'No scaffolds.fasta.'
#end if
]]></token>

    <!--
      input
    -->

    <xml name="input_files" token_format="">
        <conditional name="singlePaired">
            <param name="sPaired" type="select" label="Single-end or paired-end reads">
                <yield/>
                <option value="paired">Paired-end: individual datasets</option>
                <option value="paired_interlaced">Paired-end: interlaced reads</option>
                <option value="paired_collection">Paired-end: list of dataset pairs</option>
            </param>
            <when value="single">
                <param format="@FORMAT@" name="input1" type="data"  multiple="true" label="RNA-Seq FASTQ/FASTA file"/>
            </when>
            <when value="paired">
                <param format="@FORMAT@" name="input1" type="data" multiple="true" label="RNA-Seq FASTQ/FASTA file, forward reads"/>
                <param format="@FORMAT@" name="input2" type="data" multiple="true" label="RNA-Seq FASTQ/FASTA file, reverse reads"/>
            </when>
            <when value="paired_interlaced">
                <param format="@FORMAT@" name="input1" type="data"  multiple="true" label="RNA-Seq FASTQ/FASTA file"/>
            </when>
            <when value="paired_collection">
                <param format="@FORMAT@" name="input" type="data_collection" collection_type="list:paired" label="RNA-Seq FASTQ/FASTA paired reads"/>
            </when>
        </conditional>
    </xml>
    <xml name="covcutoff">
        <conditional name="cov_cond">
            <param argument="--cov-cutoff" type="select" label="Set coverage cutoff option" help="When set to 'auto' SPAdes automatically computes coverage threshold using conservative strategy">
                <option value="off">Off</option>
                <option value="auto">Auto</option>
                <option value="value">User specific</option>
            </param>
            <when value="off"/>
            <when value="auto"/>
            <when value="value">
                <param name="manual" type="float" min="0" value="" label="Set value"/>
            </when>
        </conditional>
    </xml>
    <xml name="pipeline_options">
        <param name="mode_sel" type="select" label="Pipeline options"  multiple="true" optional="true" display="checkboxes" help="Error correction requires FASTQ input files.">
            <option value="--disable-rr">Disable repeat resolution: disable repeat reoslution stage of assembly (--disable-rr)</option>
            <yield/>
        </param>
    </xml>
    <xml name="filetype_sel">
        <param name="filetype_sel" type="select" label="Select read file type">
            <option value="interlaced">Interlaced reads</option>
            <option value="separate" selected="true">Separated file pairs</option>
            <yield/>
            <option value="unpaired">Unpaired</option>
        </param>
    </xml>
    <xml name="filetype_sel_when">
        <when value="interlaced">
            <expand macro="reads" label="Interlaced" help="When reads are interlaced each forward read goes after the corresponding paired reverse read (--12)"/>
        </when>
        <when value="separate">
            <expand macro="reads" paramname="fwd_reads" label="Forward" help="Forward reads (-1)"/>
            <expand macro="reads" paramname="rev_reads" label="Reverse" help="Reverse reads (-2)"/>
        </when>
        <yield/>
        <when value="unpaired">
            <expand macro="reads" label="Unpaired" help="(-s)"/>
        </when>
    </xml>
    <xml name="kmer" token_help="" token_default="">
        <conditional name="kmer_cond">
            <param name="kmer_sel" argument="-k" type="select" label="Select k-mer detection option" help="@HELP@ Comma-separated list, all values must be odd, less than 128 and listed in ascending order.">
                <option value="auto">Auto</option>
                <option value="manual">User specific</option>
            </param>
            <when value="auto"/>
            <when value="manual">
                <param name="manual" type="text" value="21,33,55,77" label="K-mer size values" help="List of k-mer sizes (must be odd and less than 128)">
                    <sanitizer invalid_char="">
                        <valid initial="string.digits">
                            <add value="," />
                        </valid>
                    </sanitizer>
                    <validator type="regex">[0-9,]+</validator>
                </param>
            </when>
        </conditional>
    </xml>
    <xml name="nanopore">
        <param argument="--nanopore" type="data" format="@INTYPES@" multiple="true" optional="true" label="Select file with Nanopore reads"/>
    </xml>
    <xml name="orientation" token_type="" token_label="" token_fr="false" token_rf="false">
        <param name="@TYPE@_orientation" type="select" label="Select orientation of @LABEL@ reads" help="Option is ignored if no corresponding reads are applied in this library number.">
            <option value="-fr" selected="@FR@"><![CDATA[-> <- (fr)]]></option>
            <option value="-rf" selected="@RF@"><![CDATA[<- -> (rf)]]></option>
            <option value="-ff"><![CDATA[-> -> (ff)]]></option>
        </param>
    </xml>
    <xml name="pacbio">
        <param argument="--pacbio" type="data" format="@INTYPES@" multiple="true" optional="true" label="Select file with PacBio CLR reads"/>
    </xml>
    <xml name="phred">
        <param argument="--phred-offset" type="select" label="Set Phred quality offset" help="Phred quality offset in the input reads. Default: auto-detect">
            <option value="auto" selected="true">Auto</option>
            <option value="33">33 (Sanger)</option>
            <option value="64">64 (Illumina)</option>
        </param>
    </xml>
    <xml name="reads" token_paramname="reads" token_help="" token_label="">
        <param name="@PARAMNAME@" type="data" format="@INTYPES@" label="Select file with @LABEL@ reads" help="@HELP@"/>
    </xml>
    <xml name="sanger">
        <param argument="--sanger" type="data" format="@INTYPES@" multiple="true" optional="true" label="Select file with Sanger reads"/>
    </xml>
    <xml name="trusted_contigs">
        <param argument="--trusted-contigs" name="trustedcontigs" type="data" format="@INTYPES@" multiple="true" optional="true" label="Select file with trusted contigs" help="Reliable contigs of the same genome, which are likely to have no misassemblies and small rate of other errors (e.g. mismatches and indels). This option is not intended for contigs of the related species."/>
    </xml>
    <xml name="tslr">
        <param argument="--tslr" type="data" format="@INTYPES@" multiple="true" optional="true" label="Select file with TSLR contigs"/>
    </xml>
    <xml name="untrusted_contigs">
        <param argument="--untrusted-contigs" name="untrustedcontigs" type="data" format="@INTYPES@" multiple="true" optional="true" label="Select file with untrusted contigs" help="Contigs of the same genome, quality of which is average or unknown. Contigs of poor quality can be used but may introduce errors in the assembly. This option is also not intended for contigs of the related species."/>
    </xml>
    <xml name="optional_output">
        <param name="optional_output" type="select" multiple="true" optional="false" label="Select optional output file(s)" help="Only shown in history if selected here and generated by the specific run.">
            <option value="ag" selected="true">Assembly graph</option>
            <option value="ags" selected="true">Assembly graph with scaffolds</option>
            <option value="cn" selected="true">Contigs</option>
            <option value="cp">Contigs paths</option>
            <option value="cr">Corrected reads</option>
            <option value="cs">Contigs stats</option>
            <option value="l">Log</option>
            <option value="sc" selected="true">Scaffolds</option>
            <option value="sp">Scaffolds paths</option>
            <option value="ss">Scaffolds stats</option>            
        </param>
    </xml>
    <!--
      output
    -->

    <xml name="out_ag">
        <data name="out_ag" format="fastg" from_work_dir="output/assembly_graph.fastg" label="${tool.name} on ${on_string}: Assembly graph">
            <filter>'ag' in optional_output</filter>
            <filter> operation_mode != '--only-error-correction'</filter>
        </data>
    </xml>
    <xml name="out_ags">
        <data name="out_ags" format="txt" from_work_dir="output/assembly_graph_with_scaffolds.gfa" label="${tool.name} on ${on_string}: Assembly graph with scaffolds">
            <filter>'ags' in optional_output</filter>
            <filter> operation_mode != '--only-error-correction'</filter>
        </data>
    </xml>
    <xml name="out_cn">
        <data name="out_cn" format="fasta" from_work_dir="output/contigs.fasta" label="${tool.name} on ${on_string}: Contigs">
            <filter>'cn' in optional_output</filter>
            <filter> operation_mode != '--only-error-correction'</filter>
        </data>
    </xml>
    <xml name="out_cp">
        <data name="out_cp" format="txt" from_work_dir="output/contigs.paths" label="${tool.name} on ${on_string}: Contigs paths">
            <filter>'cp' in optional_output</filter>
            <filter> operation_mode != '--only-error-correction'</filter>
        </data>
    </xml>
    <xml name="out_cr">
        <!-- some mode combinations create fastq, some fasta -->
        <collection name="out_cr" type="list" label="${tool.name} on ${on_string}: Corrected reads">
            <filter>'cr' in optional_output</filter>
            <filter> operation_mode != '--only-assembler'</filter>
            <discover_datasets pattern="(?P&lt;designation&gt;.+)\.fastq\.gz" format="fastq" directory="output/corrected"/>
            <discover_datasets pattern="(?P&lt;designation&gt;.+)\.fasta\.gz" format="fasta" directory="output/corrected"/>
        </collection>
    </xml>
    <xml name="out_cs">
        <data name="out_cs" format="tabular" label="${tool.name} on ${on_string}: Contigs stats">
            <actions>
                <action name="column_names" type="metadata" default="name,length,coverage"/>
            </actions>
            <filter>'cs' in optional_output</filter>
            <filter> operation_mode != '--only-error-correction'</filter>
        </data>
    </xml>
    <xml name="out_l">
        <data name="out_l" format="txt" from_work_dir="output/spades.log" label="${tool.name} on ${on_string}: Log">
            <filter>'l' in optional_output</filter>
        </data>
    </xml>
    <xml name="out_sc">
        <data name="out_sc" format="fasta" from_work_dir="output/scaffolds.fasta" label="${tool.name} on ${on_string}: Scaffolds">
            <filter>'sc' in optional_output</filter>
            <filter> operation_mode != '--only-error-correction'</filter>
        </data>
    </xml>
    <xml name="out_sp">
        <data name="out_sp" format="txt" from_work_dir="output/scaffolds.paths" label="${tool.name} on ${on_string}: Scaffolds paths">
            <filter>'sp' in optional_output</filter>
            <filter> operation_mode != '--only-error-correction'</filter>
        </data>
    </xml>
    <xml name="out_ss">
        <data name="out_ss" format="tabular" label="${tool.name} on ${on_string}: Scaffolds stats">
            <actions>
                <action name="column_names" type="metadata" default="name,length,coverage"/>
            </actions>
            <filter>'ss' in optional_output</filter>
            <filter> operation_mode != '--only-error-correction'</filter>
        </data>
    </xml>
    <xml name="out_rs">
        <data name="out_rs" format="fasta" from_work_dir="output/raw_scaffolds.fasta" label="${tool.name} on ${on_string}: Raw scaffolds">
            <filter>'rs' in optional_output</filter>
        </data>
    </xml>
    <xml name="out_b">
        <data name="out_b" format="txt" from_work_dir="output/hmm_statistics.txt" label="${tool.name} on ${on_string}: HMM statistics">
            <filter>'b' in optional_output</filter>
        </data>
    </xml>
    <xml name="out_dg">
        <data name="out_dg" format="fasta" from_work_dir="output/domain_graph.dot" label="${tool.name} on ${on_string}: Domain graph">
            <filter>'dg' in optional_output</filter>
        </data>
    </xml>
    <!--
      help
    -->

    <token name="@HELP_IN@"><![CDATA[
SPAdes works with Illumina or IonTorrent reads and is capable of providing hybrid assemblies using PacBio, Oxford Nanopore and Sanger reads. You can also provide additional contigs that will be used as long reads.

- Illumina paired-end/high-quality mate-pairs/unpaired reads
- IonTorrent paired-end/high-quality mate-pairs/unpaired reads
- PacBio CCS reads

SPAdes takes as input

- Single-read
- Paired-end
- Mate-pair
- High-quality mate-pair
- Lucigen NxSeq® Long Mate Pair

Depending on the read type, input can be provided as interlaced, forward and reverse, merged and unpaired files.

A detailed description can be found in the `input section <https://github.com/ablab/spades/#sec3.1>`_ of the manual.
    ]]></token>
    <token name="@HELP_OUT_AG@">
- Assembly graph
    </token>
    <token name="@HELP_OUT_AGS@">
- Assembly graph with scaffolds
    </token>
    <token name="@HELP_OUT_C@">
- Contigs
    </token>
    <token name="@HELP_OUT_CP@">
- Contigs paths in the assembly graph
    </token>
    <token name="@HELP_OUT_CS@">
- Contigs stats
    </token>
    <token name="@HELP_OUT_CR@">   
- Corrected reads by BayesHammer
    </token>
    <token name="@HELP_OUT_L@">
- Log file
    </token>
    <token name="@HELP_OUT_S@">
- Scaffolds (recommended for use as resulting sequences)
    </token>
    <token name="@HELP_OUT_SP@">
- Scaffolds paths in the assembly graph
    </token>
    <token name="@HELP_OUT_SS@">
- Scaffolds stats
    </token>
    <token name="@HELP_WID@">
SPAdes - St. Petersburg genome assembler - is an assembly toolkit containing various assembly pipelines.
    </token>
    <token name="@IONTORRENT@"><![CDATA[
The selection of k-mer length is non-trivial for IonTorrent. If the dataset is more or less conventional (good coverage, not high GC, etc), then use our `recommendation for long reads <https://cab.spbu.ru/files/release3.12.0/manual.html#sec3.4>`_ (e.g. assemble using k-mer lengths 21,33,55,77,99,127). However, due to increased error rate some changes of k-mer lengths (e.g. selection of shorter ones) may be required. For example, if you ran SPAdes with k-mer lengths 21,33,55,77 and then decided to assemble the same data set using more iterations and larger values of K, you can run SPAdes once again specifying the same output folder and the following options: --restart-from k77 -k 21,33,55,77,99,127 --mismatch-correction -o <previous_output_dir>. Do not forget to copy contigs and scaffolds from the previous run. We're planning to tackle issue of selecting k-mer lengths for IonTorrent reads in next versions.

You may need no error correction for Hi-Q enzyme at all. However, we suggest trying to assemble your data with and without error correction and select the best variant.

For non-trivial datasets (e.g. with high GC, low or uneven coverage) we suggest to enable single-cell mode (setting --sc option) and use k-mer lengths of 21,33,55.

    ]]></token>    

</macros>
