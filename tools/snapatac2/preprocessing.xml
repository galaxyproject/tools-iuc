<tool id="snapatac2_preprocessing" name="SnapATAC2 Preprocessing" version="@TOOL_VERSION@+galaxy@VERSION_SUFFIX@" profile="@PROFILE@">
    <description>and integration</description>
    <macros>
        <import>macros.xml</import>
    </macros>
    <expand macro="xrefs"/>
    <requirements>
        <expand macro="requirements">
            <requirement type="package" version="0.0.10">harmonypy</requirement>
            <requirement type="package" version="1.7.4">scanorama</requirement>
        </expand>
    </requirements>
    <command detect_errors="exit_code"><![CDATA[
#if $method.method != 'pp.make_fragment_file'
@CMD_PREP_ADATA@
#end if
@CMD@
    ]]></command>
    <configfiles>
        <configfile name="script_file"><![CDATA[
@CONF_IMPORTS@

#if $method.method != 'pp.make_fragment_file'
@CONF_READ_INPUTS@
#end if

#if $method.method == 'pp.make_fragment_file'
snap.pp.make_fragment_file(
    bam_file = '$method.bam_file',
    is_paired = $method.is_paired,
    #if $method.barcode.extract_type == 'from_tag'
        #if $method.barcode.barcode_tag != ''
    barcode_tag = '$method.barcode.barcode_tag',
        #end if
    #else if $method.barcode.extract_type == 'from_read_names'
        #if $method.barcode.barcode_regex != ''
    barcode_regex = '$method.barcode.barcode_regex',
        #end if
    #end if
    #if $method.umi_tag != ''
    umi_tag = '$method.umi_tag',
    #end if
    #if $method.umi_regex != ''
    umi_regex = '$method.umi_regex',
    #end if
    shift_right = $method.shift_right,
    shift_left = $method.shift_left,
    min_mapq = $method.min_mapq,
    chunk_size = $method.chunk_size,
    compression = 'gzip',
    output_file = '$fragments_out',
    tempdir = "."
)

#else if $method.method == 'pp.import_fragments'
snap.pp.import_fragments(
    fragment_file = '$method.fragment_file',
    chrom_sizes = $method.chrom_sizes,
    file = '$anndata_out',
    min_num_fragments = $method.min_num_fragments,
    sorted_by_barcode = $method.sorted_by_barcode,
    #if str($method.whitelist) != 'None'
    whitelist = '$method.whitelist',
    #end if
    #if $method.chrM != ''
    #set $chrM = ([x.strip() for x in str($method.chrM).split(',')])
    chrM = $chrM,
    #end if
    shift_left = $method.shift_left,
    shift_right = $method.shift_right,
    chunk_size = $method.chunk_size,
    tempdir = ".",
    backend = 'hdf5',
    n_jobs = int(os.getenv("GALAXY_SLOTS", 4))
)
## Not sure how this should work and there is no documentation for it.
## #else if $method.method == 'pp.import_values'
## snap.pp.import_values(
##     input_dir = 'input',
##     file = '$anndata_out',
##     chrom_sizes = $method.chrom_sizes,
##     chunk_size = $method.chunk_size,
##     backend = 'hdf5'
## )

#else if $method.method == 'pp.import_contacts'
snap.pp.import_contacts(
    contact_file = '$method.contact_file',
    chrom_sizes = $method.chrom_sizes,
    file = '$anndata_out',
    sorted_by_barcode = $method.sorted_by_barcode,
    bin_size = $method.bin_size,
    chunk_size = $method.chunk_size,
    tempdir = ".",
    backend = 'hdf5'
)

#else if $method.method == 'pp.call_cells'
snap.pp.call_cells(
    adata,
    use_rep = $method.use_rep,
    inplace = True,
    n_jobs = int(os.getenv("GALAXY_SLOTS", 4))
)

#else if $method.method == 'pp.add_tile_matrix'
snap.pp.add_tile_matrix(
    adata,
    bin_size = $method.bin_size,
    chunk_size = $method.chunk_size,
    #if $method.exclude_chroms != ''
    #set $excl_chroms = ([x.strip() for x in str($method.exclude_chroms).split(',')])
    exclude_chroms = $excl_chroms,
    #end if
    #if $method.min_frag_size
    min_frag_size = $method.min_frag_size,
    #end if
    #if $method.max_frag_size
    max_frag_size = $method.max_frag_size,
    #end if
    counting_strategy = '$method.counting_strategy',
    n_jobs = int(os.getenv("GALAXY_SLOTS", 4))
)



#else if $method.method == 'pp.make_gene_matrix'
adata = snap.pp.make_gene_matrix(
    adata,
    gene_anno = '$method.gene_anno',
    chunk_size = $method.chunk_size,
    use_x = $method.use_x,
    id_type = '$method.id_type',
    upstream = '$method.upstream',
    downstream = '$method.downstream',
    include_gene_body = $method.include_gene_body,
    transcript_name_key = '$method.transcript_name_key',
    transcript_id_key = '$method.transcript_id_key',
    gene_name_key = '$method.gene_name_key',
    gene_id_key = '$method.gene_id_key',
    #if $method.min_frag_size
    min_frag_size = $method.min_frag_size,
    #end if
    #if $method.max_frag_size
    max_frag_size = $method.max_frag_size,
    #end if
    counting_strategy = '$method.counting_strategy'
)

#else if $method.method == 'pp.filter_cells'
snap.pp.filter_cells(
    adata,
    min_counts = $method.min_counts,
    min_tsse = $method.min_tsse,
    #if $method.max_counts
    max_counts = $method.max_counts,
    #end if
    #if $method.max_tsse
    max_tsse = $method.max_tsse,
    #end if
    inplace = True,
    n_jobs = int(os.getenv("GALAXY_SLOTS", 4))
)

#else if $method.method == 'pp.select_features'
snap.pp.select_features(
    adata,
    n_features = $method.n_features,
    filter_lower_quantile = $method.filter_lower_quantile,
    filter_upper_quantile = $method.filter_upper_quantile,
    #if str($method.whitelist) != 'None'
    whitelist = '$method.whitelist',
    #end if
    #if str($method.blacklist) != 'None'
    blacklist = '$method.blacklist',
    #end if
    max_iter = $method.max_iter,
    inplace = True,
    n_jobs = int(os.getenv("GALAXY_SLOTS", 4))
)

#else if $method.method == 'pp.scrublet'
snap.pp.scrublet(
    adata,
    #if $method.features
    features = '$method.features',
    #end if
    n_comps = $method.n_comps,
    sim_doublet_ratio = $method.sim_doublet_ratio,
    expected_doublet_rate = $method.expected_doublet_rate,
    #if $method.n_neighbors
    n_neighbors = $method.n_neighbors,
    #end if
    use_approx_neighbors = $method.use_approx_neighbors,
    random_state = $method.random_state,
    inplace = True,
    n_jobs = int(os.getenv("GALAXY_SLOTS", 4))
)

#else if $method.method == 'pp.filter_doublets'
snap.pp.filter_doublets(
    adata,
    #if $method.probability_threshold
    probability_threshold = $method.probability_threshold,
    #end if
    #if $method.score_threshold
    score_threshold = $method.score_threshold,
    #end if
    inplace = True,
    n_jobs = int(os.getenv("GALAXY_SLOTS", 4))
)

#else if $method.method == 'pp.mnc_correct'
snap.pp.mnc_correct(
    adata,
    batch = '$method.batch',
    n_neighbors = $method.n_neighbors,
    n_clusters = $method.n_clusters,
    n_iter = $method.n_iter,
    @CONF_PARAMS_DATA_INTEGRATION@
    inplace = True,
    n_jobs = int(os.getenv("GALAXY_SLOTS", 4))
)

#else if $method.method == 'pp.harmony'
snap.pp.harmony(
    adata,
    batch = '$method.batch',
    @CONF_PARAMS_DATA_INTEGRATION@
    inplace = True
)

#else if $method.method == 'pp.scanorama_integrate'
snap.pp.scanorama_integrate(
    adata,
    batch = '$method.batch',
    n_neighbors = $method.n_neighbors,
    @CONF_PARAMS_DATA_INTEGRATION@
    inplace = True
)
#end if

#if $method.method != 'pp.make_fragment_file'
@CONF_ANNDATA_WRITE_OUTPUTS@
#end if
    ]]></configfile>
    </configfiles>
    <inputs>
        <conditional name="method">
            <param name="method" type="select" label="Method used for preprocessing">
                <option value="pp.make_fragment_file">Convert a BAM file to a fragment file, using 'pp.make_fragment_file'</option>
                <option value="pp.import_fragments">Import data fragment files and compute basic QC metrics, using 'pp.import_fragments'</option>
                <!-- Not sure how this should work and there is no documentation for it. -->
                <!-- <option value="pp.import_values">Import values associated with base pairs, using 'pp.import_values'</option> -->
                <option value="pp.import_contacts">Import chromatin contacts, using 'pp.import_contacts'</option>
                <option value="pp.call_cells">Calling cells based on the number of feature counts, using 'pp.call_cells'</option>
                <option value="pp.add_tile_matrix">Generate cell by bin count matrix, using 'pp.add_tile_matrix'</option>
                <option value="pp.make_gene_matrix">Generate cell by gene activity matrix, using 'pp.make_gene_matrix'</option>
                <option value="pp.filter_cells">Filter cell outliers based on counts and numbers of genes expressed, using 'pp.filter_cells'</option>
                <option value="pp.select_features">Perform feature selection, using 'pp.select_features'</option>
                <option value="pp.scrublet">Compute probability of being a doublet using the scrublet algorithm, using 'pp.scrublet'</option>
                <option value="pp.filter_doublets">Remove doublets according to the doublet probability or doublet score, using 'pp.filter_doublets'</option>
                <option value="pp.mnc_correct">A modified MNN-Correct algorithm based on cluster centroid, using 'pp.mnc_correct'</option>
                <option value="pp.harmony">Use harmonypy to integrate different experiments,using 'pp.harmony'</option>
                <option value="pp.scanorama_integrate">Use Scanorama [Hie19] to integrate different experiments, using 'pp.scanorama_integrate'</option>
            </param>
            <when value="pp.make_fragment_file">
                <param argument="bam_file" type="data" format="bam" label="File name of the BAM file"/>
                <param argument="is_paired" type="boolean" truevalue="True" falsevalue="False" checked="true" label="Indicate whether the BAM file contain paired-end reads"/>
                <conditional name="barcode">
                    <param name="extract_type" type="select" label="How to extract barcodes from BAM records?">
                        <option value="from_tag">From TAG fields</option>
                        <option value="from_read_names">From read names using regular expressions</option>
                    </param>
                    <when value="from_tag">
                        <param argument="barcode_tag" type="text" value="CB" optional="true" label="Extract barcodes from TAG fields of BAM records"/>
                    </when>
                    <when value="from_read_names">
                        <param argument="barcode_regex" type="text" value="" optional="true" label="Extract barcodes from read names of BAM records using regular expressions" help="`(..:..:..:..):\w+$` extracts `bd:69:Y6:10` from `A01535:24:HW2MMDSX2:2:1359:8513:3458:bd:69:Y6:10:TGATAGGTT``"/>
                    </when>
                </conditional>
                <param argument="umi_tag" type="text" value="" optional="true" label="Extract UMI from TAG fields of BAM records"/>
                <param argument="umi_regex" type="text" value="" optional="true" label="Extract UMI from read names of BAM records using regular expressions"/>
                <expand macro="param_shift" varname="shift_left" label="Shift left" value="4"/>
                <expand macro="param_shift" varname="shift_right" label="Shift right" value="-5"/>
                <param argument="min_mapq" type="integer" min="0" value="30" label="Filter the reads based on MAPQ"/>
                <expand macro="param_chunk_size" size="50000000"/>
            </when>
            <when value="pp.import_fragments">
                <param argument="fragment_file" type="data" format="bed" label="Fragment file to import" help=" A fragment file must contain at least 5 columns: chromosome, start, end, barcode, count"/>
                <expand macro="param_chrom_sizes"/>
                <param argument="min_num_fragments" type="integer" value="200" label="Minimum number of fragments required for a cell to pass filtering"/>
                <param argument="sorted_by_barcode" type="boolean" truevalue="True" falsevalue="False" checked="true" label="Whether the fragment file is sorted by barcode"/>
                <param argument="whitelist" type="data" format="bed" optional="true" label="A user provided bed file containing genome-wide whitelist regions"/>
                <param argument="chrM" type="text" value="" optional="true" label="A list of chromosomes to be treated as mitochondrial chromosomes, e.g. chrM, M, mt, mtDNA">
                    <expand macro="sanitize_query"/>
                </param>
                <expand macro="param_shift" varname="shift_left" label="Shift left" value="0"/>
                <expand macro="param_shift" varname="shift_right" label="Shift right" value="0"/>
                <expand macro="param_chunk_size" size="2000"/>
            </when>
            <!-- Not sure how this should work and there is no documentation for it. -->
            <!-- <when value="pp.import_values">
                <expand macro="param_inputs_anndata" multiple="true"/>
                <expand macro="param_chrom_sizes"/>
                <expand macro="param_chunk_size" size="200"/>
            </when> -->
            <when value="pp.import_contacts">
                <param argument="contact_file" type="data" format="bed" label="Contact file to import"/>
                <expand macro="param_chrom_sizes"/>
                <param argument="sorted_by_barcode" type="boolean" truevalue="True" falsevalue="False" checked="true" label="Whether the contact file is sorted by barcode"/>
                <param argument="bin_size" type="integer" value="500000" label="The size of consecutive genomic regions used to record the counts"/>
                <expand macro="param_chunk_size" size="200"/>
            </when>
            <when value="pp.call_cells">
                <expand macro="param_inputs_anndata"/>
                <param argument="use_rep" type="float" value="" optional="true" label="The representation to use for filtering"/>
            </when>
            <when value="pp.add_tile_matrix">
                <expand macro="param_inputs_anndata"/>
                <param argument="bin_size" type="integer" value="500" label="The size of consecutive genomic regions used to record the counts"/>
                <expand macro="param_chunk_size" size="500"/>
                <param argument="exclude_chroms" type="text" value="chrM, chrY, M, Y" optional="true" label="A list of chromosomes to exclude">
                    <expand macro="sanitize_query"/>
                </param>
                <expand macro="param_min_max_frag_size"/>
                <expand macro="param_counting_strategy"/>
            </when>
            <when value="pp.make_gene_matrix">
                <expand macro="param_inputs_anndata"/>
                <param argument="gene_anno" type="data" format="gtf,gff3" label="GTF/GFF file containing the gene annotation"/>
                <expand macro="param_chunk_size" size="500"/>
                <param argument="use_x" type="boolean" truevalue="True" falsevalue="False" checked="false" label="If True, use the matrix stored in .X as raw counts"/>
                <param argument="id_type" type="select" label="Id type, 'gene' or 'transcript'">
                    <option value="gene" selected="true">gene</option>
                    <option value="transcript">transcript</option>
                </param>
                <param argument="upstream" type="integer" value="2000" label="Number of base pairs upstream of the regulatory domain"/>
                <param argument="downstream" type="integer" value="0" label="Number of base pairs downstream of regulatory domain"/>
                <param argument="include_gene_body" type="boolean" truevalue="True" falsevalue="False" checked="true" label="Whether to include the gene body in the regulatory domain. If False, the TSS is used as the regulatory domain."/>
                <param argument="transcript_name_key" type="text" value="transcript_name" label="The key of the transcript name in the gene annotation file"/>
                <param argument="transcript_id_key" type="text" value="transcript_id" label="The key of the transcript id in the gene annotation file"/>
                <param argument="gene_name_key" type="text" value="gene_name" label="The key of the gene name in the gene annotation file"/>
                <param argument="gene_id_key" type="text" value="gene_id" label="The key of the gene id in the gene annotation file"/>
                <expand macro="param_min_max_frag_size"/>
                <expand macro="param_counting_strategy"/>
            </when>
            <when value="pp.filter_cells">
                <expand macro="param_inputs_anndata"/>
                <param argument="min_counts" type="integer" value="1000" label="Minimum number of counts required for a cell to pass filtering"/>
                <param argument="min_tsse" type="float" value="5.0" label="Minimum TSS enrichment score required for a cell to pass filtering"/>
                <param argument="max_counts" type="integer" value="" optional="true" label="Maximum number of counts required for a cell to pass filtering"/>
                <param argument="max_tsse" type="float" value="" optional="true" label="Maximum TSS enrichment score expressed required for a cell to pass filtering"/>
            </when>
            <when value="pp.select_features">
                <expand macro="param_inputs_anndata"/>
                <param argument="n_features" type="integer" min="1" value="500000" label="Number of features to keep"/>
                <param argument="filter_lower_quantile" type="float" min="0" value="0.005" label="Lower quantile of the feature count distribution to filter out"/>
                <param argument="filter_upper_quantile" type="float" min="0" value="0.005" label="Upper quantile of the feature count distribution to filter out"/>
                <param argument="whitelist" type="data" format="bed" optional="true" label="A user provided bed file containing genome-wide whitelist regions"/>
                <param argument="blacklist" type="data" format="bed" optional="true" label="A user provided bed file containing genome-wide blacklist regions"/>
                <param argument="max_iter" type="integer" value="1" label="If greater than 1, this function will perform iterative clustering and feature selection"/>
            </when>
            <when value="pp.scrublet">
                <expand macro="param_inputs_anndata"/>
                <param argument="features" type="text" value="" optional="true" label=" Boolean index mask, where True means that the feature is kept, and False means the feature is removed."/>
                <param argument="n_comps" type="integer" value="15" label="Number of components" help="15 is usually sufficient. The algorithm is not sensitive to this parameter"/>
                <param argument="sim_doublet_ratio" type="float" value="2.0" label="Number of doublets to simulate relative to the number of observed cells"/>
                <param argument="expected_doublet_rate" type="float" value="0.1" label="Expected doublet rate"/>
                <param argument="n_neighbors" type="integer" value="" optional="true" label="Number of neighbors used to construct the KNN graph of observed cells and simulated doublets"/>
                <param argument="use_approx_neighbors" type="boolean" truevalue="True" falsevalue="False" checked="false" label="Whether to use approximate search"/>
                <param argument="random_state" type="integer" value="0" label="Random state"/>
            </when>
            <when value="pp.filter_doublets">
                <expand macro="param_inputs_anndata"/>
                <param argument="probability_threshold" type="float" value="0.5" label="Threshold for doublet probability"/>
                <param argument="score_threshold" type="float" value="" optional="true" label="Threshold for doublet score"/>
            </when>
            <when value="pp.mnc_correct">
                <expand macro="param_inputs_anndata"/>
                <param argument="batch" type="text" value="batch" label="Batch labels for cells">
                    <expand macro="sanitize_query"/>
                </param>
                <param argument="n_neighbors" type="integer" value="5" label="Number of mutual nearest neighbors"/>
                <param argument="n_clusters" type="integer" value="40" label="Number of clusters"/>
                <param argument="n_iter" type="integer" value="1" label="Number of iterations"/>
                <expand macro="param_data_integration"/>
            </when>
            <when value="pp.harmony">
                <expand macro="param_inputs_anndata"/>
                <param argument="batch" type="text" value="batch" label="Batch labels for cells">
                    <expand macro="sanitize_query"/>
                </param>
                <expand macro="param_data_integration"/>
            </when>
            <when value="pp.scanorama_integrate">
                <expand macro="param_inputs_anndata"/>
                <param argument="batch" type="text" value="batch" label="Batch labels for cells">
                    <expand macro="sanitize_query"/>
                </param>
                <param argument="n_neighbors" type="integer" value="20" label="Number of mutual nearest neighbors"/>
                <expand macro="param_data_integration"/>
            </when>
        </conditional>
        <expand macro="param_common_advanced"/>
    </inputs>
    <outputs>
        <data name="fragments_out" format="interval" label="${tool.name} (${method.method}) on ${on_string}: Fragment file">
            <filter>method['method'] == 'pp.make_fragment_file'</filter>
        </data>
        <data name="anndata_out" format="h5ad" from_work_dir="anndata.h5ad" label="${tool.name} (${method.method}) on ${on_string}: Annotated data matrix">
            <filter>method['method'] != 'pp.make_fragment_file'</filter>
        </data>
        <data name="hidden_output" format="txt" label="Log file">
            <filter>advanced_common['show_log']</filter>
        </data>
    </outputs>
    <tests>
        <test expect_num_outputs="1">
            <!-- pp.make_fragment_file -->
            <conditional name="method">
                <param name="method" value="pp.make_fragment_file"/>
                <param name="bam_file" location="https://zenodo.org/records/11260316/files/pbmc_500_chr21_subsample.bam"/>
                <param name="is_paired" value="true"/>
                <conditional name="barcode">
                    <param name="extract_type" value="from_tag"/>
                    <param name="barcode_tag" value="CB"/>
                </conditional>
                <param name="shift_left" value="4"/>
                <param name="shift_right" value="-5"/>
                <param name="min_mapq" value="10"/>
                <param name="chunk_size" value="50000000"/>
            </conditional>
            <output name="fragments_out" location="https://zenodo.org/records/11260316/files/pp.make_fragment_file.pbmc_500_chr21.tsv.gz" ftype="interval" compare="sim_size" delta_frac="0.1"/>
        </test>
        <test expect_num_outputs="2">
            <!-- pp.make_gene_matrix -->
            <conditional name="method">
                <param name="method" value="pp.make_gene_matrix"/>
                <param name="adata" location="https://zenodo.org/records/11260316/files/tl.leiden.modularity.pbmc_500_chr21.h5ad"/>
                <param name="gene_anno" location="https://zenodo.org/records/11260316/files/chr21.gff3.gz"/>
                <param name="chunk_size" value="500"/>
                <param name="use_x" value="False"/>
                <param name="id_type" value="gene"/>
                <param name="transcript_name_key" value="transcript_name"/>
                <param name="transcript_id_key" value="transcript_id"/>
                <param name="gene_name_key" value="gene_name"/>
                <param name="gene_id_key" value="gene_id"/>
                <param name="counting_strategy" value="insertion"/>
                </conditional>
            <section name="advanced_common">
                <param name="show_log" value="true" />
            </section>
            <output name="hidden_output">
                <assert_contents>
                    <has_text_matching expression="snap.pp.make_gene_matrix"/>
                    <has_text_matching expression="chunk_size = 500"/>
                    <has_text_matching expression="use_x = False"/>
                    <has_text_matching expression="id_type = 'gene'"/>
                    <has_text_matching expression="transcript_name_key = 'transcript_name'"/>
                    <has_text_matching expression="transcript_id_key = 'transcript_id'"/>
                    <has_text_matching expression="gene_name_key = 'gene_name'"/>
                    <has_text_matching expression="gene_id_key = 'gene_id'"/>
                    <has_text_matching expression="counting_strategy = 'insertion'"/>
                </assert_contents>
            </output>
            <output name="anndata_out" location="https://zenodo.org/records/12548681/files/pp.make_gene_matrix.pbmc_500_chr21.h5ad" ftype="h5ad" compare="sim_size" delta_frac="0.1" />
        </test>
        <test expect_num_outputs="2">
            <!-- pp.filter_cells -->
            <conditional name="method">
                <param name="method" value="pp.filter_cells"/>
                <param name="adata" location="https://zenodo.org/records/11260316/files/metrics.tsse.pbmc_500_chr21.h5ad"/>
                <param name="min_counts" value="200"/>
                <param name="min_tsse" value="5"/>
                <param name="max_counts" value="10000"/>
              </conditional>
            <section name="advanced_common">
                <param name="show_log" value="true" />
            </section>
            <output name="hidden_output">
                <assert_contents>
                    <has_text_matching expression="snap.pp.filter_cells"/>
                    <has_text_matching expression="min_counts = 200"/>
                    <has_text_matching expression="min_tsse = 5"/>
                    <has_text_matching expression="max_counts = 10000"/>
                </assert_contents>
            </output>
            <output name="anndata_out" location="https://zenodo.org/records/11260316/files/pp.filter_cells.pbmc_500_chr21.h5ad" ftype="h5ad" compare="sim_size" delta_frac="0.1" />
        </test>
        <test expect_num_outputs="2">
            <!-- pp.add_tile_matrix -->
            <conditional name="method">
                <param name="method" value="pp.add_tile_matrix"/>
                <param name="adata" location="https://zenodo.org/records/11260316/files/pp.filter_cells.pbmc_500_chr21.h5ad"/>
                <param name="bin_size" value="5000"/>
                <param name="chunk_size" value="500"/>
                <param name="exclude_chroms" value="chr1, chr2, chr3, chr4, chr5, chr6, chr7, chr8, chr9, chr10, chr11, chr12, chr13, chr14, chr15, chr16, chr17, chr18, chr19, chr20, chr22, chrX, chrY"/>
                <param name="counting_strategy" value="insertion"/>
                </conditional>
            <section name="advanced_common">
                <param name="show_log" value="true" />
            </section>
            <output name="hidden_output">
                <assert_contents>
                    <has_text_matching expression="snap.pp.add_tile_matrix"/>
                    <has_text_matching expression="bin_size = 5000"/>
                    <has_text_matching expression="chunk_size = 500"/>
                    <has_text_matching expression="exclude_chroms = \['chr1', 'chr2', 'chr3', 'chr4', 'chr5', 'chr6', 'chr7', 'chr8', 'chr9', 'chr10', 'chr11', 'chr12', 'chr13', 'chr14', 'chr15', 'chr16', 'chr17', 'chr18', 'chr19', 'chr20', 'chr22', 'chrX', 'chrY'\]"/>
                    <has_text_matching expression="counting_strategy = 'insertion'"/>
                </assert_contents>
            </output>
            <output name="anndata_out"  ftype="h5ad" compare="sim_size" delta_frac="0.1" location="https://zenodo.org/records/11260316/files/pp.add_tile_matrix.pbmc_500_chr21.h5ad"/>
        </test>
        <test expect_num_outputs="2">
            <!-- pp.add_tile_matrix counting_strategy fragment -->
            <conditional name="method">
                <param name="method" value="pp.add_tile_matrix"/>
                <param name="adata" location="https://zenodo.org/records/11260316/files/pp.filter_cells.pbmc_500_chr21.h5ad"/>
                <param name="bin_size" value="5000"/>
                <param name="chunk_size" value="500"/>
                <param name="exclude_chroms" value="chr1, chr2, chr3, chr4, chr5, chr6, chr7, chr8, chr9, chr10, chr11, chr12, chr13, chr14, chr15, chr16, chr17, chr18, chr19, chr20, chr22, chrX, chrY"/>
                <param name="counting_strategy" value="fragment"/>
                </conditional>
            <section name="advanced_common">
                <param name="show_log" value="true" />
            </section>
            <output name="hidden_output">
                <assert_contents>
                    <has_text_matching expression="snap.pp.add_tile_matrix"/>
                    <has_text_matching expression="bin_size = 5000"/>
                    <has_text_matching expression="chunk_size = 500"/>
                    <has_text_matching expression="exclude_chroms = \['chr1', 'chr2', 'chr3', 'chr4', 'chr5', 'chr6', 'chr7', 'chr8', 'chr9', 'chr10', 'chr11', 'chr12', 'chr13', 'chr14', 'chr15', 'chr16', 'chr17', 'chr18', 'chr19', 'chr20', 'chr22', 'chrX', 'chrY'\]"/>
                    <has_text_matching expression="counting_strategy = 'fragment'"/>
                </assert_contents>
            </output>
            <output name="anndata_out"  ftype="h5ad" compare="sim_size" delta_frac="0.1" location="https://zenodo.org/records/11260316/files/pp.add_tile_matrix.pbmc_500_chr21.h5ad"/>
        </test>
        <test expect_num_outputs="2">
            <!-- pp.select_features -->
            <conditional name="method">
                <param name="method" value="pp.select_features"/>
                <param name="adata" location="https://zenodo.org/records/11260316/files/pp.add_tile_matrix.pbmc_500_chr21.h5ad"/>
                <param name="n_features" value="15000"/>
              </conditional>
            <section name="advanced_common">
                <param name="show_log" value="true" />
            </section>
            <output name="hidden_output">
                <assert_contents>
                    <has_text_matching expression="snap.pp.select_features"/>
                    <has_text_matching expression="n_features = 15000"/>
                </assert_contents>
            </output>
            <output name="anndata_out" ftype="h5ad" compare="sim_size" delta_frac="0.1" location="https://zenodo.org/records/11260316/files/pp.select_features.pbmc_500_chr21.h5ad"/>
        </test>
        <test expect_num_outputs="2">
        <!-- pp.scrublet -->
            <conditional name="method">
                <param name="method" value="pp.scrublet"/>
                <param name="adata" location="https://zenodo.org/records/11260316/files/pp.select_features.pbmc_500_chr21.h5ad"/>
                <param name="n_comps" value="15"/>
                <param name="sim_doublet_ratio" value="2.0"/>
                <param name="expected_doublet_rate" value="0.1"/>
                <param name="random_state" value="0"/>
              </conditional>
            <section name="advanced_common">
                <param name="show_log" value="true" />
            </section>
            <output name="hidden_output">
                <assert_contents>
                    <has_text_matching expression="snap.pp.scrublet"/>
                    <has_text_matching expression="n_comps = 15"/>
                    <has_text_matching expression="sim_doublet_ratio = 2.0"/>
                    <has_text_matching expression="expected_doublet_rate = 0.1"/>
                    <has_text_matching expression="random_state = 0"/>
                </assert_contents>
            </output>
            <output name="anndata_out" ftype="h5ad" compare="sim_size" delta_frac="0.1" location="https://zenodo.org/records/11260316/files/pp.scrublet.pbmc_500_chr21.h5ad"/>
        </test>
        <test expect_num_outputs="2">
        <!-- pp.filter_doublets -->
            <conditional name="method">
                <param name="method" value="pp.filter_doublets"/>
                <param name="adata" location="https://zenodo.org/records/11260316/files/pp.scrublet.pbmc_500_chr21.h5ad"/>
                <param name="probability_threshold"  value="0.1"/>
              </conditional>
            <section name="advanced_common">
                <param name="show_log" value="true" />
            </section>
            <output name="hidden_output">
                <assert_contents>
                    <has_text_matching expression="snap.pp.filter_doublets"/>
                </assert_contents>
            </output>
            <output name="anndata_out" ftype="h5ad" compare="sim_size" delta_frac="0.1" location="https://zenodo.org/records/11260316/files/pp.filter_doublets.pbmc_500_chr21.h5ad"/>
        </test>
        <test expect_num_outputs="2">
            <!-- pp.mnc_correct -->
            <conditional name="method">
                <param name="method" value="pp.mnc_correct"/>
                <param name="adata" location="https://zenodo.org/records/11260316/files/pbmc_500_chr21.batch.h5ad"/>
                <param name="batch" value="batch"/>
                <param name="n_neighbors" value="3"/>
                <param name="n_clusters" value="10"/>
                <param name="use_rep" value="X_spectral"/>
            </conditional>
            <section name="advanced_common">
                <param name="show_log" value="true" />
            </section>
            <output name="hidden_output">
                <assert_contents>
                    <has_text_matching expression="snap.pp.mnc_correct"/>
                    <has_text_matching expression="batch = 'batch'"/>
                    <has_text_matching expression="n_neighbors = 3"/>
                    <has_text_matching expression="n_clusters = 10"/>
                    <has_text_matching expression="batch = 'batch'"/>
                    <has_text_matching expression="use_rep = 'X_spectral'"/>
                </assert_contents>
            </output>
            <output name="anndata_out" ftype="h5ad" compare="sim_size" delta_frac="0.1" location="https://zenodo.org/records/11260316/files/pp.mnc_correct.pbmc_500_chr21.h5ad"/>
        </test>
        <test expect_num_outputs="2">
            <!-- pp.harmony -->
            <conditional name="method">
                <param name="method" value="pp.harmony"/>
                <param name="adata" location="https://zenodo.org/records/11260316/files/pbmc_500_chr21.batch.h5ad"/>
                <param name="batch" value="batch"/>
                <param name="use_rep" value="X_spectral"/>
            </conditional>
            <section name="advanced_common">
                <param name="show_log" value="true" />
            </section>
            <output name="hidden_output">
                <assert_contents>
                    <has_text_matching expression="snap.pp.harmony"/>
                    <has_text_matching expression="batch = 'batch'"/>
                    <has_text_matching expression="use_rep = 'X_spectral'"/>
                </assert_contents>
            </output>
            <output name="anndata_out" ftype="h5ad" compare="sim_size" delta_frac="0.1" location="https://zenodo.org/records/11260316/files/pp.harmony.pbmc_500_chr21.h5ad"/>
        </test>
        <test expect_num_outputs="2">
            <!-- pp.scanorama_integrate -->
            <conditional name="method">
                <param name="method" value="pp.scanorama_integrate"/>
                <param name="adata" location="https://zenodo.org/records/11260316/files/pbmc_500_chr21.batch.h5ad"/>
                <param name="batch" value="batch"/>
                <param name="use_rep" value="X_spectral"/>
            </conditional>
            <section name="advanced_common">
                <param name="show_log" value="true" />
            </section>
            <output name="hidden_output">
                <assert_contents>
                    <has_text_matching expression="snap.pp.scanorama_integrate"/>
                    <has_text_matching expression="batch = 'batch'"/>
                    <has_text_matching expression="use_rep = 'X_spectral'"/>
                </assert_contents>
            </output>
            <output name="anndata_out" ftype="h5ad" compare="sim_size" delta_frac="0.1" location="https://zenodo.org/records/11260316/files/pp.scanorama_integrate.pbmc_500_chr21.h5ad"/>
        </test>
    </tests>
    <help><![CDATA[
Convert a BAM file`to a fragment file, using `pp.make_fragment_file`
====================================================================

Convert a BAM file to a fragment file.

Convert a BAM file to a fragment file by performing the following steps:

- Filtering: remove reads that are unmapped, not primary alignment, mapq < 30, fails platform/vendor quality checks, or optical duplicate. For paired-end sequencing, it also removes reads that are not properly aligned.

- Deduplicate: Sort the reads by cell barcodes and remove duplicated reads for each unique cell barcode.

- Output: Convert BAM records to fragments (if paired-end) or single-end reads.

The bam file needn’t be sorted or filtered.

More details on the `SnapATAC2 documentation
<https://kzhang.org/SnapATAC2/api/_autosummary/snapatac2.pp.make_fragment_file.html>`__


Generate cell by bin count matrix, using `pp.add_tile_matrix`
=============================================================

Generate cell by bin count matrix.

This function is used to generate and add a cell by bin count matrix to the AnnData object.

More details on the `SnapATAC2 documentation
<https://kzhang.org/SnapATAC2/api/_autosummary/snapatac2.pp.add_tile_matrix.html>`__

Generate cell by gene activity matrix, using `pp.make_gene_matrix`
==================================================================

Generate cell by gene activity matrix.

Generate cell by gene activity matrix by counting the TN5 insertions in gene body regions. The result will be stored in a new file and a new AnnData object will be created.

More details on the `SnapATAC2 documentation
<https://kzhang.org/SnapATAC2/api/_autosummary/snapatac2.pp.make_gene_matrix.html>`__

Filter cell outliers based on counts and numbers of genes expressed, using `pp.filter_cells`
============================================================================================

Filter cell outliers based on counts and numbers of genes expressed. For instance, only keep cells with at least `min_counts` counts or `min_ts`` TSS enrichment scores. This is to filter measurement outliers, i.e. “unreliable” observations.

More details on the `SnapATAC2 documentation
<https://kzhang.org/SnapATAC2/api/_autosummary/snapatac2.pp.filter_cells.html>`__

Perform feature selection, using `pp.select_features`
=====================================================

Perform feature selection by selecting the most accessible features across all cells unless `max_iter` > 1

More details on the `SnapATAC2 documentation
<https://kzhang.org/SnapATAC2/api/_autosummary/snapatac2.pp.select_features.html>`__

Compute probability of being a doublet using the scrublet algorithm, using `pp.scrublet`
========================================================================================

Compute probability of being a doublet using the scrublet algorithm.

This function identifies doublets by generating simulated doublets using randomly pairing chromatin accessibility profiles of individual cells. The simulated doublets are then embedded alongside the original cells using the spectral embedding algorithm in this package. A k-nearest-neighbor classifier is trained to distinguish between the simulated doublets and the authentic cells. This trained classifier produces a “doublet score” for each cell. The doublet scores are then converted into probabilities using a Gaussian mixture model.

More details on the `SnapATAC2 documentation
<https://kzhang.org/SnapATAC2/api/_autosummary/snapatac2.pp.scrublet.html>`__

Remove doublets according to the doublet probability or doublet score, using `pp.filter_doublets`
=================================================================================================

Remove doublets according to the doublet probability or doublet score.

The user can choose to remove doublets by either the doublet probability or the doublet score. `scrublet` must be ran first in order to use this function.

More details on the `SnapATAC2 documentation
<https://kzhang.org/SnapATAC2/api/_autosummary/snapatac2.pp.filter_doublets.html>`__

A modified MNN-Correct algorithm based on cluster centroid, using `pp.mnc_correct`
==================================================================================

A modified MNN-Correct algorithm based on cluster centroid.

More details on the `SnapATAC2 documentation
<https://kzhang.org/SnapATAC2/api/_autosummary/snapatac2.pp.mnc_correct.html>`__

Use harmonypy to integrate different experiments,using `pp.harmony`
===================================================================

Use harmonypy to integrate different experiments.

Harmony is an algorithm for integrating single-cell data from multiple experiments. This function uses the python port of Harmony, `harmonypy`, to integrate single-cell data stored in an AnnData object. This function should be run after performing dimension reduction.

More details on the `SnapATAC2 documentation
<https://kzhang.org/SnapATAC2/api/_autosummary/snapatac2.pp.harmony.html>`__

Use Scanorama to integrate different experiments, using `pp.scanorama_integrate`
========================================================================================

Use Scanorama to integrate different experiments.

Scanorama is an algorithm for integrating single-cell data from multiple experiments stored in an AnnData object. This function should be run after performing `tl.spectral` but before computing the neighbor graph.

More details on the `SnapATAC2 documentation
<https://kzhang.org/SnapATAC2/api/_autosummary/snapatac2.pp.scanorama_integrate.html>`__

    ]]></help>
    <expand macro="citations"/>
</tool>
