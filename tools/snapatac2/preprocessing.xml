<tool id="snapatac2_preprocessing" name="Preprocessing" version="@TOOL_VERSION@+galaxy@VERSION_SUFFIX@">
    <description>with snapatac2</description>
    <macros>
        <import>macros.xml</import>
    </macros>
    <requirements>
    	<expand macro="requirements"/>
    </requirements>
    <command detect_errors="exit_code"><![CDATA[
@CMD@
    ]]></command>
    <configfiles>
        <configfile name="script_file"><![CDATA[

@CMD_imports@

#if $method.method == 'pp.make_fragment_file'
sa.pp.make_fragment_file(
	bam_file = '$method.bam_file',
	output_file = '$method.output_file',
	is_paired = $method.is_paired,
	barcode_tag = '$method.barcode_tag',
	barcode_regex = '$method.barcode_regex',
	umi_tag = '$method.umi_tag',
	umi_regex = '$method.umi_regex',
	shift_right = $method.shift_right,
	shift left = $method.shift_left,
	min_mapq = $method.min_mapq,
	chunk_size = $method.chunk_size,
	compression = '$method.compression',
	compression_level = $method.compression_level,
)

#else if $method.method == 'pp.import_data'
import json
import pandas as pd
import csv
with open('$method.chrom_sizes') as f:
    chr_sizes = {x[0]:int(x[1]) for x in csv.reader(f, delimiter='\t')}

sa.pp.import_data(
	fragment_file = '$method.fragment_file',
	chrom_sizes = chr_sizes,
	min_num_fragments = $method.min_num_fragments,
	sorted_by_barcode = $method.sorted_by_barcode,
	#if str($method.whitelist) != 'None'
	whitelist = '$method.whitelist',
	#end if
	shift_left = $method.shift_left,
	shift_right = $method.shift_right,
	#set $chr_mt = ([x.strip() for x in str($method.chrM).split(',')])
	chrM = $chr_mt,
	chunk_size = $method.chunk_size,
	backend = '$method.backend',
	file = 'anndata.h5ad'
)

#else if $method.method == 'pp.add_tile_matrix'
@CMD_read_inputs@
sa.pp.add_tile_matrix(
	adata = '$method.adata',
	bin_size = $method.bin_size,
	inplace = $method.inplace,
	chunk_size = $method.chunk_size,
	exclude_chroms = '$method.exclude_chroms',
	min_frag_size = $method.min_frag_size,
	max_frag_size = $method.max_frag_size,
	file = '$method.file',
	backend = '$method.backend',
)

#else if $method.method == 'pp.make_peak_matrix'
@CMD_read_inputs@
sa.pp.make_peak_matrix(
	adata = '$method.adata',
	use_rep = '$method.use_rep',
	inplace = $method.inplace,
	file = '$method.file',
	backend = '$method.backend',
	peak_file = '$method.peak_file',
	chunk_size = $method.chunk_size,
	use_x = $method.use_x,
	min_frag_size = $method.min_frag_size,
	max_frag_size = $method.max_frag_size
)

#else if $method.method == 'pp.make_gene_matrix'
@CMD_read_inputs@
sa.pp.make_gene_matrix(
	adata = '$method.adata',
	gene_anno = '$method.gene_anno',
	inplace = $method.inplace,
	file = '$method.file',
	backend = '$method.backend',
	chunk_size = $method.chunk_size,
	use_x = $method.use_x,
	id_type = '$method.id_type',
	transcript_name_key = '$method.transcript_name_key',
	transcript_id_key = '$method.transcript_id_key',
	gene_name_key = '$method.gene_name_key',
	gene_id_key = '$method.gene_id_key',
	min_frag_size = $method.min_frag_size,
	max_frag_size = $method.max_frag_size,
	count_frag_as_reads =$method.count_frag_as_reads
)

#else if $method.method == 'pp.filter_cells'
@CMD_read_inputs@
sa.pp.filter_cells(
	data = '$method.adata',
	min_counts = $method.min_counts,
	min_tsse = $method.min_tsse,
	max_counts = $method.max_counts,
	max_tsse = $method.max_tsse,
	inplace = $method.inplace,
)

#else if $method.method == 'pp.select_features'
@CMD_read_inputs@
sa.pp.select_features(
	adata = '$method.adata',
	n_features = $method.n_features,
	filter_lower_quantile = $method.filter_lower_quantile,
	filter_upper_quantile = $method.filter_upper_quantile,
	whitelist = '$method.whitelist',
	blacklist = '$method.blacklist',
	max_iter = $method.max_iter,
	inplace = $method.inplace,
	verbose = $method.verbose
)

#else if $method.method == 'pp.knn'
@CMD_read_inputs@
sa.pp.knn(
	adata = '$method.adata',
	n_neighbors = $method.n_neighbors,
	use_dims = $method.use_dims,
	use_rep = '$method.use_rep',
	method = '$method.method',
	inplace = $method.inplace,
	random_state = $method.random_state
)

#else if $method.method == 'pp.scrublet'
@CMD_read_inputs@
sa.pp.scrublet(
	adata = '$method.adata',
	features = '$method.features',
	n_comps = $method.n_comps,
	sim_doublet_ratio = $method.sim_doublet_ratio,
	expected_doublet_rate = $method.expected_doublet_rate,
	n_neighbor = $method.n_neighbor,
	use_approx_neighbors = $method.use_approx_neighbors,
	random_state = $method.random_state,
	inplace = $method.inplace,
	verbose = $method.verbose
)

#else if $method.method == 'pp.filter_doublets'
@CMD_read_inputs@
sa.pp.filter_doublets(
	adata = '$method.adata',
	probability_threshold = $method.probability_threshold,
	score_threshold = $method.score_threshold,
	inplace = $method.inplace,
	verbose = $method.verbose
)

#else if $method.method == 'pp.mnc_correct'
@CMD_read_inputs@
sa.pp.mnc_correct(
	adata = '$method.adata',
	batch = '$method.batch',
	n_neighbors = $method.n_neighbors,
	n_clusters = $method.n_clusters,
	n_iter = $method.n_iter,
	use_rep = '$method.use_rep',
	use_dims = $method.use_dims,
	groupby = '$method.groupby',
	key_added = '$method.key_added',
	inplace = $method.inplace,
)

#else if $method.method == 'pp.harmony'
@CMD_read_inputs@
sa.pp.harmony(
	adata = '$method.adata',
	batch = '$method.batch',
	use_rep = '$method.use_rep',
	use_dims = $method.use_dims,
	groupby = '$method.groupby',
	key_added = '$method.key_added',
	inplace = $method.inplace
)

#else if $method.method == 'pp.scanorama_integrate'
@CMD_read_inputs@
sa.pp.scanorama_integrate(
	adata = '$method.adata',
	batch = '$method.batch',
	n_neighbors = $method.n_neighbors,
	use_rep = '$method.use_rep',
	use_dims = $method.use_dims,
	groupby = '$method.groupby',
	key_added = '$method.key_added',
	inplace = $method.inplace
)

#end if

        ]]></configfile>
	</configfiles>
    
    <inputs>
		<conditional name="method">
			<param name="method" type="select" label="Method used for preprocessing">
				<option value="pp.make_fragment_file">Convert a BAM file to a fragment file, using pp.make_fragment_file</option>
				<option value="pp.import_data">Import data fragment files and compute basic QC metrics, using pp.import_data</option>
				<option value="pp.add_tile_matrix">Generate cell by bin count matrix, using pp.add_tile_matrix</option>
				<option value="pp.make_peak_matrix">Generate cell by peak count matrix, using pp.make_peak_matrix</option>
				<option value="pp.make_gene_matrix">Generate cell by gene activity matrix, using pp.make_gene_matrix</option>
				<option value="pp.filter_cells">Filter cell outliers based on counts and numbers of genes expressed, using pp.filter_cells</option>
				<option value="pp.select_features">Perform feature selection, using pp.select_features</option>
				<option value="pp.knn">Compute a neighborhood graph of observations, using pp.knn</option>
				<option value="pp.scrublet">Compute probability of being a doublet using the scrublet algorithm, using pp.scrublet</option>
				<option value="pp.filter_doublets">Remove doublets according to the doublet probability or doublet score, using pp.filter_doublets</option>
				<option value="pp.mnc_correct">A modified MNN-Correct algorithm based on cluster centroid, using pp.mnc_correct</option>
				<option value="pp.harmony">Use harmonypy to integrate different experiments,using pp.harmony</option>
				<option value="pp.scanorama_integrate">Use Scanorama [Hie19] to integrate different experiments, using pp.scanorama_integrate</option>
			</param>
			<when value="pp.make_fragment_file">
				<param name="bam_file" type="text" optional="false" label="File name of the BAM file"/>
				<param name="output_file" type="text" optional="false" label="File name of the output fragment file"/>
				<param name="is_paired" type="boolean" checked="true" label="Indicate whether the BAM file contain paired-end reads"/>
				<param name ="barcode_tag" type="text" value="" optional="true" label="Extract barcodes from TAG fields of BAM records"/>
				<param name ="barcode_regex" type="text" value="" optional="true" label="Extract barcodes from read names of BAM records using regular expressions"/>
				<param name ="umi_tag" type="text" value="" optional="true" label="Extract UMI from TAG fields of BAM records"/>
				<param name ="umi_regex" type="text" value="" optional="true" label="Extract UMI from read names of BAM records using regular expressions"/>
				<expand macro="shift"/>
				<param name="min_mapq" type="integer" value="" optional="true" label="Filter the reads based on MAPQ"/>
				<param name="chunk_size" type="integer" value="50000000" label="chunk size"/>
				<param name="compression" type="select" optional="true" label="Compression type">
					<option value="gzip">gzip</option>
					<option value="zstandard">zstandard</option>
				</param>
				<param name="compression_level" type="integer" value="" optional="true" label="Compression level" help="1-9 for gzip, 1-22 for zstandard"/>
			</when>
			<when value="pp.import_data">
				<param name="fragment_file" type="data" format="interval,bed" optional="false" label="Fragment file, optionally compressed with gzip or zstd" />				<param name="chrom_sizes" type="data" format="tabular" optional="false" label="A tabular file containing chromosome names and sizes"/>
				<param name="min_num_fragments" type="integer" value="200" label="Number of unique fragments threshold used to filter cells"/>
				<param name="sorted_by_barcode" type="boolean" checked="true" truevalue="True" falsevalue="False" label="Whether the fragment file has been sorted by cell barcodes"/>
				<param name="whitelist" type="data" format="txt" optional="True" label="Whitelist file with a list of barcodes" 
					help="Each line must contain a valid barcode. When provided, only barcodes in the whitelist will be retained."/>
				<param name="shift_left" type="integer" value="0" label="Insertion site correction for the left end" help="Note this has no effect on single-end reads"/>
    			<param name="shift_right" type="integer" value="0" label="Insertion site correction for the right end" help="Note this has no effect on single-end reads"/>
				<param name="chrM" type="text" value="chrM, M" optional="false" label="A list of chromosome names that are considered mitochondrial DNA">
					<expand macro="sanitize_query"/>
				</param>
				<param name="chunk_size" type="integer" value="2000" label="chunk size"/>
				<expand macro="backend"/>
			</when>
			<when value="pp.add_tile_matrix">
				<expand macro="inputs_anndata"/>
				<param name="bin_size" type="integer" value="500" label="The size of consecutive genomic regions used to record the counts"/>
				<expand macro="inplace"/>
				<expand macro="chunk_size"/>
				<param name="exclude_chroms" type="text" value="['chrM', 'chrY', 'M', 'Y']" optional="true" label=" A list of chromosomes to exclude">
					<expand macro="sanitize_query"/>
				</param>
				<expand macro="min_max_frag_size"/>
				<param name="count_frag_as_reads" type="boolean" checked="true" label="Whether to count fragments as reads"/>
				<param name="file" type="text" value="" optional="true" label="File name of the output h5ad file used to store the result"/>
				<expand macro="backend"/>
			</when>
			<when value="pp.make_peak_matrix">
				<expand macro="inputs_anndata"/>
				<param name="use_rep" type="text" value="" optional="true" label="Used to read peak information from .uns[use_rep]">
					<expand macro="sanitize_query"/>
				</param>
				<expand macro="inplace"/>
				<param name="file" type="text" value="" optional="true" label=" File name of the output h5ad file used to store the result"/>
				<expand macro="backend"/>
				<param name="peak_file" type="text" value="" optional="true" label="Bed file containing the peaks"/>
				<expand macro="chunk_size"/>
				<param name="use_x" type="boolean" checked="false" label="If True, use the matrix stored in .X as raw counts"/>
				<expand macro="min_max_frag_size"/>
				<param name="count_frag_as_reads" type="boolean" checked="true" label="Whether to count fragments as reads"/>
			</when>
			<when value="pp.make_gene_matrix">
				<expand macro="inputs_anndata"/>
				<param name="gene_anno" type="text" value="" optional="false" label="Either a Genome object or the path of a gene annotation file in GFF or GTF format"/>
				<expand macro="inplace"/>
				<param name="file" type="text" value="" optional="true" label=" File name of the output h5ad file used to store the result"/>
				<param name="backend" type="select" optional="true" label="The backend">
    				<option value="hdf5" selected="true">hdf5</option>
    			</param>
				<expand macro="chunk_size"/>
				<param name="use_x" type="boolean" checked="false" label="If True, use the matrix stored in .X as raw counts"/>
				<param name="id_type" type="select" label="“gene” or “transcript”">
					<option value="gene">gene</option>
					<option value="transcript">transcript</option>
				</param>
				<param name="transcript_name_key" type="text" value="transcript_name" optional="false" label="The key of the transcript name in the gene annotation file"/>
				<param name="transcript_id_key" type="text"	value="transcript_id" optional="false" label="The key of the transcript id in the gene annotation file"/>
				<param name="gene_name_key" type="text" value="gene_name" optional="false" label="The key of the gene name in the gene annotation file"/>
				<param name="gene_id_key" type="text" value="gene_id" optional="false" label="The key of the gene id in the gene annotation file"/>
				<expand macro="min_max_frag_size"/>
				<param name="count_frag_as_reads" type="boolean" checked="true" label="Whether to count fragments as reads"/>			
			</when>
			<when value="pp.filter_cells">
				<expand macro="inputs_anndata"/>
				<param name="min_counts" type="integer" value="" optional="true" label="Minimum number of counts required for a cell to pass filtering"/>
				<param name="min_tsse" type="float" value="" optional="true" label="Minimum TSS enrichemnt score required for a cell to pass filtering"/>
				<param name="max_counts" type="integer" value="" optional="true" label="Maximum number of counts required for a cell to pass filtering"/>
				<param name="max_tsse" type="float" value="" optional="true" label="Maximum TSS enrichment score expressed required for a cell to pass filtering"/>
				<expand macro="inplace"/>
			</when>
			<when value="pp.select_features">
				<expand macro="inputs_anndata"/>
				<param name="n_features" type="integer" value="500000" label="Number of features to keep"/>
				<param name="filter_lower_quantile" type="float" value="0.005" label="Lower quantile of the feature count distribution to filter out"/>
				<param name="filter_upper_quantile" type="float" value="0.005" label="Upper quantile of the feature count distribution to filter out"/>
				<param name="whitelist" type="text" value="" optional="true" label="A user provided bed file containing genome-wide whitelist regions"/>
				<param name="blacklist" type="text" value="" optional="true" label="A user provided bed file containing genome-wide blacklist regions"/>
				<param name="max_iter" type="integer" value="1" label="If greater than 1, this function will perform iterative clustering and feature selection"/>
				<expand macro="inplace"/>
				<expand macro="verbose"/>
			</when>
			<when value="pp.knn">
				<expand macro="inputs_anndata"/>
				<param name="n_neighbors" type="integer" value="50" label="The number of nearest neighbors to be searched"/>
				<param name="use_dims" type="text" value="" optional="true" label="The dimensions used for computation">
					<expand macro="sanitize_query"/>
				</param>
				<param name="use_rep" type="text" value="X_spectral" optional="false" label="The key for the matrix"/>
				<param name="method" type="select" label="Choose method">
					<option value="kdtree">kdtree</option>
					<option value="hora">hora</option>
					<option value="pynndescent">pynndescent</option>
				</param>
				<expand macro="inplace"/>
				<param name="random_state" type="integer" value="0" label="Random seed for approximate nearest neighbor search"/>
			</when>
			<when value="pp.scrublet">
				<expand macro="inputs_anndata"/>
				<param name="features" type="text" optional="true" label=" Boolean index mask, where True means that the feature is kept, and False means the feature is removed."/>
				<param name="n_comps" type="integer" value="15" label="Number of components"/>
				<param name="sim_doublet_ratio" type="float" value="2.0" label="Number of doublets to simulate relative to the number of observed cells"/>
				<param name="expected_doublet_rate" type="float" value="0.1" label="Expected doublet rate"/>
				<param name="n_neighbors" type="integer" optional="true" label="Number of neighbors used to construct the KNN graph of observed cells and simulated doublets"/>
				<param name="use_approx_neighbors" type="boolean" checked="false" label="Whether to use approximate search"/>
				<param name="random_state" type="integer" value="0" label="Random state"/>
				<expand macro="inplace"/>
				<expand macro="verbose"/>
			</when>
			<when value="pp.filter_doublets">
				<expand macro="inputs_anndata"/>
				<param name="probability_threshold" type="float" optional="true" label="Threshold for doublet probability"/>
				<param name="score_threshold" type="float" optional="true" label=" Threshold for doublet score"/>
				<expand macro="inplace"/>
				<expand macro="verbose"/>
			</when>
			<when value="pp.mnc_correct">
				<expand macro="inputs_anndata"/>
				<param name="batch" type="text" optional="false" label="Batch labels for cells">
					<expand macro="sanitize_query"/>
				</param>
				<param name="n_neighbors" type="integer" value="5" label="Number of mutual nearest neighbors"/>
				<param name="n_cluster" type="integer" value="40" label="Number of clusters"/>
				<param name="n_iter" type="integer" value="1" label="Number of iterations"/>
				<expand macro="data_integration"/>
				<expand macro="inplace"/>
			</when>
			<when value="pp.harmony">
				<expand macro="inputs_anndata"/>
				<param name="batch" type="text" optional="false" label="Batch labels for cells">
					<expand macro="sanitize_query"/>
				</param>
				<expand macro="data_integration"/>
				<expand macro="inplace"/>
			</when>
			<when value="pp.scanorama_integrate">
				<expand macro="inputs_anndata"/>
				<param name="batch" type="text" optional="false" label="Batch labels for cells">
					<expand macro="sanitize_query"/>
				</param>
				<param name="n_neighbors" type="integer" value="20" label="Number of mutual nearest neighbors"/>
				<expand macro="data_integration"/>
				<expand macro="inplace"/>
			</when>
		</conditional>
		<expand macro="inputs_common_advanced"/>
    </inputs>
    <outputs>
    	<data name="anndata_out" format="h5ad" from_work_dir="anndata.h5ad" label="${tool.name} (${method.method}) on ${on_string}: Annotated data matrix"/>
		<data name="hidden_output" format="txt" label="Log file" >
            <filter>advanced_common['show_log']</filter>
        </data>
    </outputs>
    <tests>
		<test expect_num_outputs="2">
		<!-- test 1: pp.make_fragment_file -->
		    <conditional name="method">
		        <param name="method" value="pp.make_fragment_file"/>
		        <param name="bam_file" value="test_file.bam"/>
		        <param name="output_file" value="pp.make_fragment_file.h5ad"/>
		        <param name="is_paired" value="True"/>
		        <param name="shift_left" value="4"/>
		        <param name="shift_right" value="-5"/>
		        <param name="chunk_size" value="50000000"/>
	  		</conditional>
		    <section name="advanced_common">
		        <param name="show_log" value="true" />
		    </section>
		    <output name="hidden_output">
                <assert_contents>
                    <has_text_matching expression="sa.pp.make_fragment_file"/>
                    <has_text_matching expression="is_paired=True"/>
                    <has_text_matching expression="shift_left=4"/>
                    <has_text_matching expression="shift_right=-5"/>
                    <has_text_matching expression="chunk_size=50000000"/>
                </assert_contents>
            </output>
		</test>
		<test expect_num_outputs="2">
		<!-- test 2: pp.pp.import_data -->
		    <conditional name="method">
		        <param name="method" value="pp.import_data"/>
		        <param name="fragment_file" value="pbmc_500_chr21.tsv.gz"/>
		        <param name="chrom_sizes" value="chr21_size.tabular"/>
		        <param name="min_num_fragments" value="200"/>
		        <param name="sorted_by_barcode" value="False"/>
		        <param name="shift_left" value="0"/>
		        <param name="chrM" value="chrM, M"/>
		        <param name="shift_right" value="0"/>
		        <param name="chunk_size" value="2000"/>
		        <param name="backend" value="hdf5"/>
	  		</conditional>
		    <section name="advanced_common">
		        <param name="show_log" value="true" />
		    </section>
		    <output name="hidden_output">
                <assert_contents>
                    <has_text_matching expression="sa.pp.import_data"/>
                    <has_text_matching expression="min_num_fragments = 200"/>
                    <has_text_matching expression="sorted_by_barcode = False"/>
                    <has_text_matching expression="shift_left = 0"/>
                    <has_text_matching expression="chrM = \['chrM', 'M'\]"/>
                    <has_text_matching expression="shift_right = 0"/>
                    <has_text_matching expression="chunk_size = 2000"/>
                </assert_contents>
            </output>
			<output name="anndata_out" file="pp.import_data.pbmc_500_chr21.h5ad" ftype="h5ad" compare="sim_size" delta_frac="0.1" />
		</test>
		<test expect_num_outputs="2">
		<!-- test 3: pp.add_tile_matrix -->
		    <conditional name="method">
		        <param name="method" value="pp.add_tile_matrix"/>
		        <param name="adata" value="pbmc_500_chr21.h5ad"/>
		        <param name="bin_size" value="500"/>
		        <param name="inplace" value="True"/>
		        <param name="chunk_size" value="500"/>
		        <param name="count_frag_as_reads" value="True"/>
		        <param name="backend" value="hdf5"/>
	  		</conditional>
		    <section name="advanced_common">
		        <param name="show_log" value="true" />
		    </section>
		    <output name="hidden_output">
                <assert_contents>
                    <has_text_matching expression="sa.pp.add_tile_matrix"/>
                    <has_text_matching expression="bin_size=500"/>
                    <has_text_matching expression="inplace=True"/>
                    <has_text_matching expression="chunk_size=500"/>
                    <has_text_matching expression="count_frag_as_reads=True"/>
                </assert_contents>
            </output>
		</test>
		<test expect_num_outputs="2">
		<!-- test 4: pp.make_peak_matrix -->
		    <conditional name="method">
		        <param name="method" value="pp.make_peak_matrix"/>
		        <param name="adata" value="pbmc_500_chr21.h5ad"/>
		        <param name="inplace" value="False"/>
		        <param name="backend" value="hdf5"/>
		        <param name="chunk_size" value="500"/>
		        <param name="use_x" value="False"/>
		        <param name="count_frag_as_reads" value="True"/>
	  		</conditional>
		    <section name="advanced_common">
		        <param name="show_log" value="true" />
		    </section>
		    <output name="hidden_output">
                <assert_contents>
                    <has_text_matching expression="sa.pp.make_peak_matrix"/>
                    <has_text_matching expression="inplace=False"/>
                    <has_text_matching expression="backend='hdf5'"/>
                    <has_text_matching expression="chunk_size=500"/>
                    <has_text_matching expression="use_x=False"/>
                    <has_text_matching expression="count_frag_as_reads=True"/>
                </assert_contents>
            </output>
		</test>
		<test expect_num_outputs="2">
		<!-- test 5: pp.make_gene_matrix -->
		    <conditional name="method">
		        <param name="method" value="pp.make_gene_matrix"/>
		        <param name="adata" value="pbmc_500_chr21.h5ad"/>
		        <param name="gene_anno" value="sa.genome.hg38"/>
		        <param name="inplace" value="False"/>
		        <param name="chunk_size" value="500"/>
		        <param name="use_x" value="False"/>
		        <param name="id_type" value="gene"/>
		        <param name="transcript_name_key" value="transcript_name"/>
		        <param name="transcript_id_key" value="transcript_id"/>
		        <param name="gene_name_key" value="gene_name"/>
		        <param name="gene_id_key" value="gene_id"/>
		        <param name="count_frag_as_reads" value="True"/>
	  		</conditional>
		    <section name="advanced_common">
		        <param name="show_log" value="true" />
		    </section>
		    <output name="hidden_output">
                <assert_contents>
                    <has_text_matching expression="sa.pp.make_gene_matrix"/>
                    <has_text_matching expression="inplace=False"/>
                    <has_text_matching expression="chunk_size=500"/>
                    <has_text_matching expression="use_x=False"/>
                    <has_text_matching expression="id_type='gene'"/>
                    <has_text_matching expression="transcript_name_key='transcript_name'"/>
                    <has_text_matching expression="transcript_id_key='transcript_id'"/>
                    <has_text_matching expression="gene_name_key='gene_name'"/>
                    <has_text_matching expression="gene_id_key='gene_id'"/>
                    <has_text_matching expression="count_frag_as_reads=True"/>
                </assert_contents>
            </output>
		</test>
		<test expect_num_outputs="2">
		<!-- test 6: pp.filter_cells -->
		    <conditional name="method">
		        <param name="method" value="pp.filter_cells"/>
		        <param name="adata" value="pbmc_500_chr21.h5ad"/>
		        <param name="inplace" value="True"/>
	  		</conditional>
		    <section name="advanced_common">
		        <param name="show_log" value="true" />
		    </section>
		    <output name="hidden_output">
                <assert_contents>
                    <has_text_matching expression="sa.pp.filter_cells"/>
                    <has_text_matching expression="inplace=True"/>
                </assert_contents>
            </output>
		</test>
		<test expect_num_outputs="2">
		<!-- test 7: pp.select_features -->
		    <conditional name="method">
		        <param name="method" value="pp.select_features"/>
		        <param name="adata" value="pbmc_500_chr21.h5ad"/>
		        <param name="n_features" value="500000"/>
		        <param name="filter_lower_quantile" value="0.005"/>
		        <param name="filter_upper_quantile" value="0.005"/>
		        <param name="max_iter" value="1"/>
		        <param name="inplace" value="True"/>
		        <param name="verbose" value="True"/>
	  		</conditional>
		    <section name="advanced_common">
		        <param name="show_log" value="true" />
		    </section>
		    <output name="hidden_output">
                <assert_contents>
                    <has_text_matching expression="sa.pp.select_features"/>
                    <has_text_matching expression="n_features=500000"/>
                    <has_text_matching expression="filter_lower_quantile=0.005"/>
                    <has_text_matching expression="filter_upper_quantile=0.005"/>
                    <has_text_matching expression="max_iter=1"/>
                    <has_text_matching expression="inplace=True"/>
                    <has_text_matching expression="verbose=True"/>
                </assert_contents>
            </output>
		</test>
		<test expect_num_outputs="2">
		<!-- test 8: pp.knn -->
		    <conditional name="method">
		        <param name="method" value="pp.knn"/>
		        <param name="adata" value="pbmc_500_chr21.h5ad"/>
		        <param name="n_neighbors" value="50"/>
		        <param name="use_rep" value="X_spectral"/>
		        <param name="method" value="kdtree"/>
		        <param name="inplace" value="True"/>
		        <param name="random_state" value="0"/>
	  		</conditional>
		    <section name="advanced_common">
		        <param name="show_log" value="true" />
		    </section>
		    <output name="hidden_output">
                <assert_contents>
                    <has_text_matching expression="sa.pp.knn"/>
                    <has_text_matching expression="n_neighbors=50"/>
                    <has_text_matching expression="use_rep='X_spectral'"/>
                    <has_text_matching expression="method='kdtree'"/>
                    <has_text_matching expression="inplace=True"/>
                    <has_text_matching expression="random_state=0"/>
                </assert_contents>
            </output>
		</test>
		<test expect_num_outputs="2">
		<!-- test 9: pp.scrublet -->
		    <conditional name="method">
		        <param name="method" value="pp.scrublet"/>
		        <param name="adata" value="pbmc_500_chr21.h5ad"/>
		        <param name="n_comps" value="15"/>
		        <param name="sim_doublet_ratio" value="2.0"/>
		        <param name="expected_doubelt_ratio" value="0.1"/>
		        <param name="random_state" value="0"/>
		        <param name="verbose" value="True"/>
	  		</conditional>
		    <section name="advanced_common">
		        <param name="show_log" value="true" />
		    </section>
		    <output name="hidden_output">
                <assert_contents>
                    <has_text_matching expression="sa.pp.scrublet"/>
                    <has_text_matching expression="n_comps=15"/>
                    <has_text_matching expression="sim_doublet_ratio=2.0"/>
                    <has_text_matching expression="expected_doubelt_ratio=0.1"/>
                    <has_text_matching expression="random_state=0"/>
                    <has_text_matching expression="verbose=True"/>
                </assert_contents>
            </output>
		</test>
		<test expect_num_outputs="2">
		<!-- test 10: pp.filter_doublets -->
		    <conditional name="method">
		        <param name="method" value="pp.filter_doublets"/>
		        <param name="adata" value="pbmc_500_chr21.h5ad"/>
		        <param name="inplace" value="True"/>
		        <param name="verbose" value="True"/>
	  		</conditional>
		    <section name="advanced_common">
		        <param name="show_log" value="true" />
		    </section>
		    <output name="hidden_output">
                <assert_contents>
                    <has_text_matching expression="sa.pp.filter_doublets"/>
                    <has_text_matching expression="inplace=True"/>
                    <has_text_matching expression="verbose=True"/>
                </assert_contents>
            </output>
		</test>
		<test expect_num_outputs="2">
		<!-- test 11: pp.mnc_correct -->
		    <conditional name="method">
		        <param name="method" value="pp.mnc_correct"/>
		        <param name="adata" value="pbmc_500_chr21.h5ad"/>
		        <param name="batch" value="sample"/>
		        <param name="n_neighbors" value="5"/>
		        <param name="n_cluster" value="40"/>
		        <param name="n_iter" value="1"/>
		        <param name="use_rep" value="X_spectral"/>
		        <param name="inplace" value="True"/>
	  		</conditional>
		    <section name="advanced_common">
		        <param name="show_log" value="true" />
		    </section>
		    <output name="hidden_output">
                <assert_contents>
                    <has_text_matching expression="sa.pp.mnc_correct"/>
                    <has_text_matching expression="batch='sample'"/>
                    <has_text_matching expression="n_neighbors=5"/>
                    <has_text_matching expression="n_cluster=40"/>
                    <has_text_matching expression="n_iter=1"/>
                    <has_text_matching expression="use_rep='X_spectral'"/>
                    <has_text_matching expression="inplace=True"/>
                </assert_contents>
            </output>
		</test>
		<test expect_num_outputs="2">
		<!-- test 12: pp.harmony -->
		    <conditional name="method">
		        <param name="method" value="pp.harmony"/>
		        <param name="adata" value="pbmc_500_chr21.h5ad"/>
		        <param name="batch" value="sample"/>
		        <param name="use_rep" value="X_spectral"/>
		        <param name="inplace" value="True"/>
	  		</conditional>
		    <section name="advanced_common">
		        <param name="show_log" value="true" />
		    </section>
		    <output name="hidden_output">
                <assert_contents>
                    <has_text_matching expression="sa.pp.harmony"/>
                    <has_text_matching expression="batch='sample'"/>
                    <has_text_matching expression="use_rep='X_spectral'"/>
                    <has_text_matching expression="inplace=True"/>
                </assert_contents>
            </output>
		</test>
		<test expect_num_outputs="2">
		<!-- test 13: pp.scanorama_integrate -->
		    <conditional name="method">
		        <param name="method" value="pp.scanorama_integrate"/>
		        <param name="adata" value="pbmc_500_chr21.h5ad"/>
		        <param name="batch" value="'sample'"/>
		        <param name="n_neighbors" value="20"/>
		        <param name="use_rep" value="'X_spectral'"/>
		        <param name="inplace" value="True"/>
	  		</conditional>
		    <section name="advanced_common">
		        <param name="show_log" value="true" />
		    </section>
		    <output name="hidden_output">
                <assert_contents>
                    <has_text_matching expression="sa.pp.scanorama_integrate"/>
                    <has_text_matching expression="batch='sample'"/>
                    <has_text_matching expression="n_neighbors=20"/>
                    <has_text_matching expression="use_rep='X_spectral'"/>
                    <has_text_matching expression="inplace=True"/>
                </assert_contents>
            </output>
		</test>

	</tests>
    <help><![CDATA[
    SnapATAC2 preprocessing functions
    ]]></help>
    <expand macro="citations"/>
</tool>

