<tool id="snapatac2_tools" name="Tools" version="@TOOL_VERSION@+galaxy@VERSION_SUFFIX@">
    <description>with snapatac2</description>
    <macros>
        <import>macros.xml</import>
    </macros>
    <requirements>
    	<expand macro="requirements"/>
    </requirements>
    <command detect_errors="exit_code"><![CDATA[
@CMD@
    ]]></command>
	<configfiles>
        <configfile name="script_file"><![CDATA[

@CMD_imports@
@CMD_read_inputs@

#if $method.method == 'tl.spectral'
sa.tl.spectral(
	adata = '$method.adata',
	n_comps = $method.n_comps,
	features = '$method.features',
	random_state = $method.random_state,
	sample_size = $method.sample_size,
	chunk_size = $method.chunk_size,
	distance_metric = '$method.distance_metric',
	weighted_by_sd = $method.weighted_by_sd,
	feature_weights = $method.feature_weights,
	inplace = $method.inplace
)
#else if $method.method == 'tl.multi_spectral'
sa.tl.multi_spectral(
	adatas = '$method.adata',
	n_comps = $method.n_comps,
	features = '$method.features',
	weights = $method.weights,
	random_state = $method.random_state,
	weighted_by_sd = $method.weighted_by_sd
)

#else if $method.method == 'tl.umap'
sa.tl.umap(
	adata = '$method.adata',
	n_comps = $method.n_comps,
	use_dims = $method.use_dims,
	use_rep = '$method.use_rep',
	key_added = '$method.key_added',
	random_state = $method.random_state,
	inplace = $method.inplace
)

#else if $method.method == 'tl.leiden'
sa.tl.leiden(
	adata = '$method.adata',
	resolution = $method.resolution,
	objective_function = '$method.objective_function',
	min_cluster_size = $method.min_cluster_size,
	n_iterations = $method.n_iterations,
	random_state = $method.random_state,
	key_added = '$method.key_added',
	use_leidenalg = $method.use_leidenalg,
	weighted = $method.weighted,
	inplace = $method.inplace
)

#else if $method.method == 'tl.kmeans'
sa.tl.kmeans(
	adata = '$method.adata',
	n_clusters = $method.n_clusters,
	n_iterations = $method.n_iterations,
	random_state = $method.random_state,
	use_rep = '$method.use_rep',
	key_added = '$method.key_added'
)

#else if $method.method == 'tl.dbscan'
sa.tl.dbscan(
	adata = '$method.adata',
	eps = $method.eps,
	min_samples = $method.min_samples,
	leaf_size = $method.leaf_size,
	use_rep = '$method.use_rep',
	key_added = '$method.key_added'
)

#else if $method.method == 'tl.hdbscan'
sa.tl.hdbscan(
	adata = '$method.adata',
	min_cluster_size = $method.min_cluster_size,
	min_samples = $method.min_samples,
	cluster_selection_epsilon = $method.cluster_selection_epsilon,
	alpha = $method.alpha,
	cluster_selection_method = '$method.cluster_selection_method',
	random_state = $method.random_state,
	use_rep = '$method.use_rep',
	key_added = '$method.key_added'
)

#else if $method.method == 'tl.macs3'
sa.tl.macs3(
	adata = '$method.adata',
	groupby = '$method.groupby',
	qvalue = $method.qvalue,
	replicate = '$method.replicate',
	replicate_qvalue = $method.replicate_qvalue,
	max_frag_size = $method.max_frag_size,
	selections = '$method.selections',
	nolambda = $method.nolambda,
	shift = $method.shift,
	extsize = $method.extsize,
	blacklist = '$method.blacklist',
	key_added = '$method.key_added',
	tempdir = '$method.tempdir',
	inplace = $method.inplace,
)

#else if $method.method == 'tl.merge_peaks'
sa.tl.merge_peaks(
	peaks = '$method.peaks',
	chrom_sizes = '$method.chrom_sizes',
	half_width = $method.half_width
)

#else if $method.method == 'tl.marker_regions'
sa.tl.marker_regions(
	data = '$method.adata',
	groupby = '$method.groupby',
	pvalue = $method.pvalue
)

#else if $method.method == 'tl.diff_test'
sa.tl.diff_test(
	data = '$method.adata',
	cell_group1 = '$method.cell_group1',
	cell_group2 = '$method.cell_group2',
	features = '$method.features',
	covariates = '$method.covariates',
	direction = '$method.direction',
	min_log_fc = $method.min_log_fc,
	min_pct = $method.min_pct
)

#else if $method.method == 'tl.motif_enrichment'
sa.tl.motif_enrichment(
	motifs = '$method.motifs',
	regions = '$method.regions',
	genome_fasta = '$method.genome_fasta',
	background = '$method.background',
	method = '$method.test_method'
)

#else if $method.method == 'tl.init_network_from_annotation'
sa.tl.init_network_from_annotation(
	regions = '$method.regions',
	anno_file = '$method.anno_file',
	upstream = $method.upstream,
	downstream = $method.downstream,
	id_type = '$method.id_type',
	coding_gene_only = $method.coding_gene_only
)

#else if $method.method == 'tl.add_cor_scores'
sa.tl.add_cor_scores(
	network = '$method.network',
	gene_mat = '$method.gene_mat',
	peak_mat = '$method.peak_mat',
	select = '$method.select_genes',
	overwrite = $method.overwrite
)

#else if $method.method == 'tl.add_regr_scores'
sa.tl.add_regr_scores(
	network = '$method.network',
	peak_mat = '$method.peak_mat',
	gene_mat = '$method.gene_mat',
	select = '$method.select_genes',
	method = '$method.regresson_model',
	scale_X = $method.scale_X,
	scale_Y = $method.scale_Y,
	alpha = $method.alpha,
	l1_ratio = $method.l1_ratio,
	use_gpu = $method.use_gpu,
	overwrite = $method.overwrite
)

#else if $method.method == 'tl.add_tf_binding'
sa.tl.add_tf_binding(
	network = '$method.network',
	motifs = '$method.motifs',
	genome_fasta = '$method.genome_fasta',
	pvalue = $method.pvalue
)

#else if $method.method == 'tl.link_tf_to_gene'
sa.tl.link_tf_to_gene(
	network = '$method.network'
)

#else if $method.method == 'tl.prune_network'
sa.tl.prune_network(
	network = '$method.network',
	node_filter = '$method.node_filter',
	edge_filter = '$method.edge_filter',
	remove_isolates = $method.remove_isolates
)

#else if $method.method == 'tl.aggregate_X'
sa.tl.aggregate_X(
	adata = '$method.adata',
	groupby = '$method.groupby',
	normalize = '$method.normalize',
	file = '$method.file'
)

#else if $method.method == 'tl.aggregate_cells'
sa.tl.aggregate_cells(
	adata = '$method.adata',
	use_rep = '$method.use_rep',
	target_num_cells = $method.target_num_cells,
	min_cluster_size = $method.min_cluster_size,
	random_state = $method.random_state,
	key_added = '$method.gene_id_key',
	inplace = $method.inplace
)

#end if

@CMD_anndata_write_outputs@
	]]></configfile>
	</configfiles>
    <inputs>
		<conditional name="method">
			<param name="method" type="select" label="Tool">
				<option value="tl.spectral">Perform dimension reduction using Laplacian Eigenmap, using tl.spectral</option>
				<option value="tl.multi_spectral">Compute Laplacian Eigenmaps simultaneously on multiple modalities, using tl.multi_spectral</option>
				<option value="tl.umap">Compute Umap, using tl.umap</option>
				<option value="tl.leiden">Cluster cells into subgroups [Traag18], using tl.leiden</option>
				<option value="tl.kmeans">Cluster cells into subgroups using the K-means algorithm, a classical algorithm in data mining, using tl.kmeans</option>
				<option value="tl.dbscan">Cluster cells into subgroups using the DBSCAN algorithm, using tl.dbscan</option>
				<option value="tl.hdbscan">Cluster cells into subgroups using the HDBSCAN algorithm, using tl.hdbscan</option>
				<option value="tl.macs3">Call peaks using MACS3, using tl.macs3</option>
				<option value="tl.merge_peaks">Merge peaks from different groups, using tl.merge_peaks</option>
				<option value="tl.marker_regions">A quick-and-dirty way to get marker regions, using tl.marker_regions</option>
				<option value="tl.diff_test">Identify differentially accessible regions,using tl.diff_test</option>
				<option value="tl.motif_enrichment">Identify enriched transcription factor motifs, using tl.motif_enrichment</option>
				<option value="tl.init_network_from_annotation">Build CRE-gene network from gene annotations, using tl.init_network_from_annotation</option>
				<option value="tl.add_cor_scores">Compute correlation scores for any two connected nodes in the network, using tl.add_cor_scores</option>
				<option value="tl.add_regr_scores">Perform regression analysis for nodes and their parents in the network, using tl.add_regr_scores</option>
				<option value="tl.add_tf_binding">Add TF motif binding information, using tl.add_tf_binding</option>
				<option value="tl.link_tf_to_gene">Contruct a genetic network by linking TFs to target genes, using tl.link_tf_to_gene</option>
				<option value="tl.prune_network">Prune the network, using tl.prune_network</option>
				<option value="tl.aggregate_X">Aggregate values in adata.X in a row-wise fashion, using tl.aggregate_X</option>
				<option value="tl.aggregate_cells">Aggregate cells into pseudo-cells, using tl.aggregate_cells</option>
			</param>
			<when value="tl.spectral">
				<expand macro="inputs_anndata"/>
				<expand macro="n_comps"/>
				<param name="features" type="text" optional="true" label="Boolean index mask" help="True means that the feature is kept. False means the feature is removed"/>
				<expand macro="random_state"/>
				<param name="sample_size" type="float" optional="true" label="Approximate the embedding using the Nystrom algorithm by selecting a subset of cells"/>
				<param name="chunk_size" type="integer" value="20000" label="chunk size"/>
				<param name="distance_metric" type="select" label="distance metric: “jaccard”, “cosine“">
					<option value="jaccard">jaccard</option>
					<option value="cosine">cosine</option>
				</param>
				<expand macro="weighted_by_sd"/>
				<param name="feature_weights" type="text" value="" optional="true" label="Feature weights used in the distance metric">
					<expand macro="sanitize_query"/>
				</param>
				<expand macro="inplace"/>
			</when>
			<when value="tl.multi_spectral">
				<expand macro="inputs_anndata"/>
				<expand macro="n_comps"/>
				<param name="features" type="text" optional="true" label="Boolean index mask" help="Boolean index mask. True means that the feature is kept.">
					<expand macro="sanitize_query"/>
				</param>
				<param name="weights" type="text" optional="true" label="Weights for each modality">
					<expand macro="sanitize_query"/>
				</param>
				<expand macro="random_state"/>
				<expand macro="weighted_by_sd"/>
			</when>
			<when value="tl.umap">
				<expand macro="inputs_anndata"/>
				<param name="n_comps" type="integer" value="2" label="Number of dimensions to keep"/>
				<expand macro="use"/>
				<param name="key_added" type="text" value="umap" optional="false" label="adata.obs key under which to add the cluster labels"/>
				<expand macro="random_state"/>
				<expand macro="inplace"/>
			</when>
			<when value="tl.leiden">
				<expand macro="inputs_anndata"/>
				<param name="resolution" type="float" value="1" label="resolution" help="parameter value controlling the coarseness of the clustering"/>
				<param name="objective_function" type="select" label=" whether to use the Constant Potts Model (CPM) or modularity. Must be either “CPM”, “modularity” or “RBConfiguration”">
					<option value="CPM">CPM</option>
					<option value="modularity">modularity</option>
					<option value="RBConfiguration">RBConfiguration</option>
				</param>
				<param name="min_cluster_size" type="integer" value="5" label="The minimum size of clusters"/>
				<param name="n_iterations" type="integer" value="-1" label="How many iterations of the Leiden clustering algorithm to perform"/>
				<expand macro="random_state"/>
				<param name="key_added" type="text" value="leiden" optional="false" label="adata.obs key under which to add the cluster labels"/>
				<param name="use_leidenalg" type="boolean" label="If True, leidenalg package is used"/>
				<param name="weighted" type="boolean" label="Whether to use the edge weights in the graph"/>
				<expand macro="inplace"/>
			</when>
			<when value="tl.kmeans">
				<expand macro="inputs_anndata"/>
				<param name="n_clusters" type="integer" label="Number of clusters to return"/>
				<param name="n_iterations" type="integer" value="-1" label="How many iterations of the kmeans clustering algorithm to perform"/>
				<expand macro="random_state"/>
				<expand macro="use_rep"/>
				<param name="key_added" type="text" value="kmeans" optional="false" label="adata.obs key under which to add the cluster labels"/>
			</when>
			<when value="tl.dbscan">
				<expand macro="inputs_anndata"/>
				<param name="eps" type="float" value="0.5" label=" The maximum distance between two samples for one to be considered as in the neighborhood of the other"/>
				<param name="min_samples" type="integer" value="5" label="The number of samples (or total weight) in a neighborhood for a point to be considered as a core point."/>
				<param name="leaf_size" type="integer" value="30" label="Leaf size passed to BallTree or cKDTree"/>
				<expand macro="use_rep"/>
				<param name="key_added" type="text" value="dbscan" optional="false" label="adata.obs key under which to add the cluster labels"/>
			</when>
			<when value="tl.hdbscan">
				<expand macro="inputs_anndata"/>
				<param name="min_cluster_size" type="integer" value="5" label="The minimum size of clusters"/>
				<param name="min_samples" type="integer" optional="true" label="The number of samples in a neighbourhood for a point to be considered a core point"/>
				<param name="cluster_selection_epsilon" type="float" value="0.0" label="A distance threshold. Clusters below this value will be merged"/>
				<param name="alpha" type="float" value="1.0" label="A distance scaling parameter as used in robust single linkage"/>
				<param name="cluster_selection_method" type="select" label="The method used to select clusters from the condensed tree">
					<option value="eom">eom</option>
					<option value="leaf">leaf</option>
				</param>
				<expand macro="random_state"/>
				<expand macro="use_rep"/>
				<param name="key_added" type="text" value="hdbscan" optional="false" label="adata.obs key under which to add the cluster labels"/>
			</when>
			<when value="tl.macs3">
				<expand macro="inputs_anndata"/>
				<expand macro="param_groupby"/>
				<param name="qvalue" type="float" value="0.05" label="qvalue cutoff used in MACS3"/>
				<param name="replicate" type="text" optional="true" label="Replicate information.">
					<expand macro="sanitize_query"/>
				</param>
				<param name="replicate_qvalue" type="float" optional="true" label="qvalue cutoff used in MACS3 for calling peaks in replicates"/>
				<param name="max_frag_size" type="integer" optional="true" label="Maximum fragment size"/>
				<param name="selections" type="text" optional="true" label="Call peaks for the selected groups only">
					<expand macro="sanitize_query"/>
				</param>
				<param name="nolambda" type="boolean" label="If True, macs3 will use the background lambda as local lambda"/>
				<param name="shift" type="integer" value="-100" label="The shift size in MACS"/>
				<param name="extsize" type="integer" value="200" label="The extension size in MACS"/>
				<param name="blacklist" type="text" optional="true" label="Path to the blacklist file in BED format"/>
				<param name="key_added" type="text" value="macs3" optional="false" label="adata.obs key under which to add the cluster labels"/>
				<param name="tempdir" type="text" optional="true" label="If provided, a temporary directory will be created in the directory"/>
				<expand macro="inplace"/>
			</when>
			<when value="tl.merge_peaks">
				<param name="peaks" type="text" optional="false" label="Peak information from different groups"/>
				<param name="chrom_sizes" type="text" optional="false" label="Chromosome sizes"/>
				<param name="half_width" type="integer" value="250" label="Half width of the merged peaks"/>
			</when>
			<when value="tl.marker_regions">
				<expand macro="inputs_anndata"/>
				<expand macro="param_groupby"/>
				<param name="pvalue" type="float" value="0.01" label="P-value threshold"/>
			</when>
			<when value="tl.diff_test">
				<expand macro="inputs_anndata"/>
				<param name="cell_group1" type="text" optional="false" label="cells belonging to group 1">
					<expand macro="sanitize_query"/>
				</param>
				<param name="cell_group2" type="text" optional="false" label="cells belonging to group 2">
					<expand macro="sanitize_query"/>
				</param>
				<param name="features" type="text" optional="true" label="Features/peaks to test">
					<expand macro="sanitize_query"/>
				</param>
				<param name="covariates" type="text" optional="true" label="covariates"/>
				<param name="direction" type="select" label="“positive”: return features that are enriched in group 1. “negative”: return features that are enriched in group 2">
					<option value="positive">positive</option>
					<option value="negative">negative</option>
					<option value="both" selected="true">both</option>
				</param>
				<param name="min_log_fc" type="float" value="0.25" label="Limit testing to features which show, on average, at least X-fold difference (log2-scale) between the two groups of cells"/>
				<param name="min_pct" type="float" value="0.05" label="Only test features that are detected in a minimum fraction of min_pct cells in either of the two population"/>
			</when>
			<when value="tl.motif_enrichment">
				<param name="motifs" type="text" optional="false" label="A list of transcription factor motifs">
					<expand macro="sanitize_query"/>
				</param>
				<param name="regions" type="text" optional="false" label="Groups of regions"/>
				<expand macro="genome_fasta"/>
				<expand macro="background"/>
				<param name="test_method" type="select" optional="true" label="Statistical testing method: “binomial” or “hypergeometric">
					<option value="binomial">binomial</option>
					<option value="hypergeometric">hypergeometric</option>
				</param>
			</when>
			<when value="tl.init_network_from_annotation">
				<param name="regions" type="text" optional="false" label="A list of peaks/regions">
					<expand macro="sanitize_query"/>
				</param>
				<param name="anno_file" type="text" optional="false" label="The GFF file containing the transcript level annotations"/>
				<param name="upstream" type="integer" value="250000" label=" Upstream extension to the transcription start site"/>
				<param name="downstream" type="integer" value="250000" label="Downstream extension to the transcription start site"/>
				<param name="id_type" type="select" label="“gene_name”, “gene_id” or “transcript_id”">
					<option value="gene_name">gene_name</option>
					<option value="gene_id">gene_id</option>
					<option value="transcript_id">transcript_id</option>
				</param>
				<param name="coding_gene_only" type="boolean" checked="true" label="Retain only coding genes in the network"/>
			</when>
			<when value="tl.add_cor_scores">
				<expand macro="network"/>
				<expand macro="mat"/>
				<param name="select_genes" type="text" optional="true" label="Run this for selected genes only">
					<expand macro="sanitize_query"/>
				</param>
				<param name="overwrite" type="boolean" label="Whether to overwrite existing records"/>
			</when>
			<when value="tl.add_regr_scores">
				<expand macro="network"/>
				<expand macro="mat"/>
				<param name="select_genes" type="text" optional="true" label="Run this for selected genes only">
					<expand macro="sanitize_query"/>
				</param>
				<param name="regresson_model" type="select" optional="false" label="Regresson model">
					<option value="gb_tree">gb_tree</option>
					<option value="elastic_net" selected="true">elastic_net</option>
				</param>
				<param name="scale_X" type="boolean" label="Whether to scale the features"/>
				<param name="scale_Y" type="boolean" label="Whether to scale the response variable"/>
				<param name="alpha" type="float" value="1.0" label="Constant that multiplies the penalty terms in ‘elastic_net’"/>
				<param name="l1_ratio" type="float" value="0.5" label="ElasticNet mixing parameter"/>
				<param name="use_gpu" type="boolean" label="Whether to use gpu"/>
				<param name="overwrite" type="boolean" label="Whether to overwrite existing records"/>
			</when>
			<when value="tl.add_tf_binding">
				<expand macro="network"/>
				<param name="motifs" type="text" optional="false" label="TF motifs">
					<expand macro="sanitize_query"/>
				</param>
				<expand macro="genome_fasta"/>
				<param name="pvalue" type="float" value="1e-05" label="P-value threshold for motif binding"/>
			</when>
			<when value="tl.link_tf_to_gene">
				<expand macro="network"/>
			</when>
			<when value="tl.prune_network">
				<expand macro="network"/>
				<param name="node_filter" type="text" optional="false" label="Node filter function"/>
				<param name="edge_filter" type="text" optional="false" label="Edge filter function"/>
				<param name="remove_isolates" type="boolean" checked="true" label="Whether to remove isolated nodes"/>
			</when>
			<when value="tl.aggregate_X">
				<expand macro="inputs_anndata"/>
				<param argument="groupby" type="text" value="" optional="true" label="The key of the observation grouping to consider" help="If it is given, the plot is ordered by the respective group. It is expected that to be a categorical. If it is not a categorical observation, it would be subdivided into 'num_categories'.">
					<expand macro="sanitize_query" />
				</param>
				<param name="normalize" type="select" optional="true" label="normalization method: “RPM” or “RPKM”">
					<option value="RPM">RPM</option>
					<option value="RPKM">RPKM</option>
				</param>
				<param name="file" type="text" optional="true" label="Path: if provided, the results will be saved to a new h5ad file."/>
			</when>
			<when value="tl.aggregate_cells">
				<expand macro="inputs_anndata"/>
				<expand macro="use_rep"/>
				<param name="target_num_cells" type="integer" optional="true" label="target_num_cells"/>
				<param name="min_cluster_size" type="integer" value="50" label="The minimum size of clusters"/>
				<expand macro="random_state"/>
				<param name="key_added" type="text" value="pseudo_cell" optional="false" label="adata.obs key under which to add the cluster labels"/>
				<expand macro="inplace"/>
			</when> 
		</conditional>
		<expand macro="inputs_common_advanced"/>         
    </inputs>
    <outputs>
		<data name="anndata_out" format="h5ad" from_work_dir="anndata.h5ad" label="${tool.name} (${method.method}) on ${on_string}: Annotated data matrix"/>
            <data name="hidden_output" format="txt" label="Log file" >
            <filter>advanced_common['show_log']</filter>
        </data>
    </outputs>
    <tests>
		<test expect_num_outputs="2">
		<!-- test 1: tl.spectral -->
		    <conditional name="method">
		        <param name="method" value="tl.spectral"/>
		        <param name="adata" value="pbmc_500_chr21.h5ad"/>
		        <param name="random_state" value="0"/>
		        <param name="chunk_size" value="20000"/>
		        <param name="distance_metric" value="cosine"/>
		        <param name="weighted_by_sd" value="True"/>
		        <param name="inplace" value="True"/>
	  		</conditional>
		    <section name="advanced_common">
		        <param name="show_log" value="true" />
		    </section>
		    <output name="hidden_output">
                <assert_contents>
                    <has_text_matching expression="sa.tl.spectrale"/>
                    <has_text_matching expression="random_state=0"/>
                    <has_text_matching expression="chunk_size=20000"/>
                    <has_text_matching expression="distance_metric='cosine'"/>
                    <has_text_matching expression="weighted_by_sd=True"/>
                    <has_text_matching expression="inplace=True"/>
                </assert_contents>
            </output>
		</test>
		<test expect_num_outputs="2">
		<!-- test 2: tl.multi_spectral -->
		    <conditional name="method">
		        <param name="method" value="tl.multi_spectral"/>
		        <param name="adata" value="pbmc_500_chr21.h5ad"/>
		        <param name="n_comps" value="30"/>
		        <param name="random_state" value="0"/>
		        <param name="weighted_by_sd" value="True"/>
	  		</conditional>
		    <section name="advanced_common">
		        <param name="show_log" value="true" />
		    </section>
		    <output name="hidden_output">
                <assert_contents>
                    <has_text_matching expression="sa.tl.multi_spectral"/>
                    <has_text_matching expression="n_comps=30"/>
                    <has_text_matching expression="random_state=0"/>
                    <has_text_matching expression="weighted_by_sd=True"/>
                </assert_contents>
            </output>
		</test>
		<test expect_num_outputs="2">
		<!-- test 3: tl.umap -->
		    <conditional name="method">
		        <param name="method" value="tl.umap"/>
		        <param name="adata" value="pbmc_500_chr21.h5ad"/>
		        <param name="n_comps" value="2"/>
		        <param name="use_rep" value="X_spectral"/>
		        <param name="key_added" value="umap"/>
		        <param name="random_state" value="0"/>
		        <param name="inplace" value="True"/>
	  		</conditional>
		    <section name="advanced_common">
		        <param name="show_log" value="true" />
		    </section>
		    <output name="hidden_output">
                <assert_contents>
                    <has_text_matching expression="sa.tl.umap"/>
                    <has_text_matching expression="n_comps=2"/>
                    <has_text_matching expression="use_rep='X_spectral'"/>
                    <has_text_matching expression="key_added='umap'"/>
                    <has_text_matching expression="random_state=0"/>
                    <has_text_matching expression="inplace=True"/>
                </assert_contents>
            </output>
		</test>
		<test expect_num_outputs="2">
		<!-- test 4: tl.leiden -->
		    <conditional name="method">
		        <param name="method" value="tl.leiden"/>
		        <param name="adata" value="pbmc_500_chr21.h5ad"/>
		        <param name="resolution" value="1"/>
		        <param name="objective_function" value="modularity"/>
		        <param name="min_cluster_size" value="5"/>
		        <param name="n_iterations" value="-1"/>
		        <param name="random_state" value="0"/>
		        <param name="key_added" value="leiden"/>
		        <param name="use_leidenalg" value="False"/>
		        <param name="weighted" value="False"/>
		        <param name="inplace" value="True"/>
	  		</conditional>
		    <section name="advanced_common">
		        <param name="show_log" value="true" />
		    </section>
		    <output name="hidden_output">
                <assert_contents>
                    <has_text_matching expression="sa.tl.leiden"/>
                    <has_text_matching expression="resolution=1"/>
                    <has_text_matching expression="objective_function='modularity'"/>
                    <has_text_matching expression="min_cluster_size=5"/>
                    <has_text_matching expression="n_iterations=-1"/>
                    <has_text_matching expression="random_state=0"/>
                    <has_text_matching expression="key_added='leiden'"/>
                    <has_text_matching expression="use_leidenalg=False"/>
                    <has_text_matching expression="weighted=False"/>
                    <has_text_matching expression="inplace=True"/>
                </assert_contents>
            </output>
		</test>
		<test expect_num_outputs="2">
		<!-- test 5: tl.kmeans -->
		    <conditional name="method">
		        <param name="method" value="tl.kmeans"/>
		        <param name="adata" value="pbmc_500_chr21.h5ad"/>
		        <param name="n_clusters" value="7"/>
		        <param name="n_iterations" value="-1"/>
		        <param name="random_state" value="0"/>
		        <param name="use_rep" value="X_spectral"/>
		        <param name="key_added" value="kmeans"/>
	  		</conditional>
		    <section name="advanced_common">
		        <param name="show_log" value="true" />
		    </section>
		    <output name="hidden_output">
                <assert_contents>
                    <has_text_matching expression="sa.tl.kmeans"/>
                    <has_text_matching expression="n_cluster=7"/>
                    <has_text_matching expression="n_iterations=-1"/>
                    <has_text_matching expression="random_state=0"/>
                    <has_text_matching expression="use_rep='X_spectral'"/>
                    <has_text_matching expression="key_added='kmeans'"/>
                </assert_contents>
            </output>
		</test>
		<test expect_num_outputs="2">
		<!-- test 6: tl.dbscan -->
		    <conditional name="method">
		        <param name="method" value="tl.dbscan"/>
		        <param name="adata" value="pbmc_500_chr21.h5ad"/>
		        <param name="eps" value="0.5"/>
		        <param name="min_samples" value="5"/>
		        <param name="leaf_size" value="30"/>
		        <param name="use_rep" value="X_spectral"/>
		        <param name="key_added" value="dbscan"/>
	  		</conditional>
		    <section name="advanced_common">
		        <param name="show_log" value="true" />
		    </section>
		    <output name="hidden_output">
                <assert_contents>
                    <has_text_matching expression="sa.tl.dbscan"/>
                    <has_text_matching expression="eps=0.5"/>
                    <has_text_matching expression="min_samples=5"/>
                    <has_text_matching expression="leaf_size=30"/>
                    <has_text_matching expression="use_rep='X_spectral'"/>
                    <has_text_matching expression="key_added='dbscan'"/>
                </assert_contents>
            </output>
		</test>
		<test expect_num_outputs="2">
		<!-- test 7: tl.hdbscan -->
		    <conditional name="method">
		        <param name="method" value="tl.hdbscan"/>
		        <param name="adata" value="pbmc_500_chr21.h5ad"/>
		        <param name="min_cluster_size" value="5"/>
		        <param name="cluster_selection_epsilon" value="0.0"/>
		        <param name="alpha" value="1.0"/>
		        <param name="cluster_selection_method" value="eom"/>
		        <param name="random_state" value="0"/>
		        <param name="use_rep" value="X_spectral"/>
		        <param name="key_added" value="hdbscan"/>
	  		</conditional>
		    <section name="advanced_common">
		        <param name="show_log" value="true" />
		    </section>
		    <output name="hidden_output">
                <assert_contents>
                    <has_text_matching expression="sa.tl.hdbscan"/>
                    <has_text_matching expression="min_cluster_size=5"/>
                    <has_text_matching expression="cluster_selection_epsilon=0.0"/>
                    <has_text_matching expression="alpha=1.0"/>
                    <has_text_matching expression="cluster_selection_method='eom'"/>
                    <has_text_matching expression="random_state=0"/>
                    <has_text_matching expression="use_rep='X_spectral'"/>
                    <has_text_matching expression="key_added='hdbscan'"/>
                </assert_contents>
            </output>
		</test>
		<test expect_num_outputs="2">
		<!-- test 8: tl.macs3 -->
		    <conditional name="method">
		        <param name="method" value="tl.macs3"/>
		        <param name="adata" value="pbmc_500_chr21.h5ad"/>
		        <param name="groupby" value="cell_type"/>
		        <param name="qvalue" value="0.05"/>
		        <param name="nolambda" value="False"/>
		        <param name="shift" value="-100"/>
		        <param name="extsize" value="200"/>
		        <param name="key_added" value="macs3"/>
		        <param name="inplace" value="True"/>
	  		</conditional>
		    <section name="advanced_common">
		        <param name="show_log" value="true" />
		    </section>
		    <output name="hidden_output">
                <assert_contents>
                    <has_text_matching expression="sa.tl.macs3"/>
                    <has_text_matching expression="groupby='cell_type'"/>
                    <has_text_matching expression="qvalue=0.05"/>
                    <has_text_matching expression="nolambda=False"/>
                    <has_text_matching expression="shift=-100"/>
                    <has_text_matching expression="extsize=200"/>
                    <has_text_matching expression="key_added='macs3'"/>
                    <has_text_matching expression="inplace=True"/>
                </assert_contents>
            </output>
		</test>
		<test expect_num_outputs="2">
		<!-- test 9: tl.merge_peaks -->
		    <conditional name="method">
		        <param name="method" value="tl.merge_peaks"/>
		        <param name="peaks" value=""/>
		        <param name="chrom_sizes" value=""/>
		        <param name="half_width" value="250"/>
	  		</conditional>
		    <section name="advanced_common">
		        <param name="show_log" value="true" />
		    </section>
		    <output name="hidden_output">
                <assert_contents>
                    <has_text_matching expression="sa.tl.merge_peaks"/>
                    <has_text_matching expression=""/>
                    <has_text_matching expression=""/>
                    <has_text_matching expression="half_width=250"/>
                </assert_contents>
            </output>
		</test>
		<test expect_num_outputs="2">
		<!-- test 10: tl.marker_regions -->
		    <conditional name="method">
		        <param name="method" value="tl.marker_regions"/>
		        <param name="adata" value="pbmc_500_chr21.h5ad"/>
		        <param name="groupby" value="cell_type"/>
		        <param name="pvalue" value="0.01"/>
	  		</conditional>
		    <section name="advanced_common">
		        <param name="show_log" value="true" />
		    </section>
		    <output name="hidden_output">
                <assert_contents>
                    <has_text_matching expression="sa.tl.marker_regions"/>
                    <has_text_matching expression="groupby='cell_type'"/>
                    <has_text_matching expression="pvalue=0.01"/>
                </assert_contents>
            </output>
		</test>
		<test expect_num_outputs="2">
		<!-- test 11: tl.diff_test -->
		    <conditional name="method">
		        <param name="method" value="tl.diff_test"/>
		        <param name="adata" value=""/>
		        <param name="cell_group1" value=""/>
		        <param name="cell_group2" value=""/>
		        <param name="direction" value="both"/>
		        <param name="min_log_fc" value="0.25"/>
		        <param name="min_pct" value="0.05"/>
	  		</conditional>
		    <section name="advanced_common">
		        <param name="show_log" value="true" />
		    </section>
		    <output name="hidden_output">
                <assert_contents>
                    <has_text_matching expression="sa.tl.diff_test"/>
                    <has_text_matching expression="cell_group1="/>
                    <has_text_matching expression="cell_group2="/>
                    <has_text_matching expression="direction='both'"/>
                    <has_text_matching expression="min_log_fc=0.25"/>
                    <has_text_matching expression="min_pct=0.05"/>
                </assert_contents>
            </output>
		</test>
		<test expect_num_outputs="2">
		<!-- test 12: tl.motif_enrichment -->
		    <conditional name="method">
		        <param name="method" value="tl.motif_enrichment"/>
		        <param name="motifs" value="sa.datasets.cis_bp(unique=True)"/>
		        <param name="regions" value="tl.marker_regions.result_file"/>
		        <param name="genome_fasta" value="sa.genome.hg38"/>
	  		</conditional>
		    <section name="advanced_common">
		        <param name="show_log" value="true" />
		    </section>
		    <output name="hidden_output">
                <assert_contents>
                    <has_text_matching expression="sa.tl.motif_enrichment"/>
                </assert_contents>
            </output>
		</test>
		<test expect_num_outputs="2">
		<!-- test 13: tl.init_network_from_annotation -->
		    <conditional name="method">
		        <param name="method" value="tl.init_network_from_annotation"/>
		        <param name="regions" value="tl.marker_regions.result_file"/>
		        <param name="anno_file" value=""/>
		        <param name="upstream" value="250000"/>
		        <param name="downstream" value="250000"/>
		        <param name="id_type" value="gene_name"/>
		        <param name="coding_gene_only" value="True"/>
	  		</conditional>
		    <section name="advanced_common">
		        <param name="show_log" value="true" />
		    </section>
		    <output name="hidden_output">
                <assert_contents>
                    <has_text_matching expression="sa.tl.init_network_from_annotation"/>
                    <has_text_matching expression="upstream=250000"/>
                    <has_text_matching expression="downstream=250000"/>
                    <has_text_matching expression="id_type='gene_name'"/>
                    <has_text_matching expression="coding_gene_only=True"/>
                </assert_contents>
            </output>
		</test>
		<test expect_num_outputs="2">
		<!-- test 14: tl.add_cor_scores -->
		    <conditional name="method">
		        <param name="method" value="tl.add_cor_scores"/>
		        <param name="network" value="tl.init_network_from_annotation.result_file"/>
		        <param name="overwrite" value="False"/>
	  		</conditional>
		    <section name="advanced_common">
		        <param name="show_log" value="true" />
		    </section>
		    <output name="hidden_output">
                <assert_contents>
                    <has_text_matching expression="sa.tl.add_cor_scores"/>
                    <has_text_matching expression="overwrite=False"/>
                </assert_contents>
            </output>
		</test>
		<test expect_num_outputs="2">
		<!-- test 15: tl.add_regr_scores -->
		    <conditional name="method">
		        <param name="method" value="tl.add_regr_scores"/>
		        <param name="network" value="tl.init_network_from_annotation.result_file"/>
		        <param name="peak_mat" value="None"/>
		        <param name="gene_mat" value="None"/>
		        <param name="method" value="eleastic_net"/>
		        <param name="scale_X" value="False"/>
		        <param name="scale_Y" value="False"/>
		        <param name="alpha" value="1.0"/>
		        <param name="l1_ratio" value="0.5"/>
		        <param name="use_gpu" value="False"/>
		        <param name="overwrite" value="False"/>
	  		</conditional>
		    <section name="advanced_common">
		        <param name="show_log" value="true" />
		    </section>
		    <output name="hidden_output">
                <assert_contents>
                    <has_text_matching expression="sa.tl.add_regr_scores"/>
                    <has_text_matching expression="method='elastic_net'"/>
                    <has_text_matching expression="scale_X=False"/>
                    <has_text_matching expression="scale_Y=False"/>
                    <has_text_matching expression="alpha=1.0"/>
                    <has_text_matching expression="l1_ratio=0.5"/>
                    <has_text_matching expression="use_gpu=False"/>
                    <has_text_matching expression="overwrite=False"/>
                </assert_contents>
            </output>
		</test>
		<test expect_num_outputs="2">
		<!-- test 16: tl.add_tf_binding -->
		    <conditional name="method">
		        <param name="method" value="tl.add_tf_binding"/>
		        <param name="network" value="tl.init_network_from_annotation.result_file"/>
		        <param name="motifs" value="sa.datasets.cis_bp(unique=True)"/>
		        <param name="genome_fasta" value="sa.genome.hg38"/>
		        <param name="pvalue" value="1e-05"/>
	  		</conditional>
		    <section name="advanced_common">
		        <param name="show_log" value="true" />
		    </section>
		    <output name="hidden_output">
                <assert_contents>
                    <has_text_matching expression="sa.tl.add_tf_binding"/>
                    <has_text_matching expression="pvalue=1e-05"/>
                </assert_contents>
            </output>
		</test>
		<test expect_num_outputs="2">
		<!-- test 17: tl.link_tf_to_gene -->
		    <conditional name="method">
		        <param name="method" value="tl.link_tf_to_gene"/>
		        <param name="network" value="tl.init_network_from_annotation.result_file"/>
	  		</conditional>
		    <section name="advanced_common">
		        <param name="show_log" value="true" />
		    </section>
		    <output name="hidden_output">
                <assert_contents>
                    <has_text_matching expression="sa.tl.link_tf_to_gene"/>
                </assert_contents>
            </output>
		</test>
		<test expect_num_outputs="2">
		<!-- test 18: tl.prune_network -->
		    <conditional name="method">
		        <param name="method" value="tl.prune_network"/>
		        <param name="network" value="tl.init_network_from_annotation.result_file"/>
		        <param name="remove_isolates" value="True"/>
	  		</conditional>
		    <section name="advanced_common">
		        <param name="show_log" value="true" />
		    </section>
		    <output name="hidden_output">
                <assert_contents>
                    <has_text_matching expression="sa.tl.prune_network"/>
                    <has_text_matching expression="remove_isolates=True"/>
                </assert_contents>
            </output>
		</test>
		<test expect_num_outputs="2">
		<!-- test 19: tl.aggregate_X -->
		    <conditional name="method">
		        <param name="method" value="tl.aggregate_X"/>
		        <param name="adata" value="pbmc_500_chr21.h5ad"/>
	  		</conditional>
		    <section name="advanced_common">
		        <param name="show_log" value="true" />
		    </section>
		    <output name="hidden_output">
                <assert_contents>
                    <has_text_matching expression="sa.tl.aggregate_X"/>
                </assert_contents>
            </output>
		</test>
		<test expect_num_outputs="2">
		<!-- test 20: tl.aggregate_cells -->
		    <conditional name="method">
		        <param name="method" value="tl.aggregate_cells"/>
		        <param name="adata" value="pbmc_500_chr21.h5ad"/>
		        <param name="use_rep" value="X_spectral"/>
		        <param name="min_cluster_size" value="50"/>
		        <param name="random_state" value="0"/>
		        <param name="key_added" value="pseudo_cell"/>
		        <param name="inplace" value="True"/>
	  		</conditional>
		    <section name="advanced_common">
		        <param name="show_log" value="true" />
		    </section>
		    <output name="hidden_output">
                <assert_contents>
                    <has_text_matching expression="tl.aggregate_cells"/>
                    <has_text_matching expression="use_rep='X_spectral'"/>
                    <has_text_matching expression="min_cluster_size=50"/>
                    <has_text_matching expression="random_state=0"/>
                    <has_text_matching expression="key_added='pseudo_cell'"/>
                    <has_text_matching expression="inplace=True"/>
                </assert_contents>
            </output>
        </test>
	</tests>
    <help><![CDATA[
    SnapATAC2 tools functions
    ]]></help>
    <expand macro="citations"/>
</tool>

