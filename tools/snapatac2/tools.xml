<tool id="snapatac2_tools" name="Tools" version="@TOOL_VERSION@+galaxy@VERSION_SUFFIX@">
    <description>with snapatac2</description>
    <macros>
        <import>macros.xml</import>
    </macros>
    <requirements>
    	<expand macro="requirements"/>
    </requirements>
    <command detect_errors="exit_code"><![CDATA[
export NUMBA_CACHE_DIR="\${TEMP:-/tmp}";
#if $method.method != 'tl.merge_peaks' and $method.method != 'tl.motif_enrichment' and $method.method != 'tl.init_network_from_annotation' and $method.method != 'tl.add_cor_scores' and $method.method != 'tl.add_regr_scores' and $method.method != 'tl.add_tf_binding' and $method.method != 'tl.link_tf_to_gene' and $method.method != 'tl.prune_network'
@PREP_ADATA@
#end if
@CMD@
    ]]></command>
	<configfiles>
        <configfile name="script_file"><![CDATA[

@CMD_imports@

#if $method.method == 'tl.spectral'
@CMD_read_inputs@
	#if $method.features
with open('$method.features') as f:
	features_mask = [x.lower().capitalize() == "True" for x in f.read().splitlines()]
#end if
sa.tl.spectral(
	adata,
	n_comps = $method.n_comps,
	#if $method.features
	features = features_mask,
	#end if
	random_state = $method.random_state,
	#if $method.sample_size
	sample_size = $method.sample_size,
	#end if
	chunk_size = $method.chunk_size,
	distance_metric = '$method.distance_metric',
	weighted_by_sd = $method.weighted_by_sd,
	inplace = True
)

adata.close()

#else if $method.method == 'tl.umap'
@CMD_read_inputs@
sa.tl.umap(
	adata,
	n_comps = $method.n_comps,
	#if $method.use_dims != ''
	    #set $dims = ([x.strip() for x in str($method.use_dims).split(',')])
	use_dims=$dims,
	#end if
	use_rep = '$method.use_rep',
	key_added = '$method.key_added',
	random_state = $method.random_state,
	inplace = True
)

adata.close()

#else if $method.method == 'tl.leiden'
@CMD_read_inputs@
sa.tl.leiden(
	adata,
	resolution = $method.resolution,
	objective_function = '$method.objective_function',
	min_cluster_size = $method.min_cluster_size,
	n_iterations = $method.n_iterations,
	random_state = $method.random_state,
	key_added = '$method.key_added',
	weighted = $method.weighted,
	inplace = True
)
adata.close()

#else if $method.method == 'tl.kmeans'
@CMD_read_inputs@
sa.tl.kmeans(
	adata,
	n_clusters = $method.n_clusters,
	n_iterations = $method.n_iterations,
	random_state = $method.random_state,
	use_rep = '$method.use_rep',
	key_added = '$method.key_added'
)

#else if $method.method == 'tl.dbscan'
@CMD_read_inputs@
sa.tl.dbscan(
	adata,
	eps = $method.eps,
	min_samples = $method.min_samples,
	leaf_size = $method.leaf_size,
	use_rep = '$method.use_rep',
	key_added = '$method.key_added'
)

#else if $method.method == 'tl.hdbscan'
@CMD_read_inputs@
sa.tl.hdbscan(
	adata,
	min_cluster_size = $method.min_cluster_size,
	#if $method.min_samples
	min_samples = $method.min_samples,
	#end if
	cluster_selection_epsilon = $method.cluster_selection_epsilon,
	alpha = $method.alpha,
	cluster_selection_method = '$method.cluster_selection_method',
	random_state = $method.random_state,
	use_rep = '$method.use_rep',
	key_added = '$method.key_added'
)

#else if $method.method == 'tl.macs3'
@CMD_read_inputs@
sa.tl.macs3(
	adata,
	#if $method.groupby != ''
	groupby = '$method.groupby',
	#end if
	qvalue = $method.qvalue,
	#if $method.replicate
	replicate = '$method.replicate',
	#end if
	#if $method.replicate_qvalue
	replicate_qvalue = $method.replicate_qvalue,
	#end if
	#if $method.max_frag_size
	max_frag_size = $method.max_frag_size,
	#end if
	nolambda = $method.nolambda,
	shift = $method.shift,
	extsize = $method.extsize,
	#if $method.blacklist
	blacklist = '$method.blacklist',
	#end if
	key_added = '$method.key_added',
	inplace = True,
	n_jobs = '\${GALAXY_SLOTS:-4}'
)

#else if $method.method == 'tl.merge_peaks'
@CMD_read_inputs@

import json
import pandas as pd
import csv
with open('$method.chrom_sizes') as f:
    chr_sizes = {x[0]:int(x[1]) for x in csv.reader(f, delimiter='\t')}

sa.tl.merge_peaks(
	peaks = adata.uns['$method.macs_key'],
	chrom_sizes = chr_sizes,
	half_width = $method.half_width
)

#else if $method.method == 'tl.marker_regions'
@CMD_read_inputs@
sa.tl.marker_regions(
	data = adata,
	groupby = '$method.groupby',
	pvalue = $method.pvalue
)

#else if $method.method == 'tl.diff_test'
@CMD_read_inputs@
import numpy as np

group_key = '$method.group_key'
peaks = adata.uns['$method.macs_key']

	#if $method.compare.with == 'single_group'
group1 = '$method.compare.group1_value'
group1_cells = data.obs[group_key] == group1
group2 = '$method.compare.group2_value'
group2_cells = data.obs[group_key] == group2
peaks_selected = np.logical_or(
    peaks[group1].to_numpy(),
    peaks[group2].to_numpy(),
)
	#else if $method.compare.with == 'background_group'
group1 = '$method.compare.group1_value'
group1_cells = data.obs[group_key] == group1
barcodes = np.array(adata.obs_names)
group2_cells = []
for i in np.unique(data.obs[group_key]):
    if i != group1:
        cells = np.random.choice(barcodes[data.obs[group_key] == i], size=$method.compare.number_of_cells, replace=False)
        group2_cells.append(cells)
group2_cells = np.concatenate(group2_cells)
peaks_selected = peaks[group1].to_numpy()
	#end if

diff_peaks = sa.tl.diff_test(
	data = adata,
	cell_group1 = group1_cells,
	cell_group2 = group2_cells,
	features = peaks_selected,
	direction = '$method.direction',
	min_log_fc = $method.min_log_fc,
	min_pct = $method.min_pct
)
diff_peaks.write('differential_peaks.tsv', sep='\t', index=False)

#else if $method.method == 'tl.motif_enrichment'
sa.tl.motif_enrichment(
	motifs = '$method.motifs',
	regions = '$method.regions',
	genome_fasta = '$method.genome_fasta',
	background = '$method.background',
	method = '$method.test_method'
)

#else if $method.method == 'tl.aggregate_X'
@CMD_read_inputs@
sa.tl.aggregate_X(
	adata,
	#if $method.groupby != ''
	groupby = '$method.groupby',
	#end if
	normalize = '$method.normalize'
)

#else if $method.method == 'tl.aggregate_cells'
@CMD_read_inputs@
sa.tl.aggregate_cells(
	adata,
	use_rep = '$method.use_rep',
	#if $method.target_num_cells
	target_num_cells = $method.target_num_cells,
	#end if
	min_cluster_size = $method.min_cluster_size,
	random_state = $method.random_state,
	key_added = '$method.key_added',
	inplace = True
)

#end if

	]]></configfile>
	</configfiles>
    <inputs>
		<conditional name="method">
			<param name="method" type="select" label="Tool">
				<option value="tl.spectral">Perform dimension reduction using Laplacian Eigenmap, using tl.spectral</option>
				<option value="tl.umap">Compute Umap, using tl.umap</option>
				<option value="tl.leiden">Cluster cells into subgroups [Traag18], using tl.leiden</option>
				<option value="tl.kmeans">Cluster cells into subgroups using the K-means algorithm, a classical algorithm in data mining, using tl.kmeans</option>
				<option value="tl.dbscan">Cluster cells into subgroups using the DBSCAN algorithm, using tl.dbscan</option>
				<option value="tl.hdbscan">Cluster cells into subgroups using the HDBSCAN algorithm, using tl.hdbscan</option>
				<option value="tl.macs3">Call peaks using MACS3, using tl.macs3</option>
				<option value="tl.merge_peaks">Merge peaks from different groups, using tl.merge_peaks</option>
				<option value="tl.marker_regions">A quick-and-dirty way to get marker regions, using tl.marker_regions</option>
				<option value="tl.diff_test">Identify differentially accessible regions,using tl.diff_test</option>
				<option value="tl.motif_enrichment">Identify enriched transcription factor motifs, using tl.motif_enrichment</option>
				<option value="tl.aggregate_X">Aggregate values in adata.X in a row-wise fashion, using tl.aggregate_X</option>
				<option value="tl.aggregate_cells">Aggregate cells into pseudo-cells, using tl.aggregate_cells</option>
			</param>
			<when value="tl.spectral">
				<expand macro="inputs_anndata"/>
				<expand macro="param_n_comps"/>
				<param argument="features" type="data" format="txt" optional="true" label="Text file indicating features to keep. Each line contains only word (True/False)." help="True means that the feature is kept. False means the feature is removed"/>
				<expand macro="param_random_state"/>
				<param argument="sample_size" type="float" optional="true" min="0" max="1" label="Approximate the embedding using the Nystrom algorithm by selecting a subset of cells"
					help="Using this only when the number of cells is too large, e.g. > 10,000,000, or the `distance_metric` is “jaccard”"/>
				<param argument="chunk_size" type="integer" value="20000" label="chunk size"/>
				<param argument="distance_metric" type="select" label="distance metric: “jaccard”, “cosine“">
					<option value="jaccard">jaccard</option>
					<option value="cosine">cosine</option>
				</param>
				<param argument="weighted_by_sd" type="boolean" truevalue="True" falsevalue="False" checked="true" label="Whether to weight the result eigenvectors by the square root of eigenvalues"/>
			</when>
			<when value="tl.umap">
				<expand macro="inputs_anndata"/>
				<param argument="n_comps" type="integer" value="2" label="Number of dimensions of embedding"/>
				<param argument="use_dims" type="text" optional="true" label="Use these dimensions in `use_rep`"
					help="comma separated list of dimensions">
					<expand macro="sanitize_query"/>
				</param>
				<expand macro="param_use_rep"/>
				<expand macro="param_key_added" key_added="umap"/>
				<expand macro="param_random_state"/>
			</when>
			<when value="tl.leiden">
				<expand macro="inputs_anndata"/>
				<param argument="resolution" type="float" value="1" label="Parameter value controlling the coarseness of the clustering"
					help="Higher values lead to more clusters"/>
				<param argument="objective_function" type="select" label="Whether to use the Constant Potts Model (CPM) or modularity">
					<option value="CPM">CPM</option>
					<option value="modularity">modularity</option>
					<option value="RBConfiguration">RBConfiguration</option>
				</param>
				<param argument="min_cluster_size" type="integer" value="5" label="The minimum size of clusters"/>
				<expand macro="param_n_iterations"/>
				<expand macro="param_random_state"/>
				<expand macro="param_key_added" key_added="leiden"/>
				<param argument="weighted" type="boolean" truevalue="True" falsevalue="False" label="Whether to use the edge weights in the graph"/>
			</when>
			<when value="tl.kmeans">
				<expand macro="inputs_anndata"/>
				<param argument="n_clusters" type="integer" value="5" label="Number of clusters to return"/>
				<expand macro="param_n_iterations"/>
				<expand macro="param_random_state"/>
				<expand macro="param_use_rep"/>
				<expand macro="param_key_added" key_added="kmeans"/>
			</when>
			<when value="tl.dbscan">
				<expand macro="inputs_anndata"/>
				<param argument="eps" type="float" value="0.5" label=" The maximum distance between two samples for one to be considered as in the neighborhood of the other"
					help="This is not a maximum bound on the distances of points within a cluster. This is the most important DBSCAN parameter to choose appropriately for your data set and distance function."/>
				<param argument="min_samples" type="integer" value="5" label="The number of samples (or total weight) in a neighborhood for a point to be considered as a core point."/>
				<param argument="leaf_size" type="integer" value="30" label="Leaf size passed to BallTree or cKDTree"
					help="This can affect the speed of the construction and query, as well as the memory required to store the tree."/>
				<expand macro="param_use_rep"/>
				<expand macro="param_key_added" key_added="dbscan"/>
			</when>
			<when value="tl.hdbscan">
				<expand macro="inputs_anndata"/>
				<param argument="min_cluster_size" type="integer" value="5" label="The minimum size of clusters"/>
				<param argument="min_samples" type="integer" value="" optional="true" label="The number of samples in a neighbourhood for a point to be considered a core point"/>
				<param argument="cluster_selection_epsilon" type="float" value="0.0" label="A distance threshold. Clusters below this value will be merged"/>
				<param argument="alpha" type="float" value="1.0" label="A distance scaling parameter as used in robust single linkage"/>
				<param argument="cluster_selection_method" type="select" label="The method used to select clusters from the condensed tree">
					<option value="eom">Excess of Mass algorithm to find the most persistent clusters</option>
					<option value="leaf">Select the clusters at the leaves of the tree - this provides the most fine grained and homogeneous clusters</option>
				</param>
				<expand macro="param_random_state"/>
				<expand macro="param_use_rep"/>
				<expand macro="param_key_added" key_added="hdbscan"/>
			</when>
			<when value="tl.macs3">
				<expand macro="inputs_anndata"/>
				<param argument="groupby" type="text" value="" optional="true" label="Group cells before peak calling based on key in `.obs`"/>
				<param argument="qvalue" type="float" value="0.05" label="qvalue cutoff used in MACS3"/>
				<param argument="replicate" type="text" value="" optional="true" label="Replicate information based on key in `.obs`"/>
				<param argument="replicate_qvalue" type="float" value="" optional="true" label="qvalue cutoff used in MACS3 for calling peaks in replicates"/>
				<param argument="max_frag_size" type="integer" value="" optional="true" label="Maximum fragment size"
					help="This is used to remove fragments that are not from nucleosome-free regions."/>
				<param argument="nolambda" type="boolean" checked="false" truevalue="True" falsevalue="False" label="If True, macs3 will use the background lambda as local lambda"/>
				<param argument="shift" type="integer" value="-100" label="The shift size in MACS"/>
				<param argument="extsize" type="integer" value="200" label="The extension size in MACS"/>
				<param argument="blacklist" type="data" format="bed" optional="true" label="Blacklist file in BED format"
					help="If provided, regions in the blacklist will be removed."/>
				<param argument="key_added" type="text" value="macs3"  label="`.uns` key under which to add peak information"/>
			</when>
			<when value="tl.merge_peaks">
				<expand macro="inputs_anndata"/>
				<param name="macs_key" type="text" value="macs3" label="`.uns` key under which peak information was added while peak calling"/>
				<param argument="chrom_sizes" type="data" format="tabular" label="Chromosome sizes"/>
				<param argument="half_width" type="integer" value="250" label="Half width of the merged peaks"/>
			</when>
			<when value="tl.marker_regions">
				<expand macro="inputs_anndata"/>
				<expand macro="param_groupby"/>
				<param argument="pvalue" type="float" value="0.01" label="P-value threshold"/>
			</when>
			<when value="tl.diff_test">
				<expand macro="inputs_anndata"/>
				<param name="macs_key" type="text" value="macs3" label="`.uns` key under which peak information was added while peak calling"/>
				<param name="group_key" type="text" value="cell_type" label="key in `.obs` to select cell groups"
					help="for eg. cell_type"/>
				<conditional name="compare">
					<param name="with" type="select" label="Test for differential accessibility in a group of cells compared to" help="TODO">
						<option value="single_group">Another group of cells</option>
						<option value="background_group">Background cell group built from random selection of cells from all other the groups</option>
					</param>
					<when value="single_group">
						<param name="group1_value" type="text" value="Naive B" label="name of the group 1 stored in .obs"/>
						<param name="group2_value" type="text" value="Memory B" label="name of the group 2 stored in .obs"/>
					</when>
					<when value="background_group">
						<param name="group1_value" type="text" value="Naive B" label="name of the group 1 stored in .obs"/>
						<param name="number_of_cells" type="integer" min="1" value="30" label="Number of cells to subsample from ther other groups"/>
					</when>
				</conditional>
				<param argument="direction" type="select" label="“positive”: return features that are enriched in group 1. “negative”: return features that are enriched in group 2">
					<option value="positive">“positive”: return features that are enriched in group 1</option>
					<option value="negative"> “negative”: return features that are enriched in group 2</option>
					<option value="both" selected="true">“both”: return features that are enriched in group 1 or group 2</option>
				</param>
				<param argument="min_log_fc" type="float" value="0.25" label="Limit testing to features which show, on average, at least this difference (log2-scale) between the two groups of cells"/>
				<param argument="min_pct" type="float" value="0.05" label="Only test features that are detected in a minimum fraction of min_pct cells in either of the two population"/>
			</when>
			<when value="tl.motif_enrichment">
				<param name="motifs" type="text" label="A list of transcription factor motifs">
					<expand macro="sanitize_query"/>
				</param>
				<param name="regions" type="text" label="Groups of regions"/>
				<expand macro="genome_fasta"/>
				<expand macro="background"/>
				<param argument="test_method" type="select" optional="true" label="Statistical testing method: “binomial” or “hypergeometric">
					<option value="binomial">binomial</option>
					<option value="hypergeometric">hypergeometric</option>
				</param>
			</when>
			<when value="tl.aggregate_X">
				<expand macro="inputs_anndata"/>
				<expand macro="param_groupby"/>
				<param argument="normalize" type="select" optional="true" label="normalization method">
					<option value="RPM">RPM</option>
					<option value="RPKM">RPKM</option>
				</param>
			</when>
			<when value="tl.aggregate_cells">
				<expand macro="inputs_anndata"/>
				<expand macro="param_use_rep"/>
				<param argument="target_num_cells" type="integer" value="" optional="true" label="target_num_cells"
				help="If None, `target_num_cells = num_cells / min_cluster_size`"/>
				<param argument="min_cluster_size" type="integer" value="50" label="The minimum size of clusters"/>
				<expand macro="param_random_state"/>
				<expand macro="param_key_added" key_added="pseudo_cell"/>
			</when>
		</conditional>
		<expand macro="inputs_common_advanced"/>
    </inputs>
    <outputs>
		<data name="anndata_out" format="h5ad" from_work_dir="anndata.h5ad" label="${tool.name} (${method.method}) on ${on_string}: Annotated data matrix"/>
		<data name="hidden_output" format="txt" label="Log file" >
            <filter>advanced_common['show_log']</filter>
        </data>
		<data name="diff_peaks" format="tabular" from_work_dir="differential_peaks.tsv" label="${tool.name} on ${on_string}: Differential peaks" >
			<filter>method['method'] and 'tl.diff_test' in method['method']</filter>
        </data>
    </outputs>
    <tests>
    	<test expect_num_outputs="2">
		<!-- test 1: tl.spectral -->
		    <conditional name="method">
		        <param name="method" value="tl.spectral"/>
		        <param name="adata" value="pp.select_features.pbmc_500_chr21.h5ad"/>
				<param name="n_comps" value="30"/>
		        <param name="random_state" value="0"/>
		        <param name="chunk_size" value="20000"/>
		        <param name="distance_metric" value="jaccard"/>
		        <param name="weighted_by_sd" value="True"/>
	  		</conditional>
		    <section name="advanced_common">
		        <param name="show_log" value="true" />
		    </section>
		    <output name="hidden_output">
                <assert_contents>
                    <has_text_matching expression="sa.tl.spectral"/>
                    <has_text_matching expression="random_state = 0"/>
					<has_text_matching expression="n_comps = 30"/>
                    <has_text_matching expression="chunk_size = 20000"/>
                    <has_text_matching expression="distance_metric = 'jaccard'"/>
                    <has_text_matching expression="weighted_by_sd = True"/>
                </assert_contents>
            </output>
            <output name="anndata_out" ftype="h5ad" compare="sim_size" delta_frac="0.1" file="tl.spectral.pbmc_500_chr21.h5ad"/>
		</test>
		<test expect_num_outputs="2">
		<!-- test 2: tl.umap -->
		    <conditional name="method">
		        <param name="method" value="tl.umap"/>
		        <param name="adata" value="large_files/tl.spectral.pbmc_500_chr21.h5ad"/>
		        <param name="n_comps" value="2"/>
		        <param name="use_rep" value="X_spectral"/>
		        <param name="key_added" value="umap"/>
		        <param name="random_state" value="0"/>
	  		</conditional>
		    <section name="advanced_common">
		        <param name="show_log" value="true" />
		    </section>
		    <output name="hidden_output">
                <assert_contents>
                    <has_text_matching expression="sa.tl.umap"/>
                    <has_text_matching expression="n_comps = 2"/>
                    <has_text_matching expression="use_rep = 'X_spectral'"/>
                    <has_text_matching expression="key_added = 'umap'"/>
                    <has_text_matching expression="random_state = 0"/>
                </assert_contents>
            </output>
            <output name="anndata_out" ftype="h5ad" compare="sim_size" delta_frac="0.1" file="tl.umap.pbmc_500_chr21.h5ad"/>
		</test>
		<test expect_num_outputs="2">
		<!-- test 3: tl.leiden -->
		    <conditional name="method">
		        <param name="method" value="tl.leiden"/>
		        <param name="adata" value="pp.knn.pbmc_500_chr21.h5ad"/>
		        <param name="resolution" value="2"/>
		        <param name="objective_function" value="modularity"/>
		        <param name="min_cluster_size" value="3"/>
		        <param name="n_iterations" value="-1"/>
		        <param name="random_state" value="0"/>
		        <param name="key_added" value="leiden"/>
		        <param name="weighted" value="False"/>
	  		</conditional>
		    <section name="advanced_common">
		        <param name="show_log" value="true" />
		    </section>
		    <output name="hidden_output">
                <assert_contents>
                    <has_text_matching expression="sa.tl.leiden"/>
                    <has_text_matching expression="resolution = 2"/>
                    <has_text_matching expression="objective_function = 'modularity'"/>
                    <has_text_matching expression="min_cluster_size = 3"/>
                    <has_text_matching expression="n_iterations = -1"/>
                    <has_text_matching expression="random_state = 0"/>
                    <has_text_matching expression="key_added = 'leiden'"/>
                    <has_text_matching expression="weighted = False"/>
                </assert_contents>
            </output>
            <output name="anndata_out" ftype="h5ad" compare="sim_size" delta_frac="0.1" file="tl.leiden.pbmc_500_chr21.h5ad"/>
		</test>
		<test expect_num_outputs="2">
			<!-- test 3: tl.kmeans -->
				<conditional name="method">
					<param name="method" value="tl.kmeans"/>
					<param name="adata" value="large_files/tl.spectral.pbmc_500_chr21.h5ad"/>
					<param name="n_iterations" value="-1"/>
					<param name="random_state" value="0"/>
					<param name="use_rep" value="X_spectral"/>
					<param name="key_added" value="kmeans"/>
				  </conditional>
				<section name="advanced_common">
					<param name="show_log" value="true"/>
				</section>
				<output name="hidden_output">
					<assert_contents>
						<has_text_matching expression="sa.tl.kmeans"/>
						<has_text_matching expression="n_iterations = -1"/>
						<has_text_matching expression="random_state = 0"/>
						<has_text_matching expression="use_rep = 'X_spectral'"/>
						<has_text_matching expression="key_added = 'kmeans'"/>
					</assert_contents>
				</output>
				<output name="anndata_out" ftype="h5ad" compare="sim_size" delta_frac="0.1" file="tl.kmeans.pbmc_500_chr21.h5ad"/>
			</test>
			<test expect_num_outputs="2">
				<!-- test 3: tl.dbscan -->
				<conditional name="method">
					<param name="method" value="tl.dbscan"/>
					<param name="adata" value="large_files/tl.spectral.pbmc_500_chr21.h5ad"/>
					<param name="eps" value="0.5"/>
					<param name="min_samples" value="3"/>
					<param name="leaf_size" value="5"/>
					<param name="use_rep" value="X_spectral"/>
					<param name="key_added" value="dbscan"/>
					</conditional>
				<section name="advanced_common">
					<param name="show_log" value="true"/>
				</section>
				<output name="hidden_output">
					<assert_contents>
						<has_text_matching expression="sa.tl.dbscan"/>
						<has_text_matching expression="eps = 0.5"/>
						<has_text_matching expression="min_samples = 3"/>
						<has_text_matching expression="leaf_size = 5"/>
						<has_text_matching expression="use_rep = 'X_spectral'"/>
						<has_text_matching expression="key_added = 'dbscan'"/>
					</assert_contents>
				</output>
				<output name="anndata_out" ftype="h5ad" compare="sim_size" delta_frac="0.1" file="tl.dbscan.pbmc_500_chr21.h5ad"/>
			</test>
			<test expect_num_outputs="2">
				<!-- test 3: tl.hdbscan -->
				<conditional name="method">
					<param name="method" value="tl.hdbscan"/>
					<param name="adata" value="large_files/tl.spectral.pbmc_500_chr21.h5ad"/>
					<param name="min_cluster_size" value="3"/>
					<param name="min_samples" value="3"/>
					<param name="cluster_selection_method" value="eom"/>
					<param name="random_state" value="0"/>
					<param name="use_rep" value="X_spectral"/>
					<param name="key_added" value="hdbscan"/>
					</conditional>
				<section name="advanced_common">
					<param name="show_log" value="true"/>
				</section>
				<output name="hidden_output">
					<assert_contents>
						<has_text_matching expression="sa.tl.hdbscan"/>
						<has_text_matching expression="min_cluster_size = 3"/>
						<has_text_matching expression="min_samples = 3"/>
						<has_text_matching expression="cluster_selection_method = 'eom'"/>
						<has_text_matching expression="random_state = 0"/>
						<has_text_matching expression="use_rep = 'X_spectral'"/>
						<has_text_matching expression="key_added = 'hdbscan'"/>
					</assert_contents>
				</output>
				<output name="anndata_out" ftype="h5ad" compare="sim_size" delta_frac="0.1" file="tl.dbscan.pbmc_500_chr21.h5ad"/>
			</test>
			<test expect_num_outputs="2">
				<!-- test 3: tl.aggregate_X -->
				<conditional name="method">
					<param name="method" value="tl.aggregate_X"/>
					<param name="adata" value="large_files/tl.spectral.pbmc_500_chr21.h5ad"/>
					<param name="normalize" value="RPKM"/>
					</conditional>
				<section name="advanced_common">
					<param name="show_log" value="true"/>
				</section>
				<output name="hidden_output">
					<assert_contents>
						<has_text_matching expression="sa.tl.aggregate_X"/>
						<has_text_matching expression="normalize = 'RPKM'"/>
					</assert_contents>
				</output>
				<output name="anndata_out" ftype="h5ad" compare="sim_size" delta_frac="0.1" file="tl.aggregate_X.pbmc_500_chr21.h5ad"/>
			</test>
			<test expect_num_outputs="2">
				<!-- test 3: tl.aggregate_cells -->
				<conditional name="method">
					<param name="method" value="tl.aggregate_cells"/>
					<param name="adata" value="large_files/tl.spectral.pbmc_500_chr21.h5ad"/>
					<param name="use_rep" value="X_spectral"/>
					<param name="target_num_cells" value="5"/>
					<param name="min_cluster_size" value="3"/>
					<param name="random_state" value="0"/>
					<param name="key_added" value="pseudo_cell"/>
					</conditional>
				<section name="advanced_common">
					<param name="show_log" value="true"/>
				</section>
				<output name="hidden_output">
					<assert_contents>
						<has_text_matching expression="sa.tl.aggregate_cells"/>
						<has_text_matching expression="use_rep = 'X_spectral'"/>
						<has_text_matching expression="target_num_cells = 5"/>
						<has_text_matching expression="min_cluster_size = 3"/>
						<has_text_matching expression="random_state = 0"/>
						<has_text_matching expression="key_added = 'pseudo_cell'"/>
					</assert_contents>
				</output>
				<output name="anndata_out" ftype="h5ad" compare="sim_size" delta_frac="0.1" file="tl.aggregate_cells.pbmc_500_chr21.h5ad"/>
			</test>
	</tests>
    <help><![CDATA[
    SnapATAC2 tools functions
    ]]></help>
    <expand macro="citations"/>
</tool>

