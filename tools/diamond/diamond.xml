<tool id="bg_diamond" name="Diamond" version="@TOOL_VERSION@+galaxy@VERSION_SUFFIX@" profile="24.1" license="GPL-3.0">
    <description>align sequences against a protein database</description>
    <macros>
        <import>macros.xml</import>
    </macros>
    <xrefs>
        <xref type="bio.tools">diamond</xref>
    </xrefs>
    <expand macro="requirements"/>
    <expand macro="stdio"/>
    <expand macro="version_command"/>
    <command detect_errors="aggressive">
<![CDATA[

    #if $ref_db_source.db_source == "history":
        ln -s '$ref_db_source.reference_database' ./database.dmnd &&
        #set database="database.dmnd"
    #else if $ref_db_source.db_source == "blast":
        #import os.path
        #set basename =  os.path.basename($ref_db_source.reference_database.fields.path)
        #set dirname =  os.path.dirname($ref_db_source.reference_database.fields.path)
        #set database="./db/" + basename
        mkdir ./db &&
        ## symlink all files in the directory containing the BLAST DB
        ## in newer BLAST DBs there is a file taxonomy4blast.sqlite3
        ## that is needed
        ln -s '$dirname/'* ./db/ &&
        #if $ref_db_source.ncbi_taxonomy
            ## symlink names and nodes dump files from NCBI taxonomy
            ## need to be in the same dir as the BLAST DB (which is the
            ## reason why we need to create .,/db/)
            ln -s '$ref_db_source.ncbi_taxonomy.fields.path/nodes.dmp' ./db/nodes.dmp &&
            ln -s '$ref_db_source.ncbi_taxonomy.fields.path/names.dmp' ./db/names.dmp &&
        #end if
    #else:
        ln -s '${ref_db_source.reference_database.fields.db_path}' ./database.dmnd &&
        #set database="database.dmnd"
    #end if

    diamond
        $method_cond.method_select
        --threads "\${GALAXY_SLOTS:-12}"
        --db '$database'
        --query '$query'
        #if $method_cond.method_select == "blastx"
          --query-gencode '$method_cond.query_gencode'
          --strand '$method_cond.query_strand'
          --min-orf $method_cond.min_orf
          #if $method_cond.frameshift_cond.frameshift_select == 'yes'
            --frameshift $method_cond.frameshift_cond.frameshift
            $method_cond.frameshift_cond.range_culling
          #end if
        #else if $method_cond.method_select == "blastp"
            $method_cond.no_self_hits
        #end if

        @OUTPUT_ARGS@
        #if $output_section.output.outfmt != '100'
            --compress '0'
        #end if

        $sens_cond.sensitivity
        #if str($gapopen) != "":
          --gapopen '$gapopen'
        #end if
        #if str($gapextend) != "":
          --gapextend '$gapextend'
        #end if
        --matrix '$matrix'
        --comp-based-stats '$method_cond.comp_based_stats'
        --masking '$masking'

        @HITFILTER_ARGS@

        #if str($filter_score.filter_score_select) == 'evalue':
            --evalue '$filter_score.evalue'
        #else:
            --min-score '$filter_score.min_score'
        #end if

        --id '$id'
        --approx-id '$approx_id'    
        --query-cover '$query_cover'
        --subject-cover '$subject_cover'
        --block-size '$sens_cond.block_size'
        #if $output_section.output_unal
            #if "--un" in $output_section.output_unal
                --un '$unalqueries'
                #if $query.ext.startswith("fasta"):
                    --unfmt fasta
                #else
                    --unfmt fastq
                #end if
            #end if
            #if "--al" in $output_section.output_unal
                --al '$alqueries'
                #if $query.ext.startswith("fasta"):
                    --alfmt fasta
                #else
                    --alfmt fastq
                #end if
            #end if
        #end if
        #if $output_section.max_hsps
            --max-hsps $output_section.max_hsps
        #end if
        #if $tax_cond.tax_select == 'file':
            --taxonlist \$(cat '$tax_cond.taxonlist' | grep -v "^#" | grep -v "^$" | tr "\n" "," | sed 's/,$//')
        #else if  $tax_cond.tax_select == 'list':
            --taxonlist '$tax_cond.taxonlist'
        #end if
        #if $tax_exclude_cond.tax_select == 'file':
            --taxon_exclude \$(cat '$tax_exclude_cond.taxon_exclude' | grep -v "^#" | grep -v "^$" | tr "\n" "," | sed 's/,$//')
        #else if  $tax_exclude_cond.tax_select == 'list':
            --taxon_exclude '$tax_exclude_cond.taxon_exclude'
        #end if

        #if $advanced_section.seed_cut
            --seed-cut $advanced_section.seed_cut
        #end if
        $advanced_section.freq_masking
        --motif-masking $advanced_section.motif_masking
        --soft-masking $advanced_section.soft_masking
        $advanced_section.iterate
        $advanced_section.swipe
        --algo $advanced_section.algo
        #if $advanced_section.global_ranking
            --global-ranking $advanced_section.global_ranking
        #end if
        --index-chunks "\${DIAMOND_INDEX_CHUNKS:-4}"
        --file-buffer-size "\${DIAMOND_FILE_BUFFER_SIZE:-67108864}"
        $log
    ]]></command>
    <inputs>
        <conditional name="method_cond">
            <param name="method_select" type="select" label="Alignment mode" help="(blastp/blastx)">
                <option value="blastp">Amino acid query sequences (blastp)</option>
                <option value="blastx">DNA query sequences (blastx)</option>
            </param>
            <when value="blastx">
                <param argument="--query-gencode" type="select" label="Genetic code" help="used for translation of query in BLASTX mode">
                    <option value="1">Standard Code</option>
                    <option value="2">Vertebrate Mitochondrial Code</option>
                    <option value="3">Yeast Mitochondrial Code</option>
                    <option value="4">Mold, Protozoan, and Coelenterate Mitochondrial Code and the Mycoplasma/Spiroplasma Code</option>
                    <option value="5">Invertebrate Mitochondrial Code</option>
                    <option value="6">Ciliate, Dasycladacean and Hexamita Nuclear Code</option>
                    <option value="9">Echinoderm and Flatworm Mitochondrial Code</option>
                    <option value="10">Euplotid Nuclear Code</option>
                    <option value="11">Bacterial, Archaeal and Plant Plastid Code</option>
                    <option value="12">Alternative Yeast Nuclear Code</option>
                    <option value="13">Ascidian Mitochondrial Code</option>
                    <option value="14">Alternative Flatworm Mitochondrial Code</option>
                    <option value="16">Chlorophycean Mitochondrial Code</option>
                    <option value="21">Trematode Mitochondrial Code</option>
                    <option value="22">Scenedesmus obliquus Mitochondrial Code</option>
                    <option value="23">Thraustochytrium Mitochondrial Code</option>
                    <option value="24">Pterobranchia Mitochondrial Code</option>
                    <option value="25">Candidate Division SR1 and Gracilibacteria Code</option>
                    <option value="26">Pachysolen tannophilus Nuclear Code</option>
                    <option value="27">Karyorelict Nuclear Code</option>
                    <option value="28">Condylostoma Nuclear Code</option>
                    <option value="29">Mesodinium Nuclear Code</option>
                    <option value="30">Peritrich Nuclear Code</option>
                    <option value="31">Blastocrithidia Nuclear Code</option>
                    <option value="33">Cephalodiscidae Mitochondrial UAA-Tyr Code</option>
                </param>
                <param argument="--min-orf" type="integer" value="1" min="1" label="Minimum ORF length" help="Ignore translated sequences without an open reading frame of at least this length. By default this feature is disabled for sequences of length below 30, set to 20 for sequences of length below 100, and set to 40 otherwise. Setting this option to 1 will disable this feature"/>
                <param name="query_strand" argument="--strand" type="select" label="Query strands to search" help="">
                    <option value="both" selected="True">Both</option>
                    <option value="plus">Plus</option>
                    <option value="minus">Minus</option>
                </param>
                <conditional name="frameshift_cond">
                    <param name="frameshift_select" type="select" label="Allow for frameshifts" help="">
                        <option value="yes">yes</option>
                        <option value="no" selected="true">no</option>
                    </param>
                    <when value="yes">
                        <param argument="--range-culling" type="boolean" truevalue="--range-culling" falsevalue="" checked="false" label="Restrict hit culling to overlapping query ranges" help="This feature is designed for long query DNA sequences that may span several genes. In these cases, the default of reporting the 25 best overall hits could cause hits to a lower scoring gene to be overshadowed. But just increasing the number of alignments reported will bloat the output size and reduce performance. Using this feature along with -k 25 (default), a hit will only be deleted if at least 50% of its query range is spanned by at least 25 higher or equal scoring hits. Using this feature along with --top 10, a hit will only be deleted if its score is more than 10% lower than that of a higher scoring hit over at least 50% of its query range. The percentage is configurable using --range-cover. Note that this feature is currently only available in frameshift alignment mode"/>
                        <param argument="--frameshift" type="integer" value="0" label="Frame shift penalty" help="Values around 15 are reasonable for this parameter. Enabling this feature will have the aligner tolerate missing bases in DNA sequences and is most recommended for long, error-prone sequences like MinION reads. In the pairwise output format, frameshifts will be indicated by \ and / for a shift by +1 and -1 nucleotide in the direction of translation respectively."/>
                    </when>
                    <when value="no"/>
                </conditional>
                <param argument="--comp-based-stats" type="select" label="Composition based statistics" help="Compositionally biased sequences often cause false positive matches, which are effectively filtered by this algorithm in a way similar to the composition based statistics used by BLAST">
                    <option value="0">Disable</option>
                    <option value="1" selected="True">Default mode (Hauser, 2016)</option>
                </param>
            </when>
            <when value="blastp">
                <param argument="--no-self-hits" type="boolean" truevalue="--no-self-hits" falsevalue="" checked="true" label="Suppress reporting of identical self-hits between sequences" help="The FASTA sequence identifiers as well as the sequences of query and target need to be identical for a hit to be deleted"/>
                <param argument="--comp-based-stats" type="select" label="Composition based statistics" help="Compositionally biased sequences often cause false positive matches, which are effectively filtered by this algorithm in a way similar to the composition based statistics used by BLAST">
                    <option value="0">Disable</option>
                    <option value="1" selected="True">Default mode (Hauser, 2016)</option>
                    <option value="2">Compositional matrix adjust conditioned on sequence properties, simplified (Yu, 2005)</option>
                    <option value="3">Compositional matrix adjust conditioned on sequence properties (Yu, 2005)</option>
                    <option value="4">Compositional matrix adjust unconditionally (Yu, 2005)</option>
                    <option value="5">Compositional matrix adjustment conditioned on sequence properties with fallback on composition-based statistics</option>
                </param>
            </when>
        </conditional>
        <param argument="--query" type="data" format="fasta,fasta.gz,fastqsanger,fastqsanger.gz,fastqillumina,fastqillumina.gz" label="Input query file in FASTA or FASTQ format"/>
        <conditional name="ref_db_source">
            <param name="db_source" type="select" label="Reference database source" help="">
                <option value="blast">Use a built-in BLAST index</option>
                <option value="history">Use one from the history</option>
                <option value="indexed">Use a built-in DIAMOND index</option>
            </param>
            <when value="blast">
                <param name="reference_database" type="select" label="Reference database" help="If your database of interest is not listed, contact your Galaxy admin">
                    <options from_data_table="blastdb_p">
                        <filter type="sort_by" column="2"/>
                        <validator type="no_options" message="No indexes are available for the selected input dataset"/>
                    </options>
                </param>
                <param name="ncbi_taxonomy" type="select" optional="true" label="NCBI taxonomy database" help="Needed for output of taxonomy columns in tabular output">
                    <options from_data_table="ncbi_taxonomy">
                        <validator message="No NCBI database is available. Ask your Galaxy adin" type="no_options"/>
                    </options>
                </param>
            </when>
            <when value="indexed">
                <param name="reference_database" type="select" label="Reference database" help="If your database of interest is not listed, contact your Galaxy admin">
                    <options from_data_table="diamond_database">
                        <filter type="sort_by" column="2"/>
                        <validator type="no_options" message="No indexes are available for the selected input dataset"/>
                    </options>
                </param>
            </when>
            <when value="history">
                <param name="reference_database" argument="--db" type="data" format="dmnd" label="Reference database"/>
            </when>
        </conditional>
        <expand macro="taxon_cond_macro" argument="--taxonlist" cond_name="tax_cond" label="Restrict search taxonomically" help="Any taxonomic rank can be used. Only reference sequences included in the given taxa will be used"/>
        <expand macro="taxon_cond_macro" argument="--taxon-exclude" cond_name="tax_exclude_cond" label="Exclude taxa from search" help="Any taxonomic rank can be used. Reference sequences included in the taxonomic rank will be excluded from the search."/>
        <conditional name="sens_cond">
            <param name="sensitivity" type="select" label="Sensitivity Mode" help="Choose one of the sensitivity modes. The default mode is mainly designed for short read alignment, i.e. finding significant matches of &gt;50 bits on 30-40aa fragments. The sensitive mode is a lot more sensitive than the default and generally recommended for aligning longer sequences. The more sensitive mode provides even more sensitivity. More sensitivity may increase computation time.">
                <option value="--faster">Faster (--faster)</option>
                <option value="--fast">Fast (--fast)</option>
                <option value="" selected="True">Default</option>
                <option value="--mid-sensitive">Mid Sensitive (--mid-sensitive)</option>
                <option value="--sensitive">Sensitive (--sensitive)</option>
                <option value="--more-sensitive">More Sensitive (--more-sensitive)</option>
                <option value="--very-sensitive">Very Sensitive (--very-sensitive)</option>
                <option value="--ultra-sensitive">Ultra Sensitive (--ultra-sensitive)</option>
            </param>
            <when value="--faster">
                <expand macro="block_size" value="2"/>
            </when>
            <when value="--fast">
                <expand macro="block_size" value="2"/>
            </when>
            <when value="">
                <expand macro="block_size" value="2"/>
            </when>
            <when value="--mid-sensitive">
                <expand macro="block_size" value="2"/>
            </when>
            <when value="--sensitive">
                <expand macro="block_size" value="2"/>
            </when>
            <when value="--more-sensitive">
                <expand macro="block_size" value="2"/>
            </when>
            <when value="--very-sensitive">
                <expand macro="block_size" value="0.4"/>
            </when>
            <when value="--ultra-sensitive">
                <expand macro="block_size" value="0.4"/>
            </when>
        </conditional>
        <param argument="--matrix" type="select" label="Scoring matrix" help="In parentheses are the supported values for (gap open)/(gap extend). In brackets are default gap penalties">
            <option value="BLOSUM45">BLOSUM45 ((10-13)/3; (12-16)/2; (16-19)/1) [14/2]</option>
            <option value="BLOSUM50">BLOSUM50 ((9-13)/3; (12-16)/2; (15-19)/1) [13/2]</option>
            <option value="BLOSUM62" selected="True">BLOSUM62 ((6-11)/2; (9-13)/1) [11/1]</option>
            <option value="BLOSUM80">BLOSUM80 ((6-9)/2; 13/2; 25/2; (9-11)/1) [10/1]</option>
            <option value="BLOSUM90">BLOSUM90 ((6-9)/2; (9-11)/1) [10/1]</option>
            <option value="PAM250">PAM250 ((11-15)/3; (13-17)/2; (17-21)/1) [14/2]</option>
            <option value="PAM70">PAM70 ((6-8)/2; (9-11)/1) [10/1]</option>
            <option value="PAM30">PAM30 ((5-7)/2; (8-10)/1) [9/1]</option>
        </param>
        <param argument="--gapopen" type="integer" optional="True" value="" label="Gap open penalty" help="Leave empty for default (see scoring matrix)"/>
        <param argument="--gapextend" type="integer" optional="True" value="" label="Gap extension penalty" help="Leave empty for default (see scoring matrix)"/>
        <param argument="--masking" type="select" label="Masking algorithm" help="DIAMOND by default applies the tantan repeat masking algorithm to the query and target sequences as described in (Frith, 2011). This masking procedure increases the specificity of alignments and serves to filter out spurious hits. Note that when using --comp-based-stats (2,3,4), tantan masking is disabled by default.">
            <option value="none">Disabled</option>
            <option value="tantan" selected="true">Tantan</option>
            <option value="seg">SEG</option>
        </param>

        <expand macro="hit_filter_macro"/>
        <section name="output_section" title="Output options" expanded="true">
            <expand macro="output_type_macro">
                <!-- Taxonomy features are not supported for the DAA format (i.e.
                        can't be used in diamond view) -->
                <option value="staxids">Unique Subject Taxonomy ID(s) (in numerical order)</option>
                <option value="sscinames">Unique Subject Scientific Name(s)</option>
                <option value="sskingdoms">Unique Subject Super Kingdom(s)</option>
                <option value="skingdoms">Unique Subject Kingdom(s)</option>
                <option value="sphylums">Unique Subject Phylum(s)</option>
                <option value="slineages">Unique Subject Lineage(s), separated by a '&lt;&gt;'</option>
                <option value="ssuperkingdom">Unique subject superkingdom(s)</option>
                <option value="scellular_root">Unique subject cellular root(s)</option>
                <option value="sacellular_root">Unique subject acellular root(s)</option>
                <option value="sdomain">Unique subject domain(s)</option>
                <option value="srealm">Unique subject realm(s)</option>
                <option value="skingdom">Unique subject kingdom(s)</option>
                <option value="ssubkingdom">Unique subject subkingdom(s)</option>
                <option value="ssuperphylum">Unique subject superphylum(s)</option>
                <option value="sphylum">Unique subject phylum(s)</option>
                <option value="ssubphylum">Unique subject subphylum(s)</option>
                <option value="ssuperclass">Unique subject superclass(s)</option>
                <option value="sclass">Unique subject class(s)</option>
                <option value="ssubclass">Unique subject subclass(s)</option>
                <option value="sinfraclass">Unique subject infraclass(s)</option>
                <option value="scohort">Unique subject cohort(s)</option>
                <option value="ssubcohort">Unique subject subcohort(s)</option>
                <option value="ssuperorder">Unique subject superorder(s)</option>
                <option value="sorder">Unique subject order(s)</option>
                <option value="ssuborder">Unique subject suborder(s)</option>
                <option value="sinfraorder">Unique subject infraorder(s)</option>
                <option value="sparvorder">Unique subject parvorder(s)</option>
                <option value="ssuperfamily">Unique subject superfamily(s)</option>
                <option value="sfamily">Unique subject family(s)</option>
                <option value="ssubfamily">Unique subject subfamily(s)</option>
                <option value="stribe">Unique subject tribe(s)</option>
                <option value="ssubtribe">Unique subject subtribe(s)</option>
                <option value="sgenus">Unique subject genus(s)</option>
                <option value="ssubgenus">Unique subject subgenus(s)</option>
                <option value="ssection">Unique subject section(s)</option>
                <option value="ssubsection">Unique subject subsection(s)</option>
                <option value="sseries">Unique subject series(s)</option>
                <option value="sspecies_group">Unique subject species group(s)</option>
                <option value="sspecies_subgroup">Unique subject species subgroup(s)</option>
                <option value="sspecies">Unique subject species(s)</option>
                <option value="ssubspecies">Unique subject subspecies(s)</option>
                <option value="svarietas">Unique subject varietas(s)</option>
                <option value="sforma">Unique subject forma(s)</option>
                <option value="sstrain">Unique subject strain(s)</option>
                <option value="sbiotype">Unique subject biotype(s)</option>
                <option value="sclade">Unique subject clade(s)</option>
                <option value="sforma_specialis">Unique subject forma specialis(s)</option>
                <option value="sgenotype">Unique subject genotype(s)</option>
                <option value="sisolate">Unique subject isolate(s)</option>
                <option value="smorph">Unique subject morph(s)</option>
                <option value="spathogroup">Unique subject pathogroup(s)</option>
                <option value="sserogroup">Unique subject serogroup(s)</option>
                <option value="sserotype">Unique subject serotype(s)</option>
                <option value="ssubvariety">Unique subject subvariety(s)</option>
            </expand>
            <param name="output_unal" type="select" optional="true" multiple="true" label="Output aligned/unaligned queries to separate file" help="">
                <option value="--un">Output unaligned queries (--un)</option>
                <option value="--al">Output aligned queries (--al)</option>
            </param>
            <param argument="--log" type="boolean" truevalue="--log" falsevalue="" label="Output log file"/>
            <param argument="--max-hsps" type="integer" min="0" optional="true" label="Maximum number of HSPs" help="The maximum number of HSPs (High-Scoring Segment Pairs) per target sequence to report for each query. The default policy is to report only the highest-scoring HSP for each target, while disregarding alternative, lower-scoring HSPs that are contained in the same target."/>
        </section>

        <section name="advanced_section" title="Advanced options" expanded="false">
            <param argument="--seed-cut" type="float" min="0" optional="true" label="Set a complexity cutoff for indexed seeds"/>
            <param argument="--freq-masking" type="boolean" truevalue="--freq-masking" falsevalue="" checked="false" label="Enable masking seeds based on frequency" help="This option is incompatible with --sed-cut"/>
            <param argument="--soft-masking" type="select" label="Soft Masking" help="Select type of soft masking">
                <option value="0" selected="True">Disbled</option>
                <option value="seg">seg</option>
                <option value="tantan">tantan</option>
            </param>
            <param argument="--motif-masking" type="select" label="Softmask abundant motifs" help="Enable or disable motif masking">
                <option value="0">Disabled</option>
                <option value="1">Enabled</option>
            </param>
            <param argument="--swipe" type="boolean" truevalue="--swipe" falsevalue="" checked="false" label="Run Exhaustive alignment against all database sequences" help="Smith Waterman alignments of all queries will be computed against all targets."/>
            <param argument="--iterate" type="boolean" truevalue="--iterate" falsevalue="" checked="false" label="Run multiple rounds of searches with increasing sensitivity" help="The query dataset will first be searched at a lower sensitivity setting, only searching those query sequences at the target sensitivity that fail to produce a significant alignment at a lower sensitivity."/>
            <param argument="--algo" type="select" label="Algorithm for seed search" help="Double-indexed is the main algorithm of the program, designed for large input files but less efficient for small query files. Query-indexed and improves performance for small query files. This mode will be automatically triggered based on the input. Contiguous-seed mode and further improves performance for small query files. The modes differ slightly in their sensitivity, so results are not guaranteed to be 100% identical for different settings of this option.">
                <option value="0">Double-indexed (0)</option>
                <option value="1">Query-indexed (1)</option>
                <option value="ctg">Contiguous-seed mode (ctg)</option>
            </param>
            <param argument="--global-ranking" type="integer" min="0" value="" optional="true" label="Limit on the number of Smith Waterman extensions" help="Target sequences will be ranked according to their ungapped extension scores at seed hits, and gapped extensions will only be computed for the best N targets for each query. Note that this option increases memory use."/>
        </section>
    </inputs>
    <outputs>
        <expand macro="output_macro"/>
        <data format_source="query" name="unalqueries" label="${tool.name} on ${on_string}: unaligned queries">
            <filter>output_section['output_unal'] and "--un" in output_section['output_unal']</filter>
        </data>
        <data format_source="query" name="alqueries" label="${tool.name} on ${on_string}: aligned queries">
            <filter>output_section['output_unal'] and "--al" in output_section['output_unal']</filter>
        </data>
        <data name="log_file" format="txt" label="Diamond log file" from_work_dir="diamond.log">
            <filter>output_section['log']</filter>
        </data>
    </outputs>
    <tests>
        <!--Test 01 al and unal output -->
        <test expect_num_outputs="3">
            <conditional name="method_cond">
                <param name="method_select" value="blastp"/>
                <param name="comp_based_stats" value="1"/>
            </conditional>
            <param name="query" value="protein.fasta.gz" ftype="fasta.gz"/>
            <conditional name="ref_db_source">
                <param name="db_source" value="history"/>
                <param name="reference_database" value="db-wtax.dmnd"/>
            </conditional>
            <section name="output_section">
                <conditional name="output">
                    <param name="outfmt" value="6"/>
                    <param name="fields" value="qseqid,sseqid,pident,length,mismatch,gapopen,qstart,qend,sstart,send,evalue,bitscore,scovhsp,sskingdoms,skingdoms,sphylums,cigar"/>
                </conditional>
                <param name="output_unal" value="--al,--un"/>
            </section>
            <conditional name="sens_cond">
                <param name="sensitivity" value=""/>
            </conditional>
            <param name="matrix" value="BLOSUM62"/>
            <param name="masking" value="tantan"/>
            <conditional name="hit_filter">
                <param name="hit_filter_select" value="max"/>
                <param name="max_target_seqs" value="25"/>
            </conditional>
            <conditional name="filter_score">
                <param name="filter_score_select" value="evalue"/>
                <param name="evalue" value="0.001"/>
            </conditional>
            <param name="id" value="0"/>
            <param name="query_cover" value="0"/>
            <conditional name="sens_cond">
                <param name="block_size" value="2"/>
            </conditional>
            <output name="unalqueries">
                <assert_contents>
                    <has_line line="&gt;shuffled sequence that should go to unaligned"/>
                </assert_contents>
            </output>
            <output name="alqueries">
                <assert_contents>
                    <has_line line="&gt;NP_008227.1 cytochrome c oxidase subunit I (mitochondrion) [Pongo pygmaeus]"/>
                </assert_contents>
            </output>
            <output name="blast_tabular" file="diamond_results.tabular"/>
        </test>
        <!--Test 02 non-gz input, taxon list, no al and unal output, simple header -->
        <test expect_num_outputs="1">
            <conditional name="method_cond">
                <param name="method_select" value="blastp"/>
                <param name="comp_based_stats" value="1"/>
            </conditional>
            <param name="query" value="protein.fasta" ftype="fasta"/>
            <conditional name="ref_db_source">
                <param name="db_source" value="history"/>
                <param name="reference_database" value="db-wtax.dmnd"/>
            </conditional>
            <conditional name="tax_cond">
                <param name="tax_select" value="list"/>
                <param name="taxonlist" value="42"/>  <!-- the taxID needed to use here is printed during the execution of gen.sh (filter_and_map_ids.py) it is not a NCBI taxID-->
            </conditional>
            <section name="output_section">
                <conditional name="output">
                    <param name="outfmt" value="6"/>
                    <param name="fields" value="qseqid,sseqid,pident,length,mismatch,gapopen,qstart,qend,sstart,send,evalue,bitscore"/>
                    <param name="header" value="simple"/>
                </conditional>
            </section>
            <conditional name="sens_cond">
                <param name="sensitivity" value=""/>
            </conditional>
            <param name="matrix" value="BLOSUM62"/>
            <param name="masking" value="tantan"/>
            <conditional name="hit_filter">
                <param name="hit_filter_select" value="max"/>
                <param name="max_target_seqs" value="25"/>
            </conditional>
            <conditional name="filter_score">
                <param name="filter_score_select" value="evalue"/>
                <param name="evalue" value="0.001"/>
            </conditional>
            <param name="id" value="0"/>
            <param name="query_cover" value="0"/>
            <conditional name="sens_cond">
                <param name="block_size" value="2"/>
            </conditional>
            <output name="blast_tabular" file="diamond_results.wtax.tabular"/>
        </test>
        <!--Test 03 blastx, outfmt -->
        <test expect_num_outputs="1">
            <conditional name="method_cond">
                <param name="method_select" value="blastx"/>
                <param name="comp_based_stats" value="1"/>
                <conditional name="frameshift_cond">
                    <param name="frameshift_select" value="yes"/>
                </conditional>
            </conditional>
            <param name="query" value="nucleotide.fasta" ftype="fasta"/>
            <conditional name="ref_db_source">
                <param name="db_source" value="history"/>
                <param name="reference_database" value="db.dmnd"/>
            </conditional>
            <section name="output_section">
                <conditional name="output">
                    <param name="outfmt" value="0"/>
                </conditional>
            </section>
            <conditional name="sens_cond">
                <param name="sensitivity" value=""/>
            </conditional>
            <param name="matrix" value="BLOSUM62"/>
            <param name="masking" value="tantan"/>
            <conditional name="hit_filter">
                <param name="hit_filter_select" value="top"/>
                <param name="top" value="10"/>
            </conditional>
            <conditional name="filter_score">
                <param name="filter_score_select" value="min-score"/>
                <param name="min_score" value="1"/>
            </conditional>
            <param name="id" value="0"/>
            <param name="query_cover" value="0"/>
            <conditional name="sens_cond">
                <param name="block_size" value="2"/>
            </conditional>
            <output name="blast_tabular" file="diamond_results.pairwise"/>
        </test>
        <!--Test 04 outfmt daa -->
        <test expect_num_outputs="1">
            <conditional name="method_cond">
                <param name="method_select" value="blastp"/>
            </conditional>
            <param name="query" value="protein.fasta" ftype="fasta"/>
            <conditional name="ref_db_source">
                <param name="db_source" value="history"/>
                <param name="reference_database" value="db-wtax.dmnd"/>
            </conditional>
            <section name="output_section">
                <conditional name="output">
                    <param name="outfmt" value="100"/>
                </conditional>
            </section>
            <output name="daa_output" ftype="daa">
                <assert_contents>
                    <has_size size="5602" delta="10"/>
                </assert_contents>
            </output>
        </test>
        <!--Test 05 blastx w indexed diamond DB -->
        <test expect_num_outputs="1">
            <conditional name="method_cond">
                <param name="method_select" value="blastx"/>
                <param name="comp_based_stats" value="1"/>
                <conditional name="frameshift_cond">
                    <param name="frameshift_select" value="yes"/>
                </conditional>
            </conditional>
            <param name="query" value="nucleotide.fasta" ftype="fasta"/>
            <conditional name="ref_db_source">
                <param name="db_source" value="indexed"/>
                <param name="reference_database" value="testDb"/>
            </conditional>
            <section name="output_section">
                <conditional name="output">
                    <param name="outfmt" value="0"/>
                </conditional>
            </section>
            <conditional name="sens_cond">
                <param name="sensitivity" value=""/>
            </conditional>
            <param name="matrix" value="BLOSUM62"/>
            <param name="masking" value="tantan"/>
            <conditional name="hit_filter">
                <param name="hit_filter_select" value="top"/>
                <param name="top" value="10"/>
            </conditional>
            <conditional name="filter_score">
                <param name="filter_score_select" value="min-score"/>
                <param name="min_score" value="1"/>
            </conditional>
            <param name="id" value="0"/>
            <param name="query_cover" value="0"/>
            <conditional name="sens_cond">
                <param name="block_size" value="2"/>
            </conditional>
            <output name="blast_tabular" file="diamond_results.pairwise"/>
        </test>
        <!-- Test 06 iterate option-->
        <test expect_num_outputs="1">
            <conditional name="method_cond">
                <param name="method_select" value="blastx"/>
            </conditional>
            <param name="query" value="nucleotide.fasta" ftype="fasta"/>
            <conditional name="ref_db_source">
                <param name="db_source" value="indexed"/>
                <param name="reference_database" value="testDb"/>
            </conditional>
            <section name="advanced_section">
                <param name="iterate" value="true"/>
            </section>
            <section name="output_section">
                <conditional name="output">
                    <param name="outfmt" value="6"/>
                    <param name="fields" value="qseqid,sseqid,pident,length,mismatch,gapopen,qstart,qend,sstart,send,evalue,bitscore"/>
                    <param name="header" value="verbose"/>
                </conditional>
            </section>
            <!-- verbose header contains path -> allow for lines_diff 2, assert header line separately -->
            <output name="blast_tabular" file="diamond_results_iterate.tabular" lines_diff="2">
                <assert_contents>
                    <!-- TODO https://github.com/bbuchfink/diamond/issues/928 -->
                    <has_text text="# Invocation: diamond blastx" negate="true"/>
                    <has_text text="# Invocation:"/>
                </assert_contents>
            </output>
        </test>
        <!-- Test 07 swipe option-->
        <test expect_num_outputs="1">
            <conditional name="method_cond">
                <param name="method_select" value="blastx"/>
            </conditional>
            <param name="query" value="nucleotide.fasta" ftype="fasta"/>
            <conditional name="ref_db_source">
                <param name="db_source" value="indexed"/>
                <param name="reference_database" value="testDb"/>
            </conditional>
            <section name="advanced_section">
                <param name="swipe" value="true"/>
            </section>
            <section name="output_section">
                <conditional name="output">
                    <param name="outfmt" value="6"/>
                    <param name="fields" value="qseqid,sseqid,pident,length,mismatch,gapopen,qstart,qend,sstart,send,evalue,bitscore"/>
                </conditional>
            </section>
            <output name="blast_tabular" file="diamond_results_swipe.tabular"/>
        </test>
        <!--Test 08 algo option-->
        <test expect_num_outputs="1">
            <conditional name="method_cond">
                <param name="method_select" value="blastx"/>
            </conditional>
            <param name="query" value="nucleotide.fasta" ftype="fasta"/>
            <conditional name="ref_db_source">
                <param name="db_source" value="indexed"/>
                <param name="reference_database" value="testDb"/>
            </conditional>
            <section name="advanced_section">
                <param name="algo" value="1"/>
            </section>
            <section name="output_section">
                <conditional name="output">
                    <param name="outfmt" value="6"/>
                    <param name="fields" value="qseqid,sseqid,pident,length,mismatch,gapopen,qstart,qend,sstart,send,evalue,bitscore"/>
                </conditional>
            </section>
            <output name="blast_tabular" file="diamond_results_algorithm.tabular"/>
        </test>
        <!-- Test 09 global-ranking option -->
        <test expect_num_outputs="1">
            <conditional name="method_cond">
                <param name="method_select" value="blastx"/>
            </conditional>
            <param name="query" value="nucleotide.fasta" ftype="fasta"/>
            <conditional name="ref_db_source">
                <param name="db_source" value="indexed"/>
                <param name="reference_database" value="testDb"/>
            </conditional>
            <section name="advanced_section">
                <param name="global_ranking" value="10"/>
            </section>
            <section name="output_section">
                <conditional name="output">
                    <param name="outfmt" value="6"/>
                    <param name="fields" value="qseqid,sseqid,pident,length,mismatch,gapopen,qstart,qend,sstart,send,evalue,bitscore"/>
                </conditional>
            </section>
            <output name="blast_tabular" file="diamond_results_global_ranking.tabular"/>
        </test>
        <!--Test 10 max-hsps option-->
        <test expect_num_outputs="1">
            <conditional name="method_cond">
                <param name="method_select" value="blastx"/>
            </conditional>
            <param name="query" value="nucleotide.fasta" ftype="fasta"/>
            <conditional name="ref_db_source">
                <param name="db_source" value="indexed"/>
                <param name="reference_database" value="testDb"/>
            </conditional>
            <section name="output_section">
                <param name="max_hsps" value="10"/>
                <conditional name="output">
                    <param name="outfmt" value="6"/>
                    <param name="fields" value="qseqid,sseqid,pident,length,mismatch,gapopen,qstart,qend,sstart,send,evalue,bitscore"/>
                </conditional>
            </section>
            <output name="blast_tabular" file="diamond_results_max_hsps.tabular"/>
        </test>
        <!--Test 11 seed-cut option-->
        <test expect_num_outputs="1">
            <conditional name="method_cond">
                <param name="method_select" value="blastx"/>
            </conditional>
            <param name="query" value="nucleotide.fasta" ftype="fasta"/>
            <conditional name="ref_db_source">
                <param name="db_source" value="indexed"/>
                <param name="reference_database" value="testDb"/>
            </conditional>
            <section name="advanced_section">
                <param name="seed_cut" value="100"/>
            </section>
            <section name="output_section">
                <conditional name="output">
                    <param name="outfmt" value="6"/>
                    <param name="fields" value="qseqid,sseqid,pident,length,mismatch,gapopen,qstart,qend,sstart,send,evalue,bitscore"/>
                </conditional>
            </section>
            <output name="blast_tabular" file="diamond_results_seed_cut.tabular"/>
        </test>
        <!--Test 12 freq-masking option-->
        <test expect_num_outputs="1">
            <conditional name="method_cond">
                <param name="method_select" value="blastx"/>
            </conditional>
            <param name="query" value="nucleotide.fasta" ftype="fasta"/>
            <conditional name="ref_db_source">
                <param name="db_source" value="indexed"/>
                <param name="reference_database" value="testDb"/>
            </conditional>
            <section name="advanced_section">
                <param name="freq_masking" value="true"/>
            </section>
            <section name="output_section">
                <conditional name="output">
                    <param name="outfmt" value="6"/>
                    <param name="fields" value="qseqid,sseqid,pident,length,mismatch,gapopen,qstart,qend,sstart,send,evalue,bitscore"/>
                </conditional>
            </section>
            <output name="blast_tabular" file="diamond_results_freq_masking.tabular"/>
        </test>
        <!--Test 13 motif-masking option-->
        <test expect_num_outputs="1">
            <conditional name="method_cond">
                <param name="method_select" value="blastx"/>
            </conditional>
            <param name="query" value="nucleotide.fasta" ftype="fasta"/>
            <conditional name="ref_db_source">
                <param name="db_source" value="indexed"/>
                <param name="reference_database" value="testDb"/>
            </conditional>
            <section name="advanced_section">
                <param name="motif_masking" value="0"/>
            </section>
            <section name="output_section">
                <conditional name="output">
                    <param name="outfmt" value="6"/>
                    <param name="fields" value="qseqid,sseqid,pident,length,mismatch,gapopen,qstart,qend,sstart,send,evalue,bitscore"/>
                </conditional>
            </section>
            <output name="blast_tabular" file="diamond_results_motif_masking.tabular"/>
        </test>
        <!--Test 14 soft-masking option-->
        <test expect_num_outputs="1">
            <conditional name="method_cond">
                <param name="method_select" value="blastx"/>
            </conditional>
            <param name="query" value="nucleotide.fasta" ftype="fasta"/>
            <conditional name="ref_db_source">
                <param name="db_source" value="indexed"/>
                <param name="reference_database" value="testDb"/>
            </conditional>
            <section name="advanced_section">
                <param name="soft_masking" value="0"/>
            </section>
            <section name="output_section">
                <conditional name="output">
                    <param name="outfmt" value="6"/>
                    <param name="fields" value="qseqid,sseqid,pident,length,mismatch,gapopen,qstart,qend,sstart,send,evalue,bitscore"/>
                </conditional>
            </section>
            <output name="blast_tabular" file="diamond_results_soft_masking.tabular"/>
        </test>
        <!--Test 15 soft-masking option seg -->
        <test expect_num_outputs="1">
            <conditional name="method_cond">
                <param name="method_select" value="blastx"/>
            </conditional>
            <param name="query" value="nucleotide.fasta" ftype="fasta"/>
            <conditional name="ref_db_source">
                <param name="db_source" value="indexed"/>
                <param name="reference_database" value="testDb"/>
            </conditional>
            <section name="advanced_section">
                <param name="soft_masking" value="seg"/>
            </section>
            <section name="output_section">
                <conditional name="output">
                    <param name="outfmt" value="6"/>
                    <param name="fields" value="qseqid,sseqid,pident,length,mismatch,gapopen,qstart,qend,sstart,send,evalue,bitscore"/>
                </conditional>
            </section>
            <output name="blast_tabular" file="diamond_results_soft_masking_seg.tabular"/>
        </test>
        <!--Test 16 Log option-->
        <test expect_num_outputs="2">
            <conditional name="method_cond">
                <param name="method_select" value="blastx"/>
            </conditional>
            <param name="query" value="nucleotide.fasta" ftype="fasta"/>
            <conditional name="ref_db_source">
                <param name="db_source" value="indexed"/>
                <param name="reference_database" value="testDb"/>
            </conditional>
            <section name="output_section">
                <conditional name="output">
                    <param name="outfmt" value="6"/>
                    <param name="fields" value="qseqid,sseqid,pident,length,mismatch,gapopen,qstart,qend,sstart,send,evalue,bitscore"/>
                </conditional>
                <param name="log" value="true"/>
            </section>
            <output name="blast_tabular" file="diamond_results_log_test.tabular"/>
            <output name="log_file">
                <assert_contents>
                    <has_n_lines n="375"/>
                    <has_text text="diamond blastx"/>
                    <has_text text="--log"/>
                    <has_line line="Sequences = 6, letters = 3076, average length = 512"/>
                </assert_contents>
            </output>
        </test>

        <!--Test 17 test against cached BLAST DB + NO NCBI taxonomy which works as long as (certain) tax columns are not selected in outputs-->
        <test expect_num_outputs="1">
            <conditional name="method_cond">
                <param name="method_select" value="blastp"/>
                <param name="comp_based_stats" value="1"/>
            </conditional>
            <param name="query" value="protein.fasta.gz" ftype="fasta.gz"/>
            <conditional name="ref_db_source">
                <param name="db_source" value="blast"/>
                <param name="reference_database" value="test"/>
            </conditional>
            <conditional name="tax_cond">
                <param name="tax_select" value="list"/>
                <param name="taxonlist" value="2,2759"/> <!-- simulate tax filtering ..  -->
            </conditional>
            <section name="output_section">
                <conditional name="output">
                    <param name="outfmt" value="6"/>
                    <param name="fields" value="qseqid,sseqid,pident,length,mismatch,gapopen,qstart,qend,sstart,send,evalue,bitscore,scovhsp,staxids,cigar"/>
                </conditional>
            </section>
            <conditional name="sens_cond">
                <param name="sensitivity" value=""/>
            </conditional>
            <param name="matrix" value="BLOSUM62"/>
            <param name="masking" value="seg"/>
            <conditional name="hit_filter">
                <param name="hit_filter_select" value="max"/>
                <param name="max_target_seqs" value="25"/>
            </conditional>
            <conditional name="filter_score">
                <param name="filter_score_select" value="evalue"/>
                <param name="evalue" value="0.001"/>
            </conditional>
            <param name="id" value="0"/>
            <param name="query_cover" value="0"/>
            <conditional name="sens_cond">
                <param name="block_size" value="2"/>
            </conditional>
            <output name="blast_tabular">
                <assert_contents>
                    <has_n_columns n="15"/>
                    <has_n_lines n="5"/>
                </assert_contents>
            </output>
            <assert_command>
                <!-- ensure that NCBI taxonomy is really not used-->
                <has_text text="nodes.dmp" negate="true"/>
                <has_text text="names.dmp" negate="true"/>
            </assert_command>
        </test>

        <!--Test 18 test blastx against cached BLAST DB  + tax columns in output + tax filtering file (tetrapoda and ray finned fished should result in mouse, human, zebra fish) -->
        <test expect_num_outputs="1">
            <conditional name="method_cond">
                <param name="method_select" value="blastp"/>
                <param name="comp_based_stats" value="1"/>
            </conditional>
            <param name="query" value="protein.fasta.gz" ftype="fasta.gz"/>
            <conditional name="ref_db_source">
                <param name="db_source" value="blast"/>
                <param name="reference_database" value="test"/>
                <param name="ncbi_taxonomy" value="test"/>
            </conditional>
            <conditional name="tax_cond">
                <param name="tax_select" value="file"/>
                <param name="taxonlist" value="taxon.tsv"/>
            </conditional>
            <section name="output_section">
                <conditional name="output">
                    <param name="outfmt" value="6"/>
                    <param name="fields" value="qseqid,sseqid,pident,length,mismatch,gapopen,qstart,qend,sstart,send,evalue,bitscore,scovhsp,sskingdoms,skingdoms,sphylums,cigar"/>
                </conditional>
            </section>
            <conditional name="sens_cond">
                <param name="sensitivity" value=""/>
            </conditional>
            <param name="matrix" value="BLOSUM62"/>
            <param name="masking" value="seg"/>
            <conditional name="hit_filter">
                <param name="hit_filter_select" value="max"/>
                <param name="max_target_seqs" value="25"/>
            </conditional>
            <conditional name="filter_score">
                <param name="filter_score_select" value="evalue"/>
                <param name="evalue" value="0.001"/>
            </conditional>
            <param name="id" value="0"/>
            <param name="query_cover" value="0"/>
            <conditional name="sens_cond">
                <param name="block_size" value="2"/>
            </conditional>
            <output name="blast_tabular">
                <assert_contents>
                    <has_n_columns n="17"/>
                    <has_n_lines n="3"/>
                    <has_text text="Metazoa" n="3"/>
                    <has_text text="Viridiplantae" n="0"/>
                </assert_contents>
            </output>
        </test>

        <!--Test 19 outfmt json -->
        <test expect_num_outputs="1">
            <conditional name="method_cond">
                <param name="method_select" value="blastp"/>
            </conditional>
            <param name="query" value="protein.fasta" ftype="fasta"/>
            <conditional name="ref_db_source">
                <param name="db_source" value="history"/>
                <param name="reference_database" value="db-wtax.dmnd"/>
            </conditional>
            <section name="output_section">
                <conditional name="output">
                    <param name="outfmt" value="104"/>
                    <param name="fields" value="qseqid,sseqid,pident,length,mismatch,gapopen,qstart,qend,sstart,send,evalue,bitscore,hspnum"/>
                </conditional>
            </section>
            <output name="json_output" value="diamond_results.json" ftype="json">
                <assert_contents>
                    <has_text text="hspnum"/>
                </assert_contents>
            </output>
        </test>
    </tests>
    <help>
<![CDATA[

**What it does**

DIAMOND_ is a new alignment tool for aligning full length protein sequences in ``blastp`` mode 
or DNA sequences in ``blastx`` (e.g. >100kb reads by using frameshift alignment mode) against
reference databases such as NCBI-NR.
On Illumina reads of length 100-150bp, in fast mode, DIAMOND is about 20,000 times faster than BLASTX, while reporting
about 80-90% of all matches that BLASTX finds, with an e-value of at most 1e-5. In sensitive mode, DIAMOND ist about 2,500
times faster than BLASTX, finding more than 94% of all matches.

The DIAMOND algorithm is designed for the alignment of large datasets. The algorithm is not efficient for a small number of query sequences or only a single one of them, and speed will be low. BLAST is recommended for small datasets.

.. _DIAMOND: http://ab.inf.uni-tuebingen.de/software/diamond/

**Input**

Input data is a large protein or nucleotide sequence file.


**Output**

Diamond gives you a tabular output file with 12 columns:

Column 	Description
1 	    Query Seq-id (ID of your sequence)
2 	    Subject Seq-id (ID of the database hit)
3 	    Percentage of identical matches
4 	    Alignment length
5 	    Number of mismatches
6 	    Number of gap openings
7 	    Start of alignment in query
8 	    End of alignment in query
9 	    Start of alignment in subject (database hit)
10 	    End of alignment in subject (database hit)
11 	    Expectation value (E-value)
12 	    Bit score


Supported values for gap open and gap extend parameters depending on the selected scoring matrix.

========  ============================================
Matrix    Supported values for (gap open)/(gap extend)
========  ============================================
BLOSUM45  (10-13)/3; (12-16)/2; (16-19)/1
BLOSUM50  (9-13)/3; (12-16)/2; (15-19)/1
BLOSUM62  (6-11)/2; (9-13)/1
BLOSUM80  (6-9)/2; 13/2; 25/2; (9-11)/1
BLOSUM90  (6-9)/2; (9-11)/1
PAM250    (11-15)/3; (13-17)/2; (17-21)/1
PAM70     (6-8)/2; (9-11)/1
PAM30     (5-7)/2; (8-10)/1
========  ============================================


]]>
    </help>
    <expand macro="citations"/>
</tool>
