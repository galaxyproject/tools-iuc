<tool id="bg_diamond" name="Diamond" version="@TOOL_VERSION@+galaxy@VERSION_SUFFIX@" profile="19.01">
    <description>alignment tool for short sequences against a protein database</description>
    <macros>
        <import>macros.xml</import>
    </macros>
    <xrefs>
        <xref type="bio.tools">diamond</xref>
    </xrefs>
    <expand macro="requirements" />
    <expand macro="stdio" />
    <expand macro="version_command" />
    <command detect_errors="aggressive">
<![CDATA[

    #if $ref_db_source.db_source == "history":
        ln -s $ref_db_source.reference_database ./database.dmnd
    #else:
        ln -s ${ref_db_source.index.fields.db_path} ./database.dmnd
    #end if

    &&

    diamond
        $method_cond.method_select
        --quiet
        --threads "\${GALAXY_SLOTS:-12}"
        --db ./database
        --query '$query'
        #if $method_cond.method_select == "blastx"
          --query-gencode '$method_cond.query_gencode'
          --strand '$method_cond.query_strand'
          --min-orf $method_cond.min_orf
          #if $method_cond.frameshift_cond.frameshift_select == 'yes'
            --frameshift $method_cond.frameshift_cond.frameshift
            $method_cond.frameshift_cond.range_culling
          #end if
        #else if $method_cond.method_select == "blastp"
            $method_cond.no_self_hits
        #end if

        @OUTPUT_ARGS@

        #if $output_section.output.outfmt != '100'
            --compress '0'
        #end if
        $sens_cond.sensitivity
        $iterate
        --algo $algo
        #if $global_ranking
            --global-ranking $global_ranking
        #end if
        #if str($gapopen) != "":
          --gapopen '$gapopen'
        #end if
        #if str($gapextend) != "":
          --gapextend '$gapextend'
        #end if
        --matrix '$matrix'
        --comp-based-stats '$method_cond.comp_based_stats'
        --masking '$masking'

        @HITFILTER_ARGS@

        #if str($filter_score.filter_score_select) == 'evalue':
            --evalue '$filter_score.evalue'
        #else:
            --min-score '$filter_score.min_score'
        #end if

        --id '$id'
        --query-cover '$query_cover'
        --subject-cover '$subject_cover'
        --block-size '$sens_cond.block_size'
        #if $output_section.output_unal
            #if "--un" in $output_section.output_unal
                --un '$unalqueries'
                #if $query.ext.startswith("fasta"):
                    --unfmt fasta
                #else
                    --unfmt fastq
                #end if
            #end if
            #if "--al" in $output_section.output_unal
                --al '$alqueries'
                #if $query.ext.startswith("fasta"):
                    --alfmt fasta
                #else
                    --alfmt fastq
                #end if
            #end if
        #end if
        #if $output_section.max_hsps
            --max-hsps $output_section.max_hsps
        #end if
        #if $tax_cond.tax_select == 'file':
            --taxonlist `cat '$tax_cond.taxonlistfile' | grep -v "^#" | grep -v "^$" | tr "\n" "," | sed 's/,$//'`
        #else if  $tax_cond.tax_select == 'list':
            --taxonlist '$tax_cond.taxonlist'
        #end if
        #if $advanced_section.seed_cut
            --seed-cut $advanced_section.seed_cut
        #end if
        $advanced_section.freq_masking
        --motif-masking $advanced_section.motif_masking
]]>
    </command>
    <inputs>
        <conditional name="method_cond">
            <param name="method_select" type="select" label="Alignment mode" help="(blastp/blastx)">
                <option value="blastp">Amino acid query sequences (blastp)</option>
                <option value="blastx">DNA query sequences (blastx)</option>
            </param>
            <when value="blastx">
                <param argument="--query-gencode" type="select" label="Genetic code used for translation of query in BLASTX mode" help="">
                    <option value="1">Standard Code</option>
                    <option value="2">Vertebrate Mitochondrial Code</option>
                    <option value="3">Yeast Mitochondrial Code</option>
                    <option value="4">Mold, Protozoan, and Coelenterate Mitochondrial Code and the Mycoplasma/Spiroplasma Code</option>
                    <option value="5">Invertebrate Mitochondrial Code</option>
                    <option value="6">Ciliate, Dasycladacean and Hexamita Nuclear Code</option>
                    <option value="9">Echinoderm and Flatworm Mitochondrial Code</option>
                    <option value="10">Euplotid Nuclear Code</option>
                    <option value="11">Bacterial, Archaeal and Plant Plastid Code</option>
                    <option value="12">Alternative Yeast Nuclear Code</option>
                    <option value="13">Ascidian Mitochondrial Code</option>
                    <option value="14">Alternative Flatworm Mitochondrial Code</option>
                    <option value="16">Chlorophycean Mitochondrial Code</option>
                    <option value="21">Trematode Mitochondrial Code</option>
                    <option value="22">Scenedesmus obliquus Mitochondrial Code</option>
                    <option value="23">Thraustochytrium Mitochondrial Code</option>
                    <option value="24">Pterobranchia Mitochondrial Code</option>
                    <option value="25">Candidate Division SR1 and Gracilibacteria Code</option>
                    <option value="26">Pachysolen tannophilus Nuclear Code</option>
                </param>
                <param argument="--min-orf" type="integer" value="1" label="ignore translated sequences without an open reading frame of at least this length" help="By default this feature is disabled for sequences of length below 30, set to 20 for sequences of length below 100, and set to 40 otherwise. Setting this option to 1 will disable this feature" />
                
                <param name="query_strand" argument="--strand" type="select" label="query strands to search" help="">
                    <option value="both" selected="True">Both</option>
                    <option value="plus">Plus</option>
                    <option value="minus">Minus</option>
                </param>
                <conditional name="frameshift_cond">
                    <param name="frameshift_select" type="select" label="Allow for frameshifts?" help="">
                        <option value="yes">yes</option>
                        <option value="no" selected="true">no</option>
                    </param>
                    <when value="yes">
                        <param argument="--range-culling" type="boolean" truevalue="--range-culling" falsevalue="" checked="false" label="restrict hit culling to overlapping query ranges" help="This feature is designed for long query DNA sequences that may span several genes. In these cases, the default of reporting the 25 best overall hits could cause hits to a lower scoring gene to be overshadowed. But just increasing the number of alignments reported will bloat the output size and reduce performance. Using this feature along with -k 25 (default), a hit will only be deleted if at least 50% of its query range is spanned by at least 25 higher or equal scoring hits. Using this feature along with --top 10, a hit will only be deleted if its score is more than 10% lower than that of a higher scoring hit over at least 50% of its query range. The percentage is configurable using --range-cover. Note that this feature is currently only available in frameshift alignment mode"/>
                        <param argument="--frameshift" type="integer" value="0" label="frame shift penalty" help="Values around 15 are reasonable for this parameter. Enabling this feature will have the aligner tolerate missing bases in DNA sequences and is most recommended for long, error-prone sequences like MinION reads. In the pairwise output format, frameshifts will be indicated by \ and / for a shift by +1 and -1 nucleotide in the direction of translation respectively." />
                    </when>
                    <when value="no"/>
                </conditional>

                <param argument="--comp-based-stats" type="select" label="Composition based statistics" help="Compositionally biased sequences often cause false positive matches, which are effectively filtered by this algorithm in a way similar to the composition based statistics used by BLAST">
                    <option value="0">Disable</option>
                    <option value="1" selected="True">Default mode (Hauser, 2016)</option>
                </param>
            </when>
            <when value="blastp">
                <param argument="--no-self-hits" type="boolean" truevalue="--no-self-hits" falsevalue="" checked="true" 
                    label="Suppress reporting of identical self-hits between sequences" 
                    help="The FASTA sequence identifiers as well as the sequences of query and target need to be identical for a hit to be deleted"/>

                <param argument="--comp-based-stats" type="select" label="Composition based statistics" help="Compositionally biased sequences often cause false positive matches, which are effectively filtered by this algorithm in a way similar to the composition based statistics used by BLAST">
                    <option value="0">Disable</option>
                    <option value="1" selected="True">Default mode (Hauser, 2016)</option>
                    <option value="2">Compositional matrix adjust conditioned on sequence properties, simplified (Yu, 2005)</option>
                    <option value="3">Compositional matrix adjust conditioned on sequence properties (Yu, 2005)</option>
                    <option value="4">Compositional matrix adjust unconditionally (Yu, 2005)</option>
                </param>
            </when>
        </conditional>
        <param argument="--query" type="data" format="fasta,fastq" label="Input query file in FASTA or FASTQ format" />
        <conditional name="ref_db_source">
            <param name="db_source" type="select" label="Will you select a reference database from your history or use a built-in index?" help="Built-ins were indexed using default options">
                <option value="indexed">Use a built-in index</option>
                <option value="history">Use one from the history</option>
            </param>
            <when value="indexed">
                <param name="index" type="select" label="Select a reference database" help="If your database of interest is not listed, contact your Galaxy admin">
                    <options from_data_table="diamond_database">
                        <filter type="sort_by" column="2"/>
                        <validator type="no_options" message="No indexes are available for the selected input dataset"/>
                    </options>
                </param>
            </when>
            <when value="history">
                <param name="reference_database" argument="--db" type="data" format="dmnd" label="Select the reference database" />
            </when>
        </conditional>
        <conditional name="tax_cond">
            <param name="tax_select" type="select" label="Restrict search taxonomically?" help="Any taxonomic rank can be used, and only reference sequences matching one of the specified taxon ids will be searched against.">
                <option value="no" selected="True">No</option>
                <option value="list">List of taxids entered manually</option>
                <option value="file">List of taxids from single column tabular file</option>
            </param>
            <when value="no"/>
            <when value="list">
                <param name="taxonlist" argument="--taxonlist" type="text" value="" label="Comma separated list of taxon ids" help="">
                    <validator type="regex" message="Taxonlist needs to be a comma separated list of integers">[0-9,]*</validator>
                </param>
            </when>
            <when value="file">
                <param name="taxonlistfile" argument="--taxonlist" type="data" format="tabular" label="Keep alignments within the given percentage range of the top alignment score for a quer" help="" />
            </when>
        </conditional>
        <conditional name="sens_cond">
            <param name='sensitivity' type="select" label="Sensitivity Mode" help="Choose one of the sensitivity modes. The default mode is mainly designed for short read alignment, i.e. finding significant matches of >50 bits on 30-40aa fragments. The sensitive mode is a lot more sensitive than the default and generally recommended for aligning longer sequences. The more sensitive mode provides even more sensitivity. More sensitivity may increase computation time.">
                <option value="--fast">Fast (--fast)</option>
                <option value="" selected="True">Default</option>
                <option value="--mid-sensitive">Mid Sensitive (--mid-sensitive)</option>
                <option value="--sensitive">Sensitive (--sensitive)</option>
                <option value="--more-sensitive">More Sensitive (--more-sensitive)</option>
                <option value="--very-sensitive">Very Sensitive (--very-sensitive)</option>
                <option value="--ultra-sensitive">Ultra Sensitive (--ultra-sensitive)</option>
            </param>
            <when value="--fast">
                <expand macro="block_size_low_sens"/>
            </when>
            <when value="">
                <expand macro="block_size_low_sens"/>
            </when>
            <when value="--mid-sensitive">
                <expand macro="block_size_low_sens"/>
            </when>
            <when value="--sensitive">
                <expand macro="block_size_low_sens"/>
            </when>
            <when value="--more-sensitive">
                <expand macro="block_size_low_sens"/>
            </when>
            <when value="--very-sensitive">
                <expand macro="block_size_hi_sens"/>
            </when>
            <when value="--ultra-sensitive">
                <expand macro="block_size_hi_sens"/>
            </when>
        </conditional>
        <param argument="--matrix" type="select" label="Scoring matrix" help="In parentheses are the supported values for (gap open)/(gap extend). In brackets are default gap penalties">
            <option value="BLOSUM45">BLOSUM45 ((10-13)/3; (12-16)/2; (16-19)/1) [14/2]</option>
            <option value="BLOSUM50">BLOSUM50 ((9-13)/3; (12-16)/2; (15-19)/1) [13/2]</option>
            <option value="BLOSUM62" selected="True">BLOSUM62 ((6-11)/2; (9-13)/1) [11/1]</option>
            <option value="BLOSUM80">BLOSUM80 ((6-9)/2; 13/2; 25/2; (9-11)/1) [10/1]</option>
            <option value="BLOSUM90">BLOSUM90 ((6-9)/2; (9-11)/1) [10/1]</option>
            <option value="PAM250">PAM250 ((11-15)/3; (13-17)/2; (17-21)/1) [14/2]</option>
            <option value="PAM70">PAM70 ((6-8)/2; (9-11)/1) [10/1]</option>
            <option value="PAM30">PAM30 ((5-7)/2; (8-10)/1) [9/1]</option>
        </param>
        <param argument="--gapopen" type="integer" optional="True" value="" label="Gap open penalty" help="Leave empty for default (see scoring matrix)" />
        <param argument="--gapextend" type="integer" optional="True" value="" label="Gap extension penalty" help="Leave empty for default (see scoring matrix)" />
        <param argument="--masking" type="select" label="Masking algorithm" help="DIAMOND by default applies the tantan repeat masking algorithm to the query and target sequences as described in (Frith, 2011). 
            This masking procedure increases the specificity of alignments and serves to filter out spurious hits. Note that when using --comp-based-stats (2,3,4), tantan masking is disabled by default.">
            <option value="0">Disabled</option>
            <option value="1" selected="true">Tantan</option>
            <option value="seg">SEG</option>
        </param>
        <conditional name="filter_score">
            <param name="filter_score_select" type="select" label="Method to filter?" help="(--evalue/--min-score)">
                <option value="evalue" selected="True">Maximum e-value to report alignments</option>
                <option value="min-score">Minimum bit score to report alignments</option>
            </param>
            <when value="evalue">
                <param argument="--evalue" type="float" value="0.001" label="Maximum expected value to keep an alignment" />
            </when>
            <when value="min-score">
                <param name="min_score" argument="--min-score" type="integer" value="0" label="Minimum bit score to keep an alignment" help="(--min-score)" />
            </when>
        </conditional>
        <param argument="--iterate" type="boolean" truevalue="--iterate" falsevalue="" checked="false" 
            label="Run multiple rounds of searches with increasing sensitivity" help="he query dataset will first be searched at a lower sensitivity setting, only searching those query sequences at 
                the target sensitivity that fail to produce a significant alignment at a lower sensitivity." />
        <param argument="--algo" type="select" label="Algorithm for seed search" help="Double-indexed is the main algorithm of the program, designed for large input files but less efficient for small 
            query files. Query-indexed and improves performance for small query files. This mode will be automatically triggered based on the input. Contiguous-seed mode and further improves performance
            for small query files. The modes differ slightly in their sensitivity, so results are not guaranteed to be 100% identical for different settings of this option.">
            <option value="0">Doble-indexed (0)</option>
            <option value="1">Query-indexed (1)</option>
            <option value="ctg">Contiguous-seed mode (ctg)</option>
        </param>
        <expand macro="hit_filter_macro" />
        <param argument="--global-ranking" type="integer" min="0" value="" optional="true" 
            label="Limit on the number of Smith Waterman extensions" help="Target sequences will be ranked according to their ungapped extension scores at seed hits, and gapped extensions will only 
                be computed for the best N targets for each query. Note that this option increases memory use." />
        <param argument="--id" type="integer" value="0" label="Minimum identity percentage to report an alignment" help="Report only alignments above the given percentage of sequence identity" />
        <param argument="--query-cover" type="integer" value="0" label="Minimum query cover percentage to report an alignment" help="Report only alignments above the given percentage of query cover" />
        <param argument="--subject-cover" type="integer" value="0" label="Minimum subject cover percentage to report an alignment" help="Report only alignments above the given percentage of subject cover"/>
        <section name="output_section" title="Output options">
            <param argument="--max-hsps" type="integer" min="0" optional="true" label="Maximum number of HSPs" 
                help="The maximum number of HSPs (High-Scoring Segment Pairs) per target sequence to report for each query. The default policy is to report only the highest-scoring 
                    HSP for each target, while disregarding alternative, lower-scoring HSPs that are contained in the same target." />
            <expand macro="output_type_macro">
                <!-- Taxonomy features are not supported for the DAA format (i.e.
                        can't be used in diamond view) -->
                <option value="staxids">unique Subject Taxonomy ID(s), separated by a ';' (in numerical order)</option>
                <option value="sskingdoms">Subject super kingdoms</option>
                <option value="skingdoms">Subject kingdoms</option>
                <option value="sphylums">Subject phylums</option>
            </expand>
            <param name="output_unal" type="select" optional="true" multiple="true" label="Output aligned/unaligned queries to separate file" help="">
                <option value="--un">Output unaligned queries (--un)</option>
                <option value="--al">Output alaligned queries (--al)</option>
            </param>
        </section>
        <section name="advanced_section" title="Advanced options" expanded="false">
            <param argument="--seed-cut" type="float" min="0" optional="true" label="Set a complexity cutoff for indexed seeds"/>
            <param argument="--freq-masking" type="boolean" truevalue="--freq-masking" falsevalue="" checked="false" label="Enable masking seeds based on frequency" help="This option is incompatible with --sed-cut" />
            <param argument="--motif-masking" type="select" label="Softmask abundant motifs" help="Enable or disable motif masking">
                <option value="0">Disabled</option>
                <option value="1">Enabled</option>
            </param>
        </section>
    </inputs>
    <outputs>
        <expand macro="output_macro" />
        <data format_source="query" name="unalqueries" label="${tool.name} on ${on_string}: unaligned queries">
            <filter>output_section['output_unal'] and "--un" in output_section['output_unal']</filter>
        </data>
        <data format_source="query" name="alqueries" label="${tool.name} on ${on_string}: aligned queries">
            <filter>output_section['output_unal'] and "--un" in output_section['output_unal']</filter>
        </data>
    </outputs>
    <tests>
        <!--Test 01-->
        <test expect_num_outputs="3">
            <conditional name="method_cond">
                <param name="method_select" value="blastp" />
            </conditional>
            <param name="query" value="protein.fasta" ftype="fasta"/>
            <conditional name="ref_db_source">
                <param name="db_source" value="history"/>
                <param name="reference_database" value="db-wtax.dmnd"/>
            </conditional>
            <section name="output_section">
                <conditional name="output">
                    <param name="outfmt" value="6"/>
                    <!-- removed ,cigar from test: https://github.com/bbuchfink/diamond/issues/532 -->
                    <param name="fields" value="qseqid,sseqid,pident,length,mismatch,gapopen,qstart,qend,sstart,send,evalue,bitscore,scovhsp,sskingdoms,skingdoms,sphylums"/>
                    <param name="unal" value="true"/>
                </conditional>
            </section>
            <conditional name="sens_cond">
                <param name="sensitivity" value=""/>
            </conditional>
            <param name="matrix" value="BLOSUM62"/>
            <param name="comp_based_stats" value="1"/>
            <param name="masking" value="1"/>
            <conditional name="hit_filter">
                <param name="hit_filter_select" value="max"/>
                <param name="max_target_seqs" value="25" />
            </conditional>
            <conditional name="filter_score">
                <param name="filter_score_select" value="evalue"/>
                <param name="evalue" value="0.001" />
            </conditional>
            <param name="id" value="0"/>
            <param name="query_cover" value="0"/>
            <conditional name="sens_cond">
                <param name="block_size" value="2"/>
            </conditional>
            <param name="output_unal" value="--al,--un"/>
            <output name="unalqueries">
                <assert_contents>
                    <has_line line=">shuffled sequence that should go to unaligned"/>
                </assert_contents>
            </output>
            <output name="alqueries">
                <assert_contents>
                    <has_line line=">sequence more text"/>
                </assert_contents>
            </output>
            <output name="blast_tabular" file="diamond_results.tabular"/>
        </test>
        <!--Test 02-->
        <test expect_num_outputs="1">
            <conditional name="method_cond">
                <param name="method_select" value="blastp" />
            </conditional>
            <param name="query" value="protein.fasta" ftype="fasta"/>
            <conditional name="ref_db_source">
                <param name="db_source" value="history"/>
                <param name="reference_database" value="db-wtax.dmnd"/>
            </conditional>
            <conditional name="tax_cond">
                <param name="tax_select" value="list"/>
                <param name="taxonlist" value="2" />
            </conditional>
            <section name="output_section">
                <conditional name="output">
                    <param name="outfmt" value="6"/>
                    <param name="fields" value="qseqid,sseqid,pident,length,mismatch,gapopen,qstart,qend,sstart,send,evalue,bitscore"/>
                </conditional>
            </section>
            <conditional name="sens_cond">
                <param name="sensitivity" value=""/>
            </conditional>
            <param name="matrix" value="BLOSUM62"/>
            <param name="comp_based_stats" value="1"/>
            <param name="masking" value="1"/>
            <conditional name="hit_filter">
                <param name="hit_filter_select" value="max"/>
                <param name="max_target_seqs" value="25" />
            </conditional>
            <conditional name="filter_score">
                <param name="filter_score_select" value="evalue"/>
                <param name="evalue" value="0.001" />
            </conditional>
            <param name="id" value="0"/>
            <param name="query_cover" value="0"/>
            <conditional name="sens_cond">
                <param name="block_size" value="2"/>
            </conditional>
            <output name="blast_tabular" file="diamond_results.wtax.tabular"/>
        </test>
        <!--Test 03-->
        <test expect_num_outputs="1">
            <conditional name="method_cond">
                <param name="method_select" value="blastx" />
                <conditional name="frameshift_cond">
                    <param name="frameshift_select" value="yes"/>
                </conditional>
            </conditional>
            <param name="query" value="nucleotide.fasta" ftype="fasta"/>
            <conditional name="ref_db_source">
                <param name="db_source" value="history"/>
                <param name="reference_database" value="db.dmnd"/>
            </conditional>
            <section name="output_section">
                <conditional name="output">
                    <param name="outfmt" value="0"/>
                </conditional>
            </section>
            <conditional name="sens_cond">
                <param name="sensitivity" value=""/>
            </conditional>
            <param name="matrix" value="BLOSUM62"/>
            <param name="comp_based_stats" value="1"/>
            <param name="masking" value="1"/>
            <conditional name="hit_filter">
                <param name="hit_filter_select" value="top"/>
                <param name="top" value="10" />
            </conditional>
            <conditional name="filter_score">
                <param name="filter_score_select" value="min-score"/>
                <param name="min_score" value="1" />
            </conditional>
            <param name="id" value="0"/>
            <param name="query_cover" value="0"/>
            <conditional name="sens_cond">
                <param name="block_size" value="2"/>
            </conditional>
            <output name="blast_tabular" file="diamond_results.pairwise"/>
        </test>
        <!--Test 04-->
        <test expect_num_outputs="1">
            <conditional name="method_cond">
                <param name="method_select" value="blastp" />
            </conditional>
            <param name="query" value="protein.fasta" ftype="fasta"/>
            <conditional name="ref_db_source">
                <param name="db_source" value="history"/>
                <param name="reference_database" value="db-wtax.dmnd"/>
            </conditional>
            <section name="output_section">
                <conditional name="output">
                    <param name="outfmt" value="100"/>
                    <param name="salltitles" value="false"/>
                    <param name="sallseqid" value="false"/>
                </conditional>
            </section>
            <output name="daa_output" file="diamond_results.daa" compare="sim_size" delta="10"/>
        </test>
        <!--Test 05-->
        <test expect_num_outputs="1">
            <conditional name="method_cond">
                <param name="method_select" value="blastx" />
                <conditional name="frameshift_cond">
                    <param name="frameshift_select" value="yes"/>
                </conditional>
            </conditional>
            <param name="query" value="nucleotide.fasta" ftype="fasta"/>
            <conditional name="ref_db_source">
                <param name="db_source" value="indexed"/>
                <param name="index" value="testDb"/>
            </conditional>
            <section name="output_section">
                <conditional name="output">
                    <param name="outfmt" value="0"/>
                </conditional>
            </section>
            <conditional name="sens_cond">
                <param name="sensitivity" value=""/>
            </conditional>
            <param name="matrix" value="BLOSUM62"/>
            <param name="comp_based_stats" value="1"/>
            <param name="masking" value="1"/>
            <conditional name="hit_filter">
                <param name="hit_filter_select" value="top"/>
                <param name="top" value="10" />
            </conditional>
            <conditional name="filter_score">
                <param name="filter_score_select" value="min-score"/>
                <param name="min_score" value="1" />
            </conditional>
            <param name="id" value="0"/>
            <param name="query_cover" value="0"/>
            <conditional name="sens_cond">
                <param name="block_size" value="2"/>
            </conditional>
            <output name="blast_tabular" file="diamond_results.pairwise"/>
        </test>
        <!-- Test 06 iterate option-->
        <test expect_num_outputs="1">
            <conditional name="method_cond">
                <param name="method_select" value="blastx" />
            </conditional>
            <param name="query" value="nucleotide.fasta" ftype="fasta"/>
            <conditional name="ref_db_source">
                <param name="db_source" value="indexed"/>
                <param name="index" value="testDb"/>
            </conditional>
            <param name="iterate" value="true"/>
            <section name="output_section">
                <conditional name="output">
                    <param name="outfmt" value="6"/>
                    <param name="fields" value="qseqid,sseqid,pident,length,mismatch,gapopen,qstart,qend,sstart,send,evalue,bitscore"/>
                </conditional>
            </section>
            <output name="blast_tabular" file="diamond_results_iterate.tabular"/>
        </test>
        <!--Test 07 algo option-->
        <test expect_num_outputs="1">
            <conditional name="method_cond">
                <param name="method_select" value="blastx" />
            </conditional>
            <param name="query" value="nucleotide.fasta" ftype="fasta"/>
            <conditional name="ref_db_source">
                <param name="db_source" value="indexed"/>
                <param name="index" value="testDb"/>
            </conditional>
            <param name="algo" value="1"/>
            <section name="output_section">
                <conditional name="output">
                    <param name="outfmt" value="6"/>
                    <param name="fields" value="qseqid,sseqid,pident,length,mismatch,gapopen,qstart,qend,sstart,send,evalue,bitscore"/>
                </conditional>
            </section>
            <output name="blast_tabular" file="diamond_results_algorithm.tabular"/>
        </test>
        <!--Test 08 global-ranking option-->
        <test expect_num_outputs="1">
            <conditional name="method_cond">
                <param name="method_select" value="blastx" />
            </conditional>
            <param name="query" value="nucleotide.fasta" ftype="fasta"/>
            <conditional name="ref_db_source">
                <param name="db_source" value="indexed"/>
                <param name="index" value="testDb"/>
            </conditional>
            <param name="global_ranking" value="10"/>
            <section name="output_section">
                <conditional name="output">
                    <param name="outfmt" value="6"/>
                    <param name="fields" value="qseqid,sseqid,pident,length,mismatch,gapopen,qstart,qend,sstart,send,evalue,bitscore"/>
                </conditional>
            </section>
            <output name="blast_tabular" file="diamond_results_global_ranking.tabular"/>
        </test>
        <!--Test 09 max-hsps option-->
        <test expect_num_outputs="1">
            <conditional name="method_cond">
                <param name="method_select" value="blastx" />
            </conditional>
            <param name="query" value="nucleotide.fasta" ftype="fasta"/>
            <conditional name="ref_db_source">
                <param name="db_source" value="indexed"/>
                <param name="index" value="testDb"/>
            </conditional>
            <param name="max_hsps" value="10"/>
            <section name="output_section">
                <conditional name="output">
                    <param name="outfmt" value="6"/>
                    <param name="fields" value="qseqid,sseqid,pident,length,mismatch,gapopen,qstart,qend,sstart,send,evalue,bitscore"/>
                </conditional>
            </section>
            <output name="blast_tabular" file="diamond_results_max_hsps.tabular"/>
        </test>
        <!--Test 10 seed-cut option-->
        <test expect_num_outputs="1">
            <conditional name="method_cond">
                <param name="method_select" value="blastx" />
            </conditional>
            <param name="query" value="nucleotide.fasta" ftype="fasta"/>
            <conditional name="ref_db_source">
                <param name="db_source" value="indexed"/>
                <param name="index" value="testDb"/>
            </conditional>
            <param name="seed_cut" value="100"/>
            <section name="output_section">
                <conditional name="output">
                    <param name="outfmt" value="6"/>
                    <param name="fields" value="qseqid,sseqid,pident,length,mismatch,gapopen,qstart,qend,sstart,send,evalue,bitscore"/>
                </conditional>
            </section>
            <output name="blast_tabular" file="diamond_results_seed_cut.tabular"/>
        </test>
        <!--Test 11 freq-masking option-->
        <test expect_num_outputs="1">
            <conditional name="method_cond">
                <param name="method_select" value="blastx" />
            </conditional>
            <param name="query" value="nucleotide.fasta" ftype="fasta"/>
            <conditional name="ref_db_source">
                <param name="db_source" value="indexed"/>
                <param name="index" value="testDb"/>
            </conditional>
            <param name="freq_masking" value="true"/>
            <section name="output_section">
                <conditional name="output">
                    <param name="outfmt" value="6"/>
                    <param name="fields" value="qseqid,sseqid,pident,length,mismatch,gapopen,qstart,qend,sstart,send,evalue,bitscore"/>
                </conditional>
            </section>
            <output name="blast_tabular" file="diamond_results_freq_masking.tabular"/>
        </test>
        <!--Test 12 motif-masking option-->
        <test expect_num_outputs="1">
            <conditional name="method_cond">
                <param name="method_select" value="blastx" />
            </conditional>
            <param name="query" value="nucleotide.fasta" ftype="fasta"/>
            <conditional name="ref_db_source">
                <param name="db_source" value="indexed"/>
                <param name="index" value="testDb"/>
            </conditional>
            <section name="advanced_section">
                <param name="motif_masking" value="1"/>
            </section>
            <section name="output_section">
                <conditional name="output">
                    <param name="outfmt" value="6"/>
                    <param name="fields" value="qseqid,sseqid,pident,length,mismatch,gapopen,qstart,qend,sstart,send,evalue,bitscore"/>
                </conditional>
            </section>
            <output name="blast_tabular" file="diamond_results_motif_masking.tabular"/>
        </test>
    </tests>
    <help>
<![CDATA[

**What it does**

DIAMOND_ is a new alignment tool for aligning short DNA sequencing reads to a protein reference database such as NCBI-NR.
On Illumina reads of length 100-150bp, in fast mode, DIAMOND is about 20,000 times faster than BLASTX, while reporting
about 80-90% of all matches that BLASTX finds, with an e-value of at most 1e-5. In sensitive mode, DIAMOND ist about 2,500
times faster than BLASTX, finding more than 94% of all matches.

The DIAMOND algorithm is designed for the alignment of large datasets. The algorithm is not efficient for a small number of query sequences or only a single one of them, and speed will be low. BLAST is recommended for small datasets.

.. _DIAMOND: http://ab.inf.uni-tuebingen.de/software/diamond/

**Input**

Input data is a large protein or nucleotide sequence file.


**Output**

Diamond gives you a tabular output file with 12 columns:

Column 	Description
1 	    Query Seq-id (ID of your sequence)
2 	    Subject Seq-id (ID of the database hit)
3 	    Percentage of identical matches
4 	    Alignment length
5 	    Number of mismatches
6 	    Number of gap openings
7 	    Start of alignment in query
8 	    End of alignment in query
9 	    Start of alignment in subject (database hit)
10 	    End of alignment in subject (database hit)
11 	    Expectation value (E-value)
12 	    Bit score


Supported values for gap open and gap extend parameters depending on the selected scoring matrix.

========  ============================================
Matrix    Supported values for (gap open)/(gap extend)
========  ============================================
BLOSUM45  (10-13)/3; (12-16)/2; (16-19)/1
BLOSUM50  (9-13)/3; (12-16)/2; (15-19)/1
BLOSUM62  (6-11)/2; (9-13)/1
BLOSUM80  (6-9)/2; 13/2; 25/2; (9-11)/1
BLOSUM90  (6-9)/2; (9-11)/1
PAM250    (11-15)/3; (13-17)/2; (17-21)/1
PAM70     (6-8)/2; (9-11)/1
PAM30     (5-7)/2; (8-10)/1
========  ============================================


]]>
    </help>
    <expand macro="citations" />
</tool>
