<tool id="paffy_filter" name="Paffy filter" version="@TOOL_VERSION@+galaxy@VERSION_SUFFIX@" profile="@PROFILE@">
    <description>keeps or discards PAFs based on alignment stats</description>
    <macros>
        <import>macros.xml</import>
    </macros>
    <expand macro="requirements"/> 
    <expand macro="stdio"/>
    <command detect_errors="aggressive">
        <![CDATA[    
        set -o pipefail; 
        ## Uncompress input PAF file if necessary and pipe it
        @UNCOMPRESS_PAF@

        ## Run main command
        paffy filter
            $invert
            #if $filters.minChainScore >= 0:
                --minChainScore $filters.minChainScore
            #end if
            #if $filters.minAlignmentScore >= 0:
                --minAlignmentScore $filters.minAlignmentScore
            #end if
            #if $filters.minIdentity >= 0:
                --minIdentity $filters.minIdentity
            #end if
            #if $filters.minIdentityWithGaps >= 0:
                --minIdentityWithGaps $filters.minIdentityWithGaps
            #end if
            #if $filters.maxTileLevel >= 0:
                --maxTileLevel $filters.maxTileLevel
            #end if
            --logLevel 'INFO'
        
        ## Compress output if requested by user 
        @COMPRESS_PAF@
    ]]></command>
    <inputs>
        <expand macro="input_paf"/>
        <section name="filters" title="Filter criteria" expanded="true" help="Filters can be disabled by specifying a negative value">
            <param argument="--minChainScore" type="integer" min="-1" value="-1" label="Min. chain score" help="Filter alignments with a chain score less than this value"/> 
            <param argument="--minAlignmentScore" type="integer" min="-1" value="-1" label="Min. alignment score" help="Filter alignments with an alignment score less than this value"/>        
            <param argument="--minIdentity" type="float" min="-1" value="-1" max="1" label="Min. identity" help="Filter alignments with an identity less than this value, excluding indels"/> 
            <param argument="--minIdentityWithGaps" type="float" min="-1" value="-1" max="1" label="Min. identity with gaps" help="Filter alignments with an identity less than this value, including indels"/> 
            <param argument="--maxTileLevel" type="integer" min="-1" value="-1" label="Max. tile level" help="Filter alignments with a tile level greater than this value"/> 
        </section>
        <param argument="--invert" type="boolean" truevalue="--invert" falsevalue="" checked="false" label="Invert filters" help="Only output alignments that don't pass the above filters"/>  
        <expand macro="params_conditional_compression"/>
    </inputs>
    <outputs>
        <data name="out_file" format="paf" label="${tool.name} on ${on_string}: Filtered PAF">
            <change_format>
                <when input="compression.type" value="gz" format="paf.gz"/>
            </change_format>
        </data>
    </outputs>
    <tests>
        <!-- Test 1: Filter by alignment score -->
        <test expect_num_outputs="1">
            <param name="input_paf" value="testPaf.paf"/>
            <conditional name="filters">
                <param name="minAlignmentScore" value="20000"/>
            </conditional>
            <output name="out_file" ftype="paf">
                <assert_contents>
                    <has_text text="AS:i:233953"/>
                    <has_text text="AS:i:5444" negate="true"/>
                    <has_n_lines n="88"/>
                </assert_contents>
            </output>
        </test>
        <!-- Test 2: Compressed input (.gz) and filter by alignment score -->
        <test expect_num_outputs="1">
            <param name="input_paf" value="testPaf.paf.gz"/>
            <conditional name="filters">
                <param name="minAlignmentScore" value="20000"/>
            </conditional>
            <output name="out_file" ftype="paf">
                <assert_contents>
                    <has_text text="AS:i:233953"/>
                    <has_text text="AS:i:5444" negate="true"/>
                    <has_n_lines n="88"/>
                </assert_contents>
            </output>
        </test>
        <!-- Test 3: Compressed input & output (.gz) and filter by alignment score -->
        <test expect_num_outputs="1">
            <param name="input_paf" value="testPaf.paf.gz"/>
            <conditional name="filters">
                <param name="minAlignmentScore" value="20000"/>
            </conditional>
            <conditional name="compression">
                <param name="type" value="gz"/>
            </conditional>
            <output name="out_file" ftype="paf.gz">
                <assert_contents>
                    <has_size size="32605"/>
                </assert_contents>
            </output>
        </test>
        <!-- Test 4: Filter by chain score -->
        <test expect_num_outputs="1">
            <param name="input_paf" value="paffy_chain_output.paf"/>
            <conditional name="filters">
                <param name="minChainScore" value="5000"/>
            </conditional>
            <output name="out_file" ftype="paf">
                <assert_contents>
                    <has_text text="s1:i:5426"/>
                    <has_text text="s1:i:3307" negate="true"/>
                    <has_n_lines n="191"/>
                </assert_contents>
            </output>
        </test>
        <!-- Test 5: Filter by tile level -->
        <test expect_num_outputs="1">
            <param name="input_paf" value="paffy_tile_output.paf"/>
            <conditional name="filters">
                <param name="maxTileLevel" value="2"/>
            </conditional>
            <output name="out_file" ftype="paf">
                <assert_contents>
                    <has_text text="tl:i:2"/>
                    <has_text text="tl:i:4" negate="true"/>
                    <has_n_lines n="218"/>
                </assert_contents>
            </output>
        </test>
        <!-- Test 6: Filter by identity -->
        <test expect_num_outputs="1">
            <param name="input_paf" value="paffy_add_mismatches_output.paf"/>
            <conditional name="filters">
                <param name="minIdentity" value="0.8"/>
            </conditional>
            <output name="out_file" ftype="paf">
                <assert_contents>
                    <has_text text="cg:Z:6=1X16=1X9=1X7="/>
                    <has_text text="cg:Z:3=1X5=2D4=1X6=1X2=2X9=1X7=1X9=4X5=3X1=1X2=1X7=1X5=1I2=1X1=1X1=1X6=1X1=1X1=1X2=1X5=" negate="true"/>
                    <has_n_lines n="18"/>
                </assert_contents>
            </output>
        </test>
        <!-- Test 7: Filter by identity with gaps -->
        <test expect_num_outputs="1">
            <param name="input_paf" value="paffy_add_mismatches_output.paf"/>
            <conditional name="filters">
                <param name="minIdentityWithGaps" value="0.8"/>
            </conditional>
            <output name="out_file" ftype="paf">
                <assert_contents>
                    <has_text text="cg:Z:6=1X16=1X9=1X7="/>
                    <has_text text="cg:Z:3=1X5=2D4=1X6=1X2=2X9=1X7=1X9=4X5=3X1=1X2=1X7=1X5=1I2=1X1=1X1=1X6=1X1=1X1=1X2=1X5=" negate="true"/>
                    <has_n_lines n="7"/>
                </assert_contents>
            </output>
        </test>
        <!-- Test 8: Multiple conditions. Filter by alignment score & identity with gaps -->
        <test expect_num_outputs="1">
            <param name="input_paf" value="paffy_add_mismatches_output.paf"/>
            <conditional name="filters">
                <param name="minAlignmentScore" value="5000"/>
                <param name="minIdentityWithGaps" value="0.8"/>
            </conditional>
            <output name="out_file" ftype="paf">
                <assert_contents>
                    <has_text text="AS:i:5548"/>
                    <has_text text="AS:i:3307" negate="true"/>
                    <has_text text="cg:Z:2=3X3=1X2=1X4=2X3=1X4=2X1=1X1=1X3=3X3=2X27=1X7=1X6=1X16=2X20=1X8=1X12="/>
                    <has_text text="cg:Z:6=1X16=1X9=1X7=" negate="true"/>
                    <has_n_lines n="3"/>
                </assert_contents>
            </output>
        </test>
        <!-- Test 9: Invert filters of test 8 -->
        <test expect_num_outputs="1">
            <param name="input_paf" value="paffy_add_mismatches_output.paf"/>
            <conditional name="filters">
                <param name="minAlignmentScore" value="5000"/>
                <param name="minIdentityWithGaps" value="0.8"/>
            </conditional>
            <param name="invert" value="true"/>
            <output name="out_file" ftype="paf">
                <assert_contents>
                    <has_text text="AS:i:5548" negate="true"/>
                    <has_text text="AS:i:3307"/>
                    <has_text text="cg:Z:2=3X3=1X2=1X4=2X3=1X4=2X1=1X1=1X3=3X3=2X27=1X7=1X6=1X16=2X20=1X8=1X12=" negate="true"/>
                    <has_text text="cg:Z:6=1X16=1X9=1X7="/>
                    <has_n_lines n="219"/>
                </assert_contents>
            </output>
        </test>
    </tests>
    <help><![CDATA[
Paffy filter removes PAF alignments based on a set of quantitative criteria.
This allows control over which alignments are kept for downstream analysis.
By default, only alignments that pass all specified filters are written to the output. 
An optional invert mode outputs only the alignments that don't pass filters.
As output, a new PAF file is generated with the filtered alignments.

Criteria:
  - Alignment score ('AS' tag required)
  - Chain score ('s1' tag required; e.g. set by 'Paffy chain')
  - Tile level ('tl' tag required; e.g. set by 'Paffy tile')
  - Sequence identity, with and without indels (requires CIGAR strings with explicit mismatch encoding generated by 'Paffy add mismatches')
    ]]></help>
    <expand macro="citation"/>
    <expand macro="creator"/>
</tool>