<tool id="paffy_tile" name="Paffy tile" version="@TOOL_VERSION@+galaxy@VERSION_SUFFIX@" profile="@PROFILE@">
    <description>arranges and ranks PAF alignments along the query sequence</description>
    <macros>
        <import>macros.xml</import>
    </macros>
    <expand macro="requirements"/> 
    <expand macro="stdio"/>
    <command detect_errors="aggressive">
        <![CDATA[
        set -o pipefail; 

        ## Uncompress input PAF file if necessary and pipe it
        @UNCOMPRESS_PAF@

        ## Run main command
        paffy tile
            --logLevel 'INFO'
            
        ## Compress output if requested by user 
        @COMPRESS_PAF@
    ]]></command>
    <inputs>
        <expand macro="input_paf"/>
        <expand macro="params_conditional_compression"/>
    </inputs>
    <outputs>
        <data name="out_file" format="paf" label="${tool.name} on ${on_string}">
            <change_format>
                <when input="compression.type" value="gz" format="paf.gz"/>
            </change_format>
        </data>
    </outputs>
    <tests>
        <!-- Test 1: Tool defaults. Output used as input for paffy_filter -->
        <test expect_num_outputs="1">
            <param name="input_paf" value="testPaf.paf"/>
            <output name="out_file" ftype="paf" file="paffy_tile_output.paf"/>
        </test>
        <!-- Test 2: Compressed input (.gz). Output used as input for paffy_filter -->
        <test expect_num_outputs="1">
            <param name="input_paf" value="testPaf.paf.gz"/>
            <output name="out_file" ftype="paf" file="paffy_tile_output.paf"/>
        </test>
        <!-- Test 3: Compressed input & output (.gz) -->
        <test expect_num_outputs="1">
            <param name="input_paf" value="testPaf.paf.gz"/>
            <conditional name="compression">
                <param name="type" value="gz"/>
            </conditional>
            <output name="out_file" ftype="paf.gz">
                <assert_contents>
                    <has_size size="37788"/>
                </assert_contents>
            </output>
        </test>
    </tests>
    <help><![CDATA[
Paffy tile processes each alignment and assigns tile levels along the query sequence. 
The primary goal is to identify the 'best' alignments (tiles) covering the sequence and assign them level 1. 
Overlapping or lower-quality alignments for the same sequence receive higher levels (e.g., 2, 3).

To determine priority, alignments are first sorted by their chain score (tag: 's1') if available, or otherwise by their alignment score (tag: 'AS'). 
As output PAF file, a new PAF file is generated where alignments are sorted by their score and additonally annotated with two tags:

* **tp (Type of alignment):** Indicates if the alignment is (P)rimary, (S)econdary, or an (I)nversion. Note that the 'I' state is not generated by Paffy itself but is preserved if set by a previous tool.
* **tl (Tile level):** Indicates the alignment's rank for covering the sequence. A level of 1 represents the best (optimal) alignment, level 2 is the second best, etc.
    ]]></help>
    <expand macro="citation"/>
    <expand macro="creator"/>
</tool>