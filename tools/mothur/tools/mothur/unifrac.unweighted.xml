<tool id="mothur_unifrac_unweighted" name="unifrac.unweighted" version="@WRAPPER_VERSION@.0">
    <description>Describes whether two or more communities have the same structure</description>
    <macros>
        <import>macros.xml</import>
    </macros>
    <expand macro="requirements" />

    <command interpreter="python"><![CDATA[
        mothur_wrapper.py 
        #set results = ["'^mothur.\S+\.logfile$:'" + $logfile.__str__, "'^\S+\.uwsummary$:'" + $summary.__str__]
        #set results = $results + ["'^\S+\.unweighted$:'" + $unweighted.__str__]
        #set results = $results + ["'^\S+\.unweighted\.(column\.|phylip\.)?dist$:'" + $dist.__str__]
        #set results = $results + ["'^\S+\.unweighted\.ave\.dist$:'" + $ave_dist.__str__]
        #set results = $results + ["'^\S+\.unweighted\.std\.dist$:'" + $std_dist.__str__]
        #set results = $results + ["'^\S+\.unweighted\.cons\.tre$:'" + $cons_tree.__str__]
        #set results = $results + ["'^\S+\.unweighted\.all\.tre$:'" + $all_tree.__str__]
        --cmd='unifrac.unweighted'
        ## --result='^mothur.\S+\.logfile$:'$logfile,'^\S+\.uwsummary$:'$summary,'^\S+\.unweighted\.(column\.|phylip\.)?dist$:'$dist,'^\S+\.unweighted$:'$unweighted,'^\S+\.unweighted\.ave\.dist$:'$ave_dist,'^\S+\.unweighted\.std\.dist$:'$std_dist,'^\S+\.unweighted\.all\.tre$:'$all_tree,'^\S+\.unweighted\.cons\.tre$:'$cons_tree,
        --outputdir='$logfile.extra_files_path'
        --tree="$tree"
        #if $group.__str__ != "None" and len($group.__str__) > 0:
            --group='$group'
        #end if
        #if $groups.__str__ != "None" and len($groups.__str__) > 0:
            --groups='$groups'
        #end if
        #if $name.__str__ != "None" and len($name.__str__) > 0:
            --name='$name'
        #end if
        #if int($iters.__str__) > 0:
            --iters="$iters"
        #end if
        #if $subsampling.use:
            #if len($subsampling.subsample.__str__) > 0 and int($subsampling.subsample.__str__) > 0:
                --subsample="$subsampling.subsample"
            #else
                --subsample=T
            #end if
            "$subsampling.consensus"
        #else
            "$random"
        #end if
        #if $distance.__str__ != "false":
            --distance="$distance"
        #end if
        "$root"
        --result=#echo ','.join($results)
        --processors=\${GALAXY_SLOTS:-1}
        #if $count.__str__ != "None" and len($count.__str__) > 0:
            --count="$count"
        #end if
    ]]></command>
    <inputs>
        <param name="tree" type="data" format="tre" label="tree - Tree"/>
        <param name="group" type="data" format="mothur.groups" label="group - Group file for the tree"/>
        <param name="groups" type="select" label="groups - Select groups for pairwise comparisons" multiple="true">
            <help></help>
            <options>
                <filter type="data_meta" ref="group" key="groups" />
            </options>
        </param>
        <param name="name" type="data" format="mothur.names" optional="true" label="name - Names file for the tree"/>
        <param name="iters" type="integer" value="1000" label="iters - Number of iterations to try (default 1000)"/>
        <param name="random" type="boolean" truevalue="--random=true" falsevalue="" checked="false" label="random - Compare your trees with randomly generated trees" />
        <!-- NOTE: random cannot be used with subsample option, handle in command logic -->
        <conditional name="subsampling">
            <param name="use" type="boolean" truevalue="yes" falsevalue="no" checked="false" label="use subsampling of groups"
                                        help="(instead of randomly generated comparisons)"/>
            <when value="yes">
                <param name="subsample" type="integer" value="" optional="true" label="subsample - (defaults to the size of the smallest group)"
                                            help="the size per group of the sample"/>
                <param name="consensus" type="boolean" truevalue="--consensus=true" falsevalue="" checked="false" label="consensus - " 
                                            help="The consensus parameter allows you to indicate you would like trees built from distance matrices created with the results of the subsampling, as well as a consensus tree built from these trees. Default=F"/>
            </when>
            <when value="no"/>
        </conditional> <!-- subsampling -->
        <param name="distance" type="select" label="distance - Create a distance matrix for your history">
            <option value="false">None</option>
            <option value="lt">Phylip Lower Triangle Matrix</option>
            <option value="square">Phylip Square Matrix</option>
            <option value="column">Pairwise Distance Matrix</option>
        </param>
        <param name="root" type="boolean" truevalue="--root=true" falsevalue="" checked="false" label="root - the entire root in your calculations" />
        <param name="count" type="data" format="mothur.count_table" optional="true" label="count - a count_table" help="generated by count.seqs"/>
    </inputs>
    <outputs>
        <data format="html" name="logfile" label="${tool.name} on ${on_string}: logfile" />
        <data format="tabular" name="summary" label="${tool.name} on ${on_string}: summary">
        </data>
        <data format="tabular" name="unweighted" label="${tool.name} on ${on_string}: unweighted">
            <filter>(random == True and subsampling['use'] == False)</filter>
        </data>
        <data format="mothur.lower.dist" name="dist" label="${tool.name} on ${on_string}: dist">
            <filter>distance != 'false'</filter>
            <change_format>
                <when input="distance" value="square" format="mothur.square.dist" />
                <when input="distance" value="column" format="mothur.pair.dist" />
            </change_format>
        </data>
        <data format="mothur.lower.dist" name="ave_dist" label="${tool.name} on ${on_string}: ave.dist">
            <filter>subsampling['use'] == True</filter>
            <change_format>
                <when input="distance" value="square" format="mothur.square.dist" />
                <when input="distance" value="column" format="mothur.pair.dist" />
            </change_format>
        </data>
        <data format="mothur.lower.dist" name="std_dist" label="${tool.name} on ${on_string}: std.dist">
            <filter>subsampling['use'] == True</filter>
            <change_format>
                <when input="distance" value="square" format="mothur.square.dist" />
                <when input="distance" value="column" format="mothur.pair.dist" />
            </change_format>
        </data>
        <data format="tre" name="all_tree" label="${tool.name} on ${on_string}: all.tre">
            <filter>(subsampling['use'] == True and subsampling['consensus'] == True)</filter>
        </data>
        <data format="tre" name="cons_tree" label="${tool.name} on ${on_string}: cons.tre">
            <filter>(subsampling['use'] == True and subsampling['consensus'] == True)</filter>
        </data>
    </outputs>
    <tests>
    </tests>
    <help>
<![CDATA[

@MOTHUR_OVERVIEW@

**Command Documenation**

The unifrac.unweighted_ command the unweighted UniFrac algorithm. The unifrac.weighted command implements the weighted version of the command. Both of these methods are available through the UniFrac website. The UniFrac methods are generic tests that describes whether two or more communities have the same structure. The significance of the test statistic can only indicate the probability that the communities have the same structure by chance. The value does not indicate a level of similarity.

.. _unifrac.unweighted: http://www.mothur.org/wiki/Unifrac.unweighted

]]>
    </help>
    <expand macro="citations" />
</tool>
