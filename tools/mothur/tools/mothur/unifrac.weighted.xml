<tool profile="16.07" id="mothur_unifrac_weighted" name="unifrac.weighted" version="@WRAPPER_VERSION@.0">
    <description>Describes whether two or more communities have the same structure</description>
    <macros>
        <import>macros.xml</import>
    </macros>
    <expand macro="requirements"/>
    <expand macro="version_command"/>

    <command><![CDATA[
        echo 'unifrac.weighted(
            tree=$tree,
            #if $group:
                group=$group,
                #if $groups:
                    groups=${ str($groups).replace(",","-") },
                #end if
            #end if
            #if $name:
                name=$name,
            #end if
            iters=$iters,
            #if $subsampling.use:
                #if $subsampling.subsample:
                    subsample=$subsampling.subsample,
                #else
                    subsample=T,
                #end if
                consensus=$subsampling.consensus,
            #else
                random=$random,
            #end if
            #if $distance:
                distance=$distance,
            #end if
            #if $count:
                count=$count,
            #end if
            root=$root,
            processors='\${GALAXY_SLOTS:-1}'
        )'
        | sed 's/ //g'  ## mothur trips over whitespace
        | mothur &&

        ## move output files to correct destination
        prefix="$tree" &&
        mv \${prefix%.dat}*.*wsummary "$summary" &&
        #if $subsampling.use:
            mv \${prefix%.dat}*.ave.dist "$ave_dist" &&
            mv \${prefix%.dat}*.std.dist "$std_dist" &&
            #if $subsampling.consensus:
                mv \${prefix%.dat}*.all.tre "$all_tree" &&
                mv \${prefix%.dat}*.cons.tre "$cons_tree" &&
            #end if
        #elif $random:
            mv \${prefix%.dat}*.weighted "$weighted" &&
        #end if
        mv \${prefix%.dat}*.dist "$dist" &&
        mv mothur.*.logfile "$logfile"
    ]]></command>
    <inputs>
        <param name="tree" type="data" format="mothur.tre" label="tree - Tree"/>
        <param name="group" type="data" format="mothur.groups" label="group - Group file for the tree"/>
        <param name="groups" type="select" optional="true" multiple="true" label="groups - Select groups for pairwise comparisons" help="You must select at least 2 groups">
            <options>
                <filter type="data_meta" ref="group" key="groups"/>
            </options>
        </param>
        <param name="name" type="data" format="mothur.names" optional="true" label="name - Names file for the tree"/>
        <param name="iters" type="integer" value="1000" min="0" label="iters - Number of iterations to try (default 1000)"/>
        <param name="random" type="boolean" truevalue="true" falsevalue="false" checked="false" label="random - Compare your trees with randomly generated trees" help="unused if subsample=True"/>
        <conditional name="subsampling">
            <param name="use" type="boolean" truevalue="yes" falsevalue="no" checked="false" label="use subsampling of groups" help="(instead of randomly generated comparisons)"/>
            <when value="yes">
                <param name="subsample" type="integer" value="" min="1" optional="true" label="subsample - (defaults to the size of the smallest group)" help="the size per group of the sample"/>
                <param name="consensus" type="boolean" truevalue="true" falsevalue="false" checked="false" label="consensus - " help="The consensus parameter allows you to indicate you would like trees built from distance matrices created with the results of the subsampling, as well as a consensus tree built from these trees. Default=F"/>
            </when>
            <when value="no"/>
        </conditional>
        <param name="distance" type="select" label="distance - Create a distance matrix for your history">
            <option value="lt" selected="true">Phylip Lower Triangle Matrix</option>
            <option value="square">Phylip Square Matrix</option>
            <option value="column">Pairwise Distance Matrix</option>
        </param>
        <param name="root" type="boolean" truevalue="true" falsevalue="false" checked="false" label="root - the entire root in your calculations"/>
        <param name="count" type="data" format="mothur.count_table" optional="true" label="count - a count_table" help="generated by count.seqs"/>
    </inputs>
    <outputs>
        <data name="logfile" format="txt" label="${tool.name} on ${on_string}: logfile"/>
        <data name="summary" format="tabular" label="${tool.name} on ${on_string}: summary"/>
        <data name="dist" format="mothur.lower.dist" label="${tool.name} on ${on_string}: dist">
            <change_format>
                <when input="distance" value="square" format="mothur.square.dist"/>
                <when input="distance" value="column" format="mothur.pair.dist"/>
            </change_format>
        </data>
        <data name="weighted" format="tabular" label="${tool.name} on ${on_string}: weighted">
            <filter>(random == True and subsampling['use'] == False)</filter>
        </data>
        <data name="ave_dist" format="mothur.lower.dist" label="${tool.name} on ${on_string}: ave.dist">
            <filter>subsampling['use'] == True</filter>
            <change_format>
                <when input="distance" value="square" format="mothur.square.dist"/>
                <when input="distance" value="column" format="mothur.pair.dist"/>
            </change_format>
        </data>
        <data name="std_dist" format="mothur.lower.dist" label="${tool.name} on ${on_string}: std.dist">
            <filter>subsampling['use'] == True</filter>
            <change_format>
                <when input="distance" value="square" format="mothur.square.dist"/>
                <when input="distance" value="column" format="mothur.pair.dist"/>
            </change_format>
        </data>
        <data name="all_tree" format="mothur.tre" label="${tool.name} on ${on_string}: all.tre">
            <filter>(subsampling['use'] == True and subsampling['consensus'] == True)</filter>
        </data>
        <data name="cons_tree" format="mothur.tre" label="${tool.name} on ${on_string}: cons.tre">
            <filter>(subsampling['use'] == True and subsampling['consensus'] == True)</filter>
        </data>
    </outputs>
    <tests>
        <test><!-- test with defaults -->
            <param name="tree" value="abrecovery.tre" ftype="mothur.tre"/>
            <param name="group" value="abrecovery.groups" ftype="mothur.groups"/>
            <param name="groups" value="A,B,C"/>
            <output name="summary" md5="f723493c1b909f5dbe5688d36be9fe73" ftype="tabular"/>
            <output name="dist" md5="3660f333ac1326c8df213d1d3af1f865" ftype="mothur.lower.dist"/>
            <expand macro="logfile-test"/>
        </test>
        <test><!-- test with random and no subsampling -->
            <param name="tree" value="abrecovery.tre" ftype="mothur.tre"/>
            <param name="group" value="abrecovery.groups" ftype="mothur.groups"/>
            <param name="groups" value="A,B,C"/>
            <param name="random" value="true"/>
            <output name="summary" md5="a29236de2d96703e504e667b73cba790" ftype="tabular"/>
            <output name="weighted" ftype="tabular">
                <assert_contents>
                    <has_text text="A-BScore"/>
                    <has_text text="A-CRandFreq"/>
                    <has_text text="B-CRandCumul"/>
                </assert_contents>
            </output>
            <output name="dist" md5="3660f333ac1326c8df213d1d3af1f865" ftype="mothur.lower.dist"/>
            <expand macro="logfile-test"/>
        </test>
        <test><!-- test with group file and group select -->
            <param name="tree" value="abrecovery.tre" ftype="mothur.tre"/>
            <param name="group" value="abrecovery.groups" ftype="mothur.groups"/>
            <param name="groups" value="A,B"/>
            <param name="distance" value="square"/>
            <output name="summary" md5="c253d4a3225804ad24b6c2e3a1095040" ftype="tabular"/>
            <output name="dist" md5="7df2d4a2e69b9c1259d39fe59165734f" ftype="mothur.square.dist"/>
            <expand macro="logfile-test"/>
        </test>
        <test><!-- test with subsample and consensus -->
            <param name="tree" value="abrecovery.tre" ftype="mothur.tre"/>
            <param name="group" value="abrecovery.groups" ftype="mothur.groups"/>
            <param name="groups" value="A,B,C"/>
            <param name="use" value="yes"/>
            <param name="subsample" value="10"/>
            <param name="distance" value="column"/>
            <param name="consensus" value="true"/>
            <output name="summary" md5="f723493c1b909f5dbe5688d36be9fe73" ftype="tabular"/>
            <output name="dist" md5="f017b1d7c7de38f4b90a1d8e07c8605c" ftype="mothur.pair.dist"/>
            <output name="ave_dist" ftype="mothur.pair.dist">
                <assert_contents>
                    <has_text text="A"/>
                    <has_text text="B"/>
                    <has_text text="C"/>
                </assert_contents>
            </output>
            <output name="std_dist" ftype="mothur.pair.dist">
                <assert_contents>
                    <has_text text="A"/>
                    <has_text text="B"/>
                    <has_text text="C"/>
                </assert_contents>
            </output>
            <output name="all_tree" ftype="mothur.tre">
                <assert_contents>
                    <has_text text="A"/>
                    <has_text text="B"/>
                    <has_text text="C"/>
                </assert_contents>
            </output>
            <output name="cons_tree" ftype="mothur.tre">
                <assert_contents>
                    <has_text text="A"/>
                    <has_text text="B"/>
                    <has_text text="C"/>
                </assert_contents>
            </output>
            <expand macro="logfile-test"/>
        </test>
    </tests>
    <help>
<![CDATA[

@MOTHUR_OVERVIEW@

**Command Documenation**

The unifrac.weighted_ command implements the weighted UniFrac algorithm. The unifrac.unweighted command implements the unweighted version of the command. Both of these methods are available through the UniFrac website. The UniFrac methods are generic tests that describes whether two or more communities have the same structure. The significance of the test statistic can only indicate the probability that the communities have the same structure by chance. The value does not indicate a level of similarity.

.. _unifrac.weighted: http://www.mothur.org/wiki/Unifrac.weighted

]]>
    </help>
    <expand macro="citations"/>
</tool>
