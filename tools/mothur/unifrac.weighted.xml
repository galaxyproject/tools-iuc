<tool profile="16.07" id="mothur_unifrac_weighted" name="unifrac.weighted" version="@WRAPPER_VERSION@.0">
    <description>Describes whether two or more communities have the same structure</description>
    <macros>
        <import>macros.xml</import>
    </macros>
    <expand macro="requirements"/>
    <expand macro="stdio"/>
    <expand macro="version_command"/>
    <command><![CDATA[
@SHELL_OPTIONS@

## create symlinks to input datasets
ln -s '$tree' tree.dat &&
ln -s '$group' group.dat &&
ln -s '$name' name.dat &&
ln -s '$count' count.dat &&

echo 'unifrac.weighted(
    tree=tree.dat,
    #if $group:
        group=group.dat,
        #if $groups:
            groups=${ str($groups).replace(",","-") },
        #end if
    #end if
    #if $name:
        name=name.dat,
    #end if
    iters=$iters,
    #if $subsampling.use == "yes":
        #if $subsampling.subsample:
            subsample=$subsampling.subsample,
        #else
            subsample=T,
        #end if
        consensus=$subsampling.consensus,
    #else
        random=$random,
    #end if
    #if $distance:
        distance=$distance,
    #end if
    #if $count:
        count=count.dat,
    #end if
    root=$root,
    processors='\${GALAXY_SLOTS:-1}'
)'
| sed 's/ //g'  ## mothur trips over whitespace
| mothur
| tee mothur.out.log

## rename some datasets
#if $subsampling.use == "yes":
    && mv tree.*.ave.dist tree.ave
    && mv tree.*.std.dist tree.std
#end if
    ]]></command>
    <inputs>
        <param name="tree" type="data" format="mothur.tre" label="tree - Tree"/>
        <param name="group" type="data" format="mothur.groups" label="group - Group file for the tree"/>
        <param name="groups" type="select" optional="true" multiple="true" label="groups - Select groups for pairwise comparisons" help="You must select at least 2 groups">
            <options>
                <filter type="data_meta" ref="group" key="groups"/>
            </options>
        </param>
        <param name="name" type="data" format="mothur.names" optional="true" label="name - Names file for the tree"/>
        <param name="iters" type="integer" value="1000" min="0" label="iters - Number of iterations to try (default 1000)"/>
        <param name="random" type="boolean" truevalue="true" falsevalue="false" checked="false" label="random - Compare your trees with randomly generated trees" help="unused if subsample=True"/>
        <conditional name="subsampling">
            <param name="use" type="select" label="use subsampling of groups?" help="(instead of randomly generated comparisons)">
                <option value="no" selected="true">no</option>
                <option value="yes">yes</option>
            </param>
            <when value="yes">
                <param name="subsample" type="integer" value="" min="1" optional="true" label="subsample - (defaults to the size of the smallest group)" help="the size per group of the sample"/>
                <param name="consensus" type="boolean" truevalue="true" falsevalue="false" checked="false" label="consensus - " help="The consensus parameter allows you to indicate you would like trees built from distance matrices created with the results of the subsampling, as well as a consensus tree built from these trees. Default=F"/>
            </when>
            <when value="no"/>
        </conditional>
        <param name="distance" type="select" label="distance - Create a distance matrix for your history">
            <option value="lt" selected="true">Phylip Lower Triangle Matrix</option>
            <option value="square">Phylip Square Matrix</option>
            <option value="column">Pairwise Distance Matrix</option>
        </param>
        <param name="root" type="boolean" truevalue="true" falsevalue="false" checked="false" label="root - the entire root in your calculations"/>
        <param name="count" type="data" format="mothur.count_table" optional="true" label="count - a count_table" help="generated by count.seqs"/>
        <expand macro="param-savelog"/>
    </inputs>
    <outputs>
        <expand macro="logfile-output"/>
        <data name="summary" format="tabular" from_work_dir="tree*wsummary" label="${tool.name} on ${on_string}: summary"/>
        <data name="dist" format="mothur.lower.dist" from_work_dir="tree.dat*.dist " label="${tool.name} on ${on_string}: dist">
            <change_format>
                <when input="distance" value="square" format="mothur.square.dist"/>
                <when input="distance" value="column" format="mothur.pair.dist"/>
            </change_format>
        </data>
        <data name="weighted" format="tabular" from_work_dir="tree*.weighted" label="${tool.name} on ${on_string}: weighted">
            <filter>(random and subsampling['use'] == 'no')</filter>
        </data>
        <data name="ave_dist" format="mothur.lower.dist" from_work_dir="tree.ave" label="${tool.name} on ${on_string}: ave.dist">
            <filter>subsampling['use'] == 'yes'</filter>
            <change_format>
                <when input="distance" value="square" format="mothur.square.dist"/>
                <when input="distance" value="column" format="mothur.pair.dist"/>
            </change_format>
        </data>
        <data name="std_dist" format="mothur.lower.dist" from_work_dir="tree.std" label="${tool.name} on ${on_string}: std.dist">
            <filter>subsampling['use'] == 'yes'</filter>
            <change_format>
                <when input="distance" value="square" format="mothur.square.dist"/>
                <when input="distance" value="column" format="mothur.pair.dist"/>
            </change_format>
        </data>
        <data name="all_tree" format="mothur.tre" from_work_dir="tree*.all.tre" label="${tool.name} on ${on_string}: all.tre">
            <filter>(subsampling['use'] == 'yes' and subsampling['consensus'])</filter>
        </data>
        <data name="cons_tree" format="mothur.tre" from_work_dir="tree*.cons.tre" label="${tool.name} on ${on_string}: cons.tre">
            <filter>(subsampling['use'] == 'yes' and subsampling['consensus'])</filter>
        </data>
    </outputs>
    <tests>
        <test><!-- test with defaults -->
            <param name="tree" value="abrecovery.tre" ftype="mothur.tre"/>
            <param name="group" value="abrecovery.groups" ftype="mothur.groups"/>
            <param name="groups" value="A,B,C"/>
            <output name="summary" md5="f723493c1b909f5dbe5688d36be9fe73" ftype="tabular"/>
            <output name="dist" md5="3660f333ac1326c8df213d1d3af1f865" ftype="mothur.lower.dist"/>
            <param name="savelog" value="true"/>
            <expand macro="logfile-test"/>
        </test>
        <test><!-- test with random and no subsampling -->
            <param name="tree" value="abrecovery.tre" ftype="mothur.tre"/>
            <param name="group" value="abrecovery.groups" ftype="mothur.groups"/>
            <param name="groups" value="A,B,C"/>
            <param name="random" value="true"/>
            <output name="summary" md5="a29236de2d96703e504e667b73cba790" ftype="tabular"/>
            <output name="weighted" ftype="tabular">
                <assert_contents>
                    <has_text text="A-BScore"/>
                    <has_text text="A-CRandFreq"/>
                    <has_text text="B-CRandCumul"/>
                </assert_contents>
            </output>
            <output name="dist" md5="3660f333ac1326c8df213d1d3af1f865" ftype="mothur.lower.dist"/>
            <param name="savelog" value="true"/>
            <expand macro="logfile-test"/>
        </test>
        <test><!-- test with group file and group select -->
            <param name="tree" value="abrecovery.tre" ftype="mothur.tre"/>
            <param name="group" value="abrecovery.groups" ftype="mothur.groups"/>
            <param name="groups" value="A,B"/>
            <param name="distance" value="square"/>
            <output name="summary" md5="c253d4a3225804ad24b6c2e3a1095040" ftype="tabular"/>
            <output name="dist" md5="7df2d4a2e69b9c1259d39fe59165734f" ftype="mothur.square.dist"/>
            <param name="savelog" value="true"/>
            <expand macro="logfile-test"/>
        </test>
        <test><!-- test with subsample and consensus -->
            <param name="tree" value="abrecovery.tre" ftype="mothur.tre"/>
            <param name="group" value="abrecovery.groups" ftype="mothur.groups"/>
            <param name="groups" value="A,B,C"/>
            <param name="use" value="yes"/>
            <param name="subsample" value="10"/>
            <param name="distance" value="column"/>
            <param name="consensus" value="true"/>
            <output name="summary" md5="f723493c1b909f5dbe5688d36be9fe73" ftype="tabular"/>
            <output name="dist" md5="f017b1d7c7de38f4b90a1d8e07c8605c" ftype="mothur.pair.dist"/>
            <output name="ave_dist" ftype="mothur.pair.dist">
                <assert_contents>
                    <has_text text="A"/>
                    <has_text text="B"/>
                    <has_text text="C"/>
                </assert_contents>
            </output>
            <output name="std_dist" ftype="mothur.pair.dist">
                <assert_contents>
                    <has_text text="A"/>
                    <has_text text="B"/>
                    <has_text text="C"/>
                </assert_contents>
            </output>
            <output name="all_tree" ftype="mothur.tre">
                <assert_contents>
                    <has_text text="A"/>
                    <has_text text="B"/>
                    <has_text text="C"/>
                </assert_contents>
            </output>
            <output name="cons_tree" ftype="mothur.tre">
                <assert_contents>
                    <has_text text="A"/>
                    <has_text text="B"/>
                    <has_text text="C"/>
                </assert_contents>
            </output>
            <param name="savelog" value="true"/>
            <expand macro="logfile-test"/>
        </test>
    </tests>
    <help><![CDATA[

@MOTHUR_OVERVIEW@

**Command Documentation**

The unifrac.weighted_ command implements the weighted UniFrac algorithm. The unifrac.unweighted command implements the unweighted version of the command. Both of these methods are available through the UniFrac website. The UniFrac methods are generic tests that describes whether two or more communities have the same structure. The significance of the test statistic can only indicate the probability that the communities have the same structure by chance. The value does not indicate a level of similarity.

.. _unifrac.weighted: https://www.mothur.org/wiki/Unifrac.weighted

    ]]></help>
    <expand macro="citations">
        <citation type="doi">10.1128/AEM.71.12.8228-8235.2005</citation>
    </expand>
</tool>
