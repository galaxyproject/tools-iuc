<tool id="bbtools_tadpole" name="BBTools: Tadpole" version="@WRAPPER_VERSION@+galaxy@VERSION_SUFFIX@" profile="@PROFILE@">
    <description>Kmer-based assembler</description>
    <macros>
        <import>macros.xml</import>
    </macros>
    <expand macro="requirements"/>
    <command detect_errors="exit_code"><![CDATA[
#import os

tadpole.sh in='${input_name}' threads=\${GALAXY_SLOTS:-4} mode=$mode
#if str($input_type_cond.input_type) in ['single', 'pair']:
    #set read1 = $input_type_cond.read1
    ## Tadpole uses the file extension to determine the input format.
    #set ext = '.fastq'
    #if $read1.ext.endswith('.gz'):
        #set ext = $ext + '.gz'
    #end if
    #set read1_file = 'forward' + $ext
    ln -s '${read1}' '${read1_file}' &&
    #if str($input_type_cond.input_type) == 'pair':
        #set read2 = $input_type_cond.read2
        #set read2_file = 'reverse' + $ext
        ln -s '${read2}' '${read2_file}' &&
    #end if
#else:
    #set read1 = $input_type_cond.reads_collection['forward']
    #set read1_identifier = re.sub('[^\s\w\-]', '_', str($read1.element_identifier))
    ## Tadpole uses the file extension to determine the input format.
    #set ext = #read1_identifier + '.fastq'
    #if $read1.ext.endswith('.gz'):
        #set ext = $ext + '.gz'
    #end if
    #set read1_file = $read1_identifier + $ext
    ln -s '${read1}' '${read1_file}' &&
    #set read2 = $input_type_cond.reads_collection['reverse']
    #set read2_identifier = re.sub('[^\s\w\-]', '_', str($read2.element_identifier))
    #set read2_file = $read2_identifier + $ext
    ln -s '${read2}' '${read2_file}' &&
#end if

tadpole.sh

#### Input parameters
#if str($input_type_cond.input_type) == 'single':
    in='${read1_file}'
#else:
    in='${read1_file}' in2='${read2_file}'
#end if

#### Output parameters
fastadump='$output_options.fastadump'
mincounttodump='$output_options.mincounttodump'
showstats='$output_options.showstats'
#if str($output_options.output_discard):
    outd='discarded_reads.fq'
#end if
#if str($output_options.output_dump):
    outd='kmer_dump.fa'
#end if

#### Processing modes
#if str($mode_options.mode) == 'contig':
    mode=contig
#elif str($mode_options.mode) == 'extend':
    mode=extend
#elif str($mode_options.mode) == 'correct':
    mode=correct
#end if

#if str($output_format) == 'vcf':
    vcf='out.vcf' && mv 'out.vcf' '$output'
#elif str($output_format) == 'gff':
    outgff='out.gff' && mv 'out.gff' '$output'
#else:
    out='output.txt' && mv 'output.txt' '$output'
#end if
]]></command>
    <inputs>
        <expand macro="input_type_cond"/>
        <param name="mode" type="select" label="Select mode">
            <option value="contig" selected="true">Contig: make contigs from kmers.</option>
            <option value="extend">Extend: extend sequences to be longer.</option>
            <option value="correct">Correct: error correction.</option>
        </param>
    </inputs>
    <outputs>
        <data name="output" format="fq">
            <change_format>
                <when input="mode" value="contig" format="fa"/>
            </change_format>
        </data>
    </outputs>
    <tests>
        <!-- Single file, cached reference, output coordinate sorted -->
        <test expect_num_outputs="3">
            <param name="input_type" value="single"/>
            <param name="read1" value="13-1941-6_S4_L001_R1_600000.fastq.gz"/>
            <param name="output_sort" value="coordinate"/>
            <output name="output_all_reads" ftype="bam">
                <metadata name="dbkey" value="89"/>
                <assert_contents>
                    <has_size value="9639" delta="300"/>
                </assert_contents>
            </output>
            <output name="output_unmapped_reads" ftype="bam">
                <metadata name="dbkey" value="89"/>
                <assert_contents>
                    <has_size value="9639" delta="300"/>
                </assert_contents>
            </output>
            <output name="output_mapped_reads" ftype="bam">
                <metadata name="dbkey" value="89"/>
                <assert_contents>
                    <has_size value="851" delta="100"/>
                </assert_contents>
            </output>
        </test>
        <!-- Paired reads in separate datasets, cached reference, output name sorted -->
        <test expect_num_outputs="3">
            <param name="input_type" value="pair"/>
            <param name="read1" value="13-1941-6_S4_L001_R1_600000.fastq.gz"/>
            <param name="read2" value="13-1941-6_S4_L001_R2_600000.fastq.gz"/>
            <param name="output_sort" value="name"/>
            <output name="output_all_reads" ftype="qname_sorted.bam">
                <metadata name="dbkey" value="89"/>
                <assert_contents>
                    <has_size value="17540" delta="600"/>
                </assert_contents>
            </output>
            <output name="output_unmapped_reads" ftype="qname_sorted.bam">
                <metadata name="dbkey" value="89"/>
                <assert_contents>
                    <has_size value="17540" delta="600"/>
                </assert_contents>
            </output>
            <output name="output_mapped_reads" ftype="qname_sorted.bam">
                <metadata name="dbkey" value="89"/>
                <assert_contents>
                    <has_size value="860" delta="100"/>
                </assert_contents>
            </output>
        </test>
        <!-- Collection of Paired reads, history reference, output unsorted -->
        <test expect_num_outputs="3">
            <param name="input_type" value="paired"/>
            <param name="reads_collection">
                <collection type="paired">
                    <element name="forward" value="13-1941-6_S4_L001_R1_600000.fastq.gz"/>
                    <element name="reverse" value="13-1941-6_S4_L001_R2_600000.fastq.gz"/>
                </collection>
            </param>
            <param name="ref_source" value="history"/>
            <param name="reference" value="NC_002945v4.fasta" dbkey="89" ftype="fasta"/>
            <param name="output_sort" value="unsorted"/>
            <output name="output_all_reads" ftype="qname_input_sorted.bam">
                <metadata name="dbkey" value="89"/>
                <assert_contents>
                    <has_size value="17602" delta="600"/>
                </assert_contents>
            </output>
            <output name="output_unmapped_reads" ftype="qname_input_sorted.bam">
                <metadata name="dbkey" value="89"/>
                <assert_contents>
                    <has_size value="17602" delta="600"/>
                </assert_contents>
            </output>
            <output name="output_mapped_reads" ftype="qname_input_sorted.bam">
                <metadata name="dbkey" value="89"/>
                <assert_contents>
                    <has_size value="878" delta="100"/>
                </assert_contents>
            </output>
        </test>
    </tests>
    <tests>
        <test expect_num_outputs="4">
            <param name="input" value="cv_input.bam" ftype="bam"/>
            <param name="ploidy" value="2"/>
            <param name="output_variant_score_hist" value="yes"/>
            <param name="output_zygosity_hist" value="yes"/>
            <param name="output_quality_hist" value="yes"/>
            <output name="output" file="cv_output.vcf" ftype="vcf" compare="contains"/>
            <output name="output_scorehist" file="cv_scorehist_output.tabular" ftype="tabular" compare="contains"/>
            <output name="output_zygosityhist" file="cv_zygosityhist_output.tabular" ftype="tabular" compare="contains"/>
            <output name="output_qualityhist" file="cv_qualityhist_output.tabular" ftype="tabular" compare="contains"/>
        </test>
        <test expect_num_outputs="1">
            <param name="input" value="cv_input.bam" ftype="bam"/>
            <param name="ploidy" value="2"/>
            <param name="output_format" value="gff"/>
            <output name="output" file="cv_output.gff" ftype="gff" compare="contains"/>
        </test>
        <test expect_num_outputs="1">
            <param name="input" value="cv_input.bam" ftype="bam"/>
            <param name="ploidy" value="2"/>
            <param name="output_format" value="txt"/>
            <output name="output" file="cv_output.txt" ftype="txt" compare="contains"/>
        </test>
    </tests>
    <help>
**What it does**

CallVariants is a high-speed, multithreaded variant caller that accepts bam files, and output VCF files.  It is capable
of indel realignment, multi-sample variant-calling, and processing samples with arbitrary ploidy.

BBMap is the recommended mapping program for CallVariants, but output from any aligner is acceptable.  Reads can be
realigned with the "realign" flag.  This is slower, but is highly recommended if the input is from any mapping tool
other than BBMap. Output from BBMap should not be realigned.

**Options**

 * **Ploidy** - Arbitrary ploidy is supported - the default is 1 which works for haploid organisms.  Allele fractions lower than those expected for the ploidy (for example, anything below 0.5 for a diploid, or 0.25 for a tetraploid) will incur a score penalty. When calling variants on non-haploid organisms, it is crucial to set the ploidy.

    </help>
    <expand macro="citations"/>
</tool>
