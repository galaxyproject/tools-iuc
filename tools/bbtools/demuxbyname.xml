<tool id="bbtools_bbmap" name="BBTools: Demuxbyname" version="@TOOL_VERSION@+galaxy4" profile="@PROFILE@">
    <description>demultiplexes sequences into multiple files based on their names</description>
    <macros>
        <import>macros.xml</import>
    </macros>
    <expand macro="requirements"/>
    <command detect_errors="exit_code"><![CDATA[
#import os
#import re

#if str($ref_source_cond.ref_source) == 'cached'
    #set ref = str($ref_source_cond.reference.fields.path)
#else:
    #set ref = $ref_source_cond.reference
#end if

#if str($input_type_cond.input_type) in ['single', 'pair']:
    #set read1 = $input_type_cond.read1
    ## bbmap uses the file extension to determine the input format.
    #set ext = '.fastq'
    #if $read1.ext.endswith('.gz'):
        #set ext = $ext + '.gz'
    #end if
    #set read1_file = 'forward' + $ext
    ln -s '${read1}' '${read1_file}' &&
    #if str($input_type_cond.input_type) == 'pair':
        #set read2 = $input_type_cond.read2
        #set read2_file = 'reverse' + $ext
        ln -s '${read2}' '${read2_file}' &&
    #end if
#else:
    #set read1 = $input_type_cond.reads_collection['forward']
    #set read1_identifier = re.sub('[^\s\w\-]', '_', str($read1.element_identifier))
    ## bbmap uses the file extension to determine the input format.
    #set ext = $read1_identifier + '.fastq'
    #if $read1.ext.endswith('.gz'):
        #set ext = $ext + '.gz'
    #end if
    #set read1_file = $read1_identifier + $ext
    ln -s '${read1}' '${read1_file}' &&
    #set read2 = $input_type_cond.reads_collection['reverse']
    #set read2_identifier = re.sub('[^\s\w\-]', '_', str($read2.element_identifier))
    #set read2_file = $read2_identifier + $ext
    ln -s '${read2}' '${read2_file}' &&
#end if

bbmap.sh

#### Indexing Parameters
nodisk=f
ref='${ref}'
k=13
usemodulo=f
rebuild=f

#### Input Parameters
#if str($input_type_cond.input_type) == 'single':
    in='${read1_file}'
#else:
    in='${read1_file}' in2='${read2_file}'
#end if
fastareadlen=500
unpigz=f
touppercase=t

#### Sampling Parameters
reads=-1
samplerate=1
skipreads=0

#### Mapping Parameters
maxindel=$mapping_options.maxindel
strictmaxindel='$mapping_options.strictmaxindel'
tipsearch=$mapping_options.tipsearch
minid=$mapping_options.minid
minhits=$mapping_options.minhits
local='$mapping_options.local'
perfectmode='$mapping_options.perfectmode'
semiperfectmode='$mapping_options.semiperfectmode'
threads=\${GALAXY_SLOTS:-4}
ambiguous='$mapping_options.ambiguous'
samestrandpairs='$mapping_options.samestrandpairs'
requirecorrectstrand='$mapping_options.requirecorrectstrand'
killbadpairs='$mapping_options.killbadpairs'
pairedonly='$mapping_options.pairedonly'

]]></command>
    <inputs>
        <expand macro="input_type_cond"/>
        <expand macro="reference_source_cond"/>

    </inputs>
    <outputs>
 
    </outputs>
    <tests>

        <!-- Collection of Paired reads, history reference, output unsorted -->
        <test expect_num_outputs="3">
            <param name="input_type" value="paired"/>
            <param name="reads_collection">
                <collection type="paired">
                    <element name="forward" value="13-1941-6_S4_L001_R1_600000.fastq.gz"/>
                    <element name="reverse" value="13-1941-6_S4_L001_R2_600000.fastq.gz"/>
                </collection>
            </param>
            <param name="ref_source" value="history"/>
            <param name="reference" value="NC_002945v4.fasta" dbkey="89" ftype="fasta"/>
            <param name="output_sort" value="unsorted"/>
            <output name="output_all_reads" ftype="qname_input_sorted.bam">
                <metadata name="dbkey" value="89"/>
                <assert_contents>
                    <has_size value="17059" delta="600"/>
                </assert_contents>
            </output>
            <output name="output_unmapped_reads" ftype="qname_input_sorted.bam">
                <metadata name="dbkey" value="89"/>
                <assert_contents>
                    <has_size value="17059" delta="600"/>
                </assert_contents>
            </output>
            <output name="output_mapped_reads" ftype="qname_input_sorted.bam">
                <metadata name="dbkey" value="89"/>
                <assert_contents>
                    <has_size value="906" delta="100"/>
                </assert_contents>
            </output>
        </test>
    </tests>
    <help>
**What it does**



    </help>
    <expand macro="citations"/>
</tool>

