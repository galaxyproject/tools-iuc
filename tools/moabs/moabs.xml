<tool id="moabs" name="MOABS" profile="16.04" version="@VERSION@">
    <description>MOdel based Analysis of Bisulfite Sequencing data</description>
    <macros>
        <import>macros.xml</import>
    </macros>
    <expand macro="requirements"/>
    <command detect_errors="exit_code">
        <![CDATA[
        #if $mcomp_advanced.doComp == 0:
            cp -f '$mcomp_advanced.compFile' comp.g1.vs.g2.txt &&
        #end if
        moabs --def MMAP.p="\${GALAXY_SLOTS:-4}" --def MCALL.p="\${GALAXY_SLOTS:-4}" --def MCOMP.p="\${GALAXY_SLOTS:-4}" --cf '$cfg_file' &&
        mv -f dmr_M3_g1.G.bed_vs_g2.G.bed.txt.dmr '$output1'
        ]]>
    </command>
    <configfiles>
        <configfile name="cfg_file">
            #if str( $reference_source.reference_source_selector ) == "history":
                #set $reference_fasta_filename = $reference_source.ref_file
            #else:
                #set $reference_fasta_filename = $reference_source.ref_file.fields.path
            #end if
            [INPUT]
            #for $i, $s in enumerate( $g1_fastq )
                #if str( $s.fastq_input.fastq_input_selector ) == "paired":
                    s1_r${i+1}_1='$s.fastq_input.fastq_input1'
                    s1_r${i+1}_2='$s.fastq_input.fastq_input2'
                #elif str( $s.fastq_input.fastq_input_selector ) == "paired_collection":
                    s1_r${i+1}_1='$s.fastq_input.fastq_input1.forward'
                    s1_r${i+1}_2='$s.fastq_input.fastq_input1.reverse'
                #else:
                    s1_r${i+1}='$s.fastq_input.fastq_input1'
                #end if
            #end for

            #for $i, $s in enumerate( $g2_fastq )
                #if str( $s.fastq_input.fastq_input_selector ) == "paired":
                    s2_r${i+1}_1='$s.fastq_input.fastq_input1'
                    s2_r${i+1}_2='$s.fastq_input.fastq_input2'
                #elif str( $s.fastq_input.fastq_input_selector ) == "paired_collection":
                    s2_r${i+1}_1='$s.fastq_input.fastq_input1.forward'
                    s2_r${i+1}_2='$s.fastq_input.fastq_input1.reverse'
                #else:
                    s2_r${i+1}='$s.fastq_input.fastq_input1'
                #end if
            #end for

            [TASK]
            Program=MMAP
            Label=g1,g2
            Parallel=NONE

            [MMAP]
            Path=bsmap
            d='${reference_fasta_filename}'
            v=$bsmap_advanced.v
            n=$bsmap_advanced.n
            r=$bsmap_advanced.r
            R=''

            [MCALL]
            Path=mcall
            r='${reference_fasta_filename}'

            [MCOMP]
            Path=mcomp
            reference='${reference_fasta_filename}'
            doComp=$mcomp_advanced.doComp
        </configfile>
    </configfiles>

    <inputs>
        <conditional name="reference_source">
            <param name="reference_source_selector" type="select" label="Will you select a reference genome from your history or use a cache FASTA?" help="Cached FASTA">
                <option value="cached">Use a cached genome FASTA</option>
                <option value="history">Use a genome FASTA from history</option>
            </param>
            <when value="cached">
                <param name="ref_file" type="select" label="Using reference genome" help="Select genome from the list">
                    <options from_data_table="all_fasta">
                        <filter type="sort_by" column="2" />
                        <validator type="no_options" message="No genome FASTA are available" />
                    </options>
                </param>
            </when>
            <when value="history">
                <param name="ref_file" type="data" format="fasta" label="Use the following dataset as the reference sequence" help="You can upload a FASTA sequence to the history and use it as reference" />
            </when>
        </conditional>
        <repeat name="g1_fastq" title="Group1: fastq files">
            <conditional name="fastq_input">
                <param name="fastq_input_selector" type="select" label="Single or Paired-end reads" help="Select between paired and single end data">
                    <option value="paired">Paired</option>
                    <option value="single">Single</option>
                    <option value="paired_collection">Paired Collection</option>
                </param>
                <when value="paired">
                    <param name="fastq_input1" type="data" format="fastqsanger,fastqsanger.gz" label="Select first set of reads" help="Specify dataset with forward reads"/>
                    <param name="fastq_input2" type="data" format="fastqsanger,fastqsanger.gz" label="Select second set of reads" help="Specify dataset with reverse reads"/>
                </when>
                <when value="single">
                    <param name="fastq_input1" type="data" format="fastqsanger,fastqsanger.gz" label="Select fastq dataset" help="Specify dataset with single reads"/>
                </when>
                <when value="paired_collection">
                    <param name="fastq_input1" format="fastqsanger,fastqsanger.gz" type="data_collection" collection_type="paired" label="Select a paired collection" help="See help section for an explanation of dataset collections"/>
                </when>
            </conditional>
        </repeat>
        <repeat name="g2_fastq" title="Group2: fastq files">
            <conditional name="fastq_input">
                <param name="fastq_input_selector" type="select" label="Single or Paired-end reads" help="Select between paired and single end data">
                    <option value="paired">Paired</option>
                    <option value="single">Single</option>
                    <option value="paired_collection">Paired Collection</option>
                </param>
                <when value="paired">
                    <param name="fastq_input1" type="data" format="fastqsanger,fastqsanger.gz" label="Select first set of reads" help="Specify dataset with forward reads"/>
                    <param name="fastq_input2" type="data" format="fastqsanger,fastqsanger.gz" label="Select second set of reads" help="Specify dataset with reverse reads"/>
                </when>
                <when value="single">
                    <param name="fastq_input1" type="data" format="fastqsanger,fastqsanger.gz" label="Select fastq dataset" help="Specify dataset with single reads"/>
                </when>
                <when value="paired_collection">
                    <param name="fastq_input1" format="fastqsanger,fastqsanger.gz" type="data_collection" collection_type="paired" label="Select a paired collection" help="See help section for an explanation of dataset collections"/>
                </when>
            </conditional>
        </repeat>
        <section name="bsmap_advanced" title="Advanced options for BSMAP" expanded="False">
            <param name="v" type="text" value="0.08" label="-v: Mismatch rate or number" help="[0,1]: mismatch rate w.r.t to the read length; otherwise: maximum number of mismatches allowed on a read"/>
            <param name="n" type="integer" value="1" label="-n: Set mapping strand information" help="0: only map to 2 forward strands, i.e. BSW(++) and BSC(-+); 1: map SE or PE reads to all 4 strands, i.e. ++, +-, -+, --"/>
            <param name="r" type="integer" value="0" label="-r: How to report repeat hits" help="0=none(unique hit/pair); 1=random one; 2=all(slow)"/>
        </section>
        <section name="mcomp_advanced" title="Advanced options for MCOMP" expanded="False">
            <param name="doComp" type="integer" value="1" label="--doComp: Run the comparison or not" help="0: not compare, using comparison result by `-c`; 1: compare"/>
            <param name="compFile" type="data" format="txt" label="-c: Input comparison results" help="Previously generated comparison file from history"/>
        </section>
    </inputs>
    <outputs>
        <data name="output1" format="txt" label="${tool.name} on ${on_string} (.txt)" />
    </outputs>
    <tests>
        <test>
            <!-- test single-end reads -->
            <param name="reference_source_selector" value="history"/>
            <param name="ref_file" ftype="fasta" value="chr11.fa"/>
            <repeat name="g1_fastq">
                <conditional name="fastq_input">
                    <param name="fastq_input_selector" value="single"/>
                    <param name="fastq_input1" value="WTPE1.fastq.gz"/>
                </conditional>
            </repeat>
            <repeat name="g1_fastq">
                <conditional name="fastq_input">
                    <param name="fastq_input_selector" value="single"/>
                    <param name="fastq_input1" value="WTPE2.fastq.gz"/>
                </conditional>
            </repeat>
            <repeat name="g2_fastq">
                <conditional name="fastq_input">
                    <param name="fastq_input_selector" value="single"/>
                    <param name="fastq_input1" value="TKO2PE1.fastq.gz"/>
                </conditional>
            </repeat>
            <repeat name="g2_fastq">
                <conditional name="fastq_input">
                    <param name="fastq_input_selector" value="single"/>
                    <param name="fastq_input1" value="TKO2PE2.fastq.gz"/>
                </conditional>
            </repeat>
            <param name="doComp" value="0"/>
            <param name="compFile" value="SE_comp.g1.vs.g2.txt"/>
            <output name="output1" file="SE_dmr_M3_g1.G.bed_vs_g2.G.bed.txt.dmr" ftype="txt" lines_diff="1"/>
        </test>
        <test>
            <!-- test paired-end reads -->
            <param name="reference_source_selector" value="history"/>
            <param name="ref_file" ftype="fasta" value="seg.fa"/>
            <repeat name="g1_fastq">
                <conditional name="fastq_input">
                    <param name="fastq_input_selector" value="paired"/>
                    <param name="fastq_input1" value="6_all_1.fq.gz"/>
                    <param name="fastq_input2" value="6_all_2.fq.gz"/>
                </conditional>
            </repeat>
            <repeat name="g2_fastq">
                <conditional name="fastq_input">
                    <param name="fastq_input_selector" value="paired"/>
                    <param name="fastq_input1" value="8_all_1.fq.gz"/>
                    <param name="fastq_input2" value="8_all_2.fq.gz"/>
                </conditional>
            </repeat>
            <param name="doComp" value="0"/>
            <param name="compFile" value="PE_comp.g1.vs.g2.txt"/>
            <output name="output1" file="PE_dmr_M3_g1.G.bed_vs_g2.G.bed.txt.dmr" ftype="txt" lines_diff="1"/>
        </test>
        <test>
            <!-- test paired collection -->
            <param name="reference_source_selector" value="history"/>
            <param name="ref_file" ftype="fasta" value="seg.fa"/>
            <repeat name="g1_fastq">
                <conditional name="fastq_input">
                    <param name="fastq_input_selector" value="paired_collection"/>
                    <param name="fastq_input1">
                        <collection type="paired">
                            <element name="forward" value="6_all_1.fq.gz" />
                            <element name="reverse" value="6_all_2.fq.gz" />
                        </collection>
                    </param>
                </conditional>
            </repeat>
            <repeat name="g2_fastq">
                <conditional name="fastq_input">
                    <param name="fastq_input_selector" value="paired_collection"/>
                    <param name="fastq_input1">
                        <collection type="paired">
                            <element name="forward" value="8_all_1.fq.gz" />
                            <element name="reverse" value="8_all_2.fq.gz" />
                        </collection>
                    </param>
                </conditional>
            </repeat>
            <param name="doComp" value="0"/>
            <param name="compFile" value="PE_comp.g1.vs.g2.txt"/>
            <output name="output1" file="PE_dmr_M3_g1.G.bed_vs_g2.G.bed.txt.dmr" ftype="txt" lines_diff="1"/>
        </test>
        <test>
            <!-- test data table reference -->
            <param name="reference_source_selector" value="cached"/>
            <param name="ref_file" value="chr11"/>
            <repeat name="g1_fastq">
                <conditional name="fastq_input">
                    <param name="fastq_input_selector" value="single"/>
                    <param name="fastq_input1" value="WTPE1.fastq.gz"/>
                </conditional>
            </repeat>
            <repeat name="g1_fastq">
                <conditional name="fastq_input">
                    <param name="fastq_input_selector" value="single"/>
                    <param name="fastq_input1" value="WTPE2.fastq.gz"/>
                </conditional>
            </repeat>
            <repeat name="g2_fastq">
                <conditional name="fastq_input">
                    <param name="fastq_input_selector" value="single"/>
                    <param name="fastq_input1" value="TKO2PE1.fastq.gz"/>
                </conditional>
            </repeat>
            <repeat name="g2_fastq">
                <conditional name="fastq_input">
                    <param name="fastq_input_selector" value="single"/>
                    <param name="fastq_input1" value="TKO2PE2.fastq.gz"/>
                </conditional>
            </repeat>
            <param name="doComp" value="0"/>
            <param name="compFile" value="SE_comp.g1.vs.g2.txt"/>
            <output name="output1" file="SE_dmr_M3_g1.G.bed_vs_g2.G.bed.txt.dmr" ftype="txt" lines_diff="1"/>
        </test>
    </tests>
    <help>
        <![CDATA[
**MOABS: MOdel based Analysis of Bisulfite Sequencing data**

MOABS is a comprehensive, accurate and efficient solution for analysis of large
scale base-resolution DNA methylation data, bisulfite sequencing or single
molecule direct sequencing.

MOABS seamlessly integrates alignment, methylation calling, identification of
hypomethylation for one sample and differential methylation for multiple
samples, and other downstream analysis.

For more information, check https://github.com/sunnyisgalaxy/moabs.

-----

**Input files**

MOABS needs to input Bisulfite sequencing reads in two groups of interest, e.g.
KO vs WT. Each group of reads may have combined sequencing library, i.e.
single-end reads and/or paired-end reads. Multiple replicates can be specified in each group.

**Output format**

MOABS will detect differential methylated regions (DMRs) using the input BS-Seq
reads. The output file is a tab-delimited text file (not strictly a BED
format), representing DMRs. It has 8 columns as below.

chrom<TAB>start<TAB>end<TAB>methylation_state<TAB>CpGsites<TAB>DMCcount<TAB>nonDMCcount<TAB>hidden_state

    1. **chrom** - The chromosome of the region.
    2. **start** - The start genomic locus of the region.
    3. **end** - The end genomic locus of the region.
    4. **methylation_state** - The methylation state of the region, "+"/"-" representing hyper- or hypo-methylation regions.
    5. **CpGsites** - Total number of CpG sites in the region.
    6. **DMCcount** - The number of differential methylated CpG sites (DMCs) in the region.
    7. **nonDMCcount** - The number of non-DMCs in the region.
    8. **hidden_state** - The hidden state prediced by Hidden Markov Model (HMM), "1"/"-1" representing hyper- or hypo-methylation states.

For example, six DMRs are identified in the following format.

@DMRExample@

]]>
    </help>
    <expand macro="citations"/>
</tool>
