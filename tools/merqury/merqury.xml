<tool id="merqury" name="Merqury" version="@TOOL_VERSION@" profile="20.01">
    <description>evaluate the assembly quality</description>
    <macros>
        <import>macros.xml</import>
    </macros>
    <expand macro="edam_ontology"/>
    <expand macro="requirements"/>
    <version_command>merqury --version</version_command>
    <command detect_errors="exit_code"><![CDATA[
        mkdir -p ./output_files &&
        #from math import log
        #import subprocess
        export MERQURY=\$(dirname \$(command -v merqury.sh))/../share/merqury/ &&
        echo \$MERQURY &&
        #set $kmer_size = $meryl_options.kmer_size
        #if not $meryl_options.kmer_size
            #set $kmer_size = int(log(int($meryl_options.genome_size)*(1-float($meryl_options.collision_rate))/float($meryl_options.collision_rate))/log(4))
        #end if
        echo "Kmer size: $kmer_size" > $kmer_size_file &&
        #if $mode.options == 'default'
            #for $i, $read in enumerate($child_reads):
                mkdir 'child{$i}.meryl' &&
                meryl count k=$kmer_size '${read}' output 'child{$i}.meryl' &&
            #end for
            meryl union-sum child*.meryl output child.meryl &&
            ln -s '$assembly' ./assembly.fasta &&
            merqury.sh child.meryl ./assembly.fasta '$label' &&
            mv $label* ./output_files &&
            mv completeness.stats ./output_files
        #else
            #for $i, $read in enumerate($paternal_reads):
                mkdir 'paternal{$i}.meryl' &&
                meryl count k=$kmer_size '${read}' output 'paternal{$i}.meryl' &&
            #end for
            meryl union-sum paternal*.meryl output pat.meryl &&
            #for $i, $read in enumerate($maternal_reads):
                mkdir 'maternal{$i}.meryl' &&
                meryl count k=$kmer_size '${read}' output 'maternal{$i}.meryl' &&
            #end for
            meryl union-sum maternal*.meryl output mat.meryl &&
            #for $i, $read in enumerate($child_reads):
                mkdir 'child{$i}.meryl' &&
                meryl count k=$kmer_size '${read}' output 'child{$i}.meryl' &&
            #end for
            meryl union-sum child*.meryl output child.meryl &&
            ## mat specific kmers
            meryl difference mat.meryl pat.meryl output mat.only.meryl &&
            meryl histogram mat.only.meryl > mat.only.hist &&
            java -jar -Xmx1g \$MERQURY/eval/kmerHistToPloidyDepth.jar mat.only.hist > mat.only.ploidy &&
            VAR=`sed -n 2p mat.only.ploidy | awk '{print \$NF}'` &&
            meryl greater-than \$VAR output mat.only.filt.meryl mat.only.meryl &&
            ## pat specific kmers
            meryl difference pat.meryl mat.meryl output pat.only.meryl &&
            meryl histogram pat.only.meryl > pat.only.hist &&
            java -jar -Xmx1g \$MERQURY/eval/kmerHistToPloidyDepth.jar pat.only.hist > pat.only.ploidy &&
            VAR=`sed -n 2p pat.only.ploidy | awk '{print \$NF}'` &&
            meryl greater-than \$VAR output pat.only.filt.meryl pat.only.meryl &&
            ## shared kmers
            meryl intersect output shared.meryl mat.meryl pat.meryl &&
            ## mat hapmers
            meryl intersect output mat.inherited.meryl child.meryl mat.only.filt.meryl &&
            meryl histogram mat.inherited.meryl > mat.inherited.hist &&
            java -jar -Xmx1g \$MERQURY/eval/kmerHistToPloidyDepth.jar mat.inherited.hist > mat.inherited.ploidy &&
            VAR=`sed -n 2p mat.inherited.ploidy | awk '{print \$NF}'` &&
            meryl greater-than \$VAR output mat.hapmer.meryl mat.inherited.meryl &&
            ## pat hapmers
            meryl intersect output pat.inherited.meryl child.meryl pat.only.filt.meryl &&
            meryl histogram pat.inherited.meryl > pat.inherited.hist &&
            java -jar -Xmx1g \$MERQURY/eval/kmerHistToPloidyDepth.jar pat.inherited.hist > pat.inherited.ploidy &&
            VAR=`sed -n 2p pat.inherited.ploidy | awk '{print \$NF}'` &&
            meryl greater-than \$VAR output pat.hapmer.meryl pat.inherited.meryl &&
            ## shared hapmers
            meryl intersect output shared.inherited.meryl child.meryl shared.meryl &&
            meryl histogram shared.inherited.meryl > shared.inherited.hist &&
            java -jar -Xmx1g \$MERQURY/eval/kmerHistToPloidyDepth.jar shared.inherited.hist > shared.inherited.ploidy &&
            VAR=`sed -n 2p shared.inherited.ploidy | awk '{print \$NF}'` &&
            meryl greater-than \$VAR output shared.filt.meryl shared.inherited.meryl &&
            ## child hapmers
            meryl union-sum output child.inherited.meryl mat.inherited.meryl pat.inherited.meryl shared.inherited.meryl &&
            meryl difference output read.only.meryl child.meryl child.inherited.meryl &&
            ln -s '$assembly' ./assembly.fasta &&
            merqury.sh read.only.meryl mat.hapmer.meryl pat.hapmer.meryl ./assembly.fasta '$label' &&
            find ./ -type f -not -empty -name '*.tdf' -exec basename \{} .tdf \; | xargs -I{} igvtools tdftobedgraph {}.tdf {}.bedgraph &&
            mv $label* ./output_files &&
            mv completeness.stats ./output_files &&
            mv switches.txt ./output_files/switches.stats
        #end if
        &&
        ls -l ./output_files
    ]]>    </command>
    <inputs>
        <conditional name="mode">
            <param name="options" type="select" label="Evaluation mode" help="Merqury allows two operational modes: default and trio mode.">
                <option value="default">default mode</option>
                <option value="trio">Trio mode</option>
            </param>
            <when value="default">
                <param name="child_reads" type="data" format="fastq,fasta,fastq.bgzip,fasta.bgzip" multiple="true" label="F1 reads" help="Select F1 reads used for generating the assembly"/>
                <param name="assembly" type="data" format="fasta,fasta.bgzip" label="Genome assembly" help="Select the assembled genome."/>
            </when>
            <when value="trio">
                <param name="child_reads" type="data" format="fastq,fasta,fastq.bgzip,fasta.bgzip" multiple="true" label="F1 reads" help="Select F1 reads used for generating the assembly"/>
                <param name="paternal_reads" type="data" format="fastq,fasta,fastq.bgzip,fasta.bgzip" multiple="true" optional="true" label="Paternal reads" help="Select the paternal reads used for generating the assembly"/>
                <param name="maternal_reads" type="data" format="fastq,fasta,fastq.bgzip,fasta.bgzip" multiple="true" optional="true" label="Maternal reads" help="Select the maternal reads used for generating the assembly"/>
                <param name="assembly" type="data" format="fasta,fasta.bgzip" multiple="true" label="Genome assemblies" help="Select the assembled genome/s"/>
            </when>
        </conditional>
        <param name="label" type="text" value="assembly" label="Identification label" help="Assign an identification label.">
            <sanitizer invalid_char="">
                <valid initial="string.letters,string.digits">
                    <add value="_"/>
                </valid>
            </sanitizer>
        </param>
        <section name="meryl_options" title="Meryl options" expanded="true">
            <param name="kmer_size" type="integer" min="5" max="50" value="" optional="true" label="K-mer size" help="If not k-mer size is provided, it will be estimated from the genome size. For a human genome, the best k-mer size is k=21 for both haploid or diploid."/>
            <param name="genome_size" type="integer" min="1000" max="70000000000" value="" label="Genome size" help="Haploid genome size or diploid genome size, depending on what we evaluate. In bp."/>
            <param name="collision_rate" type="float" min="0.0001" max="0.01" value="0.001" label="Tolerable collision rate" help="Tolerable collision rate. By default is 0.001."/>
        </section>
    </inputs>
    <outputs>
        <data name="kmer_size_file" format="txt"/>
        <collection name="bed_files" type="list" label="${tool.name} on ${on_string}: bed">
            <discover_datasets pattern="(?P&lt;name&gt;.+)\.bed" format="bed" directory="output_files"/>
        </collection>
        <collection name="bedgraph_files" type="list" label="${tool.name} on ${on_string}: bedgraph">
            <discover_datasets pattern="(?P&lt;name&gt;.+)\.bedgraph" format="bedgraph" directory="output_files"/>
        </collection>
        <collection name="qv_files" type="list" label="${tool.name} on ${on_string}: qv">
            <discover_datasets pattern="(?P&lt;name&gt;.+)\.qv" format="tabular" directory="output_files"/>
        </collection>
        <collection name="png_files" type="list" label="${tool.name} on ${on_string}: png">
            <discover_datasets pattern="(?P&lt;name&gt;.+)\.png" format="png" directory="output_files"/>
        </collection>
        <collection name="sizes_files" type="list" label="${tool.name} on ${on_string}: size files">
            <discover_datasets pattern="(?P&lt;name&gt;.+)\.sizes" format="tabular" directory="output_files"/>
        </collection>
        <collection name="stats_files" type="list" label="${tool.name} on ${on_string}: stats">
            <discover_datasets pattern="(?P&lt;name&gt;.+)\.stats" format="tabular" directory="output_files"/>
        </collection>
    </outputs>
    <tests>
        <test>
            <conditional name="mode">
                <param name="options" value="trio"/>
                <param name="child_reads" value="child.fasta.bgzip"/>
                <param name="paternal_reads" value="paternal.fasta.bgzip"/>
                <param name="maternal_reads" value="maternal.fasta.bgzip"/>
                <param name="assembly" value="assembly.fasta.bgzip"/>
            </conditional>
            <param name="label" value="output_01"/>
            <section name="meryl_options">
                <param name="kmer_size" value="7"/>
                <param name="genome_size" value="1000"/>
                <param name="collision_rate" value="0.001"/>
            </section>
            <output name='kmer_size' file='output_01.kmer_size.txt'>
                <assert_contents>
                    <has_text text="Kmer size: 7"/>
                </assert_contents>
            </output>
            <output_collection name="png_files" type="list" count="5">
                <element name="output_01.assembly.mat.hapmer.spectra-cn.ln" file="output_01.assembly.spectra-cn.ln.png" ftype="png">
                    <assert_contents>
                        <has_size value="2700" delta="1000"/>
                    </assert_contents>
                </element>
                <element name="output_01.assembly.pat.hapmer.spectra-cn.ln" file="output_01.assembly.spectra-cn.ln.png" ftype="png">
                    <assert_contents>
                        <has_size value="2700" delta="1000"/>
                    </assert_contents>
                </element>
                <element name="output_01.assembly.block.N" file="output_01.assembly.block.N.png" ftype="png">
                    <assert_contents>
                        <has_size value="46500" delta="1000"/>
                    </assert_contents>
                </element>
                <element name="output_01.assembly.continuity.N" file="output_01.assembly.continuity.N.png" ftype="png">
                    <assert_contents>
                        <has_size value="53800" delta="1000"/>
                    </assert_contents>
                </element>
                <element name="output_01.assembly.100_20000.phased_block.blob" file="output_01.assembly.100_20000.phased_block.blob.png" ftype="png">
                    <assert_contents>
                        <has_size value="3500" delta="1000"/>
                    </assert_contents>
                </element>
            </output_collection>
            <output_collection name="stats_files" type="list" count="3">
                <element name="completeness" file="output_01.completeness.stats.tabular" ftype="tabular">
                    <assert_contents>
                        <has_size value="0" delta="1000"/>
                    </assert_contents>
                </element>
                <element name="output_01.assembly.100_20000.phased_block" file="output_01.assembly.100_20000.phased_block.stats.tabular" ftype="tabular"/>
                <element name="switches" file="output_01.switches.txt" ftype="tabular"/>
            </output_collection>
            <output_collection name="sizes_files" type="list" count="2">
                <element name="output_01.assembly.100_20000.phased_block" file="output_01.assembly.100_20000.phased_block.tabular" ftype="tabular"/>
                <element name="output_01.assembly.contig" file="output_01.assembly.contig.tabular" ftype="tabular"/>
            </output_collection>
            <output_collection name="bed_files" type="list" count="6">
                <element name="output_01.assembly.100_20000.phased_block" file="output_01.assembly.100_20000.phased_block.bed" ftype="bed"/>
                <element name="output_01.assembly.100_20000.switch" file="output_01.assembly.100_20000.switch.bed" ftype="bed"/>
                <element name="output_01.assembly" file="output_01.assembly.bed" ftype="bed"/>
                <element name="output_01.assembly.mat.hapmer" file="output_01.assembly.mat.hapmer.bed" ftype="bed">
                    <assert_contents>
                        <has_size value="0" delta="1000"/>
                    </assert_contents>
                </element>
                <element name="output_01.assembly.pat.hapmer" file="output_01.assembly.pat.hapmer.bed" ftype="bed"/>
                <element name="output_01.assembly.sort" file="output_01.assembly.sort.bed" ftype="bed"/>
            </output_collection>
        </test>
        <test>
            <conditional name="mode">
                <param name="options" value="trio"/>
                <param name="child_reads" value="child.fasta.bgzip"/>
                <param name="paternal_reads" value="paternal.fasta.bgzip"/>
                <param name="maternal_reads" value="maternal.fasta.bgzip"/>
            </conditional>
            <param name="assembly" value="assembly.fasta.bgzip"/>
            <param name="label" value="output_02"/>
            <section name="meryl_options">
                <param name="kmer_size" value="7"/>
                <param name="genome_size" value="2000"/>
                <param name="collision_rate" value="0.01"/>
            </section>
            <output name='kmer_size' file='output_02.kmer_size.txt'>
                <assert_contents>
                    <has_text text="Kmer size: 7"/>
                </assert_contents>
            </output>
            <output_collection name="png_files" type="list" count="5">
                <element name="output_02.assembly.mat.hapmer.spectra-cn.ln" file="output_02.assembly.spectra-cn.ln.png" ftype="png">
                    <assert_contents>
                        <has_size value="2700" delta="1000"/>
                    </assert_contents>
                </element>
                <element name="output_02.assembly.pat.hapmer.spectra-cn.ln" file="output_02.assembly.spectra-cn.ln.png" ftype="png">
                    <assert_contents>
                        <has_size value="2700" delta="1000"/>
                    </assert_contents>
                </element>
                <element name="output_02.hapmers.blob" file="output_02.hapmers.blob.png" ftype="png">
                    <assert_contents>
                        <has_size value="3400" delta="1000"/>
                    </assert_contents>
                </element>
                <element name="output_02.assembly.block.N" file="output_02.assembly.block.N.png" ftype="png">
                    <assert_contents>
                        <has_size value="46500" delta="1000"/>
                    </assert_contents>
                </element>
                <element name="output_02.assembly.continuity.N" file="output_02.assembly.continuity.N.png" ftype="png">
                    <assert_contents>
                        <has_size value="53862" delta="1000"/>
                    </assert_contents>
                </element>
            </output_collection>
            <output_collection name="stats_files" type="list" count="3">
                <element name="completeness" file="output_02.completeness.stats.tabular" ftype="tabular">
                    <assert_contents>
                        <has_size value="0" delta="1000"/>
                    </assert_contents>
                </element>
                <element name="output_02.assembly.100_20000.phased_block" file="output_02.assembly.100_20000.phased_block.stats.tabular" ftype="tabular"/>
                <element name="switches" file="output_02.switches.txt" ftype="tabular"/>
            </output_collection>
            <output_collection name="sizes_files" type="list" count="2">
                <element name="output_02.assembly.100_20000.phased_block" file="output_02.assembly.100_20000.phased_block.tabular" ftype="tabular"/>
                <element name="output_02.assembly.contig" file="output_02.assembly.contig.tabular" ftype="tabular"/>
            </output_collection>
            <output_collection name="bed_files" type="list" count="6">
                <element name="output_02.assembly.100_20000.phased_block" file="output_02.assembly.100_20000.phased_block.bed" ftype="bed"/>
                <element name="output_02.assembly.100_20000.switch" file="output_02.assembly.100_20000.switch.bed" ftype="bed"/>
                <element name="output_02.assembly" file="output_02.assembly.bed" ftype="bed"/>
                <element name="output_02.assembly.mat.hapmer" file="output_02.assembly.mat.hapmer.bed" ftype="bed">
                    <assert_contents>
                        <has_size value="0" delta="1000"/>
                    </assert_contents>
                </element>
                <element name="output_02.assembly.pat.hapmer" file="output_02.assembly.pat.hapmer.bed" ftype="bed"/>
                <element name="output_02.assembly.sort" file="output_02.assembly.sort.bed" ftype="bed"/>
            </output_collection>
        </test>
        <test>
            <conditional name="mode">
                <param name="options" value="default"/>
                <param name="child_reads" value="child.fasta.bgzip"/>
                <param name="assembly" value="assembly.fasta.bgzip"/>
            </conditional>
            <param name="label" value="output_03"/>
            <section name="meryl_options">
                <param name="kmer_size" value="7"/>
                <param name="genome_size" value="1000"/>
                <param name="collision_rate" value="0.001"/>
            </section>
            <output name='kmer_size' file='output_03.kmer_size.txt'>
                <assert_contents>
                    <has_text text="Kmer size: 7"/>
                </assert_contents>
            </output>
            <output_collection name="png_files" type="list" count="2">
                <element name="output_03.assembly.spectra-cn.ln" file="output_03.assembly.spectra-cn.ln.png" ftype="png">
                    <assert_contents>
                        <has_size value="2700" delta="1000"/>
                    </assert_contents>
                </element>
                <element name="output_03.spectra-asm.ln" file="output_03.spectra-asm.ln.png" ftype="png">
                    <assert_contents>
                        <has_size value="2700" delta="1000"/>
                    </assert_contents>
                </element>
            </output_collection>
            <output_collection name="stats_files" type="list" count="1">
                <element name="completeness" file="output_03.completeness.stats.tabular" ftype="tabular"/>
            </output_collection>
            <output_collection name="qv_files" type="list" count="2">
                <element name="output_03.assembly" file="output_03.assembly.qv.tabular" ftype="tabular">
                    <assert_contents>
                        <has_size value="0" delta="1000"/>
                    </assert_contents>
                </element>
                <element name="output_03" file="output_03.qv.tabular" ftype="tabular"/>
            </output_collection>
        </test>
        <test>
            <conditional name="mode">
                <param name="options" value="default"/>
                <param name="child_reads" value="child.fasta.bgzip"/>
                <param name="assembly" value="assembly.fasta.bgzip"/>
            </conditional>
            <param name="label" value="output_04"/>
            <section name="meryl_options">
                <param name="kmer_size" value=""/>
                <param name="genome_size" value="1000"/>
                <param name="collision_rate" value="0.003"/>
            </section>
            <output name='kmer_size' file='output_04.kmer_size.txt'>
                <assert_contents>
                    <has_text text="Kmer size: 9"/>
                </assert_contents>
            </output>
            <output_collection name="png_files" type="list" count="6">
                <element name="output_04.assembly.spectra-cn.ln" file="output_04.assembly.spectra-cn.ln.png" ftype="png">
                    <assert_contents>
                        <has_size value="114000" delta="1000"/>
                    </assert_contents>
                </element>
                <element name="output_04.assembly.spectra-cn.fl" file="output_04.assembly.spectra-cn.fl.png" ftype="png">
                    <assert_contents>
                        <has_size value="106000" delta="1000"/>
                    </assert_contents>
                </element>
                <element name="output_04.assembly.spectra-cn.st" file="output_04.assembly.spectra-cn.st.png" ftype="png">
                    <assert_contents>
                        <has_size value="138000" delta="1000"/>
                    </assert_contents>
                </element>
                <element name="output_04.spectra-asm.fl" file="output_04.spectra-asm.fl.png" ftype="png">
                    <assert_contents>
                        <has_size value="101000" delta="1000"/>
                    </assert_contents>
                </element>
                <element name="output_04.spectra-asm.ln" file="output_04.spectra-asm.ln.png" ftype="png">
                    <assert_contents>
                        <has_size value="102000" delta="1000"/>
                    </assert_contents>
                </element>
                <element name="output_04.spectra-asm.st" file="output_04.spectra-asm.st.png" ftype="png">
                    <assert_contents>
                        <has_size value="101000" delta="1000"/>
                    </assert_contents>
                </element>
            </output_collection>
            <output_collection name="stats_files" type="list" count="1">
                <element name="completeness" file="output_04.completeness.stats.tabular" ftype="tabular"/>
            </output_collection>
            <output_collection name="qv_files" type="list" count="2">
                <element name="output_04.assembly" file="output_04.assembly.qv.tabular" ftype="tabular"/>
                <element name="output_04" file="output_04.qv.tabular" ftype="tabular"/>
            </output_collection>
        </test>
    </tests>
    <help><![CDATA[
.. class:: infomark

**Purpose**

Merqury allows a reference-free assembly evaluation based on efficient k-mer set operations. By comparing k-mers in a de novo
assembly to those found in unassembled high-accuracy reads, Merqury estimates base-level accuracy and completeness. 

For trios, Merqury can also evaluate haplotype-specific accuracy, completeness, phase block continuity, and switch errors.                    

----
                    
.. class:: infomark
                    
**Input**

Merqury requires two types of inputs: the rna-seq reads used for generating the assembly, and the assemblies itself.
There is no need to run merqury per-assemblies. If two assemblies areprovided, Merqury generates stats for each and combined.

----
                    
.. class:: infomark
                    
**Output**

The generated metrics include consensus quality and k-mer completeness, and when parental genomic sequences are available
(either assembled or unassembled), Merqury can output haplotype completeness, phase block statistics, switch error rates,
and visual representations of phase consistency for the childâ€™s genome. This includes TDF (or BED) features that can be
displayed in a genome browser for visualizing the presence of k-mer classes across a genome (e.g., the k-mers inherited from a parental genome).                    

    ]]>    </help>
    <expand macro="citations"/>
</tool>
