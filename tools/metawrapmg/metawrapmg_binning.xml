<tool id="metawrapmg_binning" name="MetaWRAP" version="@TOOL_VERSION@+galaxy@VERSION_SUFFIX@" profile="@PROFILE@" license="MIT">
    <description>metagenome binning pipeline.</description>
    <macros>
        <import>macros.xml</import>
    </macros>
    <expand macro="xrefs"/>
    <expand macro="requirements"/>
    <command detect_errors="exit_code"><![CDATA[
            ## Configure the checkm data path. Requires
            ## metawrap-mg_1.3.0--hdfd78af_1 or later. See
            ## https://github.com/bioconda/bioconda-recipes/pull/38299.
            echo "\${CHECKM_DATA_PATH}"
            | checkm data setRoot
            "\${CHECKM_DATA_PATH}"
            &&

            ## set memory usage
            if [ -n "\$GALAXY_MEMORY_MB" ] ; then
                GALAXY_MEMORY_GB=\$((GALAXY_MEMORY_MB / 1024)) ;
            fi ;

            ##################
            ## SET UP FILES ##
            ##################

            ## should always be FASTA
            #set mg_fn = 'metagenome.' + str($metagenome.ext)
            ln -s '$metagenome' $mg_fn
            &&

            ## Only FASTQ. Separate files for each sample. Metawrap checks for
            ## files named _1.fastq and _2.fastq.
            #set input1_fn = 'reads_1.fastq'
            ln -s '$input_1' $input1_fn
            &&

            #set input2_fn = 'reads_2.fastq'
            ln -s '$input_2' $input2_fn
            &&

            #####################
            ## INITIAL BINNING ##
            #####################

            metawrap binning 
            --metabat2 --maxbin2 --concoct 
            -a '$mg_fn'
            -m \${GALAXY_MEMORY_GB:-16}
            -o INITIAL_BINNING
            -t \${GALAXY_SLOTS:-4}
            '$input1_fn'
            '$input2_fn'
            &&

            ## Check which binning programs produced bins            
            bin_dirs=(INITIAL_BINNING/concoct_bins INITIAL_BINNING/maxbin2_bins INITIAL_BINNING/metabat2_bins) &&
            switches=('-A' '-B' '-C') &&

            i=0 &&
            bin_string="" &&

            for dir in "\${bin_dirs[@]}" ; do
                if find "\${dir}" -mindepth 1 -maxdepth 1 | read; then
                    bin_string="\${bin_string} \${switches[\$i]} \${dir}" ;
                    i+=1 ;
                fi
            done &&


            ####################
            ## BIN REFINEMENT ##
            ####################

            ## This will require a data manager for the checkm database.

            ## Note that checkm expects the database under
            ## `/srv/whitlam/bio/db/checkm_data/1.0.0`. This can be changed
            ## using the CHECKM_DATA_PATH environment variable at runtime, but
            ## only after v1.1.6. The metawrap-mg conda package has CheckM
            ## v1.0.12.
            
            ## To change the database location in the older version, checkm
            ## wants *write* access to the config file
            ## at /usr/local/lib/python2.7/site-packages/checkm/DATA_CONFIG
            
            ## One solution is to bind a
            ## directory to /srv/whitlam/bio/db/checkm_data/1.0.0, 
            ## e.g. as a singularity_run_extra_arguments in
            ## job_config_file.

            ## See https://github.com/Ecogenomics/CheckM/pull/326

            metawrap bin_refinement
            -t \${GALAXY_SLOTS:-4}
            -m \${GALAXY_MEMORY_GB:-16}
            -c $binning.c
            -x $binning.x
            -o BIN_REFINEMENT
            ## Only run bin_refinement on bins with contigs
            \${bin_string}
            &&

            ####################
            ## COLLECT OUTPUT ##
            ####################

            find BIN_REFINEMENT
            -maxdepth 1
            -mindepth 1
            -type d
            -name "metawrap*bins" 
            -exec ln -s \{\} metawrap_results ';'
            &&

            exit 0 

    ]]></command>
    <inputs>
        <!-- metagenome assembly -->
        <param name="metagenome" format="fasta" type="data" label="Metagenome" help="Metagenome co-assembly for binning" />
        <!-- fastq files (could be a repeat or a collection) -->
        <param name="input_1" format="fastqsanger" type="data" label="Read 1" help="Original reads that were used for the assembly" />
        <param name="input_2" format="fastqsanger" type="data" label="Read 2" help="Original reads that were used for the assembly" />
        <section name="binning" title="Binning parameters" expanded="false">
            <param argument='-c' type="integer" value="70" min="50" max="100" label="Percent completion" help="Minimum % completion of bins (default=70)" />
            <param argument='-x' type="integer" value="10" min="0" max="100" label="Percent contamination" help="Maximum % contamination of bins that is acceptable (default=10)" />
        </section>
    </inputs>
    <outputs>
        <!-- contigs binned into fasta files -->
        <collection name="metawrap_bins" type="list" label="MetaWRAP on ${on_string}: bins">
            <discover_datasets pattern="(?P&lt;designation&gt;.+)\.fa" format="fasta" directory="metawrap_results" visible="false" />
        </collection>
        <!-- summary figures -->
        <collection name="metawrap_figures" type="list" label="MetaWRAP on ${on_string}: summary figures">
            <discover_datasets pattern="__designation_and_ext__" directory="BIN_REFINEMENT/figures" visible="false" />
        </collection>
        <!-- statistics on binning -->
        <collection name="metawrap_stats" type="list" label="MetaWRAP on ${on_string}: stat files">
            <discover_datasets pattern="(?P&lt;designation&gt;.+)\.stats" format="tabular" directory="BIN_REFINEMENT" visible="false" />
        </collection>
        <!-- which contig went into which bin -->
        <collection name="metawrap_contigs" type="list" label="MetaWRAP on ${on_string}: contig assignments">
            <discover_datasets pattern="(?P&lt;designation&gt;.+)\.contigs" format="tabular" directory="BIN_REFINEMENT" visible="false" />
        </collection>
    </outputs>
    <tests>
        <!-- 01: basic function -->
        <test>
            <param name="metagenome" value="subset.fasta.gz"/>
            <param name="input_1" value="ALL_READS_1.subset.fastq.gz"/>
            <param name="input_2" value="ALL_READS_2.subset.fastq.gz"/>
            <output_collection name="metawrap_bins" type="list">
                <element name="bin.1" file="test01.fa" ftype="fasta"/>
            </output_collection>
            <output_collection name="metawrap_figures" type="list">
                <element name="binning_results" file="test01.png" ftype="png"/>
            </output_collection>
            <output_collection name="metawrap_stats" type="list">
                <element name="metawrap_70_10_bins" file="test01.stats" ftype="tabular"/>
            </output_collection>
            <output_collection name="metawrap_contigs" type="list">
                <element name="metawrap_70_10_bins" file="test01.contigs" ftype="tabular"/>
            </output_collection>
        </test>
        <!-- 02: binning parameters -->
        <test>
            <param name="metagenome" value="subset.fasta.gz"/>
            <param name="input_1" value="ALL_READS_1.subset.fastq.gz"/>
            <param name="input_2" value="ALL_READS_2.subset.fastq.gz"/>
            <param name="c" value="60"/>
            <param name="x" value="15"/>
            <output_collection name="metawrap_bins" type="list">
                <element name="bin.1" file="test02.fa" ftype="fasta"/>
            </output_collection>
            <output_collection name="metawrap_figures" type="list">
                <element name="binning_results" file="test02.png" ftype="png"/>
            </output_collection>
            <output_collection name="metawrap_stats" type="list">
                <element name="metawrap_60_15_bins" file="test02.stats" ftype="tabular"/>
            </output_collection>
            <output_collection name="metawrap_contigs" type="list">
                <element name="metawrap_60_15_bins" file="test02.contigs" ftype="tabular"/>
            </output_collection>
        </test>
    </tests>
        <help><![CDATA[

MetaWRAP
--------

MetaWRAP aims to be an easy-to-use metagenomic wrapper suite that
accomplishes the core tasks of metagenomic analysis. Additionally,
metaWRAP takes bin extraction and analysis to the next level. metaWRAP
is meant to be a fast and simple approach before you delve deeper into
parameterization of your analysis. MetaWRAP can be applied to a variety
of environments, including gut, water, and soil microbiomes (see
metaWRAP paper for benchmarks).

MetaWRAP binning module
~~~~~~~~~~~~~~~~~~~~~~~

The metaWRAP::Binning module is meant to be a convenient wrapper around
three metagenomic binning software: MaxBin2, metaBAT2, and CONCOCT.
First the metagenomic assembly is indexed with bwa-index, and then
paired end reads from any number of samples are aligned to it. The
alignments are sorted and compressed with samtools, and library insert
size statistics are also gathered at the same time (insert size average
and standard deviation). metaBAT2’s jgi_summarize_bam_contig_depths
function is used to generate contig adundance table, and it is then
converted into the correct format for each of the three binners to take
as input. After MaxBin2, metaBAT2, and CONCOCT finish binning the
contigs with default settings, the final bins folders are created with
formatted bin fasta files. CheckM’s lineage_wf function is used to
predict essential genes and estimate the completion and contamination of
each bin.

MetaWRAP bin refinement
~~~~~~~~~~~~~~~~~~~~~~~

The metaWRAP::Bin_refinement module utilizes a hybrid approach to take
in two or three bin sets that were obtained with different software and
produces a consolidated, improved bin set. First, binning_refiner is
used to create hybridized bins from every possible combination of sets.
If there were three bin sets: A, B, and C, then the following hybrid
sets will be produced with binning_refiner: AB, BC, AC, and ABC. CheckM
is then run to evaluate the completion and contamination of the bins in
each of the 7 bin sets (3 originals, 4 hybridized). The bins sets are
then iteratively compared to each other, and each pair is consolidated
into an improved bin set. To do this, the same bin is identified within
the two bin sets based on a minimum of 80% overlap in genome length, and
the better bin is determined based on which bin has the higher score.
The scoring function is S=Completion-5*Contamination. After all bin sets
are incorporated into the consolidated bin collection, a de-replication
function removes any duplicate contigs. If a contig is present in more
than one bin, it is removed from all but the best bin (based on scoring
function). CheckM is then run on the final bin set and a final report
file is generated showing the completion, contamination, and other
statistics generated by CheckM for each bin. Completion and
contamination rank plots are also generated to evaluate the success of
the Bin_refinement module, and compare its output to the quality of the
original bins.

        ]]></help>
    <expand macro="citations"/>
</tool>
