<tool id="hypo" name="HyPo" version="1.0.3" profile="20.05">
    <description>Super Fast & Accurate Polisher for Long Read Genome Assemblies</description>
    <requirements>
        <requirement type="package" version="1.0.3">hypo</requirement>
    </requirements>
    <command detect_errors="exit_code"><![CDATA[
        #for $fastq in $reads_short:
            echo '$fastq' >>  short_reads.txt &&
        #end for
        hypo
        --reads-short @short_reads.txt 
        --draft '$draft' 
        --bam-sr '$bam_sr'
        --coverage-short '$coverage_short '
        --size-ref '$size_ref'
        -t "\${GALAXY_SLOTS:-1}"
        -o '$out_fasta'
        --processing-size '$processing_size'
        --kind-sr '$kind_sr'
        #if $bam_lr
            --bam-lr '$bam_lr'
        #end if
    ]]></command>
    <inputs>
        <param argument="--reads-short" type="data" format="txt" multiple="true" label="List of illumina FASTQ files" help="List of files containing file names in each line can be passed with @ prefix." />
        <param argument="--draft" type="data" format="fasta,fasta.gz" label="Draft genome assembly"/>
        <param argument="--bam-lr" type="data" format="bam" optional="true" label="Bam file with ONT reads aligned" help="Input file name containing the alignments of long reads against the draft (in BAM format; must have CIGAR information)."/>
        <param argument="--bam-sr" type="data" format="bam" label="BAM file with illumina read alignments" help="Input file name containing the alignments of short reads against the draft (in BAM/SAM format; must have CIGAR information)."/>
        <param argument="--coverage-short" type="integer" value="" min="0" label="Aproximate mean coverage of the short reads"/>
        <param argument="--processing-size" type="integer" value="1" label="Number of contigs to be processed in one batch" help="Lower value means less memory usage but slower speed."/>
        <param argumen="--size-ref" type="text" label="Aproximate size of the genome" help="A number can be followed by units k/m/g; e.g. 10m, 2.3g."/>
        <param argument="--kind-sr" type="select"  label="Kind of the short reads">
            <option value="sr" selected="true">Corresponding to NGS reads like Illumina reads (sr)</option>
            <option value="ccs">Corresponding to HiFi reads like PacBio CCS reads (ccs)</option>
        </param> 
    </inputs>
    <outputs>
        <data name="out_fasta" format="fasta"/>
    </outputs>
    <tests>
    <test>
        <param name="draft" value="test2.fasta" ftype="fasta"/>
        <param name="reads_short" value="Illumina.1.fastq.gz,Illumina.2.fastq.gz"/>
        <param name="size_ref" value="10k" />
        <param name="processing_size" value="1" />
        <param name="coverage_short" value="35"/>
        <param name="bam_sr" value="Illumina.test2.bam" ftype="bam" />
        <param name="bam_lr" value="ONT.test2.bam" ftype="bam" />
        <output name="out_fasta" file="hypo_polished.fasta" ftype="fasta" />
    </test>
    </tests>
    <help><![CDATA[
 
Super Fast & Accurate Polisher for Long Read Genome Assemblies 

HyPo - a Hybrid Polisher - utilises short as well as long reads within a single run to polish a long reads assembly of small and large genomes.
It exploits unique genomic kmers to selectively polish segments of contigs using partial order alignment of selective read-segments.
As demonstrated on human genome assemblies, Hypo generates significantly more accurate polished assembly in about one-third time with
about half the memory requirements in comparison to contemporary widely used polishers like Racon.

Please note that "short reads" doesn't necessarily have to be NGS short reads; HiFi genomic reads (e.g. CCS) like those generated from PacBio SequelII
could also be used instead. The requirement is that those reads should be highly accurate (>98% accuracy).

Hypo requires the following as input:

   * Short reads/HiFi reads (in FASTA/FASTQ format; can be compressed)
   * Draft contigs (in FASTA/FASTQ format; can be compressed)
   * Alignments between short reads (or HiFi reads) and the draft (in sam/bam format; should contain CIGAR)
      * If Long (noisy) reads are also to be used for polishing, then alignments between long reads and the draft (in sam/bam format; should contain CIGAR)
   * Expected mean coverage of short reads (or HiFi reads) and approximate size of the genome.

In what follows, short reads can be replaced with HiFi reads.

Broadly, we (conceptually) divide a draft (uncorrected) contig into two types of regions (segments):
Strong and Weak. Strong regions are those which have strong evidence (support) of their correctness and
thus do not need polishing. Weak regions, on the other hand, will be polished using POA. Each weak region will
be polished using either short reads or long reads; short reads taking precedence over long reads. To identify
strong regions, we make use of solid kmers (expected unique genomic kmers). Strong regions also play a role in
selecting the read-segments to polish their neighbouring weak regions. Furthermore, our approach takes into account
that the long reads and thus the assemblies generated from them are prone to homopolymer errors as mentioned in the beginning.

 Usage: hypo <args>

 ** Mandatory args:
	-r, --reads-short <str>
	Input file name containing reads (in fasta/fastq format; can be compressed). A list of files containing file names in each line can be passed with @ prefix.

	-d, --draft <str>
	Input file name containing the draft contigs (in fasta/fastq format; can be compressed). 

	-b, --bam-sr <str>
	Input file name containing the alignments of short reads against the draft (in bam/sam format; must have CIGAR information). 

	-c, --coverage-short <int>
	Approximate mean coverage of the short reads. 

	-s, --size-ref <str>
	Approximate size of the genome (a number; could be followed by units k/m/g; e.g. 10m, 2.3g). 


 ** Optional args:
	-B, --bam-lr <str>
	Input file name containing the alignments of long reads against the draft (in bam/sam format; must have CIGAR information). 
	[Only Short reads polishing will be performed if this argument is not given]

	-o, --output <str>
	Output file name. 
	[Default] hypo_<draft_file_name>.fasta in the working directory.

 	-t, --threads <int>
	Number of threads. 
	[Default] 1.

 	-p, --processing-size <int>
	Number of contigs to be processed in one batch. Lower value means less memory usage but slower speed. 
	[Default] All the contigs in the draft.

 	-k, --kind-sr <str>
	Kind of the short reads. 
	[Valid Values] 
		sr	(Corresponding to NGS reads like Illumina reads) 
		ccs	(Corresponding to HiFi reads like PacBio CCS reads) 
	[Default] sr.

 	-m, --match-sr <int>
	Score for matching bases for short reads. 
	[Default] 5.

 	-x, --mismatch-sr <int>
	Score for mismatching bases for short reads. 
	[Default] -4.

 	-g, --gap-sr <int>
	Gap penalty for short reads (must be negative). 
	[Default] -8.

 	-M, --match-lr <int>
	Score for matching bases for long reads. 
	[Default] 3.

 	-X, --mismatch-lr <int>
	Score for mismatching bases for long reads. 
	[Default] -5.

 	-G, --gap-lr <int>
	Gap penalty for long reads (must be negative). 
	[Default] -4.

 	-n, --ned-th <int>
	Threshold for Normalised Edit Distance of long arms allowed in a window (in %). Higher number means more arms allowed which may slow down the execution.
	[Default] 20.

 	-q, --qual-map-th <int>
	Threshold for mapping quality of reads. The reads with mapping quality below this threshold will not be taken into consideration. 
	[Default] 2.



    ]]></help>
</tool>
