<tool id="cutadapt" name="Cutadapt" version="@TOOL_VERSION@+galaxy@VERSION_SUFFIX@" profile="20.01">
    <description>Remove adapter sequences from FASTQ/FASTA</description>
    <macros>
        <import>macros.xml</import>
    </macros>
    <expand macro='edam_ontology' />
    <expand macro='xrefs'/>
    <expand macro='requirements' />
    <version_command>cutadapt --version</version_command>
    <command detect_errors="exit_code"><![CDATA[
#import re

## set things up for handling inputs and outputs in single- vs paired-end modes
#set library_type = str($library.type)
#if $library_type == 'single':
    #set paired = False
#else:
    #set paired = True
#end if

#if $library_type == 'paired':
    #set input_1 = $library.input_1
    #set input_2 = $library.input_2
    ## Avoid the paired read input files sharing the same name, else the program still runs but 
    ## uses inaccurate results by using only 1 of 2 files.
    #set read1 = re.sub('[^\w\-\s]', '_', str($library.input_1.element_identifier))
    #set read2 = re.sub('[^\w\-\s]', '_', str($library.input_2.element_identifier))
    #if read1 == read2:
        #set read1 = read1 + "_1"
        #set read2 = read2 + "_2"
    #end if
#elif $library_type == 'paired_collection'
    #set input_1 = $library.input_1.forward
    #set input_2 = $library.input_1.reverse
    #set read1 = re.sub('[^\w\-\s]', '_', str($library.input_1.name)) + "_1"
    #set read2 = re.sub('[^\w\-\s]', '_', str($library.input_1.name)) + "_2"
#else
    #set input_1 = $library.input_1
    #set read1 = re.sub('[^\w\-\s]', '_', str($library.input_1.element_identifier))
#end if

#if $input_1.is_of_type("fastq", "fastq.gz", "fastq.bz2"):
    #set ext = ".fq"
#else
    #set ext = ".fa"
#end if
#if $input_1.ext.endswith(".gz"):
    #set ext=ext+".gz"
#elif $input_1.ext.endswith(".bz2")
    #set ext=ext+".bz2"
#end if

#set read1 = $read1 + $ext
#set out1 = "out1" + $ext
#set rest_output = "rest_output" + $ext
#set wild_output = "wild_output" + $ext
#set too_short_output = "too_short_output" + $ext
#set too_long_output = "too_long_output" + $ext
#set untrimmed_output = "untrimmed_output" + $ext

#if $paired:
    #if $input_2.is_of_type("fastq", "fastq.gz", "fastq.bz2"):
        #set ext2 = ".fq"
    #else
        #set ext2 = ".fa"
    #end if
    #if $input_2.ext.endswith(".gz"):
        #set ext2=ext2+".gz"
    #elif $input_2.ext.endswith(".bz2")
        #set ext2=ext2+".bz2"
    #end if
    #set read2 = $read2 + $ext2
    #set out2 = "out2" + $ext2
    #set too_short_paired_output = "too_short_paired_output" + $ext2
    #set too_long_paired_output = "too_long_paired_output" + $ext2
    #set untrimmed_paired_output = "untrimmed_paired_output" + $ext2
#end if

## Link in the input and output files, so Cutadapt can tell their type
ln -f -s '$input_1' '$read1' &&
#if $paired:
    ln -f -s '$input_2' '$read2' &&
#end if
## Create dedicated output folder if needed
#if 'multiple_output' in $output_selector:
    mkdir split &&
#end if

## Run Cutadapt
cutadapt

-j=\${GALAXY_SLOTS:-4}

## Read1 trimming
#set ADAPTER_ARGUMENT="-a"
#for $a in $library.r1.adapters
    @adapter_cli@
#end for
#set ADAPTER_ARGUMENT="-b"
#for $a in $library.r1.anywhere_adapters
    @adapter_cli@
#end for
#set ADAPTER_ARGUMENT="-g"
#for $a in $library.r1.front_adapters
    @adapter_cli@
#end for

#if $paired:
    ## Read2 trimming
    #set ADAPTER_ARGUMENT="-A"
    #for $a in $library.r2.adapters2
        @adapter_cli@
    #end for
    #set ADAPTER_ARGUMENT="-B"
    #for $a in $library.r2.anywhere_adapters2
        @adapter_cli@
    #end for
    #set ADAPTER_ARGUMENT="-G"
    #for $a in $library.r2.front_adapters2
        @adapter_cli@
    #end for
    $library.pair_adapters
#end if

--error-rate=$adapter_options.error_rate
--times=$adapter_options.times
--overlap=$adapter_options.overlap
$adapter_options.no_indels
$adapter_options.match_read_wildcards
$adapter_options.no_match_adapter_wildcards
--action=$adapter_options.action
$adapter_options.revcomp

#if $other_trimming_options.cut != 0:
    --cut=$other_trimming_options.cut
#end if
#if $paired and $other_trimming_options.cut2 != 0:
    -U $other_trimming_options.cut2
#end if
#if str($other_trimming_options.quality_cutoff) != '0':
    --quality-cutoff=$other_trimming_options.quality_cutoff
#end if
#if $paired and str($other_trimming_options.quality_cutoff2) != '':
    -Q $other_trimming_options.quality_cutoff2
#end if
#if str($other_trimming_options.nextseq_trim) != '0':
    --nextseq-trim=$other_trimming_options.nextseq_trim
#end if
$other_trimming_options.trim_n
$other_trimming_options.poly_a
#if str($other_trimming_options.shorten_options.shorten_values) == 'True':
    #if str($other_trimming_options.shorten_options.shorten_end) == '3prime'
        --length=$other_trimming_options.shorten_options.length
    #else
        --length=-$other_trimming_options.shorten_options.length
    #end if
#end if
#if $paired and str($other_trimming_options.shorten_options_r2.shorten_values_r2) == 'True':
    #if str($other_trimming_options.shorten_options_r2.shorten_end_r2) == '3prime'
        -L $other_trimming_options.shorten_options_r2.length2
    #else
        -L -$other_trimming_options.shorten_options_r2.length2
    #end if
#end if

$filter_options.discard_trimmed
$filter_options.discard_untrimmed

#if $paired and str($filter_options.minimum_length2):
    --minimum-length=$filter_options.minimum_length:$filter_options.minimum_length2
#elif $filter_options.minimum_length > 0:
    --minimum-length=$filter_options.minimum_length
#end if
#if $paired and str($filter_options.maximum_length2):
    --maximum-length=$filter_options.maximum_length:$filter_options.maximum_length2
#elif str($filter_options.maximum_length):
    --maximum-length=$filter_options.maximum_length
#end if
#if str($filter_options.max_n):
    --max-n=$filter_options.max_n
#end if
#if str($filter_options.max_expected_errors):
    --max-ee=$filter_options.max_expected_errors
#end if
#if str($filter_options.max_average_error_rate):
    --max-aer=$filter_options.max_average_error_rate
#end if
$filter_options.discard_casava
#if $paired and str($filter_options.pair_filter) != 'any':
    --pair-filter=$filter_options.pair_filter
#end if

#if $input_1.ext.startswith("fastqillumina") or $input_1.ext.startswith("fastqsolexa")
    --quality-base=64
#end if

#if $read_mod_options.strip_suffix != ''
    --strip-suffix='$read_mod_options.strip_suffix'
#end if
#if str($read_mod_options.length_tag) != '':
    --length-tag='$read_mod_options.length_tag'
#end if
#if str($read_mod_options.rename) != '':
    --rename='$read_mod_options.rename'
#end if
$read_mod_options.zero_cap

## Outputs handling
#if 'json_stats' in $output_selector:
    --json=stats.json
#end if
#if 'info_file' in $output_selector:
    --info-file='$info_file'
    #if 'info_file_paired' in $output_selector:
        --info-file-paired='$info_file_paired'
    #end if
#end if
#if 'rest_file' in $output_selector:
    -r='${rest_output}'
#end if
#if 'wildcard_file' in $output_selector:
    --wildcard-file='${wild_output}'
#end if
#if 'too_short_file' in $output_selector:
    --too-short-output='${too_short_output}'
    #if $paired:
        --too-short-paired-output='${too_short_paired_output}'
    #end if
#end if
#if 'too_long_file' in $output_selector:
    --too-long-output='${too_long_output}'
    #if $paired:
        --too-long-paired-output='${too_long_paired_output}'
    #end if
#end if
#if 'untrimmed_file' in $output_selector:
    --untrimmed-output='${untrimmed_output}'
    #if $paired:
        --untrimmed-paired-output='${untrimmed_paired_output}'
    #end if
#end if
#if not $paired and 'multiple_output' in $output_selector:
    -o 'split/{name}.${input_1.ext}'
#else:
    -o '$out1'
    #if $paired:
        -p '$out2'
    #end if
#end if

'$read1'
#if $paired:
    '$read2'
#end if

#if 'report' in $output_selector:
    > report.txt
#end if
    ]]></command>
    <inputs>
        <!-- Reads -->
        <conditional name="library">
            <param name="type" type="select" label="Single-end or Paired-end reads?">
                <option value="single">Single-end</option>
                <option value="paired">Paired-end</option>
                <option value="paired_collection">Paired-end Collection</option>
            </param>
            <when value="single">
                <param name="input_1" format="@FASTQ_TYPES@" type="data" label="FASTQ/A file" help="Should be of datatype &quot;fastq.gz&quot; or &quot;fasta&quot;" />
                <expand macro="read1_adapters" />
            </when>
            <when value="paired">
                <param name="input_1" format="@FASTQ_TYPES@" type="data" label="FASTQ/A file #1" help="Should be of datatype &quot;fastq.gz&quot;or &quot;fasta&quot;" />
                <param name="input_2" format="@FASTQ_TYPES@" type="data" label="FASTQ/A file #2" help="Should be of datatype &quot;fastq.gz&quot;or &quot;fasta&quot;" />
                <expand macro="read1_adapters" />
                <expand macro="read2_adapters" />
            </when>
            <when value="paired_collection">
                <param name="input_1" format="@FASTQ_TYPES@" type="data_collection" collection_type="paired" label="Paired Collection" help="Should be of datatype &quot;fastq.gz&quot; or &quot;fasta&quot;" />
                <expand macro="read1_adapters" />
                <expand macro="read2_adapters" />
            </when>
        </conditional>
        <!-- Adapter Options -->
        <section name="adapter_options" title="Adapter Handling Options">
            <param name="action" type="select" label="What to do if a match is found">
                <option value="trim" selected="true">Trim: trim adapter and upstream or downstream sequence</option>
                <option value="retain">Retain: the read is trimmed, but the adapter sequence is not removed</option>
                <option value="mask">Mask: mask adapters with 'N' characters instead of trimming them</option>
                <option value="lowercase">Lowercase: convert to lowercase</option>
                <option value="crop">Crop: trim upstream and downstream sequences, i.e. retain adapter sequences only</option>
                <option value="none">None: leave unchanged</option>
            </param>
            <param argument="--error-rate" type="float" min="0" max="1" value="0.1" label="Maximum error rate" help="Maximum allowed error rate (no. of errors divided by the length of the matching region)." />
            <param argument="--no-indels" type="boolean" checked="false" truevalue="--no-indels" falsevalue="" label="Do not allow indels (Use ONLY with anchored 5' (front) adapters)." help="Do not allow indels in the alignments. That is, allow only mismatches. This option is currently only supported for anchored 5' adapters ('^ADAPTER') (default: both mismatches and indels are allowed)." />
            <param argument="--times" type="integer" min="1" value="1" label="Match times" help="Try to remove adapters at most COUNT times. Useful when an adapter gets appended multiple times." />
            <param argument="--overlap" type="integer" min="1" value="3" label="Minimum overlap length" help="Minimum overlap length. If the overlap between the adapter and the sequence is shorter than LENGTH, the read is not modified. This reduces the number of bases trimmed purely due to short random adapter matches." />
            <param argument="--match-read-wildcards" type="boolean" checked="false" truevalue="--match-read-wildcards" falsevalue="" label="Match wilcards in reads" help="Interpret IUPAC wildcards in reads"/>
            <param argument="--no-match-adapter-wildcards" type="boolean" checked="true" truevalue="" falsevalue="--no-match-adapter-wildcards" label="Match wildcards in adapters" help="Interpret IUPAC wildcards in adapters."/>
            <param name="revcomp" argument="--rc" type="boolean" checked="false" truevalue="--rc" falsevalue="" label="Look for adapters in the reverse complement" help="Check both the read and its reverse complement for adapter matches. If match is on reverse-complemented version, output that one. Default: check only read." />
        </section>
        <section name="other_trimming_options" title="Other Read Trimming Options">
            <param argument="--cut" type="integer" value="0" label="Bases to cut from R1 reads before adapter trimming" help="Remove bases from each read (first read only if paired). If positive, remove bases from the beginning. If negative, remove bases from the end. This is applied *before* adapter trimming." />
            <param name="cut2" argument="-U" type="integer" value="0" label="Bases to cut from R2 reads before adapter trimming" help="For paired-end data, you can define here a cut value to apply to R2 reads. Usage is identical to the R1 setting. Default: 0; ignored for single-end data." />
            <param argument="--quality-cutoff" type="text" value="0" label="Quality cutoff(s) (R1)" help="Trim low-quality bases from 5' and/or 3' ends of each read before adapter removal. If one value is given, only the 3' end is trimmed. If two comma-separated cutoffs are given, the 5' end is trimmed with the first cutoff, the 3' end with the second.">
                <sanitizer>
                    <valid initial="string.digits"><add value="," /></valid>
                </sanitizer>
                <validator type="regex">[0-9]+(,[0-9])?</validator>
            </param>
            <param name="quality_cutoff2" argument="-Q" type="text" optional="true" value="" label="Quality cutoff(s) R2" help="For paired-end data, you can set here a separate quality cutoff to apply to R2 reads specifically. Leave empty to reuse the R1 cutoff setting. Ignored for single-end data. Syntax is identical to the R1 setting.">
                <sanitizer>
                    <valid initial="string.digits"><add value="," /></valid>
                </sanitizer>
                <validator type="regex">[0-9]+(,[0-9])?</validator>
            </param>
            <param argument="--nextseq-trim" type="integer" value="0" label="NextSeq trimming" help="Experimental option for quality trimming of NextSeq data. This is necessary because that machine cannot distinguish between G and reaching the end of the fragment (it encodes G as ‘black’). This option works like regular quality trimming (where one would use -q 20 instead), except that the qualities of G bases are ignored." />
            <param argument="--trim-n" type="boolean" truevalue="--trim-n" falsevalue="" checked="false" label="Trim Ns" help="Trim N's on ends of reads." />
            <param argument="--poly-a" type="boolean" truevalue="--poly-a" falsevalue="" checked="false" label="Trim poly-A tails" help="Note, this trim poly-T 'heads' on R2"/>
            <conditional name="shorten_options">
                <param name="shorten_values" type="select" label="Shortening reads to a fixed length" help="If you want to remove a fixed number of bases from each read, use the –cut option instead.">
                    <option value="True">Enabled</option>
                    <option value="False" selected="true">Disabled</option>
                </param>
                <when value="True">
                    <param argument="--length" type="integer" value="0" label="Length" help="Shorten reads to this length. This modification is applied after adapter trimming." />
                    <param name="shorten_end" type="select" label="End at which to apply the slice">
                        <option value="3prime">3' ends</option>
                        <option value="5prime">5' ends</option>
                    </param>
                </when>
                <when value="False">
                </when>
            </conditional>
            <conditional name="shorten_options_r2">
                <param name="shorten_values_r2" type="select" label="Separate shortening of R2 reads to a fixed length?" help="For paired-end data, shortening of R2 reads can be handled separately. Ignored for single-end data.">
                    <option value="True">Separate shortening of R2 reads</option>
                    <option value="False" selected="true">Treat R2 reads the same as R1 reads</option>
                </param>
                <when value="True">
                    <param argument="-L" name="length2" type="integer" value="0" label="Length" help="Shorten R2 reads to this length. This modification is applied after adapter trimming." />
                    <param name="shorten_end_r2" type="select" label="End at which to apply the slice">
                        <option value="3prime">3' ends</option>
                        <option value="5prime">5' ends</option>
                    </param>
                </when>
                <when value="False">
                </when>
            </conditional>
        </section>
        <!-- Filter Options -->
        <section name="filter_options" title="Read Filtering Options">
            <param argument="--discard-trimmed" type="boolean" checked="false" truevalue="--discard-trimmed" falsevalue="" label="Discard Trimmed Reads" help="Discard reads that contain the adapter instead of trimming them. Use the 'Minimum overlap length' option in order to avoid throwing away too many randomly matching reads!" />
            <param argument="--discard_untrimmed" type="boolean" checked="false" truevalue="--discard-untrimmed" falsevalue="" label="Discard Untrimmed Reads" help="Discard reads that do not contain the adapter." />
            <param argument="--minimum-length" type="integer" min="0" value="1" label="Minimum length (R1)" help="Discard reads that, after processing, are shorter than LENGTH. Note: You can set this parameter to zero to keep empty reads (with zero-length sequence and quality string) in the output, but some downstream tools may have problems with these. Default: 1" />
            <param name="minimum_length2" type="integer" min="0" value="" optional="true" label="Minimum length (R2)" help="For paired-end data, you can specify here a separate minimum length cutoff to apply to R2 reads. Leave empty to reuse the R1 cutoff set above. Ignored for single-end data." />
            <param argument="--maximum-length" type="integer" min="0" optional="true" value="" label="Maximum length (R1)" help="Discard trimmed reads that are longer than LENGTH. Reads that are too long even before adapter removal are also discarded." />
            <param name="maximum_length2" type="integer" min="0" value="" optional="true" label="Maximum length (R2)" help="For paired-end data, you can specify here a separate maximum length cutoff to apply to R2 reads. Leave empty to reuse the R1 cutoff set above. Ignored for single-end data." />
            <param argument="--max-n" type="float" min="0" optional="true" label="Max N" help="Discard reads with more than this number of 'N' bases. A number between 0 and 1 is interpreted as a fraction of the read length." />
            <param name="max_expected_errors" argument="--max-ee" type="float" min="0" optional="true" value="" label="Max expected errors" help="Discard reads whose expected number of errors (computed from quality values) exceeds this value." />
            <param name="max_average_error_rate" argument="--max-aer" type="float" min="0" max="1" optional="true" value="" label="Max average expected errors" help="As --max-expected-errors (see above), but divided by length to account for reads of varying length" />
            <param argument="--discard-casava" type="boolean" truevalue="--discard-casava" falsevalue="" checked="false" label="Discard CASAVA-filtered reads" help="Discard reads that did not pass CASAVA filtering (header has :Y:)." />
            <param argument="--pair-filter" type="select" label="Pair filter" help="Which of the reads in a paired-end read have to match the filtering critera above in order for the pair to be filtered. Default: any">
                <option value="any" selected="true">Any: a read pair is discarded (or redirected) if one of the reads (R1 or R2) fulfills the filtering criterion.</option>
                <option value="both">Both: filtering criteria must apply to both reads in order for a read pair to be discarded.</option>
                <option value="first">First: will make a decision about the read pair by inspecting whether the filtering criterion applies to the first read, ignoring the second read.</option>
            </param>
        </section>
        <!-- Read Modification Options -->
        <section name="read_mod_options" title="Read Modification Options">
            <param argument="--strip-suffix" label="Strip suffix" type="text" help="Remove this suffix from read names if present." />
            <param argument="--length-tag" label="Length tag" type="text" optional="true" help="Search for TAG followed by a decimal number in the name of the read (description/comment field of the FASTA or FASTQ file). Replace the decimal number with the correct length of the trimmed read. For example, use --length-tag 'length=' to search for fields like 'length=123'." >
                <sanitizer invalid_char="">
                    <valid initial="string.letters,string.digits">
                        <add value="/" />
                        <add value="+" />
                        <add value="-" />
                        <add value="=" />
                        <add value=" " />
                        <add value="_" />
                    </valid>
                </sanitizer>
                <validator type="regex">[A-Za-z0-9 =-_/+]+</validator>
            </param>
            <param argument="--rename" label="Rename reads" type="text" optional="true" help="This option can be used to rename both single-end and paired-end reads. ">
                <sanitizer invalid_char="">
                    <valid initial="string.letters,string.digits">
                        <add value="{" />
                        <add value="}" />
                        <add value="_" />
                        <add value="=" />
                        <add value=" " />
                    </valid>
                </sanitizer>
                <validator type="regex">[A-Za-z0-9 {}=_]+</validator>
            </param>
            <param argument="--zero-cap" type="boolean" truevalue="--zero-cap" falsevalue="" checked="false" label="Change negative quality values to zero" />
        </section>
        <!-- Output Options -->
        <param name="output_selector" type="select" multiple="true" display="checkboxes" label="Additional outputs to generate">
            <option value="report">Report: Cutadapt's per-adapter statistics. You can use this file with MultiQC.</option>
            <option value="info_file">Info file: write information about each read and its adapter matches.</option>
            <option value="info_file_paired">Paired Info file: write information about each read and its adapter matches for Paired end reads.</option>
            <option value="rest_file">Rest of read: when the adapter matches in the middle of a read, write the rest (after the adapter).</option>
            <option value="wildcard_file">Wildcard file: when the adapter has wildcard bases (Ns) write adapter bases matching wildcard positions.</option>
            <option value="too_short_file">Too short reads: write reads that are too short according to minimum length specified (default: discard reads).</option>
            <option value="too_long_file">Too long reads: write reads that are too long (according to maximum length specified)</option>
            <option value="untrimmed_file">Untrimmed reads: write reads that do not contain the adapter to a separate file, instead of writing them to the regular output file (default: output to same file as trimmed)</option>
            <option value="multiple_output">Multiple output: create a separate file for each adapter trimmed (default: all trimmed reads are in a single file)</option>
            <option value="json_stats">Statistics in JSON format</option>
        </param>
    </inputs>
    <outputs>
        <data name="out1" format="fastqsanger" metadata_source="library|input_1" default_identifier_source="library|input_1" from_work_dir="out1.*" label="${tool.name} on ${on_string}: Read 1 Output">
            <filter>library['type'] != 'paired_collection'</filter>
            <filter>not output_selector or 'multiple_output' not in output_selector</filter>
            <expand macro="inherit_format_1" />
        </data>
        <data name="out2" format="fastqsanger" metadata_source="library|input_2" default_identifier_source="library|input_2" from_work_dir="out2.*" label="${tool.name} on ${on_string}: Read 2 Output" >
            <filter>library['type'] == 'paired'</filter>
            <filter>not output_selector or 'multiple_output' not in output_selector</filter>
            <expand macro="inherit_format_2" />
        </data>
        <collection name="out_pairs" type="paired" format_source="library|input_1" label="${tool.name} on ${on_string}: Reads">
            <filter>library['type'] == 'paired_collection'</filter>
            <filter>not output_selector or 'multiple_output' not in output_selector</filter>
            <data name="forward" from_work_dir="out1.*" />
            <data name="reverse" from_work_dir="out2.*" />
        </collection>
        <data name="report" format="txt" from_work_dir="report.txt" label="${tool.name} on ${on_string}: Report">
            <filter>output_selector and 'report' in output_selector</filter>
        </data>
        <data name="info_file" format="txt" metadata_source="library|input_1" label="${tool.name} on ${on_string}: Info File" >
            <filter>output_selector and 'info_file' in output_selector</filter>
        </data>
        <data name="info_file_paired" format="txt" metadata_source="library|input_1" label="${tool.name} on ${on_string}: Paired Info File" >
            <filter>output_selector and 'info_file_paired' in output_selector</filter>
        </data>
        <data name="rest_output" format="fastqsanger" metadata_source="library|input_1" from_work_dir="rest_output*" label="${tool.name} on ${on_string}: Rest of Reads (R1 only)" >
            <filter>output_selector and 'rest_file' in output_selector</filter>
            <expand macro="inherit_format_1" />
        </data>
        <data name="wild_output" format="txt" metadata_source="library|input_1" from_work_dir="wild_output*" label="${tool.name} on ${on_string}: Wildcard File" >
            <filter>output_selector and 'wildcard_file' in output_selector</filter>
        </data>
        <data name="untrimmed_output" format="fastqsanger" metadata_source="library|input_1" default_identifier_source="library|input_1" from_work_dir="untrimmed_output*" label="${tool.name} on ${on_string}: Untrimmed Read 1" >
            <filter>output_selector and 'untrimmed_file' in output_selector</filter>
            <expand macro="inherit_format_1" />
        </data>
        <data name="untrimmed_paired_output" format="fastqsanger" metadata_source="library|input_2" default_identifier_source="library|input_2" from_work_dir="untrimmed_paired_output*" label="${tool.name} on ${on_string}: Untrimmed Read 2" >
            <filter>library['type'] == 'paired' or library['type'] == 'paired_collection'</filter>
            <filter>output_selector and 'untrimmed_file' in output_selector </filter>
            <expand macro="inherit_format_2" />
        </data>
        <data name="too_short_output" format="fastqsanger" metadata_source="library|input_1" default_identifier_source="library|input_1" from_work_dir="too_short_output*" label="${tool.name} on ${on_string}: Too Short Read 1" >
            <filter>output_selector and 'too_short_file' in output_selector</filter>
            <expand macro="inherit_format_1" />
        </data>
        <data name="too_short_paired_output" format="fastqsanger" metadata_source="library|input_2" default_identifier_source="library|input_2" from_work_dir="too_short_paired_output*" label="${tool.name} on ${on_string}: Too Short Read 2" >
            <filter>library['type'] == 'paired' or library['type'] == 'paired_collection'</filter>
            <filter>output_selector and 'too_short_file' in output_selector</filter>
            <expand macro="inherit_format_2" />
        </data>
        <data name="too_long_output" format="fastqsanger" metadata_source="library|input_1" default_identifier_source="library|input_1" from_work_dir="too_long_output*" label="${tool.name} on ${on_string}: Too Long Read 1" >
            <filter>output_selector and 'too_long_file' in output_selector</filter>
            <expand macro="inherit_format_1" />
        </data>
        <data name="too_long_paired_output" format="fastqsanger" metadata_source="library|input_2" default_identifier_source="library|input_2" from_work_dir="too_long_paired_output*" label="${tool.name} on ${on_string}: Too Long Read 2" >
            <filter>library['type'] == 'paired' or library['type'] == 'paired_collection'</filter>
            <filter>output_selector and 'too_long_file' in output_selector</filter>
            <expand macro="inherit_format_2" />
        </data>
        <data name="json_stats" format="json" from_work_dir="stats.json" label="${tool.name} on ${on_string}: Statistics (JSON)" >
            <filter>output_selector and 'json_stats' in output_selector</filter>
        </data>
        <collection name="split_output" type="list" label="${tool.name} on ${on_string}: Split outputs" format="fastqsanger" >
            <discover_datasets pattern="(?P&lt;designation&gt;.+)\.(?P&lt;ext&gt;fastq.*)" directory="split" />
            <filter>output_selector and 'multiple_output' in output_selector</filter>
        </collection>
    </outputs>
    <tests>
        <!-- Ensure fastq works -->
        <test expect_num_outputs="1">
            <param name="type" value="single" />
            <param name="input_1" ftype="fastq" value="cutadapt_small.fastq" />
            <section name="r1">
                <repeat name="adapters">
                    <conditional name="adapter_source">
                        <param name="adapter_source_list" value="user"/>
                        <param name="adapter" value="AGATCGGAAGAGC"/>
                    </conditional>
                </repeat>
            </section>
            <output name="out1" file="cutadapt_small.out" ftype="fastq"/>
        </test>
        <!-- Ensure single end fastq.gz works -->
        <test expect_num_outputs="1">
            <param name="type" value="single" />
            <param name="input_1" ftype="fastq.gz" value="bwa-mem-fastq1.fq.gz" />
            <section name="r1">
                <repeat name="adapters">
                    <conditional name="adapter_source">
                        <param name="adapter_source_list" value="user"/>
                        <param name="adapter" value="AGATCGGAAGAGC"/>
                    </conditional>
                </repeat>
            </section>
            <output name="out1" decompress="true" file="cutadapt_out1.fq.gz" ftype="fastq.gz"/>
        </test>
        <!-- Ensure paired end fastq.gz works -->
        <test expect_num_outputs="2">
            <param name="type" value="paired" />
            <param name="input_1" ftype="fastq.gz" value="bwa-mem-fastq1.fq.gz" />
            <param name="input_2" ftype="fastq.gz" value="bwa-mem-fastq2.fq.gz" />
            <section name="r1">
                <repeat name="adapters">
                    <conditional name="adapter_source">
                        <param name="adapter_source_list" value="user"/>
                        <param name="adapter" value="AGATCGGAAGAGC"/>
                    </conditional>
                </repeat>
            </section>
            <section name="r2">
                <repeat name="adapters2">
                    <conditional name="adapter_source">
                        <param name="adapter_source_list" value="user"/>
                        <param name="adapter" value="AGATCGGAAGAGC"/>
                    </conditional>
                </repeat>
            </section>
            <output name="out1" decompress="true" file="cutadapt_out1.fq.gz" ftype="fastq.gz"/>
            <output name="out2" decompress="true" file="cutadapt_out2.fq.gz" ftype="fastq.gz"/>
            <assert_command>
                <not_has_text text="--discard-trimmed"/>
                <not_has_text text="--discard-untrimmed"/>
                <not_has_text text="--maximum-length"/>
                <not_has_text text="--max-n"/>
                <has_text text="--minimum-length=1 "/>
            </assert_command>
        </test>
        <!-- Ensure paired collection works -->
        <test expect_num_outputs="3">
            <param name="type" value="paired_collection" />
            <param name="input_1">
                <collection type="paired">
                    <element name="forward" ftype="fastq.gz" value="bwa-mem-fastq1.fq.gz" />
                    <element name="reverse" ftype="fastq.gz" value="bwa-mem-fastq2.fq.gz" />
                </collection>
            </param>
            <section name="r1">
                <repeat name="adapters">
                    <conditional name="adapter_source">
                        <param name="adapter_source_list" value="user"/>
                        <param name="adapter" value="AGATCGGAAGAGC"/>
                    </conditional>
                </repeat>
            </section>
            <section name="r2">
                <repeat name="adapters2">
                    <conditional name="adapter_source">
                        <param name="adapter_source_list" value="user"/>
                        <param name="adapter" value="AGATCGGAAGAGC"/>
                    </conditional>
                </repeat>
            </section>
            <output_collection name="out_pairs" type="paired" count="2">
                <element name="forward" decompress="true" file="cutadapt_out1.fq.gz" ftype="fastq.gz"/>
                <element name="reverse" decompress="true" file="cutadapt_out2.fq.gz" ftype="fastq.gz"/>
            </output_collection>
        </test>
        <!-- Ensure built-in adapters work -->
        <test expect_num_outputs="1">
            <param name="type" value="single" />
            <param name="input_1" ftype="fastq" value="cutadapt_small.fastq" />
            <section name="r1">
                <repeat name="adapters">
                    <conditional name="adapter_source">
                        <param name="adapter_source_list" value="builtin"/>
                        <param name="adapter" value="TGTAGGCC"/>
                    </conditional>
                </repeat>
            </section>
            <output name="out1" file="cutadapt_builtin.out" ftype="fastq"/>
        </test>
        <!-- Ensure discard file output works -->
        <test expect_num_outputs="1">
            <param name="input_1" ftype="fastq" value="cutadapt_small.fastq" />
            <section name="r1">
                <repeat name="adapters">
                    <conditional name="adapter_source">
                        <param name="adapter_source_list" value="user"/>
                        <param name="adapter" value="TTAGACATATCTCCGTCG"/>
                    </conditional>
                </repeat>
            </section>
            <section name="filter_options">
                <param name="discard_trimmed" value="true"/>
            </section>
            <output name="out1" file="cutadapt_discard.out" ftype="fastq"/>
            <assert_command>
                <has_text text="--discard-trimmed"/>
            </assert_command>
        </test>
        <!-- Ensure pair-adapters option works -->
        <test expect_num_outputs="2">
            <param name="type" value="paired" />
            <param name="input_1" ftype="fastq.gz" value="bwa-mem-fastq1.fq.gz" />
            <param name="input_2" ftype="fastq.gz" value="bwa-mem-fastq2.fq.gz" />
            <section name="r1">
                <repeat name="adapters">
                    <conditional name="adapter_source">
                        <param name="adapter_source_list" value="user"/>
                        <param name="adapter" value="AGATCGGAAGAGC"/>
                    </conditional>
                </repeat>
            </section>
            <section name="r2">
                <repeat name="adapters2">
                    <conditional name="adapter_source">
                        <param name="adapter_source_list" value="user"/>
                        <param name="adapter" value="AGATCGGAAGAGC"/>
                    </conditional>
                </repeat>
            </section>
            <param name="pair_adapters" value="true"/>
            <output name="out1" decompress="true" file="cutadapt_out1_pair_adapters.fq.gz" ftype="fastq.gz"/>
            <output name="out2" decompress="true" file="cutadapt_out2_pair_adapters.fq.gz" ftype="fastq.gz"/>
            <assert_command>
                <not_has_text text="--discard-trimmed"/>
                <not_has_text text="--discard-untrimmed"/>
                <not_has_text text="--maximum-length"/>
                <not_has_text text="--max-n"/>
                <has_text text="--pair-adapters"/>
                <has_text text="--minimum-length=1 "/>
            </assert_command>
        </test>
        <!-- Ensure rest file output works, test json output -->
        <test expect_num_outputs="3">
            <param name="input_1" ftype="fasta" value="cutadapt_rest.fa" />
            <section name="r1">
                <repeat name="adapters">
                    <conditional name="adapter_source">
                        <param name="adapter_source_list" value="user"/>
                        <param name="adapter" value="AAAGATG"/>
                    </conditional>
                </repeat>
            </section>
            <param name="output_selector" value="rest_file,json_stats"/>
            <output name="out1" file="cutadapt_rest.out" ftype="fasta"/>
            <!-- compare to expected reproducible part of json output -->
            <output name="json_stats" file="cutadapt_rest_json.txt" compare="contains"/>
            <output name="rest_output" file="cutadapt_rest2.out" ftype="fasta"/>
        </test>
        <!-- Ensure nextseq-trim option works -->
        <test expect_num_outputs="1">
            <param name="type" value="single" />
            <param name="input_1" ftype="fastq.gz" value="bwa-mem-fastq1.fq.gz" />
            <section name="r1">
                <repeat name="adapters">
                    <conditional name="adapter_source">
                        <param name="adapter_source_list" value="user"/>
                        <param name="adapter" value="AGATCGGAAGAGC"/>
                    </conditional>
                </repeat>
            </section>
            <section name="other_trimming_options">
                <param name="nextseq_trim" value="20" />
            </section>
            <output name="out1" decompress="true" file="cutadapt_nextseq_out.fq.gz" ftype="fastq.gz"/>
        </test>
        <!-- Ensure Report and Info file output work -->
        <test expect_num_outputs="3">
            <param name="type" value="single" />
            <param name="input_1" ftype="fastq" value="cutadapt_small.fastq" />
            <section name="r1">
                <repeat name="adapters">
                    <conditional name="adapter_source">
                        <param name="adapter_source_list" value="user"/>
                        <param name="adapter" value="AGATCGGAAGAGC"/>
                    </conditional>
                </repeat>
            </section>
            <param name="output_selector" value="report,info_file" />
            <output name="out1" value="cutadapt_small.out" ftype="fastq"/>
            <output name="report">
                <assert_contents>
                    <has_text text="Summary"/>
                </assert_contents>
            </output>
            <output name="info_file" value="cutadapt_info_out.txt" ftype="txt"/>
        </test>
        <!-- Ensure Report and Paired Info file output work -->
        <test expect_num_outputs="5">
            <param name="type" value="paired" />
            <param name="input_1" ftype="fastq.gz" value="bwa-mem-fastq1.fq.gz" />
            <param name="input_2" ftype="fastq.gz" value="bwa-mem-fastq2.fq.gz" />
            <section name="r1">
                <repeat name="adapters">
                    <conditional name="adapter_source">
                        <param name="adapter_source_list" value="user"/>
                        <param name="adapter" value="AGATCGGAAGAGC"/>
                    </conditional>
                </repeat>
            </section>
            <section name="r2">
                <repeat name="adapters">
                    <conditional name="adapter_source">
                        <param name="adapter_source_list" value="user"/>
                        <param name="adapter" value="AGATCGGAAGAGC"/>
                    </conditional>
                </repeat>
            </section>
            <param name="output_selector" value="report,info_file,info_file_paired"/>
            <output name="out1" decompress="true" file="cutadapt_out1_r1.fq.gz" ftype="fastq.gz"/>
            <output name="out2" decompress="true" file="cutadapt_out2_r2.fq.gz" ftype="fastq.gz"/>
            <output name="report">
                <assert_contents>
                    <has_text text="Summary"/>
                </assert_contents>
            </output>
            <output name="info_file" value="cutadapt_info_paired_out_2.txt" ftype="txt"/>
            <output name="info_file_paired" value="cutadapt_info_paired_out.txt" ftype="txt"/>
        </test>
        <test expect_num_outputs="1">
            <conditional name="library">
                <param name="type" value="single" />
                <param name="input_1" ftype="fastq" value="cutadapt_in_split.fastq" />
                <section name="r1" >
                    <repeat name="front_adapters">
                        <conditional name="adapter_source">
                            <param name="adapter_source_list" value="user"/>
                            <param name="adapter_name" value="A1" />
                            <param name="adapter" value="^GTCGGTAA" />
                        </conditional>
                    </repeat>
                    <repeat name="front_adapters">
                        <conditional name="adapter_source">
                            <param name="adapter_source_list" value="user"/>
                            <param name="adapter_name" value="A2" />
                            <param name="adapter" value="^AGGTCACT" />
                        </conditional>
                    </repeat>
                </section>
            </conditional>
            <param name="output_selector" value="multiple_output" />
            <output_collection name="split_output" type="list" count="3">
                   <element name="A1" value="A1.fastq" ftype="fastq">
                   </element>
                   <element name="A2" value="A2.fastq" ftype="fastq">
                   </element>
                   <element name="unknown" value="unknown.fastq" ftype="fastq">
                   </element>
             </output_collection>
        </test>
        <test expect_num_outputs="1">
            <conditional name="library">
                <param name="type" value="single" />
                <param name="input_1" ftype="fastq.gz" value="cutadapt_in_split.fastq.gz" />
                <section name="r1" >
                    <repeat name="front_adapters">
                        <conditional name="adapter_source">
                            <param name="adapter_source_list" value="file"/>
                            <param name="adapter_file" ftype="fasta"  value="barcodes.fasta" />
                        </conditional>
                    </repeat>
                </section>
            </conditional>
            <param name="output_selector" value="multiple_output" />
            <output_collection name="split_output" type="list" count="3">
                   <element name="A1"  decompress="true" file="A1.fastq.gz" ftype="fastq.gz"/>
                   <element name="A2" decompress="true" file="A2.fastq.gz" ftype="fastq.gz"/>
                   <element name="unknown" decompress="true" file="unknown.fastq.gz" ftype="fastq.gz"/>
             </output_collection>
        </test>
        <!-- Ensure untrimmed file output works -->
        <test expect_num_outputs="2">
            <param name="type" value="single" />
            <param name="input_1" ftype="fastq" value="cutadapt_small.fastq" />
            <section name="r1">
                <repeat name="adapters">
                    <conditional name="adapter_source">
                        <param name="adapter_source_list" value="user"/>
                        <param name="adapter" value="AAAT"/>
                    </conditional>
                </repeat>
            </section>
            <param name="output_selector" value="untrimmed_file" />
            <output name="out1" file="cutadapt_trimmed.out" ftype="fastq"/>
            <output name="untrimmed_output" file="cutadapt_untrimmed.out" ftype="fastq"/>
        </test>
        <!-- Ensure untrimmed gzip file output works -->
        <test expect_num_outputs="2">
            <param name="type" value="single" />
            <param name="input_1" ftype="fastq.gz" value="bwa-mem-fastq1.fq.gz" />
            <section name="r1">
                <repeat name="adapters">
                    <conditional name="adapter_source">
                        <param name="adapter_source_list" value="user"/>
                        <param name="adapter" value="AGATCGGAAGAGC"/>
                    </conditional>
                </repeat>
            </section>
            <param name="output_selector" value="untrimmed_file" />
            <output name="out1" decompress="true" file="cutadapt_trimmed.out.gz" ftype="fastq.gz"/>
            <!--
                Do not use the decompress option for this assertion, since it does NOT test that the file is compressed
                See discussion at https://github.com/galaxyproject/galaxy/issues/7671
                `delta="4000" is more than the difference between gzip level 1 and gzip level 9, but much less than the
                difference between level 1 compression and no compression
            -->
            <output name="untrimmed_output" file="cutadapt_untrimmed.out.gz" compare="sim_size" delta="4000" ftype="fastq.gz"/>
        </test>
        <!-- same as 1st test with paired data + filter options (because of discard_untrimmed no comparison is done) -->
        <test expect_num_outputs="2">
            <param name="type" value="paired" />
            <param name="input_1" ftype="fastq.gz" value="bwa-mem-fastq1.fq.gz" />
            <param name="input_2" ftype="fastq.gz" value="bwa-mem-fastq2.fq.gz" />
            <section name="r1">
                <repeat name="adapters">
                    <conditional name="adapter_source">
                        <param name="adapter_source_list" value="user"/>
                        <param name="adapter" value="AGATCGGAAGAGC"/>
                    </conditional>
                </repeat>
            </section>
            <section name="r2">
                <repeat name="adapters">
                    <conditional name="adapter_source">
                        <param name="adapter_source_list" value="user"/>
                        <param name="adapter" value="AGATCGGAAGAGC"/>
                    </conditional>
                </repeat>
            </section>
            <section name="filter_options">
                <param name="discard_untrimmed" value="true"/>
                <param name="minimum_length" value="1"/>
                <param name="maximum_length" value="1000"/>
                <param name="max_n" value="0"/>
                <param name="pair_filter" value="both"/>
            </section>
            <assert_command>
                <has_text text="--discard-untrimmed"/>
                <has_text text="--minimum-length=1 " />
                <has_text text="--maximum-length=1000 "/>
                <has_text text="--max-n=0"/>
                <has_text text="--pair-filter=both"/>
            </assert_command>
        </test>
        <!-- Test cut option -->
        <test expect_num_outputs="1">
            <param name="type" value="single" />
            <param name="input_1" ftype="fastq" value="cutadapt_small.fastq" />
            <section name="r1">
                <repeat name="adapters">
                    <conditional name="adapter_source">
                        <param name="adapter_source_list" value="user"/>
                        <param name="adapter" value="AGATCGGAAGAGC"/>
                    </conditional>
                </repeat>
            </section>
            <section name="other_trimming_options">
                <param name="cut" value="5"/>
            </section>
            <output name="out1" file="cutadapt_small_cut.out" ftype="fastq"/>
        </test>
        <!-- Test rename options -->
        <test expect_num_outputs="1">
            <param name="type" value="single" />
            <param name="input_1" ftype="fastq" value="cutadapt_small.fastq" />
            <section name="r1">
                <repeat name="adapters">
                    <conditional name="adapter_source">
                        <param name="adapter_source_list" value="user"/>
                        <param name="adapter" value="AGATCGGAAGAGC"/>
                    </conditional>
                </repeat>
            </section>
            <section name="other_trimming_options">
                <param name="cut" value="5"/>
            </section>
            <section name="read_mod_options">
                <param name="rename" value="{id} barcode={cut_prefix}"/>
            </section>
            <output name="out1" file="cutadapt_small_rename.out" ftype="fastq">
                <assert_contents>
                    <has_text text="@prefix:1_13_1259/1 barcode=AGCCG"/>
                </assert_contents>
            </output>
        </test>
        <!-- Test action options -->
        <test expect_num_outputs="1">
            <param name="type" value="single" />
            <param name="input_1" ftype="fastq" value="cutadapt_small.fastq" />
            <section name="r1">
                <repeat name="adapters">
                    <conditional name="adapter_source">
                        <param name="adapter_source_list" value="user"/>
                        <param name="adapter" value="CGTCCGAANTAG"/>
                    </conditional>
                </repeat>
            </section>
            <section name="adapter_options">
                <param name="action" value="retain"/>
            </section>
            <output name="out1" file="cutadapt_action_retain.out" ftype="fastq"/>
        </test>
           <test expect_num_outputs="1">
            <param name="type" value="single" />
            <param name="input_1" ftype="fastq" value="cutadapt_small.fastq" />
            <section name="r1">
                <repeat name="adapters">
                    <conditional name="adapter_source">
                        <param name="adapter_source_list" value="user"/>
                        <param name="adapter" value="CGTCCGAANTAG"/>
                    </conditional>
                </repeat>
            </section>
            <section name="adapter_options">
                <param name="action" value="mask"/>
            </section>
            <output name="out1" file="cutadapt_action_mask.out" ftype="fastq"/>
        </test>
        <test expect_num_outputs="1">
            <param name="type" value="single" />
            <param name="input_1" ftype="fastq" value="cutadapt_small.fastq" />
            <section name="r1">
                <repeat name="adapters">
                    <conditional name="adapter_source">
                        <param name="adapter_source_list" value="user"/>
                        <param name="adapter" value="CGTCCGAANTAG"/>
                    </conditional>
                </repeat>
            </section>
            <section name="adapter_options">
                <param name="action" value="lowercase"/>
            </section>
            <output name="out1" file="cutadapt_action_lowercase.out" ftype="fastq"/>
        </test>
        <test expect_num_outputs="1">
            <param name="type" value="single" />
            <param name="input_1" ftype="fastq" value="cutadapt_small.fastq" />
            <section name="r1">
                <repeat name="adapters">
                    <conditional name="adapter_source">
                        <param name="adapter_source_list" value="user"/>
                        <param name="adapter" value="CGTCCGAANTAG"/>
                    </conditional>
                </repeat>
            </section>
            <section name="adapter_options">
                <param name="action" value="crop"/>
            </section>
            <output name="out1" file="cutadapt_action_crop.out" ftype="fastq"/>
        </test>
        <test expect_num_outputs="1">
            <param name="type" value="single" />
            <param name="input_1" ftype="fastq" value="cutadapt_small.fastq" />
            <section name="r1">
                <repeat name="adapters">
                    <conditional name="adapter_source">
                        <param name="adapter_source_list" value="user"/>
                        <param name="adapter" value="CGTCCGAANTAG"/>
                    </conditional>
                </repeat>
            </section>
            <section name="adapter_options">
                <param name="action" value="none"/>
            </section>
            <output name="out1" file="cutadapt_action_none.out" ftype="fastq"/>
        </test>
        <!-- Test revcomp options -->
        <test expect_num_outputs="1">
            <param name="type" value="single" />
            <param name="input_1" ftype="fastq" value="cutadapt_small.fastq" />
            <section name="r1">
                <repeat name="adapters">
                    <conditional name="adapter_source">
                        <param name="adapter_source_list" value="user"/>
                        <param name="adapter" value="TAAACAGATTAGT"/>
                    </conditional>
                </repeat>
            </section>
            <section name="adapter_options">
                <param name="revcomp" value="true"/>
            </section>
            <output name="out1" file="cutadapt_revcomp.out" ftype="fastq"/>
        </test>
        <!-- Test minimum length paired-reads -->
        <test expect_num_outputs="2">
            <param name="type" value="paired" />
            <param name="input_1" ftype="fastq.gz" value="bwa-mem-fastq1_assimetric.fq.gz" />
            <param name="input_2" ftype="fastq.gz" value="bwa-mem-fastq2_assimetric.fq.gz" />
            <section name="r1">
                <repeat name="adapters">
                    <conditional name="adapter_source">
                        <param name="adapter_source_list" value="user"/>
                        <param name="adapter" value="ATCTGGTTCC"/>
                    </conditional>
                </repeat>
            </section>
            <section name="r2">
                <repeat name="adapters2">
                    <conditional name="adapter_source">
                        <param name="adapter_source_list" value="user"/>
                        <param name="adapter" value="CTACAAG"/>
                    </conditional>
                </repeat>
            </section>
            <section name="filter_options">
                <param name="minimum_length" value="30"/>
                <param name="minimum_length2" value="10"/>
                <param name="pair_filter" value="both"/>
            </section>
            <output name="out1" decompress="true" file="cutadapt_out1_min_length.fq.gz" ftype="fastq.gz"/>
            <output name="out2" decompress="true" file="cutadapt_out2_min_length.fq.gz" ftype="fastq.gz"/>
            <assert_command>
                <has_text text="--minimum-length=30:10"/>
                <has_text text="--pair-filter=both"/>
            </assert_command>
        </test>
        <!-- Test maximum length paired-reads -->
        <test expect_num_outputs="2">
            <param name="type" value="paired" />
            <param name="input_1" ftype="fastq.gz" value="bwa-mem-fastq1_assimetric.fq.gz" />
            <param name="input_2" ftype="fastq.gz" value="bwa-mem-fastq2_assimetric.fq.gz" />
            <section name="r1">
                <repeat name="adapters">
                    <conditional name="adapter_source">
                        <param name="adapter_source_list" value="user"/>
                        <param name="adapter" value="AGATCGGAAGAGC"/>
                    </conditional>
                </repeat>
            </section>
            <section name="r2">
                <repeat name="adapters2">
                    <conditional name="adapter_source">
                        <param name="adapter_source_list" value="user"/>
                        <param name="adapter" value="AGATCGGAAGAGC"/>
                    </conditional>
                </repeat>
            </section>
            <section name="filter_options">
                <param name="pair_filter" value="both"/>
                <param name="maximum_length" value="50"/>
                <param name="maximum_length2" value="30"/>
            </section>
            <output name="out1" decompress="true" file="cutadapt_out1_max_length.fq.gz" ftype="fastq.gz"/>
            <output name="out2" decompress="true" file="cutadapt_out2_max_length.fq.gz" ftype="fastq.gz"/>
            <assert_command>
                <has_text text="--maximum-length=50:30"/>
                <has_text text="--pair-filter=both"/>
            </assert_command>
        </test>
        <!-- Test combination maximum and minimum length paired reads -->
        <test expect_num_outputs="2">
            <param name="type" value="paired" />
            <param name="input_1" ftype="fastq.gz" value="bwa-mem-fastq1_assimetric.fq.gz" />
            <param name="input_2" ftype="fastq.gz" value="bwa-mem-fastq2_assimetric.fq.gz" />
            <section name="r1">
                <repeat name="adapters">
                    <conditional name="adapter_source">
                        <param name="adapter_source_list" value="user"/>
                        <param name="adapter" value="AGATCGGAAGAGC"/>
                    </conditional>
                </repeat>
            </section>
            <section name="filter_options">
                <param name="pair_filter" value="both"/>
                <param name="minimum_length" value="10"/>
                <param name="maximum_length" value="50"/>
                <param name="maximum_length2" value="30"/>
            </section>
            <output name="out1" decompress="true" file="cutadapt_out1_max_min_01.fq.gz" ftype="fastq.gz"/>
            <output name="out2" decompress="true" file="cutadapt_out2_max_min_01.fq.gz" ftype="fastq.gz"/>
            <assert_command>
                <has_text text="--minimum-length=10 "/>
                <has_text text="--maximum-length=50:30"/>
                <has_text text="--pair-filter=both"/>
            </assert_command>
        </test>
        <test expect_num_outputs="2">
            <param name="type" value="paired" />
            <param name="input_1" ftype="fastq.gz" value="bwa-mem-fastq1_assimetric.fq.gz" />
            <param name="input_2" ftype="fastq.gz" value="bwa-mem-fastq2_assimetric.fq.gz" />
            <section name="r1">
                <repeat name="adapters">
                    <conditional name="adapter_source">
                        <param name="adapter_source_list" value="user"/>
                        <param name="adapter" value="AGATCGGAAGAGC"/>
                    </conditional>
                </repeat>
            </section>
            <section name="filter_options">
                <param name="pair_filter" value="both"/>
                <param name="minimum_length" value="10"/>
                <param name="minimum_length2" value="10"/>
                <param name="maximum_length" value="50"/>
            </section>
            <output name="out1" decompress="true" file="cutadapt_out1_max_min_02.fq.gz" ftype="fastq.gz"/>
            <output name="out2" decompress="true" file="cutadapt_out2_max_min_02.fq.gz" ftype="fastq.gz"/>
            <assert_command>
                <has_text text="--minimum-length=10:10"/>
                <has_text text="--maximum-length=50 "/>
                <has_text text="--pair-filter=both"/>
            </assert_command>
        </test>
        <!-- Test length options -->
        <test expect_num_outputs="1">
            <param name="type" value="single" />
            <param name="input_1" ftype="fastq" value="cutadapt_small.fastq" />
            <section name="r1">
                <repeat name="adapters">
                    <conditional name="adapter_source">
                        <param name="adapter_source_list" value="user"/>
                        <param name="adapter" value="AGCCGCTANGACG"/>
                    </conditional>
                </repeat>
            </section>
            <section name="other_trimming_options">
                <conditional name="shorten_options">
                    <param name="shorten_values" value="True"/>
                    <param name="shorten_end" value="3prime"/>
                    <param name="length" value="10"/>
                </conditional>
            </section>
            <section name="filter_options">
                <param name="minimum_length" value="0"/>
            </section>
            <output name="out1" file="cutadapt_shorten_3prime.out" ftype="fastq"/>
        </test>
        <test expect_num_outputs="1">
            <param name="type" value="single" />
            <param name="input_1" ftype="fastq" value="cutadapt_small.fastq" />
            <section name="r1">
                <repeat name="adapters">
                    <conditional name="adapter_source">
                        <param name="adapter_source_list" value="user"/>
                        <param name="adapter" value="AGCCGCTANGACG"/>
                    </conditional>
                </repeat>
            </section>
            <section name="other_trimming_options">
                <conditional name="shorten_options">
                    <param name="shorten_values" value="True"/>
                    <param name="shorten_end" value="5prime"/>
                    <param name="length" value="10"/>
                </conditional>
            </section>
            <section name="filter_options">
                <param name="minimum_length" value="0"/>
            </section>
            <output name="out1" file="cutadapt_shorten_5prime.out" ftype="fastq"/>
        </test>
        <test expect_num_outputs="2">
            <param name="type" value="paired" />
            <param name="input_1" ftype="fastq" value="cutadapt_small.fastq" />
            <section name="r1">
                <repeat name="adapters">
                    <conditional name="adapter_source">
                        <param name="adapter_source_list" value="user"/>
                        <param name="adapter" value="AGCCGCTANGACG"/>
                    </conditional>
                </repeat>
            </section>
            <section name="r2">
                <repeat name="adapters2">
                    <conditional name="adapter_source">
                        <param name="adapter_source_list" value="user"/>
                        <param name="adapter" value="AGCCGCTANGACG"/>
                    </conditional>
                </repeat>
            </section>
            <section name="other_trimming_options">
                <conditional name="shorten_options">
                    <param name="shorten_values" value="True"/>
                    <param name="shorten_end" value="3prime"/>
                    <param name="length" value="10"/>
                </conditional>
                <conditional name="shorten_options_r2">
                    <param name="shorten_values_r2" value="True"/>
                    <param name="shorten_end_r2" value="5prime"/>
                    <param name="length2" value="10"/>
                </conditional>
            </section>
            <section name="filter_options">
                <param name="minimum_length" value="0"/>
            </section>
            <output name="out1" file="cutadapt_shorten_3prime.out" ftype="fastq"/>
            <output name="out2" file="cutadapt_shorten_5prime.out" ftype="fastq"/>
        </test>
        <test expect_num_outputs="2">
            <param name="type" value="paired" />
            <param name="input_1" ftype="fastq" value="cutadapt_small.fastq" />
            <section name="r2">
                <repeat name="adapters2">
                    <conditional name="adapter_source">
                        <param name="adapter_source_list" value="user"/>
                        <param name="adapter" value="AGCCGCTANGACG"/>
                    </conditional>
                </repeat>
            </section>
            <section name="other_trimming_options">
                <conditional name="shorten_options_r2">
                    <param name="shorten_values_r2" value="True"/>
                    <param name="shorten_end_r2" value="3prime"/>
                    <param name="length2" value="10"/>
                </conditional>
            </section>
            <section name="filter_options">
                <param name="minimum_length" value="0"/>
            </section>
            <output name="out1" file="cutadapt_small.fastq" ftype="fastq"/>
            <output name="out2" file="cutadapt_shorten_3prime.out" ftype="fastq"/>
        </test>
        <!-- Test max expected errors options -->
        <test expect_num_outputs="1">
            <param name="type" value="single" />
            <param name="input_1" ftype="fastq" value="cutadapt_small.fastq" />
            <section name="r1">
                <repeat name="adapters">
                    <conditional name="adapter_source">
                        <param name="adapter_source_list" value="user"/>
                        <param name="adapter" value="AGCGGCTTAGACG"/>
                    </conditional>
                </repeat>
            </section>
            <section name="filter_options">
                <param name="max_expected_errors" value="10"/>
            </section>
            <output name="out1" file="cutadapt_shorten_expected_errors.out" ftype="fastq"/>
        </test>

        <!-- Test disallow internal adaptors option -->
        <test expect_num_outputs="1">
            <param name="type" value="single" />
            <param name="input_1" ftype="fastq" value="cutadapt_small.fastq" />
            <section name="r1">
                <repeat name="adapters">
                    <conditional name="adapter_source">
                        <param name="adapter_source_list" value="user"/>
                        <param name="adapter" value="GAANTAGCTACCACX"/>
                    </conditional>
                </repeat>
            </section>
            <output name="out1" file="cutadapt_shorten_internal_adapters.out" ftype="fastq"/>
            <assert_command>
                <has_text text="GAANTAGCTACCACX"/>
            </assert_command>
        </test>
        <test expect_num_outputs="2">
            <param name="type" value="paired" />
            <param name="input_1" ftype="fastq.gz" value="bwa-mem-fastq1_assimetric.fq.gz" />
            <param name="input_2" ftype="fastq.gz" value="bwa-mem-fastq2_assimetric.fq.gz" />
            <section name="r1">
                <repeat name="adapters">
                    <conditional name="adapter_source">
                        <param name="adapter_source_list" value="user"/>
                        <param name="adapter" value="AGATCGGAAGAGCX"/>
                    </conditional>
                </repeat>
            </section>
            <section name="r2">
                <repeat name="adapters2">
                    <conditional name="adapter_source">
                        <param name="adapter_source_list" value="user"/>
                        <param name="adapter" value="AGATCGGAAGAGCX"/>
                    </conditional>
                </repeat>
            </section>
            <output name="out1" decompress="true" file="cutadapt_out1_internal_adapter.fq.gz" ftype="fastq.gz"/>
            <output name="out2" decompress="true" file="cutadapt_out2_internal_adapter.fq.gz" ftype="fastq.gz"/>
            <assert_command>
                <has_text text="'AGATCGGAAGAGCX'" n="2"/>
            </assert_command>
        </test>
        <test expect_num_outputs="1">
            <param name="type" value="single" />
            <param name="input_1" ftype="fastq" value="cutadapt_small.fastq" />
            <section name="r1">
                <repeat name="adapters">
                    <conditional name="adapter_source">
                        <param name="adapter_source_list" value="builtin"/>
                        <param name="adapter" value="TGTAGGCC"/>
                    </conditional>
                </repeat>
            </section>
            <output name="out1" file="cutadapt_builtin_internal_adapter.out" ftype="fastq"/>
            <assert_command>
                <has_text text="'TGTAGGCC'"/>
            </assert_command>
        </test>
        <!-- Ensure individual per adapter noindels parameter works -->
        <test expect_num_outputs="3">
            <param name="type" value="paired_collection" />
            <param name="input_1">
                <collection type="paired">
                    <element name="forward" ftype="fastq.gz" value="bwa-mem-fastq1.fq.gz" />
                    <element name="reverse" ftype="fastq.gz" value="bwa-mem-fastq2.fq.gz" />
                </collection>
            </param>
            <section name="r1">
                <repeat name="adapters">
                    <conditional name="adapter_source">
                        <param name="adapter_source_list" value="user"/>
                        <param name="adapter" value="AGATCGGAAGAGC"/>
                    </conditional>
                    <param name="single_noindels" value=";noindels" />
                </repeat>
            </section>
            <section name="r2">
                <repeat name="adapters2">
                    <conditional name="adapter_source">
                        <param name="adapter_source_list" value="user"/>
                        <param name="adapter" value="AGATCGGAAGAGC"/>
                    </conditional>
                    <param name="single_noindels" value=";noindels" />
                </repeat>
            </section>
            <output_collection name="out_pairs" type="paired">
                <element name="forward" decompress="true" file="cutadapt_out1.fq.gz" ftype="fastq.gz" />
                <element name="reverse" decompress="true" file="cutadapt_out2.fq.gz" ftype="fastq.gz" />
            </output_collection>
        </test>
        <!-- Ensure specifying quality cutoff (for both reads) works -->
        <test expect_num_outputs="3">
            <param name="type" value="paired_collection" />
            <param name="input_1">
                <collection type="paired">
                    <element name="forward" ftype="fastq.gz" value="bwa-mem-fastq1.fq.gz" />
                    <element name="reverse" ftype="fastq.gz" value="bwa-mem-fastq2.fq.gz" />
                </collection>
            </param>
            <section name="r1">
                <repeat name="adapters">
                    <conditional name="adapter_source">
                        <param name="adapter_source_list" value="user"/>
                        <param name="adapter" value="AGATCGGAAGAGC"/>
                    </conditional>
                </repeat>
            </section>
            <section name="r2">
                <repeat name="adapters2">
                    <conditional name="adapter_source">
                        <param name="adapter_source_list" value="user"/>
                        <param name="adapter" value="AGATCGGAAGAGC"/>
                    </conditional>
                </repeat>
            </section>
            <section name="other_trimming_options">
                <param name="quality_cutoff" value="5"/>
                <param name="quality_cutoff2" value="15,20"/>
            </section>
            <output_collection name="out_pairs" type="paired">
                <element name="forward" decompress="true" file="cutadapt_out1.fq.gz" ftype="fastq.gz" />
                <element name="reverse" decompress="true" file="cutadapt_out2_cutoff.fq.gz" ftype="fastq.gz" />
            </output_collection>
            <assert_command>
                <has_text text="--quality-cutoff=5"/>
                <has_text text="-Q 15,20"/>
            </assert_command>
        </test>

        <!-- ployA trimmining https://github.com/marcelm/cutadapt/blob/e04cc32e392e1cbe0c518b4e0637cdf03533d440/tests/test_paired.py#L768 -->
        <test expect_num_outputs="3">
            <param name="type" value="paired_collection" />
            <param name="input_1">
                <collection type="paired">
                    <element name="forward" ftype="fasta" value="cutadapt/data/polya.1.fasta" />
                    <element name="reverse" ftype="fasta" value="cutadapt/data/polya.2.fasta" />
                </collection>
            </param>
            <section name="other_trimming_options">
                <param name="poly_a" value="true"/>
            </section>
            <output_collection name="out_pairs" type="paired">
                <element name="forward" file="cutadapt/cut/polya.1.fasta" ftype="fasta" />
                <element name="reverse" file="cutadapt/cut/polya.2.fasta" ftype="fasta" />
            </output_collection>
            <assert_command>
                <has_text text="--poly-a"/>
            </assert_command>
        </test>

        <!-- polyA legacy https://github.com/marcelm/cutadapt/blob/e04cc32e392e1cbe0c518b4e0637cdf03533d440/tests/test_commandline.py#L267 -->
        <test expect_num_outputs="1">
            <param name="type" value="single" />
            <param name="input_1" ftype="fasta" value="cutadapt/data/polya.1.fasta" />
            <section name="r1">
                <repeat name="adapters">
                    <conditional name="adapter_source">
                        <param name="adapter_source_list" value="user"/>
                        <param name="adapter" value="AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"/>
                    </conditional>
                </repeat>
            </section>
            <param name="overlap" value="10"/>
            <output name="out1" file="cutadapt/cut/polya.legacy.1.fasta" ftype="fasta"/>
            <assert_command>
                <has_text text="-a 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA'"/>
                <has_text text="--overlap=10"/>
            </assert_command>
        </test>

        <!-- polyA legacy brace notation https://github.com/marcelm/cutadapt/blob/e04cc32e392e1cbe0c518b4e0637cdf03533d440/tests/test_commandline.py#L276 -->
        <test expect_num_outputs="1">
            <param name="type" value="single" />
            <param name="input_1" ftype="fasta" value="cutadapt/data/polya.1.fasta" />
            <section name="r1">
                <repeat name="adapters">
                    <conditional name="adapter_source">
                        <param name="adapter_source_list" value="user"/>
                        <param name="adapter" value="A{35}"/>
                    </conditional>
                </repeat>
            </section>
            <param name="overlap" value="10"/>
            <output name="out1" file="cutadapt/cut/polya.legacy.1.fasta" ftype="fasta"/>
            <assert_command>
                <has_text text="-a 'A{35}'"/>
                <has_text text="--overlap=10"/>
            </assert_command>
        </test>

        <!-- polyA https://github.com/marcelm/cutadapt/blob/e04cc32e392e1cbe0c518b4e0637cdf03533d440/tests/test_commandline.py#L281 -->
        <test expect_num_outputs="1">
            <param name="type" value="single" />
            <param name="input_1" ftype="fasta" value="cutadapt/data/polya.1.fasta" />
            <section name="other_trimming_options">
                <param name="poly_a" value="true"/>
            </section>
            <output name="out1" file="cutadapt/cut/polya.1.fasta" ftype="fasta"/>
            <assert_command>
                <has_text text="--poly-a"/>
            </assert_command>
        </test>
        <!-- fasta.gz input https://github.com/marcelm/cutadapt/blob/e04cc32e392e1cbe0c518b4e0637cdf03533d440/tests/test_commandline.py#L78 
             in contrast to the original test the tool automatically compresses the output -->
        <test expect_num_outputs="1">
            <param name="type" value="single" />
            <param name="input_1" ftype="fasta.gz" value="cutadapt/data/simple.fasta.gz" />
            <output name="out1" decompress="true" file="cutadapt/cut/simple.fasta.gz" ftype="fasta.gz"/>
        </test>
        <!-- fatstqillumina input https://github.com/marcelm/cutadapt/blob/e04cc32e392e1cbe0c518b4e0637cdf03533d440/tests/test_commandline.py#L252 -->
        <test expect_num_outputs="1">
            <param name="type" value="single" />
            <param name="input_1" ftype="fastqillumina" value="cutadapt/data/illumina64.fastq" />
            <section name="r1">
                <repeat name="adapters">
                    <conditional name="adapter_source">
                        <param name="adapter_source_list" value="user"/>
                        <param name="adapter" value="XXXXXX"/>
                    </conditional>
                </repeat>
            </section>
            <section name="other_trimming_options">
                <param name="quality_cutoff" value="10"/>
            </section>
            <section name="filter_options">
                <param name="minimum_length" value="0"/>
            </section>
            <output name="out1" file="cutadapt/cut/illumina64.fastq" ftype="fastqillumina"/>
            <assert_command>
                <has_text text="-a 'XXXXXX'"/>
                <has_text text="--quality-cutoff=10"/>
                <has_text text="--quality-base=64"/>
                <not_has_text text="--minimum-length "/>
            </assert_command>
        </test>
        <!-- fatstqillumina input https://github.com/marcelm/cutadapt/blob/e04cc32e392e1cbe0c518b4e0637cdf03533d440/tests/test_commandline.py#L257 -->
        <test expect_num_outputs="1">
            <param name="type" value="single" />
            <param name="input_1" ftype="fastqillumina" value="cutadapt/data/illumina64.fastq" />
            <section name="other_trimming_options">
                <param name="quality_cutoff" value="10"/>
            </section>
            <section name="filter_options">
                <param name="minimum_length" value="0"/>
            </section>
            <output name="out1" file="cutadapt/cut/illumina64.fastq" ftype="fastqillumina"/>
            <assert_command>
                <has_text text="--quality-cutoff=10"/>
                <has_text text="--quality-base=64"/>
                <not_has_text text="--minimum-length"/>
            </assert_command>
        </test>
        <!-- https://github.com/marcelm/cutadapt/blame/3407ac0004d04b11ae7157934a6665ecaf82c328/tests/test_commandline.py#L1028 --> 
        <test expect_num_outputs="3">
            <param name="type" value="single" />
            <param name="input_1" ftype="fastqillumina" value="cutadapt/data/maxee.fastq" />
            <section name="filter_options">
                <param name="minimum_length" value="0"/>
                <param name="max_expected_errors" value="0.9"/>
            </section>
            <param name="output_selector" value="report,info_file"/>
            <output name="out1" file="cutadapt/cut/maxee.fastq" ftype="fastqillumina"/>
            <output name="report">
                <assert_contents>
                    <has_text text="Reads with too many exp. errors:             2"/>
                </assert_contents>
            </output>
            <output name="info_file">
                <assert_contents>
                    <has_n_lines n="4"/>
                    <has_text text="ee_0.8&#09;-1&#09;ACGTTGCA&#09;++++++++"/>
                </assert_contents>
            </output>
            <assert_command>
                <has_text text="--max-ee=0.9"/>
            </assert_command>
        </test>
        <!-- https://github.com/marcelm/cutadapt/blob/3407ac0004d04b11ae7157934a6665ecaf82c328/tests/test_commandline.py#L335 -->
        <test expect_num_outputs="1">
            <param name="type" value="single" />
            <param name="input_1" ftype="fasta" value="cutadapt/data/wildcard.fa" />
            <section name="r1">
                <repeat name="anywhere_adapters">
                    <conditional name="adapter_source">
                        <param name="adapter_source_list" value="user"/>
                        <param name="adapter" value="ACGTACGT"/>
                    </conditional>
                </repeat>
            </section>
            <section name="adapter_options">
                <param name="match_read_wildcards" value="true"/>
            </section>
            <output name="out1" file="cutadapt/cut/wildcard.fa" ftype="fasta" sort="true"/>
            <assert_command>
                <has_text text="--match-read-wildcards"/>
                <has_text text="-b 'ACGTACGT'"/>
            </assert_command>
        </test>
        <!-- https://github.com/marcelm/cutadapt/blob/3407ac0004d04b11ae7157934a6665ecaf82c328/tests/test_commandline.py#L368 -->
        <test expect_num_outputs="1">
            <param name="type" value="single" />
            <param name="input_1" ftype="fasta" value="cutadapt/data/wildcardN.fa" />
            <section name="r1">
                <repeat name="adapters">
                    <conditional name="adapter_source">
                        <param name="adapter_source_list" value="user"/>
                        <param name="adapter" value="GGGGGGG"/>
                    </conditional>
                </repeat>
            </section>
            <section name="adapter_options">
                <param name="match_read_wildcards" value="true"/>
                <param name="error_rate" value="0"/>
            </section>
            <output name="out1" file="cutadapt/cut/wildcardN.fa" ftype="fasta" sort="true"/>
            <assert_command>
                <has_text text="--match-read-wildcards"/>
                <has_text text="--error-rate=0.0"/>
                <has_text text="-a 'GGGGGGG'"/>
            </assert_command>
        </test>
        <!-- 44. Test mispaired read detection -->
        <test expect_failure="true">
            <param name="type" value="paired" />
            <param name="input_1" ftype="fastq.gz" value="bwa-mem-fastq1.fq.gz" />
            <param name="input_2" ftype="fastq.gz" value="bwa-mem-fastq_mispaired2.fq.gz" />
            <section name="r1">
                <repeat name="adapters">
                    <conditional name="adapter_source">
                        <param name="adapter_source_list" value="user"/>
                        <param name="adapter" value="AGATCGGAAGAGC"/>
                    </conditional>
                </repeat>
            </section>
            <section name="r2">
                <repeat name="adapters2">
                    <conditional name="adapter_source">
                        <param name="adapter_source_list" value="user"/>
                        <param name="adapter" value="AGATCGGAAGAGC"/>
                    </conditional>
                </repeat>
            </section>
            <assert_stderr>
                <has_text text="Reads are improperly paired"/>
            </assert_stderr>
        </test>
    </tests>

    <help><![CDATA[

.. class:: infomark

**What it does**

**Cutadapt** finds and removes adapter sequences, primers, poly-A tails and other types of unwanted sequence from your high-throughput sequencing reads.

Cleaning your data in this way is often required: Reads from small-RNA sequencing contain the 3’ sequencing adapter because the read is longer than the molecule that is sequenced, such as in microRNA, or CRISPR data, or Poly-A tails that are useful for pulling out RNA from your sample but often you don’t want them to be in your reads.

Cutadapt helps with these trimming tasks by finding the adapter or primer sequences in an error-tolerant way. It can also modify and filter reads in various ways. Cutadapt searches for the adapter in all reads and removes it when it finds it. Unless you use a filtering option, all reads that were present in the input file will also be present in the output file, some of them trimmed, some of them not. Even reads that were trimmed entirely (because the adapter was found in the very beginning) are output. All of this can be changed with options in the tool form above.

See the complete `Cutadapt documentation`_ for additional details.

If you use Cutadapt, please cite *Marcel, 2011* under **Citations** below.

-----

Input Sequences
***************

Accepted input formats for the tool are:

- FASTQ.GZ
- FASTQ.BZ2
- FASTQ or
- FASTA

-----

Specifying Adapters
*******************

To trim an adapter, input the ADAPTER sequence in plain text or in a FASTA file e.g. AACCGGTT (with the characters: **$**, **^**, **...**, if anchored or linked).

    =============================================   ===================
    **Option**                                      **Sequence**
    ---------------------------------------------   -------------------
    3’ (End) Adapter                                ADAPTER
    Anchored 3’ Adapter                             ADAPTER$

    5’ (Front) Adapter                              ADAPTER
    Anchored 5’ Adapter                             ^ADAPTER

    5’ or 3’ (Both possible)                        ADAPTER

    Linked Adapter - 3' (End) only                  ADAPTER1...ADAPTER2
    Non-anchored Linked Adapter - 5' (Front) only   ADAPTER1...ADAPTER2
    =============================================   ===================

Below is an illustration of the allowed adapter locations relative to the read and depending on the adapter type:

.. image:: $PATH_TO_IMAGES/adapters.svg


-------------------

*Example: Illumina TruSeq Adapters*

-------------------

If you have reads containing Illumina TruSeq adapters, for example, follow these steps.


For Single-end reads as well as the first reads of Paired-end data:

**Read 1**

In the **3' (End) Adapters** option above, insert A + the “TruSeq Indexed Adapter” prefix that is common to all Indexed Adapter sequences, e.g insert:

AGATCGGAAGAGCACACGTCTGAACTCCAGTCAC


For the second reads of Paired-end data:

**Read 2**

In the **3' (End) Adapters** option above, insert the reverse complement of the “TruSeq Universal Adapter”:

AGATCGGAAGAGCGTCGTGTAGGGAAAGAGTGTAGATCTCGGTGGTCGCCGTATCATT

The adapter sequences can be found in the document `Illumina TruSeq Adapters De-Mystified`_.


-----------

**Paired Adapters**

-----------

Normally, the tool looks for adapters on R1 and R2 reads independently. That is, the best matching R1 adapter of each type (3' End, 5' End, Anywhere) is removed from R1 and the best matching R2 adapter of each type is removed from R2.

To change this, you can use the **Pairwise adapter search** (--pair-adapters) option, which causes each R1 adapter to be paired up with its corresponding R2 adapter. The first R1 adapter of a given type that you specify will be paired up with the first R2 adapter of that type, and so on. The adapters are then always removed in pairs from a read pair.

For example, if you specify the following two 3'-end adapters for the R1 reads:

- ``AAAAA``
- ``GGGGG``

and these two 3'-end adapters for the R2 reads:

- ``CCCC``
- ``TTTT``

then, with this option enabled, the tool will trim a pair of reads only if:

- either ``AAAAA`` is found in R1 and ``CCCCC`` is found in R2,
- or ``GGGG`` is found in R1 and ``TTTT`` is found in R2.

Two limitations exist in this mode:

1. You need to provide equal numbers of R1 and R2 adapters of each type to allow pair formation, or  the tool run will fail.
2. The algorithm identifies the best-matching R1 adapter first and then checks whether it can find its corresponding R2 adapter. If not, the read pair remains unchanged, even though it is, in theory, possible that a different R1 adapter that does not fit as well would have had a corresponding R2 adapter present, i.e., some legitimate adapter pairs might remain unhandled.

This mode is useful, for example, for `demultiplexing Illumina unique dual indices (UDIs)`_.

-----

Outputs
*******

- Trimmed reads

Optionally, under **Output Options** you can choose to output

    * Report
    * Info file

-----------

**Report**

-----------

Cutadapt can output per-adapter statistics if you select to generate the report above.

Example:

    ::
        
        This is cutadapt 3.4 with Python 3.9.2

        Command line parameters: -j=1 -a AGATCGGAAGAGC -A AGATCGGAAGAGC --output=out1.fq.gz --paired-output=out2.fq.gz --error-rate=0.1 --times=1 
        --overlap=3 --action=trim --minimum-length=30:40 --pair-filter=both --cut=0 bwa-mem-fastq1_assimetric_fq_gz.fq.gz bwa-mem-fastq2_assimetric_fq_gz.fq.gz
        
        Processing reads on 1 core in paired-end mode ...
        Finished in 0.01 s (129 µs/read; 0.46 M reads/minute).

        === Summary ===

        Total read pairs processed:                 99
        Read 1 with adapter:                       2 (2.0%)
        Read 2 with adapter:                       4 (4.0%)
        Pairs that were too short:                   3 (3.0%)
        Pairs written (passing filters):            96 (97.0%)

        Total basepairs processed:        48,291 bp
        Read 1:        24,147 bp
        Read 2:        24,144 bp
        Total written (filtered):         48,171 bp (99.8%)
        Read 1:        24,090 bp
        Read 2:        24,081 bp

-----------

**Info file**

-----------

The info file contains information about the found adapters. The output is a tab-separated text file. Each line corresponds to one read of the input file.

Columns contain the following data:

    * **1st**:   Read name
    * **2nd**:   Number of errors
    * **3rd**:   0-based start coordinate of the adapter match
    * **4th**:   0-based end coordinate of the adapter match
    * **5th**:   Sequence of the read to the left of the adapter match (can be empty)
    * **6th**:   Sequence of the read that was matched to the adapter
    * **7th**:   Sequence of the read to the right of the adapter match (can be empty)
    * **8th**:   Name of the found adapter
    * **9th**:   Quality values corresponding to sequence left of the adapter match (can be empty)
    * **10th**:  Quality values corresponding to sequence matched to the adapter (can be empty)
    * **11th**:  Quality values corresponding to sequence to the right of the adapter (can be empty)

The concatenation of columns 5-7 yields the full read sequence. Column 8 identifies the found adapter. Adapters without a name are numbered starting from 1. Fields 9-11 are empty if quality values are not available. Concatenating them yields the full sequence of quality values.

If no adapter was found, the format is as follows:

     #. Read name
     #. The value -1
     #. The read sequence
     #. Quality values

When parsing the file, be aware that additional columns may be added in the future. Note also that some fields can be empty, resulting in consecutive tabs within a line.

If the --times option is used and greater than 1, each read can appear more than once in the info file. There will be one line for each found adapter, all with identical read names. Only for the first of those lines will the concatenation of columns 5-7 be identical to the original read sequence (and accordingly for columns 9-11). For subsequent lines, the shown sequence are the ones that were used in subsequent rounds of adapter trimming, that is, they get successively shorter.

--------------------

Renaming Reads
**************

The --rename option expects a template string such as {id} extra_info {adapter_name} as a parameter. It can contain regular text and placeholders that consist of a name enclosed in curly braces ({placeholdername}).

The read name will be set to the template string in which the placeholders are replaced with the actual values relevant for the current read.

The following placeholders are currently available for single-end reads:

        * {header} – the full, unchanged header
        * {id} – the read ID, that is, the part of the header before the first whitespace
        * {comment} – the part of the header after the whitespace following the ID
        * {adapter_name} – the name of adapter that was found in this read or no_adapter if there was none adapter match. If you use --times to do multiple rounds of adapter matching, this is the name of the last found adapter.
        * {match_sequence} – the sequence of the read that matched the adapter (including errors). If there was no adapter match, this is set to an empty string. If you use a linked adapter, this is to the two matching strings, separated by a comma.
        * {cut_prefix} – the prefix removed by the --cut (or -u) option (that is, when used with a positive length argument)
        * {cut_suffix} – the suffix removed by the --cut (or -u) option (that is, when used with a negative length argument)
        * {rc} – this is replaced with the string rc if the read was reverse complemented. This only applies when reverse complementing was requested

If the --rename option is used with paired-end data, the template is applied separately to both R1 and R2. That is, for R1, the placeholders are replaced with values from R1, and for R2, the placeholders are replaced with values from R2. For example, {comment} becomes R1’s comment in R1 and it becomes R2’s comment in R2.

For paired-end data, the placeholder {rn} is available (“read number”), and it is replaced with 1 in R1 and with 2 in R2.

In addition, it is possible to write a placeholder as {r1.placeholdername} or {r2.placeholdername}, which always takes the replacement value from R1 or R2, respectively.
The {r1.placeholder} and {r2.placeholder} notation is available for all placeholders except {rn} and {id} because the read ID needs to be identical for both reads.

-----

**Galaxy Wrapper Development**

Original author: Lance Parsons <lparsons@princeton.edu>

-----

.. _`Cutadapt documentation`: https://cutadapt.readthedocs.io
.. _`Illumina TruSeq Adapters De-Mystified`: http://tucf-genomics.tufts.edu/documents/protocols/TUCF_Understanding_Illumina_TruSeq_Adapters.pdf
.. _`demultiplexing Illumina unique dual indices (UDIs)`: https://cutadapt.readthedocs.io/en/stable/guide.html#unique-dual-indices
    ]]></help>
    <expand macro="citations" />
</tool>
