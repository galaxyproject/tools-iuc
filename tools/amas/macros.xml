<macros>
    <xml name="requirements">
        <requirements>
            <requirement type="package" version="@TOOL_VERSION@">amas</requirement>
        </requirements>
    </xml>

    <xml name="version_command">
        <version_command>python -m amas.AMAS -h</version_command>
    </xml>

    <xml name="command">
        <command detect_errors="exit_code"><![CDATA[
set -eu;

rm -rf "run_dir/${action.action_selector}";
mkdir -p "run_dir/${action.action_selector}";

## Create symlinks with original filename for consistent tests because
##  input filenames are used as str vars in the partitions.txt output
#for $f in $input_files
    ln -s '${f}' "run_dir/${action.action_selector}/${f.element_identifier}";
#end for

cd "run_dir/${action.action_selector}";

python -m amas.AMAS
#if $action.action_selector == "concat":
    concat
    --concat-part partitions.txt
    --concat-out concatenated.out
    --part-format $part_format
    --out-format $concat_out_format
#elif $action.action_selector == "convert":
    convert
    --out-format $convert_out_format
#elif $action.action_selector == "replicate":
    replicate
    --rep-aln $replicate_replicates $replicate_loci
    --out-format $replicate_out_format
#elif $action.action_selector == "split":
    split
    --split-by '$split_by'
    $remove_empty
    --out-format $split_out_format
#elif $action.action_selector == "summary":
    summary
    --summary-out summary.txt
    #if str($by_taxon) == "true":
        --by-taxon
    #end if
#elif $action.action_selector == "remove":
    remove
    --out-prefix '$out_prefix'
    --out-format $remove_out_format
    --taxa-to-remove
    #for $taxon in $taxa_to_remove
        '$taxon.taxon'
    #end for
#elif $action.action_selector == "translate":
    translate
    --code $genetic_code
    --reading-frame $reading_frame
    --out-format $translate_out_format
#elif $action.action_selector == "trim":
    trim
    --trim-fraction $trim_fraction
    #if str($retain_parsimony) == "true":
        --retain-only-parsimony-sites
    #end if
    --out-format $trim_out_format
#end if
    --in-files
#for $f in $input_files
        '${f.element_identifier}'
#end for
    --in-format $in_format
    --data-type $data_type
    --cores $cores
    $check_align
        ]]></command>
    </xml>

    <xml name="input_format">
        <param name="in_format" type="select" label="Format of the input file">
            <option value="fasta">fasta</option>
            <option value="phylip">phylip</option>
            <option value="phylip-int">phylip-int</option>
            <option value="nexus">nexus(sequential)</option>
            <option value="nexus-int">nexus(interleaved)</option>
        </param>
    </xml>

    <xml name="output_format" token_name="out_format" token_label="Format of the output file">
        <param name="@NAME@" type="select" label="@LABEL@">
            <option value="fasta">fasta</option>
            <option value="phylip">phylip</option>
            <option value="phylip-int">phylip-int</option>
            <option value="nexus">nexus (sequential)</option>
            <option value="nexus-int">nexus (interleaved)</option>
        </param>
    </xml>

    <xml name="change_format" token_input="out_format">
        <change_format>
            <when input="@INPUT@" value="fasta" format="fasta" />
            <when input="@INPUT@" value="phylip" format="phylip" />
            <when input="@INPUT@" value="phylip-int" format="phylip" />
            <when input="@INPUT@" value="nexus" format="nex" />
            <when input="@INPUT@" value="nexus-int" format="nex" />
        </change_format>
    </xml>

</macros>