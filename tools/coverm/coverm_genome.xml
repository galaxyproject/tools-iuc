<tool id="coverm-genome" name="CoverM-GENOME" version="@TOOL_VERSION@" python_template_version="3.5">
    <macros>
        <import>macros.xml</import>
        <token name="@INPUT_FORMATS@">fasta,fastq,fastq.gz,fasta.gz</token>
        <token name="@TOOL_VERSION@">0.2.1</token>
    </macros>
    <expand macro="requirements"/>
    <command><![CDATA[
         #if $reads.read_type == "single" or $reads.read_type == "interleaved"
            mkdir -p reads1 &&
            #set file_paths1 = []
            #for $input_file in $reads.single
                
                #set $fname = $input_file.element_identifier.replace(" ","_")
                #set $file_path = 'reads1/' + $fname
                ln -s '$input_file' '$file_path' &&
                $file_paths1.append($file_path)
            #end for
        #else if $reads.read_type == "bam"
            mkdir -p bam &&
            #set bam_files = []
            #for $input_file in $reads.bam
                
                #set $fname = $input_file.element_identifier.replace(" ","_")
                #set $file_path = 'bam/' + $fname
                ln -s '$input_file' '$file_path' &&
                $bam_files.append($file_path)
            #end for
        #else if $reads.read_type == "paired"
            mkdir -p paired_reads1 &&
            #set fw_reads1 = []
            #for $input_file in $reads.read1
                
                #set $fname = $input_file.element_identifier.replace(" ","_")
                #set $file_path = 'paired_reads1/' + str($fname)
                ln -s '$input_file' '$file_path' &&
                $fw_reads1.append($file_path)
            #end for
            #set rv_reads1 = []
            #for $input_file in $reads.read2
                
                #set $fname = $input_file.element_identifier.replace(" ","_")
                #set $file_path = 'paired_reads1/' + str($fname)
                ln -s '$input_file' '$file_path' &&
                $rv_reads1.append($file_path)
            #end for
            #silent $fw_reads1.sort()
            #silent $rv_reads1.sort()
        #else
            mkdir -p paired_reads &&
            #set paired_reads1 = []
            #for $i, $input_file in enumerate($reads.paired_reads)
                #set $file_path = 'paired_reads/fw' + str($i)
                ln -s '$input_file.forward' '$file_path' &&
                $paired_reads1.append($file_path)
                #set $file_path = 'paired_reads/rv' + str($i)
                ln -s '$input_file.reverse' '$file_path' &&
                $paired_reads1.append($file_path)
            #end for
        #end if           
        #if $add_reads.extra_read.read_type == "single" or $add_reads.extra_read.read_type == "interleaved"
            mkdir -p add_reads1 &&
            #set add_file_paths1 = []
            #for $input_file in $add_reads.extra_read.single
                #set $fname = $input_file.element_identifier.replace(" ","_")
                #set $file_path = 'add_reads1/' + $fname
                ln -s '$input_file' '$file_path' &&
                $add_file_paths1.append($file_path)
            #end for
        #else if $add_reads.extra_read.read_type == "bam"
            mkdir -p add_bam &&
            #set add_bam_files = []
            #for $input_file in $reads.bam
                #set $fname = $input_file.element_identifier.replace(" ","_")
                #set $file_path = 'add_bam/' + $fname
                ln -s '$input_file' '$file_path' &&
                $add_bam_files.append($file_path)
            #end for
        #else if $add_reads.extra_read.read_type == "paired"
            mkdir -p add_paired_reads1 &&
            #set add_fw_reads1 = []
            #for $input_file in $add_reads.extra_read.read1
                #set $fname = $input_file.element_identifier.replace(" ","_")
                #set $file_path = 'add_paired_reads1/' + str($fname)
                ln -s '$input_file' '$file_path' &&
                $add_fw_reads1.append($file_path)
            #end for
            #set add_rv_reads1 = []
            #for $input_file in $add_reads.extra_read.read2
                #set $fname = $input_file.element_identifier.replace(" ","_")
                #set $file_path = 'add_paired_reads1/' + str($fname)
                ln -s '$input_file' '$file_path' &&
                $add_rv_reads1.append($file_path)
            #end for
            #silent $add_fw_reads1.sort()
            #silent $add_rv_reads1.sort()
        #else if $add_reads.extra_read.read_type == "paired_collection"
            mkdir -p add_paired_reads &&
            #set add_paired_reads1 = []
            #for $i, $input_file in enumerate($add_reads.extra_read.paired_reads)
                #set $ext = $input_file.forward.ext
                #set $file_path = 'add_paired_reads/fw' + str($i) + '.' + $ext
                ln -s '$input_file.forward' '$file_path' &&
                $add_paired_reads1.append($file_path)
                #set $file_path = 'add_paired_reads/rv' + str($i) + '.' + $ext
                ln -s '$input_file.reverse' '$file_path' &&
                $add_paired_reads1.append($file_path)
            #end for
        #end if
        #if $reads.genome.ref_or_genome == "genomic"
                mkdir -p genomes &&
                #set genome_files = []
            #if $reads.genome.genomic.source == "history"
                #for $input_file in $reads.genome.genomic.fasta_history
                    
                    #set $fname = $input_file.element_identifier.replace(" ","_")
                    #set $file_path = 'genomes/' + $fname
                    ln -s '$input_file' '$file_path' &&
                    $genome_files.append($file_path)
                #end for
             #else
                #for $input_file in $reads.genome.genomic.fasta_builtin
                    #set $ext = $input_file.fields.path.ext
                    #set $fname = $input_file.fields.path.element_identifier.replace(" ","_")
                    #set $file_path = 'genomes/' + $fname
                    ln -s '$input_file' '$file_path' &&
                    $genome_files.append($file_path)
                #end for
            #end if
        #else if $reads.genome.ref_or_genome != "none"
            mkdir -p reference &&
            #set ref_files = []
            #if $reads.genome.ref_genome.ref_source == "history"
                #for $input_file in $reads.genome.ref_genome.ref_fasta_history
                    #set $fname = $input_file.element_identifier.replace(" ","_")
                    #set $file_path = 'reference/' + $fname
                    ln -s '$input_file' '$file_path' &&
                    $ref_files.append($file_path)
                #end for
             #else
                #for $input_file in $reads.genome.ref_genome.ref_fasta_builtin
                    #set $ext = $input_file.fields.path.ext
                    #set $fname = $input_file.fields.path.element_identifier.replace(" ","_")
                    #set $file_path = 'reference/' + $fname
                    ln -s '$input_file' '$file_path' &&
                    $ref_files.append($file_path)
                #end for
            #end if
            #if $reads.genome.add_genome.add_genome
                mkdir -p genomes &&
                #set genome_files = []
                #if $reads.genome.add_genome.add_genomic == "history"
                    #for $input_file in $reads.genome.add_genome.add_genomic.fasta_history
                        #set $fname = $input_file.element_identifier.replace(" ","_")
                        #set $file_path = 'genomes/' + $fname
                        ln -s '$input_file' '$file_path' &&
                        $genome_files.append($file_path)
                    #end for
                #else
                    #for $input_file in $reads.genome.add_genome.add_genomic.fasta_builtin
                        #set $ext = $input_file.fields.path.ext
                        #set $fname = $input_file.fields.path.element_identifier.replace(" ","_")
                        #set $file_path = 'genomes/' + $fname
                        ln -s '$input_file' '$file_path' &&
                        $genome_files.append($file_path)
                    #end for
                #end if
            #end if
        #end if
    
        coverm genome
            #if $reads.read_type == 'paired'
                -1
                #for $read in $fw_reads1
                    '${read}'
                #end for
                -2
                #for $read in $rv_reads1
                    '${read}'
                #end for
            #else if $reads.read_type == 'paired_collection'
                --coupled
                #for $read in $paired_reads1
                    '${read}'
                #end for
            #else if $reads.read_type == 'single'
                --single
                #for $read in $file_paths1
                    '${read}'
                #end for
            #else if $reads.read_type == 'interleaved'
                --interleaved
                #for $read in $file_paths1
                    '${read}'
                #end for
            #else if $reads.read_type == 'bam'
                -b
                #for $read in $bam_files
                    '${read}'
                #end for
            #end if

            #if $add_reads.extra_read.read_type == 'paired'
                -1
                #for $read in $add_fw_reads1
                    '${read}'
                #end for
                -2
                #for $read in $add_rv_reads1
                    '${read}'
                #end for
            #else if $add_reads.extra_read.read_type == 'paired_collection'
                --coupled
                #for $read in $add_paired_reads1
                    '${read}'
                #end for
            #else if $add_reads.extra_read.read_type == 'single'
                --single
                #for $read in $add_file_paths1
                    '${read}'
                #end for
            #else if $add_reads.extra_read.read_type == 'interleaved'
                --interleaved
                #for $read in $add_file_paths1
                    '${read}'
                #end for
            #else if $add_reads.extra_read.read_type == 'bam'
                #for $read in $add_bam_files
                    '${read}'
                #end for
            #end if
            

            #if $reads.genome.ref_or_genome == "genomic":
                -f
                #for $genome in $genome_files
                    '${genome}'
                #end for
            #else if $reads.genome.ref_or_genome != "none":
                --reference
                #for $reference in $ref_files
                    '${reference}'
                #end for
                $reads.genome.ref_as_index
                #if $reads.genome.separator:
                    -s "$reads.genome.separator"
                #end if
                $reads.genome.single_genome
                #if $reads.genome.genome_definition
                    --genome-definition $reads.genome.genome_definition
                #end if
                #if $reads.genome.add_genome.add_genome
                    -f
                    #for $genome in $genome_files
                        '${genome}'
                    #end for
                #end if
            #end if

            $derep.dereplicate
            #if $derep.checkm_tab_table:
                --chekm-tab-table $derep.checkm_tab_table
            #end if
            #if $derep.genome_info:
                --genome-info $derep.genome_info
            #end if
            #if $derep.min_completeness:
                --min-completeness $derep.min_completeness
            #end if
            #if $derep.max_contamination:
                --max-contamination $derep.max_contamination
            #end if
            #if $derep.dereplication_ani:
                --dereplication-ani $derep.dereplication_ani
            #end if
            #if $derep.dereplication_aligned_fraction:
                --dereplication-aligned-fraction $derep.dereplication_aligned_fraction
            #end if
            #if $derep.dereplication_fragment_length:
                --dereplication-fragment-length $derep.dereplication_fragment_length
            #end if
            #if $derep.dereplication_prethreshold_ani:
                --dereplication-prethreshold-ani $derep.dereplication_prethreshold_ani
            #end if
            #if $derep.dereplication_quality_formula:
                --dereplication-quality-formula $derep.dereplication_quality_formula
            #end if
            #if $derep.dereplication_precluster_method:
                --dereplication-precluster-method $derep.dereplication_precluster_method
            #end if
            #if $derep.dereplication_output_cluster_definition:
                --dereplication-output-cluster-definition .
            #end if
            #if $derep.dereplication_output_representative_fasta_directory_copy:
                --dereplication-output-representative-fasta-directory-copy .
            #end if

            $shar.sharded
            $shar.exclude_genoms_from_deshard

            #if $mapping.mapper:
                --mapper $mapping.mapper
            #end if
            $mapping.minimap2_reference_is_index

            #if $al_thresh.min_read_aligned_length:
                --min-read-aligned-length $al_thresh.min_read_aligned_length
            #end if
            #if $al_thresh.min_read_percent_identity:
                --min-read-percent-identity $al_thresh.min_read_percent_identity
            #end if
            #if $al_thresh.min_read_aligned_percent:
                --min-read-aligned-percent $al_thresh.min_read_aligned_percent
            #end if
            #if $al_thresh.min_read_aligned_length_pair:
                --min-read-aligned-length-pair $al_thresh.min_read_aligned_length_pair
            #end if
            #if $al_thresh.min_read_percent_identity_pair:
                --min-read-percent-identity-pair $al_thresh.min_read_percent_identity_pair
            #end if
            #if $al_thresh.min_read_aligned_percent_pair:
                --min-read-aligned-percent-pair $al_thresh.min_read_aligned_percent_pair
            #end if
            $al_thresh.proper_pairs_only
            $al_thresh.exclude_supplementary

            #if $cov.methods:
                --methods ${ str($cov.methods).replace(","," ") }
            #end if
            #if $cov.min_covered_fraction:
                --min-covered-fraction $cov.min_covered_fraction
            #end if
            #if $cov.contig_end_exclusion:
                --contig-end-exclusion $cov.contig_end_exclusion
            #end if
            #if $cov.trim_min:
                --trim-min $cov.trim_min
            #end if
            #if $cov.trim_max:
                --trim_max $cov.trim_max
            #end if

            #if $out.output_format:
                --output-format $out.output_format
            #end if
            $out.no_zeros
            -o output.tsv
            --threads \${GALAXY_SLOTS:-1}

    ]]></command>
    <inputs>
        <expand macro="reads" />
        <expand macro="add_reads" />
        <section name="derep" title="Dereplication" expanded="false">
            <param name="dereplicate" type="boolean" truevalue="--dereplicate" falsevalue="" optional="true" label="Do genome dereplication via average nucleotide identity (ANI) - choose a genome to represent all within a small distance, using Dashing for preclustering and FastANI for final ANI calculation. When this flag is used, dereplication occurs transparently through the Galah method (https://github.com/wwood/galah)"/>
            <param name="checkm_tab_table" type="data" format="tsv" optional="true" label="CheckM tab table (i.e. the output of checkm .. --tab_table -f PATH ..) for defining genome quality, which is used both for filtering and to rank genomes during clustering." />
            <param name="genome_info" type="data" format="csv" optional="true" label="dRep style genome info table for defining quality." />
            <param name="min_completeness" type="float" optional="true" min="0" max="1" label="Ignore genomes with less completeness than this percentage." />
            <param name="max_contamination" type="float" optional="true" min="0" max="1" label="Ignore genomes with more contamination than this percentage." />
            <param name="dereplication_ani" type="float" optional="true" min="0" label="Overall ANI level to dereplicate at with FastANI. default: 99" />
            <param name="dereplication_aligned_fraction" type="float" optional="true" min="0" label="Min aligned fraction of two genomes for clustering. default: 50" />
            <param name="dereplication_fragment_length" type="float" optional="true" min="0" label="Length of fragment used in FastANI calculation (i.e. --fragLen). default: 3000" />
            <param name="dereplication_prethreshold_ani" type="float" optional="true" min="0" label="Require at least this dashing-derived ANI for preclustering and to avoid FastANI on distant lineages within preclusters. default: 95" />
            <param type="select" name="dereplication_quality_formula" optional="true" label="Scoring function for genome quality [default: Parks2020_reduced]. One of:">
                <option value="Parks2020-reduced">(default) A quality formula described in Parks et. al. 2020 https://doi.org/10.1038/s41587-020-0501-8 (Supplementary Table 19) but only including those scoring criteria that can be calculated from the sequence without homology searching: completeness-5*contamination-5*num_contigs/100-5*num_ambiguous_bases/100000</option>
                <option value="completeness-4contamination">completeness-4*contamination</option>
                <option value="completeness-5contamination">completeness-5*contamination</option>
                <option value="dRep">completeness-5*contamination+contamination*(strain_heterogeneity/100)+0.5*log10(N50)</option>
            </param>
            <param type="select" name="dereplication_precluster_method" optional="true" label="method of calculating rough ANI for dereplication. 'dashing' for HyperLogLog, 'finch' for finch MinHash. default: dashing">
                <option value="dashing">HyperLogLog</option>
                <option value="finch">finch MinHash</option>
            </param>
            <param name="dereplication_output_cluster_definition" type="boolean" optional="true" label="Output a file of representative TAB member lines." />
            <param name="dereplication_output_representative_fasta_directory_copy" type="boolean" optional="true" label="Output representative genomes" />
        </section>
        <section name="shar" title="Sharding" expanded="false">
            <param name="sharded" type="boolean" optional="true" truevalue="--sharded" falsevalue="" label="If -b/--bam-files was used: Input BAM files are read-sorted alignments of a set of reads mapped to multiple reference contig sets. Choose the best hit for each read pair. Otherwise if mapping was carried out: Map reads to each reference, choosing the best hit for each pair." />
            <param name="exclude_genoms_from_deshard" type="boolean" optional="true" truevalue="--exclude-genoms-from-deshard" falsevalue="" label="Ignore genomes whose name appears in this newline-separated file when combining shards." />
        </section>
            <expand macro="mapping"/>
            <expand macro="al_thresh"/>
            <expand macro="coverage"/>
            <expand macro="out"/>
    </inputs>
    <outputs>
        <data name="output1" format="tsv" from_work_dir="./output.tsv"/>
        <data name="cluster-definition" format="tsv">
            <filter>derep['dereplication_output_cluster_definition']</filter>
        </data>
    </outputs>
    <tests>
        <test>
            <conditional name="reads">
                <param name="read_type" value="paired_collection"/>
                <param name="paired_reads">
                    <collection type="list:paired">
                        <element name="reads">
                            <collection type="paired">
                                <element name="forward" value="reads_for_seq1_and_seq2.1.fq.gz"/>
                                <element name="reverse" value="reads_for_seq1_and_seq2.2.fq.gz"/>
                            </collection>
                        </element>
                    </collection>
                </param>
                <conditional name="genome">
                    <param name="ref_or_genome" value="reference"/>
                        <conditional name="ref_genome">
                            <param name="ref_source" value="history"/>
                            <param name="ref_fasta_history" value="7seqs.fna"/>
                        </conditional>
                        <param name="separator" value="~"/>
                </conditional>
            </conditional>
            <section name="add_reads">
                <conditional name="extra_read">
                    <param name="read_type" value="single"/>
                    <param name="single" value="reads_for_seq1_and_seq2.fna"/>
                </conditional>
            </section>
            <section name="cov">
                <param name="methods" value="relative_abundance,mean,variance"/>
            </section>
            
            <section name="out">
                <param name="output_format" value="sparse"/>
            </section>
            <output name="output1" file="test1.tsv" ftype="tsv"/>
        </test>
        <test expect_num_outputs="1">
            <!--TODO: auto-generated test case. Please fill in the required values-->
            <conditional name="reads">
                <param name="read_type" value="bam"/>
                <param name="bam" value="7seqs.reads_for_seq1_and_seq2.bam"/>
                <conditional name="genome">
                    <param name="ref_or_genome" value="none"/>
                </conditional>
            </conditional>
            <section name="shar">
                <param name="sharded" value="false"/>
                <param name="exclude_genoms_from_deshard" value="false"/>
            </section>
            <section name="mapping">
                <param name="mapper" value="minimap2-sr"/>
                <param name="minimap2_reference_is_index" value="false"/>
            </section>
            <section name="cov">
                <param name="methods" value="relative_abundance,mean"/>
            </section>
            <section name="out">
                <param name="output_format" value="sparse"/>
            </section>
            <output name="output1">
                <assert_contents>
                    <has_text text="Sample	Genome	Relative Abundance (%)	Mean
7seqs.reads_for_seq1_and_seq2	unmapped	0	NA
7seqs.reads_for_seq1_and_seq2	genome1	0	0
7seqs.reads_for_seq1_and_seq2	genome2	53.16792	1.4117647
7seqs.reads_for_seq1_and_seq2	genome3	0	0
7seqs.reads_for_seq1_and_seq2	genome4	0	0
7seqs.reads_for_seq1_and_seq2	genome5	46.832077	1.2435294
7seqs.reads_for_seq1_and_seq2	genome6	0	0"/>
                </assert_contents>
            </output>
        </test>
        <test expect_num_outputs="1">
        <!--TODO: auto-generated test case. Please fill in the required values-->
        <section name="derep">
            <param name="dereplicate" value="true"/>
            <param name="genome_info" value="genomeInfo.csv"/>
        </section>
        <section name="cov">
            <param name="methods" value="covered_fraction"/>
            <param name="min_covered_fraction" value="0"/>
        </section>
        <conditional name="reads">
            <param name="read_type" value="single"/>
            <param name="single" value="1read.actually_fasta.fq"/>
            <conditional name="genome">
                <param name="ref_or_genome" value="genomic"/>
                <conditional name="genomic">
                    <param name="source" value="history"/>
                    <param name="fasta_history" value="500kb.fna,1mbp.fna"/>
                </conditional>
            </conditional>
        </conditional>
        <output name="output1">
            <assert_contents>
                <has_text text="Genome	1read.actually_fasta.fq Covered Fraction\n\
                1mbp	0.00232\n"/>
            </assert_contents>
        </output>
        </test>
        </tests>
    <help><![CDATA[
        TODO: Fill in help.
    ]]></help>
</tool>