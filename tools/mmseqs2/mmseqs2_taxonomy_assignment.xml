<tool id="mmseqs2_taxonomy_assignment" name="MMseqs2 Taxonomy Assignment" version="@TOOL_VERSION@+galaxy@VERSION_SUFFIX@" profile="@PROFILE@">
    <description>
        Assigns taxonomic labels to sequences by comparing them to a reference database and identifying the lowest common ancestor
    </description>
    <macros>
        <import>macro.xml</import>
    </macros>
    <expand macro="biotools"/>
    <expand macro="requirements"/>
    <expand macro="version_command"/>
    <command detect_errors="exit_code"><![CDATA[
mmseqs createdb
    '$createdb.input_fasta'
    'sequenceDB'
    --dbtype '$createdb.dbtype'
    --shuffle $createdb.shuffle &&

mmseqs createtaxdb
    'sequenceDB' ## Ici ça ne doit pas être la sortie de la commande précédente mais la DB de référence
    '$createtaxdb.mmseqs2_db_select.fields.path' ## J'aurais plus mis ça
    'tmp'
    #if '$createtaxdb.tax_mapping_file'
    --tax-mapping-file '$createtaxdb.tax_mapping_file'
    #end if
    --tax-mapping-mode '$createtaxdb.tax_mapping_mode'
    --threads "\${GALAXY_SLOTS:-1}" &&

    #if '$filtertaxseqdb.filtertaxseqdb_bool.use_filter' == "yes"
mmseqs filtertaxseqdb
    'sequenceDB'
    'sequenceDB_filtered'
        #if '$filtertaxseqdb.filtertaxseqdb_bool.use_filter.taxon_list' != ""
    --taxon-list '$filtertaxseqdb.filtertaxseqdb_bool.use_filter.taxon_list'
        #end if
    #end if

mmseqs taxonomy
    #if '$filtertaxseqdb.filtertaxseqdb_bool.use_filter' == "yes"
        'sequenceDB_filtered'
    #else 
        'sequenceDB'
    #end if
    '$createtaxdb.mmseqs2_db_select.fields.path'
    'output_taxonomy'
    'tmp'
    ##Pre-filter options
    --comp-bias-corr-scale $taxonomy.prefilter.comp_bias_corr_scale
    --add_self_matches $taxonomy.prefilter.add_self_matches
    -s $taxonomy.prefilter.sensitivity
    -k $taxonomy.prefilter.kmer_length
    --target-search-mode $taxonomy.prefilter.target_search_mode
    #if '$taxonomy.prefilter.alph_type.type' == "amino_acid"
        --alph-size $taxonomy.prefilter.alph_type.type.alph_size_amino_acid
    #else
        --alph-size $taxonomy.prefilter.alph_type.type.alph_size_nucleotide
    #end if
    --max-seqs $taxonomy.prefilter.max_seqs
    --split $taxonomy.prefilter.split
    --split-mode $taxonomy.prefilter.split_mode
    --diag-score $taxonomy.prefilter.diag_score
    --exact-kmer-matching $taxonomy.prefilter.exact_kmer_matching
    --mask $taxonomy.prefilter.mask
    --mask-prob $taxonomy.prefilter.mask_prob
    --mask-lower-case $taxonomy.prefilter.mask_lower_case
    --min-ungapped-score $taxonomy.prefilter.min_ungapped_score
    --spaced-kmer-mode $taxonomy.prefilter.spaced_kmer_mode
    ##Align options
    -a $taxonomy.align.convertalis
    --alignment-mode $taxonomy.align.alignment_mode 
    --alignment-output-mode $taxonomy.align.alignment_output_mode 
    --wrapped-scoring $taxonomy.align.wrapped_scoring
    -e $taxonomy.align.evalue
    --min-seq-id $taxonomy.align.min_seq_id
    --min-aln-len $taxonomy.align.min_aln_len
    --seq-id-mode $taxonomy.align.seq_id_mode
    -c $taxonomy.align.cov
    --cov-mode $taxonomy.align.cov_mode
    --max-rejected $taxonomy.align.max_rejected
    --max-accept $taxonomy.align.max_accept
    --score-bias $taxonomy.align.score_bias
    --realign $taxonomy.align.realign
    --realign-score-bias $taxonomy.align.realign_score_bias
    --realign-max-seqs $taxonomy.align.realign_max_seqs
    --corr-score-weight $taxonomy.align.corr_score_weight
    ##refaire une condition dans la partie align ?
    #if '$taxonomy.align.alph_type.type' == "amino_acid"
        --gap-open 11
        --gap-extend 1
    #else
        --gap-open 5
        --gap-extend 2
        --zdrop $taxonomy.align.alph_type.type.zdrop
    #end if
    --exhaustive-search-filter $taxonomy.align.exhaustive_search_filter

    

    ]]></command>
    <inputs>
        <section name="createdb" title="Convert FASTA/Q file(s) to MMseqs sequence DB format"  expanded="true">
            <param name="input_fasta" type="data" format="fasta,fasta.gz" label="Input fasta file" help="" />
            <param argument="--dbtype" type="select" label="Database type" help="" >
                <option value="0" selected="true">Auto</option>
                <option value="1">Amino acid</option>
                <option value="2">Nucleotides</option>
            </param>
            <param argument="--shuffle" type="boolean" checked="true" label="Shuffle input database" truevalue="1" falsevalue="0" optional="true" help="" />
        </section>
        <section name="createtaxdb" title="Add taxonomic labels to sequence DB">
            <param name="mmseqs2_db_select" type="select" label="MMseqs2 databases">
                <options from_data_table="mmseqs2_database"> <!--Le from_data_table reste à définir car 5 data_table différentes dans le DM-->
                    <validator message="No mmseqs2 database is available" type="no_options"/>
                </options>
            </param>
            <param name="tax_mapping_file" type="data" format="tabular,tsv,txt" label="File to map sequence identifier to taxonomical identifier" help="(--tax-mapping-file)"  optional="true"/>
            <param argument="--tax-mapping-mode" type="select" label="Map taxonomy based on sequence database" help="" >
                <option value="0" selected="true">0: .lookup file</option>
                <option value="1">1: .source file</option>
            </param>
        </section>
        <section name="filtertaxseqdb" title="Filter taxonomy sequence database">
            <conditional name="filtertaxseqdb_bool">
                <param name="use_filter" type="select" label="Do you want to retain (or exclude) sequences based on their taxonomic labels?" help="" >
                    <option value="no" selected="true">No</option>
                    <option value="yes">Yes</option>
                </param>
                <when value="no"/>
                <when value="yes">
                    <param argument="--taxon-list" type="text" optional="true" value="" label="Taxonomy ID" help="Possibly multiple values separated by ','"/>
                </when>
            </conditional>
        </section>
        <section name="taxonomy" title="Taxonomy assignment by computing the lowest common ancestor of homologs">
            <section name="prefilter" title="Pre-filter">
                <param argument="--comp-bias-corr-scale" type="float" min="0" max="1" value="1" label="Scale composition bias correction" help=""/>
                <param argument="--add-self-matches" type="boolean" checked="false" truevalue="1" falsevalue="0" label="Artificially add entries of queries with themselves (for clustering)" help=""/>
                <param name="sensitivity" type="float" min="0" max="7.5" value="2" label="Sensitivity" help="1.0 faster; 4.0 fast; 7.5 sensitive"/>
                <param name="kmer_length" type="integer" min="0" value="0" label="k-mer length" help="(0: automatically set to optimum)"/>
                <param argument="--target-search-mode" type="select" label="Target search mode" help="" >
                    <option value="0" selected="true">Regular k-mer</option>
                    <option value="1">Similar k-mer</option>
                </param>
                <conditional name="alph_type">
                    <param name="type" type="select" label="Alphabet type" help="" >
                        <option value="amino_acid" selected="true">Amino acid</option>
                        <option value="nucleotide">Nucleotide</option>
                    </param>
                    <when value="amino_acid">
                        <param name="alph_size_amino_acid" type="integer" min="2" max="5" value="5" label="Alphabet size" help=""/>
                    </when>
                    <when value="nucleotide">
                        <param name="alph_size_nucleotide" type="integer" min="2" max="21" value="21" label="Alphabet size" help=""/>
                    </when>
                </conditional>
                <param argument="--max-seqs" type="integer" min="0" value="300" label="Maximum results per query sequence allowed to pass the prefilter" help="Affects sensitivity"/>
                <param argument="--split" type="integer" min="0" value="0" label="Split input into N equally distributed chunks" help="0: set the best split automatically"/>            
                <param argument="--split-mode" type="select" label="Split mode" help="" >
                    <option value="0">Split target db</option>
                    <option value="1">Split query db</option>
                    <option value="2" selected="true">Auto, depending on main memory</option>
                </param>
                <param argument="--diag-score" type="boolean" checked="true" truevalue="1" falsevalue="0" label="Use ungapped diagonal scoring during prefilter" help=""/>
                <param argument="--exact-kmer-matching" type="integer" min="0" max="1" value="0" label="Extract only exact k-mers for matching" help=""/>
                <param argument="--mask" type="select" label="Mask sequences in k-mer stage" help="">
                    <option value="0">Without low complexity masking</option>
                    <option value="1" selected="true">With low complexity masking</option>
                </param>
                <param argument="--mask-prob" type="float" min="0" value="0.9" label="Mask sequences if probablity is above threshold" help=""/>
                <param argument="--mask-lower-case" type="select" label="Mask lower case letters" help="">
                    <option value="0" selected="true">Include region</option>
                    <option value="1">Exclude region</option>
                </param>
                <param argument="--min-ungapped-score" type="integer" min="0" value="15" label="Accept only matches with ungapped alignment score above threshold" help=""/>
                <param argument="--spaced-kmer-mode" type="select" label="Spaced k-mer mode" help="">
                    <option value="0">Use consecutive positions in k-mers</option>
                    <option value="1" selected="true">Use spaced k-mers</option>
                </param>
            </section>
            <section name="align" title="Align">
                <param name="convertalis" type="boolean" checked="false" truevalue="1" falsevalue="0" label="Add backtrace string" help="Convert to alignments with mmseqs convertalis module (-a)"/>
                <param argument="--alignment-mode" type="select" label="Alignment mode : How to compute the alignment" help="" >
                    <option value="0">Automatic</option>
                    <option value="1" selected="true">Only score and end_pos</option>
                    <option value="2">Also start_pos and cov</option>
                    <option value="3">Also seq.id</option>
                    <option value="4">Only ungapped alignment</option>
                </param>
                <param argument="--alignment-output-mode" type="select" label="Alignment mode : How to compute the alignment" help="" >
                    <option value="0" selected="true">Automatic</option>
                    <option value="1">Only score and end_pos</option>
                    <option value="2">Also start_pos and cov</option>
                    <option value="3">Also seq.id</option>
                    <option value="4">Only ungapped alignment</option>
                    <option value="5">score only (output) cluster format</option>
                </param>
                <param argument="--wrapped-scoring" type="boolean" checked="false" truevalue="1" falsevalue="0" label="Double the (nucleotide) query sequence during the scoring process" help="Allow wrapped diagonal scoring around end and start"/>
                <param name="evalue" type="float" min="0" value="1" label="E-value threshold" help="List matches below this E-value (-e)"/>
                <param argument="--min-seq-id" type="float" min="0" max="1" value="0" label="Minimum sequence identity" help="List matches above this sequence identity for clustering"/>
                <param argument="--min-aln-len" type="integer" min="0" value="0" label="Minimum alignment length" help=""/>
                <param argument="--seq-id-mode" type="select" label="Sequence identity mode" help="" >
                    <option value="0" selected="true">Alignment length</option>
                    <option value="1">Shorter</option>
                    <option value="2">Longer sequence</option>
                </param>
                <param name="cov" type="float" min="0" value="0" label="List matches above this fraction of aligned (covered) residues" help="(-c)"/>
                <param argument="--cov-mode" type="select" label="Coverage mode" help="" >
                    <option value="0" selected="true">Coverage of query and target</option>
                    <option value="1">Coverage of target</option>
                    <option value="2">Coverage of query</option>
                    <option value="3">Target seq. length has to be at least x% of query length</option>
                    <option value="4">Query seq. length has to be at least x% of target length</option>
                    <option value="5">Short seq. needs to be at least x% of the other seq. length</option>
                </param>
                <param argument="--max-rejected" type="integer" min="0" value="5" label="Maximum rejected alignments before alignment calculation for a query is stopped" help=""/>
                <param argument="--max-accept" type="integer" min="0" value="30" label="Maximum accepted alignments before alignment calculation for a query is stopped" help=""/>
                <param argument="--score-bias" type="float" value="0" label="Score bias when computing Smith-Waterman alignment" help=""/>
                <param argument="--realign" type="boolean" checked="false" truevalue="1" falsevalue="0" label="Compute more conservative, shorter alignments" help="Scores and E-values not changed"/>
                <param argument="--realign-score-bias" type="float" value="-0.200" label="Additional bias when computing realignment" help=""/>
                <param argument="--realign-max-seqs" type="integer" min="0" value="2147483647" label="Maximum number of results to return in realignment" help=""/>
                <param argument="--corr-score-weight" type="float" value="0" label="Weight of backtrace correlation score that is added to the alignment score" help=""/>
                <conditional name="alph_type">
                    <param name="type" type="select" label="Alphabet type" help="" >
                        <option value="amino_acid" selected="true">Amino acid</option>
                        <option value="nucleotide">Nucleotide</option>
                    </param>
                    <when value="amino_acid"/>
                    <when value="nucleotide">
                        <param name="zdrop" type="integer" min="0" value="40" label="Maximal allowed difference between score values before alignment is truncated" help=""/>
                    </when>
                </conditional>
                <param argument="--exhaustive-search-filter" type="boolean" checked="false" truevalue="1" falsevalue="0" label="Filter result during search ?" help=""/>
            </section>
        </section>
        <section name="profile" title="Profile">
        </section>
    </inputs>
    <outputs>
    </outputs>
    <help><![CDATA[
**MMseqs2: ultra fast and sensitive sequence search and clustering suite**

MMseqs2 (Many-against-Many sequence searching) is a software suite to search and cluster huge protein and nucleotide sequence sets. 
MMseqs2 is open source GPL-licensed software implemented in C++ for Linux, MacOS, and (as beta version, via cygwin) Windows. 
The software is designed to run on multiple cores and servers and exhibits very good scalability. 
MMseqs2 can run 10000 times faster than BLAST. At 100 times its speed it achieves almost the same sensitivity. 
It can perform profile searches with the same sensitivity as PSI-BLAST at over 400 times its speed.

**Usage** 

* Convert FASTA/Q file(s) to MMseqs sequence DB format
    *mmseqs createdb <i:fastaFile1[.gz|.bz2]> ... <i:fastaFileN[.gz|.bz2]>|<i:stdin> <o:sequenceDB> [options]*

* Add taxonomic labels to sequence DB
    *mmseqs createtaxdb <i:sequenceDB> <tmpDir> [options]*

* Filter taxonomy sequence database
    *mmseqs filtertaxseqdb <i:taxSeqDB> <o:taxSeqDB> [options]*

* Taxonomy assignment by computing the lowest common ancestor of homologs
    *mmseqs taxonomy <i:queryDB> <i:targetDB> <o:taxaDB> <tmpDir> [options]*

* Convert result DB to tab-separated flat file
    *mmseqs createtsv <i:queryDB> [<i:targetDB>] <i:resultDB> <o:tsvFile> [options]*

* Create a taxonomy report in Kraken or Krona format
    *mmseqs taxonomyreport <i:seqTaxDB> <i:taxResultDB/resultDB/sequenceDB> <o:taxonomyReport> [options]*

By Martin Steinegger <martin.steinegger@snu.ac.kr> & Milot Mirdita <milot@mirdita.de> & Florian Breitwieser <florian.bw@gmail.com> & Eli Levy Karin <eli.levy.karin@gmail.com>

-----

**References**

- Steinegger M, Soding J: MMseqs2 enables sensitive protein sequence searching for the analysis of massive data sets. Nature Biotechnology, 35(11), 1026-1028 (2017)
- Mirdita M, Steinegger M, Breitwieser F, Soding J, Levy Karin E: Fast and sensitive taxonomic assignment to metagenomic contigs. Bioinformatics, btab184 (2021)
    ]]></help>
    <expand macro="citations"/>
</tool>