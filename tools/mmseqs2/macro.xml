<macros>
    <token name="@TOOL_VERSION@">17-b804f</token>
    <token name="@VERSION_SUFFIX@">0</token>
    <token name="@PROFILE@">25.0</token>
    <xml name="version_command">
        <version_command><![CDATA[mmseqs version]]></version_command>
    </xml>
    <xml name="requirements">
        <requirements>
            <requirement type="package" version="@TOOL_VERSION@">mmseqs2</requirement>
            <yield/>
        </requirements>
    </xml>
    <xml name="stdio">
        <stdio>
            <regex match="Failed to allocate" source="stderr" level="fatal_oom"/>
            <regex match="std::bad_alloc" source="stderr" level="fatal_oom"/>
            <regex match="Cannot allocate memory" source="stderr" level="fatal_oom"/>
        </stdio>
    </xml>
    <xml name="biotools">
        <xrefs>
            <xref type="bio.tools">MMseqs2</xref>
        </xrefs>
    </xml>
    <xml name="citations">
        <citations>
            <citation type="doi">10.1038/nbt.3988</citation>
            <citation type="doi">10.1101/079681</citation>
            <citation type="doi">10.1038/s41467-018-04964-5</citation>
            <citation type="doi">10.1093/bioinformatics/bty1057</citation>
            <citation type="doi">10.1101/2020.11.27.401018</citation>
            <citation type="doi">10.1093/bioinformatics/btab184</citation>
        </citations>
    </xml>

    <!-- ==================== Tokens for command blocks ==================== -->

    <token name="@CMD_THREADS@"><![CDATA[--threads "\${GALAXY_SLOTS:-1}"]]></token>

    <token name="@CMD_DBTYPE@"><![CDATA[
#if str($alph_type.dbtype) == "1"
    --comp-bias-corr-scale $alph_type.comp_bias_corr_scale
#elif str($alph_type.dbtype) == "2"
    --zdrop $alph_type.zdrop
#end if
    --dbtype $alph_type.dbtype
]]></token>

    <token name="@CMD_PREFILTER@"><![CDATA[
    --add-self-matches $prefilter.add_self_matches
    -k $prefilter.kmer_length
    --mask $prefilter.mask
    --mask-prob $prefilter.mask_prob
    --mask-lower-case $prefilter.mask_lower_case
    --mask-n-repeat $prefilter.mask_n_repeat
]]></token>

    <token name="@CMD_ALIGN@"><![CDATA[
    -a $align.convertalis
    --alignment-output-mode $align.alignment_output_mode
    --wrapped-scoring $align.wrapped_scoring
    --min-aln-len $align.min_aln_len
    --seq-id-mode $align.seq_id_mode
    --alt-ali $align.alt_ali
    --score-bias $align.score_bias
    --realign $align.realign
    --realign-score-bias $align.realign_score_bias
    --realign-max-seqs $align.realign_max_seqs
    --corr-score-weight $align.corr_score_weight
]]></token>

    <token name="@CMD_EXPERT@"><![CDATA[
    --filter-hits $expert.filter_hits
    --sort-results $expert.sort_results
]]></token>

    <token name="@CMD_SEARCH_COMMON@"><![CDATA[
    -s $prefilter.sensitivity
    --max-seqs $prefilter.max_seqs
    --split $prefilter.split
    --split-mode $prefilter.split_mode
    --diag-score $prefilter.diag_score
    --exact-kmer-matching $prefilter.exact_kmer_matching
    --min-ungapped-score $prefilter.min_ungapped_score
]]></token>

    <token name="@CMD_SEARCH_ALIGN@"><![CDATA[
    --alignment-mode $align.alignment_mode
    -e $align.evalue
    --min-seq-id $align.min_seq_id
    -c $align.cov
    --cov-mode $align.cov_mode
    --max-rejected $align.max_rejected
    --max-accept $align.max_accept
]]></token>

    <token name="@CMD_CLUSTERING@"><![CDATA[
    --cluster-mode $cluster.cluster_mode
    --max-iterations $cluster.max_iterations
    --similarity-type $cluster.similarity_type
]]></token>

    <token name="@CMD_KMERMATCHER@"><![CDATA[
    --cluster-weight-threshold $kmermatcher.cluster_weight_threshold
    --kmer-per-seq $kmermatcher.kmer_per_seq
    --hash-shift $kmermatcher.hash_shift
    --include-only-extendable $kmermatcher.include_only_extendable
    --ignore-multi-kmer $kmermatcher.ignore_multi_kmer
]]></token>

    <token name="@CMD_MISC@"><![CDATA[
    --rescore-mode $misc.rescore_mode
    --shuffle $misc.shuffle
    --id-offset $misc.id_offset
]]></token>

    <token name="@CMD_FORMAT_OUTPUT@"><![CDATA[
#if str($output_format.format_mode) == "0" or str($output_format.format_mode) == "2" or str($output_format.format_mode) == "4"
    #if str($output_format.format_fields).strip()
        --format-output '$output_format.format_fields'
    #end if
#end if
    --format-mode $output_format.format_mode
]]></token>

    <!-- ==================== Shared input parameter macros ==================== -->

    <xml name="dbtype_conditional">
        <conditional name="alph_type">
            <param argument="--dbtype" type="select" label="Input data type" help="">
                <option value="0" selected="true">Automatic</option>
                <option value="1">Amino acid</option>
                <option value="2">Nucleotides</option>
            </param>
            <when value="0"/>
            <when value="1">
                <param argument="--comp-bias-corr-scale" type="float" min="0" max="1" value="1" label="Scale composition bias correction" help=""/>
            </when>
            <when value="2">
                <param argument="--zdrop" type="integer" min="0" value="40" label="Maximal allowed difference between score values before alignment is truncated" help=""/>
            </when>
        </conditional>
    </xml>

    <xml name="dbtype_conditional_with_kmer_scale">
        <conditional name="alph_type">
            <param argument="--dbtype" type="select" label="Input data type" help="">
                <option value="0" selected="true">Automatic</option>
                <option value="1">Amino acid</option>
                <option value="2">Nucleotides</option>
            </param>
            <when value="0"/>
            <when value="1">
                <param argument="--comp-bias-corr-scale" type="float" min="0" max="1" value="1" label="Scale composition bias correction" help=""/>
                <param argument="--kmer-per-seq-scale" type="float" min="0" value="0.000" label="Scale k-mer per sequence based on sequence length" help=""/>
            </when>
            <when value="2">
                <param argument="--zdrop" type="integer" min="0" value="40" label="Maximal allowed difference between score values before alignment is truncated" help=""/>
                <param argument="--kmer-per-seq-scale" type="float" min="0" value="0.200" label="Scale k-mer per sequence based on sequence length" help=""/>
                <param argument="--adjust-kmer-len" type="boolean" checked="false" truevalue="1" falsevalue="0" label="Adjust k-mer length based on specificity" help=""/>
            </when>
        </conditional>
    </xml>

    <xml name="target_source_conditional">
        <conditional name="target_source">
            <param name="target_source_select" type="select" label="Target sequences source" help="">
                <option value="history" selected="true">FASTA file from history</option>
                <option value="cached">Cached MMseqs2 database</option>
            </param>
            <when value="history">
                <param name="target_fasta" type="data" format="fasta,fasta.gz" label="Target FASTA file" help=""/>
            </when>
            <when value="cached">
                <param name="mmseqs2_db_select" type="select" label="MMseqs2 database" help="">
                    <options from_data_table="mmseqs2_databases">
                        <validator message="No MMseqs2 database is available" type="no_options"/>
                    </options>
                </param>
            </when>
        </conditional>
    </xml>

    <xml name="sensitivity_param" tokens="default_value,help_text">
        <param argument="-s" name="sensitivity" type="float" min="1" max="7.5" value="@DEFAULT_VALUE@" label="Sensitivity" help="@HELP_TEXT@"/>
    </xml>

    <xml name="coverage_params" tokens="cov_default,cov_mode_default">
        <param argument="--cov-mode" type="select" label="Coverage mode" help="">
            <option value="0" selected="true">Coverage of query and target</option>
            <option value="1">Coverage of target</option>
            <option value="2">Coverage of query</option>
            <option value="3">Target seq. length has to be at least x% of query length</option>
            <option value="4">Query seq. length has to be at least x% of target length</option>
            <option value="5">Short seq. needs to be at least x% of the other seq. length</option>
        </param>
        <param argument="-c" name="cov" type="float" min="0" max="1" value="@COV_DEFAULT@" label="Minimum coverage fraction of aligned residues" help=""/>
    </xml>

    <xml name="sequence_identity_param" tokens="default_value">
        <param argument="--min-seq-id" type="float" min="0" max="1" value="@DEFAULT_VALUE@" label="Minimum sequence identity" help=""/>
    </xml>

    <xml name="evalue_param" tokens="default_value">
        <param argument="-e" name="evalue" type="float" min="0" value="@DEFAULT_VALUE@" label="E-value threshold" help="List matches below this E-value"/>
    </xml>

    <!-- ==================== Prefilter parameters ==================== -->

    <xml name="prefilter_common_parameters">
        <param argument="--add-self-matches" type="boolean" checked="false" truevalue="1" falsevalue="0" label="Artificially add entries of queries with themselves (for clustering)" help=""/>
        <param argument="-k" name="kmer_length" type="integer" min="0" value="0" label="k-mer length" help="(0: automatically set to optimum)"/>
        <param argument="--mask" type="select" label="Mask sequences in k-mer stage" help="">
            <option value="0">Without low complexity masking</option>
            <option value="1" selected="true">With low complexity masking</option>
        </param>
        <param argument="--mask-prob" type="float" min="0" value="0.9" label="Mask sequences if probability is above threshold" help=""/>
        <param argument="--mask-lower-case" type="select" label="Mask lower case letters" help="">
            <option value="0" selected="true">Include region</option>
            <option value="1">Exclude region</option>
        </param>
        <param argument="--mask-n-repeat" type="integer" min="0" value="0" label="Repeat letters that occur > threshold in a row" help=""/>
    </xml>

    <xml name="search_prefilter_parameters">
        <expand macro="sensitivity_param" default_value="5.7" help_text="1.0 faster; 4.0 fast; 7.5 sensitive"/>
        <param argument="--target-search-mode" type="select" label="Target search mode" help="">
            <option value="0" selected="true">Regular k-mer</option>
            <option value="1">Similar k-mer</option>
        </param>
        <param argument="--max-seqs" type="integer" min="0" value="300" label="Maximum results per query sequence allowed to pass the prefilter" help="Affects sensitivity"/>
        <param argument="--split" type="integer" min="0" value="0" label="Split input into N equally distributed chunks" help="0: set the best split automatically"/>
        <param argument="--split-mode" type="select" label="Split mode" help="">
            <option value="0">Split target db</option>
            <option value="1">Split query db</option>
            <option value="2" selected="true">Auto, depending on main memory</option>
        </param>
        <param argument="--diag-score" type="boolean" checked="true" truevalue="1" falsevalue="0" label="Use ungapped diagonal scoring during prefilter" help=""/>
        <param argument="--exact-kmer-matching" type="integer" min="0" max="1" value="0" label="Extract only exact k-mers for matching" help=""/>
        <param argument="--min-ungapped-score" type="integer" min="0" value="15" label="Accept only matches with ungapped alignment score above threshold" help=""/>
    </xml>

    <!-- ==================== Align parameters ==================== -->

    <xml name="align_common_parameters">
        <param argument="-a" name="convertalis" type="boolean" checked="false" truevalue="1" falsevalue="0" label="Add backtrace string" help="Convert to alignments with mmseqs convertalis module"/>
        <param argument="--alignment-output-mode" type="select" label="Alignment output mode" help="">
            <option value="0" selected="true">Automatic</option>
            <option value="1">Only score and end_pos</option>
            <option value="2">Also start_pos and cov</option>
            <option value="3">Also seq.id</option>
            <option value="4">Only ungapped alignment</option>
            <option value="5">Score only (output) cluster format</option>
        </param>
        <param argument="--wrapped-scoring" type="boolean" checked="false" truevalue="1" falsevalue="0" label="Double the (nucleotide) query sequence during the scoring process" help="Allow wrapped diagonal scoring around end and start"/>
        <param argument="--min-aln-len" type="integer" min="0" value="0" label="Minimum alignment length" help=""/>
        <param argument="--seq-id-mode" type="select" label="Sequence identity mode" help="">
            <option value="0" selected="true">Alignment length</option>
            <option value="1">Shorter</option>
            <option value="2">Longer sequence</option>
        </param>
        <param argument="--alt-ali" type="integer" min="0" value="0" label="Number of alternative alignments to show" help=""/>
        <param argument="--score-bias" type="float" value="0" label="Score bias when computing Smith-Waterman alignment" help=""/>
        <param argument="--realign" type="boolean" checked="false" truevalue="1" falsevalue="0" label="Compute more conservative, shorter alignments" help="Scores and E-values not changed"/>
        <param argument="--realign-score-bias" type="float" value="-0.200" label="Additional bias when computing realignment" help=""/>
        <param argument="--realign-max-seqs" type="integer" min="0" value="2147483647" label="Maximum number of results to return in realignment" help=""/>
        <param argument="--corr-score-weight" type="float" value="0" label="Weight of backtrace correlation score that is added to the alignment score" help=""/>
    </xml>

    <xml name="search_align_parameters" tokens="evalue_default,min_seq_id_default,cov_default,max_rejected_default,max_accept_default">
        <param argument="--alignment-mode" type="select" label="Alignment mode" help="">
            <option value="0">Automatic</option>
            <option value="1">Only score and end_pos</option>
            <option value="2">Also start_pos and cov</option>
            <option value="3">Also seq.id</option>
            <option value="4">Only ungapped alignment</option>
        </param>
        <expand macro="evalue_param" default_value="@EVALUE_DEFAULT@"/>
        <expand macro="sequence_identity_param" default_value="@MIN_SEQ_ID_DEFAULT@"/>
        <expand macro="coverage_params" cov_default="@COV_DEFAULT@" cov_mode_default="0"/>
        <param argument="--max-rejected" type="integer" min="0" value="@MAX_REJECTED_DEFAULT@" label="Maximum rejected alignments before alignment calculation for a query is stopped" help=""/>
        <param argument="--max-accept" type="integer" min="0" value="@MAX_ACCEPT_DEFAULT@" label="Maximum accepted alignments before alignment calculation for a query is stopped" help=""/>
    </xml>

    <!-- ==================== Clustering parameters ==================== -->

    <xml name="clustering_parameters">
        <param argument="--cluster-mode" type="select" label="Cluster mode" help="">
            <option value="0" selected="true">Set-Cover (greedy)</option>
            <option value="1">Connected component (BLASTclust)</option>
            <option value="2">Greedy clustering by sequence length (CDHIT)</option>
        </param>
        <param argument="--max-iterations" type="integer" min="0" value="1000" label="Maximum depth of breadth first search in connected component clustering" help=""/>
        <param argument="--similarity-type" type="select" label="Type of score used for clustering" help="">
            <option value="1">Alignment score</option>
            <option value="2" selected="true">Sequence identity</option>
        </param>
    </xml>

    <!-- ==================== K-mer matcher parameters ==================== -->

    <xml name="kmermatcher_parameters">
        <param argument="--cluster-weight-threshold" type="float" min="0" value="0.900" label="Weight threshold used for cluster priorization" help=""/>
        <param argument="--kmer-per-seq" type="integer" min="0" value="21" label="Number of k-mers per sequence" help=""/>
        <param argument="--hash-shift" type="integer" min="0" value="67" label="Shift k-mer hash initialization" help=""/>
        <param argument="--include-only-extendable" type="boolean" checked="false" truevalue="1" falsevalue="0" label="Include only extendable" help=""/>
        <param argument="--ignore-multi-kmer" type="boolean" checked="false" truevalue="1" falsevalue="0" label="Skip k-mers occurring multiple times (>=2)" help=""/>
    </xml>

    <!-- ==================== Misc parameters ==================== -->

    <xml name="misc_parameters">
        <param argument="--rescore-mode" type="select" label="Rescore diagonals with" help="">
            <option value="0" selected="true">Hamming distance</option>
            <option value="1">Local alignment (score only)</option>
            <option value="2">Local alignment</option>
            <option value="3">Global alignment</option>
            <option value="4">Longest alignment fulfilling window quality criterion</option>
        </param>
        <param argument="--shuffle" type="boolean" checked="true" truevalue="1" falsevalue="0" label="Shuffle input database" help=""/>
        <param argument="--id-offset" type="integer" min="0" value="0" label="Numeric ids in index file are offset by this value" help=""/>
    </xml>

    <xml name="common_section">
        <section name="common" title="Common">
            <param argument="--max-seq-len" type="integer" min="0" value="65535" label="Maximum sequence length" help=""/>
        </section>
    </xml>

    <xml name="expert_common_parameters">
        <param argument="--filter-hits" type="boolean" checked="false" truevalue="1" falsevalue="0" label="Filter hits by seq.id. and coverage" help=""/>
        <param argument="--sort-results" type="select" label="Sort results" help="">
            <option value="0" selected="true">No sorting</option>
            <option value="1">Sort by E-value (Alignment) or seq.id. (Hamming)</option>
        </param>
    </xml>

    <!-- ==================== Search type macros ==================== -->

    <xml name="search_type_aa">
        <param argument="--search-type" type="select" label="Search type" help="">
            <option value="0" selected="true">Auto</option>
            <option value="1">Amino acid</option>
            <option value="2">Translated</option>
            <option value="3">Nucleotide</option>
            <option value="4">Translated nucleotide alignment</option>
        </param>
    </xml>
    <xml name="search_type_nt">
        <param argument="--search-type" type="select" label="Search type" help="">
            <option value="2">Translated</option>
            <option value="3" selected="true">Nucleotide</option>
            <option value="4">Translated nucleotide alignment</option>
        </param>
    </xml>

    <!-- ==================== Output format macros ==================== -->

    <xml name="output_format_section">
        <section name="output_format" title="Output format">
            <param argument="--format-mode" type="select" label="Output format" help="">
                <option value="0" selected="true">BLAST-TAB</option>
                <option value="1">SAM</option>
                <option value="2">BLAST-TAB with query/target length</option>
                <option value="3">Pretty HTML</option>
                <option value="4">BLAST-TAB with column headers</option>
            </param>
            <param argument="--format-output" name="format_fields" type="text" value="" label="Custom output columns" help="Comma-separated list of output columns. Leave empty for default (query,target,fident,alnlen,mismatch,gapopen,qstart,qend,tstart,tend,evalue,bits). Available: query, target, evalue, gapopen, pident, fident, nident, qstart, qend, qlen, tstart, tend, tlen, alnlen, raw, bits, cigar, qseq, tseq, qheader, theader, qaln, taln, qframe, tframe, mismatch, qcov, tcov, taxid, taxname, taxlineage, qset, qsetid, tset, tsetid, qorfstart, qorfend, torfstart, torfend, ppos">
                <validator type="regex" message="Must be a comma-separated list of valid field names or empty">^$|^[a-z,_]+$</validator>
            </param>
        </section>
    </xml>

    <!-- ==================== Clustering output selection ==================== -->

    <xml name="clustering_output_selection">
        <section name="output_files" title="Selection of the output files">
            <param name="output_selection" type="select" min="1" multiple="true" label="Output files selection">
                <option value="file_rep_seq" selected="true">Representative sequences in FASTA</option>
                <option value="file_all_seq" selected="true">FASTA-like per cluster</option>
                <option value="file_cluster_tsv" selected="true">Adjacency list in TSV</option>
                <validator type="no_options" message="Select at least one output file"/>
            </param>
        </section>
    </xml>

    <xml name="clustering_outputs">
        <data name="output_rep_seq" format="fasta" from_work_dir="result_rep_seq.fasta" label="${tool.name} on ${on_string}: Representative sequences">
            <filter>output_files['output_selection'] and "file_rep_seq" in output_files['output_selection']</filter>
        </data>
        <data name="output_all_seq" format="fasta" from_work_dir="result_all_seqs.fasta" label="${tool.name} on ${on_string}: FASTA-like per cluster">
            <filter>output_files['output_selection'] and "file_all_seq" in output_files['output_selection']</filter>
        </data>
        <data name="output_cluster" format="tabular" from_work_dir="result_cluster.tsv" label="${tool.name} on ${on_string}: Adjacency list">
            <filter>output_files['output_selection'] and "file_cluster_tsv" in output_files['output_selection']</filter>
        </data>
    </xml>

    <!-- ==================== Profile parameters (for taxonomy/search) ==================== -->

    <xml name="profile_parameters">
        <param argument="--mask-profile" type="boolean" checked="true" truevalue="1" falsevalue="0" label="Mask query sequence of profile using tantan" help=""/>
        <param argument="--e-profile" type="float" min="0" value="1e-03" label="Include sequences matches with E-value threshold into the profile" help=""/>
        <param argument="--wg" type="boolean" checked="false" truevalue="1" falsevalue="0" label="Use global sequence weighting for profile calculation" help=""/>
        <param argument="--filter-msa" type="boolean" checked="true" truevalue="1" falsevalue="0" label="Filter MSA" help=""/>
        <param argument="--filter-min-enable" type="integer" min="0" value="0" label="Only filter MSAs with more than N sequences, 0 always filters" help=""/>
        <param argument="--max-seq-id" type="float" min="0" max="1" value="0.9" label="Reduce redundancy of output MSA using max. pairwise sequence identity" help=""/>
        <param argument="--qid" type="text" value="0" label="Reduce diversity of output MSAs using min. seq. identity with query sequences [0.0,1.0]" help="Alternatively, can be a list of multiple thresholds: e.g. 0.15,0.30,0.50"/>
        <param argument="--qsc" type="float" min="-50" max="100" value="-20" label="Reduce diversity of output MSAs using min. score per aligned residue with query sequences" help=""/>
        <param argument="--cov" type="float" min="0" max="1" value="0" label="Filter output MSAs using min. fraction of query residues covered by matched sequences" help=""/>
        <param argument="--diff" type="integer" min="0" value="1000" label="Filter MSAs by selecting most diverse set of sequences, keeping at least this many seqs in each MSA block of length 50" help=""/>
        <param argument="--pseudo-cnt-mode" type="select" label="Pseudo count mode" help="">
            <option value="0" selected="true">Substitution-matrix</option>
            <option value="1">Context-specific pseudocounts</option>
        </param>
        <param argument="--exhaustive-search" type="boolean" checked="false" truevalue="1" falsevalue="0" label="Exhaustive search" help=""/>
        <param argument="--lca-search" type="boolean" checked="false" truevalue="1" falsevalue="0" label="Efficient search for LCA candidates" help=""/>
    </xml>

    <!-- ==================== Taxonomy-specific parameters ==================== -->

    <xml name="taxonomy_misc_parameters">
        <param argument="--orf-filter-e" type="float" min="0" value="1.000E+02" label="E-value threshold used for query ORF prefiltering" help=""/>
        <param argument="--orf-filter-s" type="float" min="0" value="2" label="Sensitivity used for query ORF prefiltering" help=""/>
        <param argument="--lca-mode" type="select" label="LCA mode" help="">
            <option value="1">Single search LCA</option>
            <option value="3" selected="true">Approximate 2bLCA</option>
            <option value="4">Top hit</option>
        </param>
        <param argument="--tax-output-mode" type="select" label="Taxonomy output mode" help="">
            <option value="0" selected="true">Output LCA</option>
            <option value="1">Output alignment</option>
            <option value="2">Output both</option>
        </param>
        <param argument="--majority" type="float" min="0" value="0.5" label="Minimal fraction of agreement among taxonomically assigned sequences of a set" help=""/>
        <param argument="--vote-mode" type="select" label="Mode of assigning weights to compute majority" help="">
            <option value="0">Uniform</option>
            <option value="1" selected="true">Minus log E-value</option>
            <option value="2">Score</option>
        </param>
        <param argument="--tax-lineage" type="select" label="Taxonomy lineage" help="">
            <option value="0" selected="true">Don't show</option>
            <option value="1">Add all lineage names</option>
            <option value="2">Add all lineage taxids</option>
        </param>
        <param argument="--blacklist" type="text" value="" label="Comma separated list of ignored taxa in LCA computation" help=""/>
        <param argument="--taxon-list" type="text" value="" label="Taxonomy ID, possibly multiple values separated by ','" help=""/>
    </xml>

    <!-- ==================== ORF extraction parameters ==================== -->

    <xml name="orf_extraction_parameters">
        <param argument="--allow-deletion" type="boolean" checked="false" truevalue="1" falsevalue="0" label="Allow deletions in a MSA" help=""/>
        <param argument="--min-length" type="integer" min="0" value="30" label="Minimum codon number in open reading frames" help=""/>
        <param argument="--max-length" type="integer" min="0" value="32734" label="Maximum codon number in open reading frames" help=""/>
        <param argument="--max-gaps" type="integer" min="0" value="2147483647" label="Maximum number of codons with gaps or unknown residues before an open reading frame is rejected" help=""/>
        <param argument="--contig-start-mode" type="select" label="Contig start can be" help="">
            <option value="0">Incomplete</option>
            <option value="1">Complete</option>
            <option value="2" selected="true">Both</option>
        </param>
        <param argument="--contig-end-mode" type="select" label="Contig end can be" help="">
            <option value="0">Incomplete</option>
            <option value="1">Complete</option>
            <option value="2" selected="true">Both</option>
        </param>
        <param argument="--orf-start-mode" type="select" label="ORF fragment can be" help="">
            <option value="0">From start to stop</option>
            <option value="1" selected="true">From any to stop</option>
            <option value="2">From last encountered start to stop (no start in the middle)</option>
        </param>
        <param argument="--forward-frames" type="text" value="1,2,3" label="Comma-separated list of frames on the forward strand to be extracted" help=""/>
        <param argument="--reverse-frames" type="text" value="1,2,3" label="Comma-separated list of frames on the reverse strand to be extracted" help=""/>
        <param argument="--translation-table" type="select" label="Translation table" help="">
            <option value="1" selected="true">Canonical</option>
            <option value="2">The Vertebrate Mitochondrial Code</option>
            <option value="3">The Yeast Mitochondrial Code</option>
            <option value="4">The Mold, Protozoan, and Coelenterate Mitochondrial Code and the Mycoplasma/Spiroplasma Code</option>
            <option value="5">The Invertebrate Mitochondrial Code</option>
            <option value="6">The Ciliate, Dasycladacean and Hexamita Nuclear Code</option>
            <option value="9">The Echinoderm and Flatworm Mitochondrial Code</option>
            <option value="10">The Euplotid Nuclear Code</option>
            <option value="11">The Bacterial, Archaeal and Plant Plastid Code</option>
            <option value="12">The Alternative Yeast Nuclear Code</option>
            <option value="13">The Ascidian Mitochondrial Code</option>
            <option value="14">The Alternative Flatworm Mitochondrial Code</option>
            <option value="15">Blepharisma Nuclear Code</option>
            <option value="16">Chlorophycean Mitochondrial Code</option>
            <option value="21">Trematode Mitochondrial Code</option>
            <option value="22">Scenedesmus obliquus Mitochondrial Code</option>
            <option value="23">Thraustochytrium Mitochondrial Code</option>
            <option value="24">Rhabdopleuridae Mitochondrial Code</option>
            <option value="25">Candidate Division SR1 and Gracilibacteria Code</option>
            <option value="26">Pachysolen tannophilus Nuclear Code</option>
            <option value="27">Karyorelict Nuclear Code</option>
            <option value="28">Condylostoma Nuclear Code</option>
            <option value="29">Mesodinium Nuclear Code</option>
            <option value="30">Peritrich Nuclear Code</option>
            <option value="31">Blastocrithidia Nuclear Code</option>
        </param>
        <param argument="--translate" type="boolean" checked="false" truevalue="1" falsevalue="0" label="Translate ORF to amino acid" help=""/>
        <param argument="--use-all-table-starts" type="boolean" checked="false" truevalue="1" falsevalue="0" label="Use all alternatives for a start codon in the genetic table, if false - only ATG (AUG)" help=""/>
    </xml>

    <!-- ==================== createtsv parameters ==================== -->

    <xml name="createtsv_parameters">
        <param argument="--first-seq-as-repr" type="boolean" checked="false" truevalue="1" falsevalue="0" label="Use the first sequence of the clustering result as representative sequence" help=""/>
        <param argument="--target-column" type="integer" min="0" value="1" label="Select a target column, 0 if no target id exists" help=""/>
        <param argument="--full-header" type="boolean" checked="false" truevalue="1" falsevalue="0" label="Replace DB ID by its corresponding Full Header" help=""/>
        <param argument="--idx-seq-src" type="select" label="Index sequences source" help="">
            <option value="0" selected="true">Auto</option>
            <option value="1">Split/translated sequences</option>
            <option value="2">Input sequences</option>
        </param>
    </xml>

    <!-- ==================== Help text macros ==================== -->

    <token name="@HELP_HEADER@"><![CDATA[
**MMseqs2: ultra fast and sensitive sequence search and clustering suite**

MMseqs2 (Many-against-Many sequence searching) is a software suite to search and cluster huge protein and nucleotide sequence sets.
MMseqs2 is open source GPL-licensed software implemented in C++ for Linux, MacOS, and (as beta version, via cygwin) Windows.
The software is designed to run on multiple cores and servers and exhibits very good scalability.
MMseqs2 can run 10000 times faster than BLAST. At 100 times its speed it achieves almost the same sensitivity.
It can perform profile searches with the same sensitivity as PSI-BLAST at over 400 times its speed.
]]></token>

    <token name="@HELP_FOOTER@"><![CDATA[

-----

More information is available at https://github.com/soedinglab/MMseqs2
]]></token>

</macros>
