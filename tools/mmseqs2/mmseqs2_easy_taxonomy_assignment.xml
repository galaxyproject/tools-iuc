<tool id="mmseqs2_easy_taxonomy_assignment" name="MMseqs2 Easy Taxonomy Assignments" version="@TOOL_VERSION@+galaxy@VERSION_SUFFIX@" profile="@PROFILE@">
    <description>
        Assigns taxonomic labels to sequences by comparing them to a reference database and identifying the lowest common ancestor
    </description>
    <macros>
        <import>macro.xml</import>
    </macros>
    <expand macro="biotools"/>
    <expand macro="requirements"/>
    <expand macro="version_command"/>
    <command detect_errors="exit_code"><![CDATA[
mmseqs easy-taxonomy
    '$input_fasta'
    '$mmseqs2_db_select.fields.path'
    'result'
    'tmp'
    #if str($alph_type.type) == "amino_acid"
        --sub-mat 'blosum62.out'
        --alph-size $alph_type.alph_size_amino_acid
        --comp-bias-corr-scale $alph_type.comp_bias_corr_scale
        --seed-sub-mat 'VTML80.out'
        --gap-open 11
        --gap-extend 1
    #elif str($alph_type.type) == "nucleotide"
        --sub-mat 'nucleotide.out'
        --alph-size $alph_type.alph_size_nucleotide
        --seed-sub-mat 'nucleotide.out'
        --gap-open 5
        --gap-extend 2
        --zdrop $alph_type.zdrop
    #end if
    ##Pre-filter options
    --add-self-matches $prefilter.add_self_matches
    -s $prefilter.sensitivity
    -k $prefilter.kmer_length
    --target-search-mode $prefilter.target_search_mode
    ##--k-score TWIN                   k-mer threshold for generating similar k-mer lists [seq:2147483647,prof:2147483647]
    --max-seqs $prefilter.max_seqs
    --split $prefilter.split
    --split-mode $prefilter.split_mode
    ##--split-memory-limit BYTE        Set max memory per split. E.g. 800B, 5K, 10M, 1G. Default (0) to all available system memory [0]
    --diag-score $prefilter.diag_score
    --exact-kmer-matching $prefilter.exact_kmer_matching
    --mask $prefilter.mask
    --mask-prob $prefilter.mask_prob
    --mask-lower-case $prefilter.mask_lower_case
    --min-ungapped-score $prefilter.min_ungapped_score
    --spaced-kmer-mode $prefilter.spaced_kmer_mode
    ##--spaced-kmer-pattern STR        User-specified spaced k-mer pattern []
    ##--local-tmp STR                  Path where some of the temporary files will be created []
    ##--disk-space-limit BYTE          Set max disk space to use for reverse profile searches. E.g. 800B, 5K, 10M, 1G. Default (0) to all available disk space in the temp folder [0]
    
    ##Align options
    -a $align.convertalis
    ##The next 2 parameters seems to be the same
    --alignment-mode $align.alignment_mode 
    --alignment-output-mode $align.alignment_output_mode 
    --wrapped-scoring $align.wrapped_scoring
    -e $align.evalue
    --min-seq-id $align.min_seq_id
    --min-aln-len $align.min_aln_len
    --seq-id-mode $align.seq_id_mode
    --alt-ali $align.alt_ali
    -c $align.cov
    --cov-mode $align.cov_mode
    --max-rejected $align.max_rejected
    --max-accept $align.max_accept
    --score-bias $align.score_bias
    --realign $align.realign
    --realign-score-bias $align.realign_score_bias
    --realign-max-seqs $align.realign_max_seqs
    --corr-score-weight $align.corr_score_weight
    --exhaustive-search-filter $align.exhaustive_search_filter

    ##Profile options
    ##--pca                            Pseudo count admixture strength []
    ##--pcb                            Pseudo counts: Neff at half of maximum admixture (range 0.0-inf) []
    --mask-profile $profile.mask_profile
    --e-profile $profile.e_profile
    --wg $profile.wg
    --filter-msa $profile.filter_msa
    --filter-min-enable $profile.filter_min_enable
    --max-seq-id $profile.max_seq_id
    --qid $profile.qid
    --qsc $profile.qsc
    --cov $profile.cov
    --diff $profile.diff
    --pseudo-cnt-mode $profile.pseudo_cnt_mode
    --exhaustive-search $profile.exhaustive_search
    --lca-search $profile.lca_search

    ##Misc options
    ##--orf-filter INT                 Prefilter query ORFs with non-selective search
    ##                             Only used during nucleotide-vs-protein classification
    ##                             NOTE: Consider disabling when classifying short reads [1]
    --orf-filter-e $misc.orf_filter_e
    --orf-filter-s $misc.orf_filter_s
    --lca-mode $misc.lca_mode
    --majority $misc.majority
    --vote-mode $misc.vote_mode
    ##--lca-ranks STR                  Add column with specified ranks (',' separated) []
    --tax-lineage $misc.tax_lineage
    --blacklist $misc.blacklist
    --rescore-mode $misc.rescore_mode
    --allow-deletion $misc.allow_deletion
    --min-length $misc.min_length
    --max-length $misc.max_length
    --max-gaps $misc.max_gaps
    --contig-start-mode $misc.contig_start_mode
    --contig-end-mode $misc.contig_end_mode
    --orf-start-mode $misc.orf_start_mode
    --forward-frames $misc.forward_frames
    --reverse-frames $misc.reverse_frames
    --translation-table $misc.translation_table
    --translate $misc.translate
    --use-all-table-starts $misc.use_all_table_starts
    --id-offset $misc.id_offset
    --add-orf-stop $misc.add_orf_stop
    --sequence-overlap $misc.sequence_overlap
    --sequence-split-mode $misc.sequence_split_mode
    --headers-split-mode $misc.headers_split_mode
    --search-type $misc.search_type
    --prefilter-mode $misc.prefilter_mode
    --report-mode $report_mode
    --format-mode $misc.out_format.format_mode
    #if str($misc.out_format.format_mode) == "0"
        --format-output $misc.out_format.format_output
    #elif str($misc.out_format.format_mode) == "4"
        --format-output $misc.out_format.format_output
    #end if
    --dbtype $misc.dbtype
    --shuffle $misc.shuffle
    --createdb-mode $misc.createdb_mode

    ##Common options
    ##--compressed INT                 Write compressed output [0]
    --threads "\${GALAXY_SLOTS:-1}"
    ##-v INT                           Verbosity level: 0: quiet, 1: +errors, 2: +warnings, 3: +info [3]
    --max-seq-len $common.max_seq_len
    ##--db-load-mode INT               Database preload mode 0: auto, 1: fread, 2: mmap, 3: mmap+touch [0]
    ##--mpi-runner STR                 Use MPI on compute cluster with this MPI command (e.g. "mpirun -np 42") []
    ##--force-reuse BOOL               Reuse tmp filse in tmp/latest folder ignoring parameters and version changes [0]
    ##--remove-tmp-files BOOL          Delete temporary files [0]

    ##Expert options
    --filter-hits $expert.filter_hits
    --sort-results $expert.sort_results
    ##--create-lookup INT              Create database lookup file (can be very large) [0]
    --chain-alignments $expert.chain_alignments
    --merge-query $expert.merge_query
    ##--strand INT                     Strand selection only works for DNA/DNA search 0: reverse, 1: forward, 2: both [1]
    ##--db-output BOOL                 Return a result DB instead of a text file [0]
    ##--write-lookup INT               write .lookup file containing mapping from internal id, fasta id and file number
    ]]></command>
    <inputs>
        <param name="input_fasta" type="data" format="fasta,fasta.gz" label="Input fasta file" help="" />
        <param name="mmseqs2_db_select" type="select" label="MMseqs2 databases">
            <options from_data_table="mmseqs2_aminoacid_taxonomy_databases">
                <validator message="No mmseqs2 database is available" type="no_options"/>
            </options>
        </param>
        <conditional name="alph_type">
            <param name="type" type="select" label="Alphabet type" help="" >
                <option value="amino_acid" selected="true">Amino acid</option>
                <option value="nucleotide">Nucleotide</option>
            </param>
            <when value="amino_acid">
                <param name="alph_size_amino_acid" type="integer" min="2" max="21" value="21" label="Alphabet size" help=""/>
                <param argument="--comp-bias-corr-scale" type="float" min="0" max="1" value="1" label="Scale composition bias correction" help=""/>
            </when>
            <when value="nucleotide">
                <param name="alph_size_nucleotide" type="integer" min="2" max="5" value="5" label="Alphabet size" help=""/>
                <param name="zdrop" type="integer" min="0" value="40" label="Maximal allowed difference between score values before alignment is truncated" help=""/>
            </when>
        </conditional>
        <param argument="--report-mode" type="select" label="Report mode" help="" >
                <option value="0" selected="true">Kraken</option>
                <option value="1">Krona</option>
        </param>
        <section name="prefilter" title="Pre-filter">
            <param argument="--add-self-matches" type="boolean" checked="false" truevalue="1" falsevalue="0" label="Artificially add entries of queries with themselves (for clustering)" help=""/>
            <param name="sensitivity" type="float" min="0" max="7.5" value="2" label="Sensitivity" help="1.0 faster; 4.0 fast; 7.5 sensitive"/>
            <param name="kmer_length" type="integer" min="0" value="0" label="k-mer length" help="(0: automatically set to optimum)"/>
            <param argument="--target-search-mode" type="select" label="Target search mode" help="" >
                <option value="0" selected="true">Regular k-mer</option>
                <option value="1">Similar k-mer</option>
            </param>
            <param argument="--max-seqs" type="integer" min="0" value="300" label="Maximum results per query sequence allowed to pass the prefilter" help="Affects sensitivity"/>
            <param argument="--split" type="integer" min="0" value="0" label="Split input into N equally distributed chunks" help="0: set the best split automatically"/>            
            <param argument="--split-mode" type="select" label="Split mode" help="" >
                <option value="0">Split target db</option>
                <option value="1">Split query db</option>
                <option value="2" selected="true">Auto, depending on main memory</option>
            </param>
            <param argument="--diag-score" type="boolean" checked="true" truevalue="1" falsevalue="0" label="Use ungapped diagonal scoring during prefilter" help=""/>
            <param argument="--exact-kmer-matching" type="integer" min="0" max="1" value="0" label="Extract only exact k-mers for matching" help=""/>
            <param argument="--mask" type="select" label="Mask sequences in k-mer stage" help="">
                <option value="0">Without low complexity masking</option>
                <option value="1" selected="true">With low complexity masking</option>
            </param>
            <param argument="--mask-prob" type="float" min="0" value="0.9" label="Mask sequences if probablity is above threshold" help=""/>
            <param argument="--mask-lower-case" type="select" label="Mask lower case letters" help="">
                <option value="0" selected="true">Include region</option>
                <option value="1">Exclude region</option>
            </param>
            <param argument="--min-ungapped-score" type="integer" min="0" value="15" label="Accept only matches with ungapped alignment score above threshold" help=""/>
            <param argument="--spaced-kmer-mode" type="select" label="Spaced k-mer mode" help="">
                <option value="0">Use consecutive positions in k-mers</option>
                <option value="1" selected="true">Use spaced k-mers</option>
            </param>
        </section>
        <section name="align" title="Align">
            <param name="convertalis" type="boolean" checked="false" truevalue="1" falsevalue="0" label="Add backtrace string" help="Convert to alignments with mmseqs convertalis module (-a)"/>
            <param argument="--alignment-mode" type="select" label="Alignment mode : How to compute the alignment" help="" >
                <option value="0">Automatic</option>
                <option value="1" selected="true">Only score and end_pos</option>
                <option value="2">Also start_pos and cov</option>
                <option value="3">Also seq.id</option>
                <option value="4">Only ungapped alignment</option>
            </param>
            <param argument="--alignment-output-mode" type="select" label="Alignment mode : How to compute the alignment" help="" >
                <option value="0" selected="true">Automatic</option>
                <option value="1">Only score and end_pos</option>
                <option value="2">Also start_pos and cov</option>
                <option value="3">Also seq.id</option>
                <option value="4">Only ungapped alignment</option>
                <option value="5">score only (output) cluster format</option>
            </param>
            <param argument="--wrapped-scoring" type="boolean" checked="false" truevalue="1" falsevalue="0" label="Double the (nucleotide) query sequence during the scoring process" help="Allow wrapped diagonal scoring around end and start"/>
            <param name="evalue" type="float" min="0" value="1" label="E-value threshold" help="List matches below this E-value (-e)"/>
            <param argument="--min-seq-id" type="float" min="0" max="1" value="0" label="Minimum sequence identity" help="List matches above this sequence identity for clustering"/>
            <param argument="--min-aln-len" type="integer" min="0" value="0" label="Minimum alignment length" help=""/>
            <param argument="--seq-id-mode" type="select" label="Sequence identity mode" help="" >
                <option value="0" selected="true">Alignment length</option>
                <option value="1">Shorter</option>
                <option value="2">Longer sequence</option>
            </param>
            <param argument="--alt-ali" type="integer" min="0" value="0" label="Show up to this many alternative alignments" help=""/>
            <param name="cov" type="float" min="0" value="0" label="List matches above this fraction of aligned (covered) residues" help="(-c)"/>
            <param argument="--cov-mode" type="select" label="Coverage mode" help="" >
                <option value="0" selected="true">Coverage of query and target</option>
                <option value="1">Coverage of target</option>
                <option value="2">Coverage of query</option>
                <option value="3">Target seq. length has to be at least x% of query length</option>
                <option value="4">Query seq. length has to be at least x% of target length</option>
                <option value="5">Short seq. needs to be at least x% of the other seq. length</option>
            </param>
            <param argument="--max-rejected" type="integer" min="0" value="5" label="Maximum rejected alignments before alignment calculation for a query is stopped" help=""/>
            <param argument="--max-accept" type="integer" min="0" value="30" label="Maximum accepted alignments before alignment calculation for a query is stopped" help=""/>
            <param argument="--score-bias" type="float" value="0" label="Score bias when computing Smith-Waterman alignment" help=""/>
            <param argument="--realign" type="boolean" checked="false" truevalue="1" falsevalue="0" label="Compute more conservative, shorter alignments" help="Scores and E-values not changed"/>
            <param argument="--realign-score-bias" type="float" value="-0.200" label="Additional bias when computing realignment" help=""/>
            <param argument="--realign-max-seqs" type="integer" min="0" value="2147483647" label="Maximum number of results to return in realignment" help=""/>
            <param argument="--corr-score-weight" type="float" value="0" label="Weight of backtrace correlation score that is added to the alignment score" help=""/>
            <param argument="--exhaustive-search-filter" type="boolean" checked="false" truevalue="1" falsevalue="0" label="Filter result during search ?" help=""/>
        </section>
        <section name="profile" title="Profile">
            <param argument="--mask-profile" type="boolean" checked="true" truevalue="1" falsevalue="0" label="Mask query sequence of profile using tantan" help=""/>
            <param argument="--e-profile" type="float" min="0" value="1e-03" label="Include sequences matches with inf E-value threshold into the profile" help=""/>
            <param argument="--wg" type="boolean" checked="false" truevalue="1" falsevalue="0" label="Use global sequence weighting for profile calculation" help=""/>
            <param argument="--filter-msa" type="boolean" checked="true" truevalue="1" falsevalue="0" label="Filter MSA" help=""/>
            <param argument="--filter-min-enable" type="integer" min="0" value="0" label="Only filter MSAs with more than N sequences, 0 always filters" help=""/>
            <param argument="--max-seq-id" type="float" min="0" max="1" value="0.9" label="Reduce redundancy of output MSA using max. pairwise sequence identity" help=""/>
            <param argument="--qid" type="text" value="0" label="Reduce diversity of output MSAs using min.seq. identity with query sequences [0.0,1.0]" help="Alternatively, can be a list of multiple thresholds:
                                E.g.: 0.15,0.30,0.50 to defines filter buckets of ]0.15-0.30] and ]0.30-0.50]"/>
            <param argument="--qsc" type="float" min="-50" max="100" value="-20" label="Reduce diversity of output MSAs using min. score per aligned residue with query sequences" help=""/>
            <param argument="--cov" type="float" min="0" max="1" value="0" label="Filter output MSAs using min. fraction of query residues covered by matched sequences" help=""/>
            <param argument="--diff" type="integer" min="0" value="1000" label="Filter MSAs by selecting most diverse set of sequences, keeping at least this many seqs in each MSA block of length 50" help=""/>
            <param argument="--pseudo-cnt-mode" type="select" label="Pseudo count mode" help="" >
                <option value="0" selected="true">Substitution-matrix</option>
                <option value="1">Context-specific pseudocounts</option>
            </param>
            <param argument="--exhaustive-search" type="boolean" checked="false" truevalue="1" falsevalue="0" label="Exhaustive search" help=""/>
            <param argument="--lca-search" type="boolean" checked="false" truevalue="1" falsevalue="0" label="Efficient search for LCA candidates" help=""/>
        </section>
        <section name="misc" title="Misc">
            <param argument="--orf-filter-e" type="float" min="0" value="1.000E+02" label="E-value threshold used for query ORF prefiltering" help=""/>
            <param argument="--orf-filter-s" type="float" min="0" value="2" label="Sensitivity used for query ORF prefiltering" help=""/>
            <param argument="--lca-mode" type="select" label="LCA mode" help="" >
                <option value="1">Single search LCA</option>
                <option value="3" selected="true">Approximate 2bLCA</option>
                <option value="4">Top hit</option>
            </param>
            <param argument="--majority" type="float" min="0" value="0.5" label="Minimal fraction of agreement among taxonomically assigned sequences of a set" help=""/>
            <param argument="--vote-mode" type="select" label="Mode of assigning weights to compute majority" help="" >
                <option value="0">Uniform</option>
                <option value="1" selected="true">Minus log E-value</option>
                <option value="2">Score</option>
            </param>
            <param argument="--tax-lineage" type="select" label="Taxonomy lineage" help="" >
                <option value="0" selected="true">Don't show</option>
                <option value="1">Add all lineage names</option>
                <option value="2">Add all lineage taxids</option>
            </param>
            <param argument="--blacklist" type="text" value="" label="Comma separated list of ignored taxa in LCA computation" help=""/>
            <param argument="--rescore-mode" type="select" label="Rescore diagonals with" help="" >
                <option value="0" selected="true">Hamming distance</option>
                <option value="1">Local alignment (score only)</option>
                <option value="2">Local alignment</option>
                <option value="3">Global alignment</option>
                <option value="4">Longest alignment fulfilling window quality criterion</option>
            </param>
            <param argument="--allow-deletion" type="boolean" checked="false" truevalue="1" falsevalue="0" label="Allow deletions in a MSA" help=""/>
            <param argument="--min-length" type="integer" min="0" value="30" label="Minimum codon number in open reading frames" help=""/>
            <param argument="--max-length" type="integer" min="0" value="32734" label="Maximum codon number in open reading frames" help=""/>
            <param argument="--max-gaps" type="integer" min="0" value="2147483647" label="Maximum number of codons with gaps or unknown residues before an open reading frame is rejected" help=""/>
            <param argument="--contig-start-mode" type="select" label="Contig start can be" help="" >
                <option value="0">Incomplete</option>
                <option value="1">Complete</option>
                <option value="2" selected="true">Both</option>
            </param>
            <param argument="--contig-end-mode" type="select" label="Contig end can be" help="" >
                <option value="0">Incomplete</option>
                <option value="1">Complete</option>
                <option value="2" selected="true">Both</option>
            </param>
            <param argument="--orf-start-mode" type="select" label="ORF fragment can be" help="" >
                <option value="0">From start to stop</option>
                <option value="1" selected="true">From any to stop</option>
                <option value="2">From last encountered start to stop (no start in the middle)</option>
            </param>
            <param argument="--forward-frames" type="text" value="1,2,3" label="Comma-separated list of frames on the forward strand to be extracted" help=""/>
            <param argument="--reverse-frames" type="text" value="1,2,3" label="Comma-separated list of frames on the reverse strand to be extracted" help=""/>
            <param argument="--translation-table" type="select" label="Translation table" help="">
                <option value="1" selected="true">Canonical</option>
                <option value="2">Vert_mitochondrial</option>
                <option value="3">Yeast_mitochondrial</option>
                <option value="4">Mold_mitochondrial</option>
                <option value="5">Invert_mitochondrial</option>
                <option value="6">Ciliate</option>
                <option value="9">Flatworm_mitochondrial</option>
                <option value="10">Euplotid</option>
                <option value="11">Prokaryote</option>
                <option value="12">Alt_yeast</option>
                <option value="13">Ascidian_mitochondrial</option>
                <option value="14">Alt_flatworm_mitochondrial</option>
                <option value="15">Blepharisma</option>
                <option value="16">Chlorophycean_mitochondrial</option>
                <option value="21">Trematode_mitochondrial</option>
                <option value="22">Scenedesmus_mitochondrial</option>
                <option value="23">Thraustochytrium_mitochondrial</option>
                <option value="24">Pterobranchia_mitochondrial</option>
                <option value="25">Gracilibacteria</option>
                <option value="26">Pachysolen</option>
                <option value="27">Karyorelict</option>
                <option value="28">Condylostoma</option>
                <option value="29">Mesodium</option>
                <option value="30">Pertrich</option>
                <option value="31">Blastocrithidia</option>
            </param>
            <param argument="--translate" type="boolean" checked="false" truevalue="1" falsevalue="0" label="Translate ORF to amino acid" help=""/>
            <param argument="--use-all-table-starts" type="boolean" checked="false" truevalue="1" falsevalue="0" label="Use all alternatives for a start codon in the genetic table, if false - only ATG (AUG)" help=""/>
            <param argument="--id-offset" type="integer" min="0" value="0" label="Numeric ids in index file are offset by this value" help=""/>
            <param argument="--add-orf-stop" type="boolean" checked="false" truevalue="1" falsevalue="0" label="Add stop codon '*' at complete start and end" help=""/>
            <param argument="--sequence-overlap" type="integer" min="0" value="0" label="Overlap between sequences" help=""/>
            <param argument="--sequence-split-mode" type="select" label="Sequence split mode" help="" >
                <option value="0">Copy data</option>
                <option value="1" selected="true">Soft link data and write new index</option>
            </param>
            <param argument="--headers-split-mode" type="select" label="Headers split mode" help="" >
                <option value="0" selected="true">Split position</option>
                <option value="1">Original header</option>
            </param>
            <param argument="--search-type" type="select" label="Search type" help="" >
                <option value="0" selected="true">Auto</option>
                <option value="1">Amino acid</option>
                <option value="2">Translated</option>
                <option value="3">Nucleotide</option>
                <option value="4">Translated nucleotide alignment</option>
            </param>
            <param argument="--prefilter-mode" type="select" label="Prefilter mode" help="" >
                <option value="0" selected="true">Kmer/ungapped</option>
                <option value="1">Ungapped</option>
                <option value="2">No filter</option>
            </param>
            <conditional name="out_format">
                <param argument="--format-mode" type="select" label="Output format" help="" >
                    <option value="0" selected="true">BLAST-TAB</option>
                    <option value="1">SAM</option>
                    <option value="2">BLAST-TAB + query/db length</option>
                    <option value="3">Pretty HTML</option>
                    <option value="4">BLAST-TAB + column headers</option>
                </param>
                <when value="0">
                    <param argument="--format-output" type="select" multiple="true" label="Choose list of output columns" help="">
                        <option value="query" selected="true">Query</option>
                        <option value="target">Target</option>
                        <option value="evalue">E-value</option>
                        <option value="gapopen">Gap open</option>
                        <option value="pident">Percentage identity</option>
                        <option value="fident" selected="true">Filtered identity</option>
                        <option value="nident">Number of identical matches</option>
                        <option value="qstart" selected="true">Query start</option>
                        <option value="qend" selected="true">Query end</option>
                        <option value="qlen">Query length</option>
                        <option value="tstart" selected="true">Target start</option>
                        <option value="tend" selected="true">Target end</option>
                        <option value="tlen">Target length</option>
                        <option value="alnlen" selected="true">Alignment length</option>
                        <option value="raw">Raw score</option>
                        <option value="bits" selected="true">Bit score</option>
                        <option value="cigar">CIGAR string</option>
                        <option value="qseq">Query sequence</option>
                        <option value="tseq">Target sequence</option>
                        <option value="qheader">Query header</option>
                        <option value="theader">Target header</option>
                        <option value="qaln">Query alignment</option>
                        <option value="taln">Target alignment</option>
                        <option value="qframe">Query frame</option>
                        <option value="tframe">Target frame</option>
                        <option value="mismatch" selected="true">Mismatch</option>
                        <option value="qcov">Query coverage</option>
                        <option value="tcov">Target coverage</option>
                        <option value="qset">Query set</option>
                        <option value="qsetid">Query set ID</option>
                        <option value="tset">Target set</option>
                        <option value="tsetid">Target set ID</option>
                        <option value="taxid">Taxonomy ID</option>
                        <option value="taxname">Taxonomy name</option>
                        <option value="taxlineage">Taxonomy lineage</option>
                        <option value="qorfstart">Query ORF start</option>
                        <option value="qorfend">Query ORF end</option>
                        <option value="torfstart">Target ORF start</option>
                        <option value="torfend">Target ORF end</option>
                        <option value="ppos">Positive matches</option>
                    </param>
                </when>
                <when value="1"/>
                <when value="2"/>
                <when value="3"/>
                <when value="4">
                    <param argument="--format-output" type="select" multiple="true" label="Choose list of output columns" help="">
                        <option value="query" selected="true">Query</option>
                        <option value="target">Target</option>
                        <option value="evalue">E-value</option>
                        <option value="gapopen">Gap open</option>
                        <option value="pident">Percentage identity</option>
                        <option value="fident" selected="true">Filtered identity</option>
                        <option value="nident">Number of identical matches</option>
                        <option value="qstart" selected="true">Query start</option>
                        <option value="qend" selected="true">Query end</option>
                        <option value="qlen">Query length</option>
                        <option value="tstart" selected="true">Target start</option>
                        <option value="tend" selected="true">Target end</option>
                        <option value="tlen">Target length</option>
                        <option value="alnlen" selected="true">Alignment length</option>
                        <option value="raw">Raw score</option>
                        <option value="bits" selected="true">Bit score</option>
                        <option value="cigar">CIGAR string</option>
                        <option value="qseq">Query sequence</option>
                        <option value="tseq">Target sequence</option>
                        <option value="qheader">Query header</option>
                        <option value="theader">Target header</option>
                        <option value="qaln">Query alignment</option>
                        <option value="taln">Target alignment</option>
                        <option value="qframe">Query frame</option>
                        <option value="tframe">Target frame</option>
                        <option value="mismatch" selected="true">Mismatch</option>
                        <option value="qcov">Query coverage</option>
                        <option value="tcov">Target coverage</option>
                        <option value="qset">Query set</option>
                        <option value="qsetid">Query set ID</option>
                        <option value="tset">Target set</option>
                        <option value="tsetid">Target set ID</option>
                        <option value="taxid">Taxonomy ID</option>
                        <option value="taxname">Taxonomy name</option>
                        <option value="taxlineage">Taxonomy lineage</option>
                        <option value="qorfstart">Query ORF start</option>
                        <option value="qorfend">Query ORF end</option>
                        <option value="torfstart">Target ORF start</option>
                        <option value="torfend">Target ORF end</option>
                        <option value="ppos">Positive matches</option>
                    </param>
                </when>
            </conditional>
            <param argument="--first-seq-as-repr" type="boolean" checked="false" truevalue="1" falsevalue="0" label="Use the first sequence of the clustering result as representative sequence" help=""/>
            <param argument="--target-column" type="integer" min="0" value="1" label="Select a target column" help="0 if no target id exists"/>
            <param argument="--full-header" type="boolean" checked="false" truevalue="1" falsevalue="0" label="Replace DB ID by its corresponding Full Header" help=""/>
            <param argument="--idx-seq-src" type="select" label="Index sequence source" help="">
                <option value="0" selected="true">Auto</option>
                <option value="1">Split/translated sequences</option>
                <option value="2">Input sequences</option>
            </param>
            <param argument="--dbtype" type="select" label="Database type" help="" >
                <option value="0" selected="true">Auto</option>
                <option value="1">Amino acid</option>
                <option value="2">Nucleotides</option>
            </param>
            <param argument="--shuffle" type="boolean" checked="true" label="Shuffle input database" truevalue="1" falsevalue="0" optional="true" help="" />
            <param argument="--createdb-mode" type="select" label="Createdb mode" help="">
                <option value="0">Copy data</option>
                <option value="1" selected="true">Soft link data and write new index (works only with single line fasta/q)</option>
            </param>
        </section>
        <section name="common" title="Common">
            <param argument="--max-seq-len" type="integer" min="0" value="65535" label="Maximum sequence length" help=""/>
        </section>
        <section name="expert" title="Expert">
            <param argument="--filter-hits" type="boolean" checked="false" truevalue="1" falsevalue="0" label="Filter hits by seq.id. and coverage" help=""/>
            <param argument="--sort-results" type="select" label="Sort results" help="">
                <option value="0" selected="true">No sorting</option>
                <option value="1">Sort by E-value (Alignment) or seq.id. (Hamming)</option>
            </param>
            <param argument="--chain-alignments" type="integer" min="0" value="0" label="Chain alignments" help=""/>
            <param argument="--merge-query" type="integer" min="0" value="1" label="Combine ORFs/split sequences to a single entry" help=""/>
        </section>
        <section name="output_files" title="Selection of the output files">
          <param name="output_selection" type="select" display="checkboxes" multiple="true"  label="Output files selection">
              <option value="file_lca" selected="true">LCA outpout information</option>
              <option value="file_report" selected="true">Global report (Kraken or Krona style, see report-mode)</option>
              <option value="file_tophit_aln" selected="true">Top hits</option>
              <option value="file_tophit_report" selected="true">Coverage profiles per database entry</option>
          </param>
        </section>
    </inputs>
    <outputs>
        <data name="output_lca" format="tabular" from_work_dir="result_lca.tsv" label="${tool.name} on ${on_string}: LCA outpout information">
            <filter>output_files['output_selection'] and "file_lca" in output_files['output_selection']</filter>
        </data>
        <data name="output_report" format="tabular" from_work_dir="result_report" label="${tool.name} on ${on_string}: Global report">
            <change_format>
                <when input="--report-mode" value="1" format="html"/>
            </change_format>
            <filter>output_files['output_selection'] and "file_report" in output_files['output_selection']</filter>
        </data>
        <data name="output_tophit_aln" format="tabular" from_work_dir="result_tophit_aln" label="${tool.name} on ${on_string}: Top hits">
            <filter>output_files['output_selection'] and "file_tophit_aln" in output_files['output_selection']</filter>
        </data>
        <data name="output_tophit_report" format="tabular" from_work_dir="result_tophit_report" label="${tool.name} on ${on_string}: Coverage profiles per database entry">
            <filter>output_files['output_selection'] and "file_tophit_report" in output_files['output_selection']</filter>
        </data>
    </outputs>
    <tests>
        <test expect_num_outputs="4">
            <param name="input_fasta" value="light_mystery_reads.fasta" ftype="fasta"/>
            <param name="mmseqs2_db_select" value="UniProtKBSwiss-Prot-15.6f452-23102024" />
            <output name="output_lca" ftype="tabular">
                <assert_contents>
                    <has_line line="MYSTERY.34&#009;91347&#009;order&#009;Enterobacterales&#009;1&#009;1&#009;1&#009;1.000"/>
                    <has_line line="MYSTERY.215&#009;119060&#009;family&#009;Burkholderiaceae&#009;1&#009;1&#009;1&#009;1.000"/>
                    <has_n_columns n="8"/>
                </assert_contents>
            </output>
            <output name="output_report" ftype="tabular">
                <assert_contents>
                    <has_line line="59.6421&#009;300&#009;8&#009;class&#009;28216&#009;Betaproteobacteria"/>
                    <has_line line="0.3976&#009;2&#009;0&#009;genus&#009;10358&#009;Cytomegalovirus"/>
                    <has_n_columns n="6"/>
                </assert_contents>
            </output>
            <output name="output_tophit_aln" ftype="tabular">
                <assert_contents>
                    <has_line line="MYSTERY.112&#009;Q04222&#009;0.144&#009;866&#009;27&#009;0&#009;0&#009;33&#009;0&#009;866&#009;1.144E-14&#009;68"/>
                    <has_n_columns n="12"/>
                </assert_contents>
            </output>
            <output name="output_tophit_report" ftype="tabular">
                <assert_contents>
                    <has_text text="Haemophilus influenzae Rd KW20"/>
                    <has_n_columns n="8"/>
                </assert_contents>
            </output>
        </test>
    </tests>
    <help><![CDATA[
**MMseqs2: ultra fast and sensitive sequence search and clustering suite**

MMseqs2 (Many-against-Many sequence searching) is a software suite to search and cluster huge protein and nucleotide sequence sets. 
MMseqs2 is open source GPL-licensed software implemented in C++ for Linux, MacOS, and (as beta version, via cygwin) Windows. 
The software is designed to run on multiple cores and servers and exhibits very good scalability. 
MMseqs2 can run 10000 times faster than BLAST. At 100 times its speed it achieves almost the same sensitivity. 
It can perform profile searches with the same sensitivity as PSI-BLAST at over 400 times its speed.

**Usage** 

* Convert FASTA/Q file(s) to MMseqs sequence DB format
    *mmseqs createdb <i:fastaFile1[.gz|.bz2]> ... <i:fastaFileN[.gz|.bz2]>|<i:stdin> <o:sequenceDB> [options]*

* Add taxonomic labels to sequence DB
    *mmseqs createtaxdb <i:sequenceDB> <tmpDir> [options]*

* Filter taxonomy sequence database
    *mmseqs filtertaxseqdb <i:taxSeqDB> <o:taxSeqDB> [options]*

* Taxonomy assignment by computing the lowest common ancestor of homologs
    *mmseqs taxonomy <i:queryDB> <i:targetDB> <o:taxaDB> <tmpDir> [options]*

* Convert result DB to tab-separated flat file
    *mmseqs createtsv <i:queryDB> [<i:targetDB>] <i:resultDB> <o:tsvFile> [options]*

* Create a taxonomy report in Kraken or Krona format
    *mmseqs taxonomyreport <i:seqTaxDB> <i:taxResultDB/resultDB/sequenceDB> <o:taxonomyReport> [options]*

By Martin Steinegger <martin.steinegger@snu.ac.kr> & Milot Mirdita <milot@mirdita.de> & Florian Breitwieser <florian.bw@gmail.com> & Eli Levy Karin <eli.levy.karin@gmail.com>

-----

**References**

- Steinegger M, Soding J: MMseqs2 enables sensitive protein sequence searching for the analysis of massive data sets. Nature Biotechnology, 35(11), 1026-1028 (2017)
- Mirdita M, Steinegger M, Breitwieser F, Soding J, Levy Karin E: Fast and sensitive taxonomic assignment to metagenomic contigs. Bioinformatics, btab184 (2021)
    ]]></help>
    <expand macro="citations"/>
</tool>