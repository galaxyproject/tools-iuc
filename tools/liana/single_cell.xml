<tool id="liana_single_cell" name="Liana single cell methods" version="@TOOL_VERSION@+galaxy@VERSION_SUFFIX@" profile="@PROFILE@">
    <description>for ligand-receptor inference</description>
    <macros>
        <import>macros_copy.xml</import>
    </macros>
    <expand macro="bio_tools"/>
    <expand macro="requirements"/>
    <expand macro="version_command"/>
    <command detect_errors="exit_code"><![CDATA[
@CMD@
      ]]></command>
    <configfiles>
        <configfile name="script_file"><![CDATA[
@CMD_IMPORTS@
@CMD_READ_INPUTS@

#if str($method.method) == 'rank_aggregate':
li.method.rank_aggregate(
    adata=adata,
    groupby='$method.groupby',
    #if str($method.resource_selection.resource_type) == 'interactions':
    interactions=[tuple(x.strip().split(',')) for x in '''$method.resource_selection.interactions'''.strip().split('\n') if x.strip()],
    #else if str($method.resource_selection.resource_type) == 'resource':
    resource=pd.read_csv('$method.resource_selection.resource', sep='\t'),
    #else:
    resource_name='$method.resource_selection.resource_name',
    #end if
    expr_prop=$method.expr_prop,
    min_cells=$method.min_cells,
    #if str($method.groupby_pairs.groupby_pairs_selector) == 'custom':
    groupby_pairs=pd.read_csv('$method.groupby_pairs.pairs_file', sep='\t'),
    #end if
    #if str($method.base) != '':
    base=$method.base,
    #end if
    aggregate_method='$method.aggregate_method',
    #if str($method.consensus_opts.consensus_opts_selector) == 'custom':
    consensus_opts=$method.consensus_opts.opts,
    #end if
    return_all_lrs=$method.return_all_lrs,
    #if str($method.key_added) != '':
    key_added='$method.key_added',
    #end if
    use_raw=$method.use_raw,
    #if str($method.layer) != '':
    layer='$method.layer',
    #end if
    de_method='$method.de_method',
    #if str($method.n_perms) != '':
    n_perms=$method.n_perms,
    #end if
    seed=$method.seed,
    verbose=$method.verbose,
    inplace=True)

#else if str($method.method) == 'cellchat':
li.method.cellchat(
    adata=adata,
    groupby='$method.groupby',
    #if str($method.resource_selection.resource_type) == 'interactions':
    interactions=[tuple(x.strip().split(',')) for x in '''$method.resource_selection.interactions'''.strip().split('\n') if x.strip()],
    #else if str($method.resource_selection.resource_type) == 'resource':
    resource=pd.read_csv('$method.resource_selection.resource', sep='\t'),
    #else:
    resource_name='$method.resource_selection.resource_name',
    #end if
    expr_prop=$method.expr_prop,
    min_cells=$method.min_cells,
    return_all_lrs=$method.return_all_lrs,
    #if str($method.key_added) != '':
    key_added='$method.key_added',
    #end if
    use_raw=$method.use_raw,
    #if str($method.layer) != '':
    layer='$method.layer',
    #end if
    de_method='$method.de_method',
    #if str($method.n_perms) != '':
    n_perms=$method.n_perms,
    #end if
    seed=$method.seed,
    verbose=$method.verbose,
    inplace=True)

#else if str($method.method) == 'cellphonedb':
li.method.cellphonedb(
    adata=adata,
    groupby='$method.groupby',
    #if str($method.resource_selection.resource_type) == 'interactions':
    interactions=[tuple(x.strip().split(',')) for x in '''$method.resource_selection.interactions'''.strip().split('\n') if x.strip()],
    #else if str($method.resource_selection.resource_type) == 'resource':
    resource=pd.read_csv('$method.resource_selection.resource', sep='\t'),
    #else:
    resource_name='$method.resource_selection.resource_name',
    #end if
    expr_prop=$method.expr_prop,
    min_cells=$method.min_cells,
    return_all_lrs=$method.return_all_lrs,
    #if str($method.key_added) != '':
    key_added='$method.key_added',
    #end if
    use_raw=$method.use_raw,
    #if str($method.layer) != '':
    layer='$method.layer',
    #end if
    de_method='$method.de_method',
    #if str($method.n_perms) != '':
    n_perms=$method.n_perms,
    #end if
    seed=$method.seed,
    verbose=$method.verbose,
    inplace=True)

#else if str($method.method) == 'connectome':
li.method.connectome(
    adata=adata,
    groupby='$method.groupby',
    #if str($method.resource_selection.resource_type) == 'interactions':
    interactions=[tuple(x.strip().split(',')) for x in '''$method.resource_selection.interactions'''.strip().split('\n') if x.strip()],
    #else if str($method.resource_selection.resource_type) == 'resource':
    resource=pd.read_csv('$method.resource_selection.resource', sep='\t'),
    #else:
    resource_name='$method.resource_selection.resource_name',
    #end if
    expr_prop=$method.expr_prop,
    min_cells=$method.min_cells,
    return_all_lrs=$method.return_all_lrs,
    #if str($method.key_added) != '':
    key_added='$method.key_added',
    #end if
    use_raw=$method.use_raw,
    #if str($method.layer) != '':
    layer='$method.layer',
    #end if
    de_method='$method.de_method',
    seed=$method.seed,
    verbose=$method.verbose,
    inplace=True)

#else if str($method.method) == 'natmi':
li.method.natmi(
    adata=adata,
    groupby='$method.groupby',
    #if str($method.resource_selection.resource_type) == 'interactions':
    interactions=[tuple(x.strip().split(',')) for x in '''$method.resource_selection.interactions'''.strip().split('\n') if x.strip()],
    #else if str($method.resource_selection.resource_type) == 'resource':
    resource=pd.read_csv('$method.resource_selection.resource', sep='\t'),
    #else:
    resource_name='$method.resource_selection.resource_name',
    #end if
    expr_prop=$method.expr_prop,
    min_cells=$method.min_cells,
    return_all_lrs=$method.return_all_lrs,
    #if str($method.key_added) != '':
    key_added='$method.key_added',
    #end if
    use_raw=$method.use_raw,
    #if str($method.layer) != '':
    layer='$method.layer',
    #end if
    de_method='$method.de_method',
    seed=$method.seed,
    verbose=$method.verbose,
    inplace=True)

#else if str($method.method) == 'logfc':
li.method.logfc(
    adata=adata,
    groupby='$method.groupby',
    #if str($method.resource_selection.resource_type) == 'interactions':
    interactions=[tuple(x.strip().split(',')) for x in '''$method.resource_selection.interactions'''.strip().split('\n') if x.strip()],
    #else if str($method.resource_selection.resource_type) == 'resource':
    resource=pd.read_csv('$method.resource_selection.resource', sep='\t'),
    #else:
    resource_name='$method.resource_selection.resource_name',
    #end if
    expr_prop=$method.expr_prop,
    min_cells=$method.min_cells,
    #if str($method.base) != '':
    base=$method.base,
    #end if
    return_all_lrs=$method.return_all_lrs,
    #if str($method.key_added) != '':
    key_added='$method.key_added',
    #end if
    use_raw=$method.use_raw,
    #if str($method.layer) != '':
    layer='$method.layer',
    #end if
    de_method='$method.de_method',
    seed=$method.seed,
    verbose=$method.verbose,
    inplace=True)

#else if str($method.method) == 'singlecellsignalr':
li.method.singlecellsignalr(
    adata=adata,
    groupby='$method.groupby',
    #if str($method.resource_selection.resource_type) == 'interactions':
    interactions=[tuple(x.strip().split(',')) for x in '''$method.resource_selection.interactions'''.strip().split('\n') if x.strip()],
    #else if str($method.resource_selection.resource_type) == 'resource':
    resource=pd.read_csv('$method.resource_selection.resource', sep='\t'),
    #else:
    resource_name='$method.resource_selection.resource_name',
    #end if
    expr_prop=$method.expr_prop,
    min_cells=$method.min_cells,
    return_all_lrs=$method.return_all_lrs,
    #if str($method.key_added) != '':
    key_added='$method.key_added',
    #end if
    use_raw=$method.use_raw,
    #if str($method.layer) != '':
    layer='$method.layer',
    #end if
    de_method='$method.de_method',
    seed=$method.seed,
    verbose=$method.verbose,
    inplace=True)

#else if str($method.method) == 'geometric_mean':
li.method.geometric_mean(
    adata=adata,
    groupby='$method.groupby',
    #if str($method.resource_selection.resource_type) == 'interactions':
    interactions=[tuple(x.strip().split(',')) for x in '''$method.resource_selection.interactions'''.strip().split('\n') if x.strip()],
    #else if str($method.resource_selection.resource_type) == 'resource':
    resource=pd.read_csv('$method.resource_selection.resource', sep='\t'),
    #else:
    resource_name='$method.resource_selection.resource_name',
    #end if
    expr_prop=$method.expr_prop,
    min_cells=$method.min_cells,
    return_all_lrs=$method.return_all_lrs,
    #if str($method.key_added) != '':
    key_added='$method.key_added',
    #end if
    use_raw=$method.use_raw,
    #if str($method.layer) != '':
    layer='$method.layer',
    #end if
    de_method='$method.de_method',
    seed=$method.seed,
    verbose=$method.verbose,
    inplace=True)
#end if

@CMD_ANNDATA_WRITE_OUTPUTS@
        ]]>
        </configfile>
    </configfiles>
    <inputs>
        <expand macro="inputs_anndata"/>
        <conditional name="method">
            <param argument="method" type="select" label="Method for ligand-receptor inference">
                <option value="rank_aggregate">Aggregate ligand-receptor scores from multiple methods (rank_aggregate)</option>
                <option value="cellchat">CellChat method (cellchat)</option>
                <option value="cellphonedb">CellPhoneDB method (cellphonedb)</option>
                <option value="connectome">Connectome method (connectome)</option>
                <option value="natmi">NATMI method (natmi)</option>
                <option value="logfc">Log fold change method (logfc)</option>
                <option value="singlecellsignalr">SingleCellSignalR method (singlecellsignalr)</option>
                <option value="geometric_mean">Geometric mean method (geometric_mean)</option>
            </param>
            <when value="rank_aggregate">
                <expand macro="params_common_basic"/>
                <expand macro="param_groupby_pairs"/>
                <expand macro="param_base"/>
                <param argument="aggregate_method" type="select" label="Aggregation method">
                    <option value="rra" selected="true">RobustRankAggregate (rra)</option>
                    <option value="mean">Mean rank (mean)</option>
                </param>
                <conditional name="consensus_opts">
                    <param name="consensus_opts_selector" type="select" label="Consensus options">
                        <option value="default" selected="true">Default (Specificity and Magnitude)</option>
                        <option value="custom">Custom</option>
                    </param>
                    <when value="default"/>
                    <when value="custom">
                        <param name="opts" type="select" multiple="true" label="Strategies to aggregate interactions">
                            <option value="Specificity">Specificity</option>
                            <option value="Magnitude">Magnitude</option>
                        </param>
                    </when>
                </conditional>
                <expand macro="params_common_output"/>
                <expand macro="params_common_advanced_with_perms"/>
            </when>
            <when value="cellchat">
                <expand macro="params_lr_method_with_perms"/>
            </when>
            <when value="cellphonedb">
                <expand macro="params_lr_method_with_perms"/>
            </when>
            <when value="connectome">
                <expand macro="params_lr_method_basic"/>
            </when>
            <when value="natmi">
                <expand macro="params_lr_method_basic"/>
            </when>
            <when value="logfc">
                <expand macro="params_common_basic"/>
                <expand macro="param_base"/>
                <expand macro="params_common_output"/>
                <expand macro="params_common_advanced"/>
            </when>
            <when value="singlecellsignalr">
                <expand macro="params_lr_method_basic"/>
            </when>
            <when value="geometric_mean">
                <expand macro="params_lr_method_basic"/>
            </when>
        </conditional>
        <expand macro="inputs_common_advanced"/>
    </inputs>
    <outputs>
        <expand macro="anndata_outputs"/>
    </outputs>
    <tests>
        <!-- TODO: Add tests for liana methods -->
    </tests>
    <help><![CDATA[
Liana Single Cell Ligand-Receptor Methods
=========================================

This tool wraps the single-cell ligand-receptor inference methods from LIANA (LIgand-receptor ANalysis frAmework).

Available Methods
-----------------

**rank_aggregate**
    Get an aggregate of ligand-receptor scores from multiple methods using RobustRankAggregate or mean rank.

**cellchat**
    Run the CellChat ligand-receptor method.

**cellphonedb**
    Run the CellPhoneDB ligand-receptor method with permutation testing.

**connectome**
    Run the Connectome ligand-receptor method.

**natmi**
    Run the NATMI (Network Analysis Toolkit for Multicellular Interactions) method.

**logfc**
    Run the log fold change ligand-receptor method.

**singlecellsignalr**
    Run the SingleCellSignalR ligand-receptor method.

**geometric_mean**
    Run the geometric mean ligand-receptor method.

Common Parameters
-----------------

**groupby**
    Key in adata.obs to be used for grouping cells (e.g., cell type annotation).

**Resource Selection (hierarchy: interactions > resource > resource_name)**
    There are three ways to specify ligand-receptor pairs, with the following priority:
    
    1. **interactions** (highest priority): Provide specific ligand-receptor pairs as a list.
       Format: one pair per line as "ligand,receptor" (e.g., "TGFB1,TGFBR1").
       If provided, this overrides both resource and resource_name.
    
    2. **resource** (medium priority): Provide a custom tabular file with 'ligand' and 'receptor' columns.
       If provided, this overrides resource_name.
    
    3. **resource_name** (lowest priority, default): Use a built-in resource by name.
       Default is 'consensus'. Use `li.rs.show_resources()` to see available resources.

**expr_prop**
    Minimum expression proportion for ligands and receptors in corresponding cell identities.
    Set to 0 to return unfiltered results.

**min_cells**
    Minimum number of cells per cell identity to be considered for analysis.

**use_raw**
    Whether to use the raw attribute of adata if present.

**layer**
    Layer in adata.layers to use. If None, uses adata.X.

**de_method**
    Differential expression method for ranking genes. Default is 't-test'.

**n_perms**
    Number of permutations for permutation testing (relevant for CellPhoneDB-like methods).

**seed**
    Random seed for reproducibility.

Output
------

Results are stored in `adata.uns['liana_res']` (or custom key_added) as a DataFrame with ligand-receptor interaction scores.

More details on the `LIANA documentation <https://liana-py.readthedocs.io/>`__
    ]]></help>
    <expand macro="citations"/>
</tool>
