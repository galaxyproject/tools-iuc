<tool id="hicexplorer_hicconvertformat" name="@BINARY@" version="@WRAPPER_VERSION@.0">
    <description>Convert between different file formats</description>
    <macros>
        <token name="@BINARY@">hicConvertFormat</token>
        <token name="@SINGLE_INPUT@">
            #if $xml_path.inputFormat_selector == 'optionCool':
                --matrices '$xml_path.matrix_h5_cooler'
                --inputFormat cool
                #if $xml_path.correctionName:
                    --correction_name $xml_path.correctionName
                #end if

                #if $xml_path.correctionDivision:
                    --correction_division
                #end if

                #if $xml_path.chromosome:
                    --chromosome $inputFormat_conditional.chromosome
                #end if

                #if $xml_path.loadRawValues:
                    --load_raw_values
                #end if
            #end if
            #if $xml_path.inputFormat_selector == 'optionH5':
                --matrices '$xml_path.matrix_h5_cooler'
                --inputFormat h5

            #end if 
             #if $xml_path.inputFormat_selector == 'optionHomer':
                --matrices '$xml_path.matrixHomer'
                --inputFormat homer

            #end if 
             #if $xml_path.inputFormat_selector == 'optionHicpro':
                --matrices '$xml_path.matrixHicpro'
                --bedFileHicpro '$xml_path.bedHicpro'
                --inputFormat hicpro
            #end if 
            #if $xml_path.inputFormat_selector == 'optionHic':
                --matrices '$xml_path.matrixHic'
                #if $xml_path.resolutions:
                    --resolutions '$xml_path.resolutions'
                #end if
                --inputFormat hic
            #end if 
        </token>
        <import>macros.xml</import>
    </macros>

    <expand macro="requirements" />
    <command detect_errors="exit_code"><![CDATA[


        ## single to single case
        @BINARY@ 
        #set xml_path = $outputSingleMultiple_conditional.inputFormat_conditional

        #if $outputSingleMultiple_conditional.outputSingleMultiple_selector == 'singleMatrix':
            @SINGLE_INPUT@
            
            --outputFromat $outputSingleMultiple_conditional.outputFormat_conditional.outputFormat_selector
            
        #end if

        

        #if $outputSingleMultiple_conditional.outputSingleMultiple_selector == 'multipleMatrix':
            --outputFormat mcool
            #set xml_path = $outputSingleMultiple_conditional.resolutionOrManyToOne_conditional.inputFormat_conditional

            #if $outputSingleMultiple_conditional.resolutionOrManyToOne_conditional.inputFormat_selector == 'resolution_option':
                --resolutions '$outputSingleMultiple_conditional.resolutionOrManyToOne_conditional.resolutions'
                @SINGLE_INPUT@
            #end if
            #set xml_manyToOne = $outputSingleMultiple_conditional.resolutionOrManyToOne_conditional

            #if $xml_manyToOne.inputFormat_selector == 'manyToOne_option':
                #if $xml_manyToOne.inputFormat_conditional.inputFormat_selector == 'optionCool':
                    --inputFormat cool
                    #for $counter, $m in enumerate($xml_manyToOne.matrix_h5_cooler_multiple):

                        ln -s '$m' ${counter}_matrix &&
                    #end for
                    #set $m = '" "'.join([ '%s_matrix' % $counter for $counter, $matrix in enumerate($xml_manyToOne.matrix_h5_cooler_multiple) ])
                    #if $outputSingleMultiple_conditional.inputFormat_conditional.correctionName:
                        --correction_name $inputFormat_conditional.correctionName
                    #end if

                    #if $outputSingleMultiple_conditional.inputFormat_conditional.correctionDivision:
                        --correction_division
                    #end if

                    #if $outputSingleMultiple_conditional.inputFormat_conditional.chromosome:
                        --chromosome $inputFormat_conditional.chromosome
                    #end if

                    #if $outputSingleMultiple_conditional.inputFormat_conditional.loadRawValues:
                        --load_raw_values
                    #end if
                #end if

                #if $xml_manyToOne.inputFormat_conditional.inputFormat_selector == 'optionH5':
                    --inputFormat h5
                    #for $counter, $m in enumerate($xml_manyToOne.matrix_h5_cooler_multiple):

                        ln -s '$m' ${counter}_matrix &&
                    #end for
                    #set $m = '" "'.join([ '%s_matrix' % $counter for $counter, $matrix in enumerate($xml_manyToOne.matrix_h5_cooler_multiple) ])
                #end if


                #if $xml_manyToOne.inputFormat_conditional.inputFormat_selector == 'optionHomer':
                    --inputFormat homer
                    #for $counter, $m in enumerate($xml_manyToOne.matrixHomer):

                        ln -s '$m' ${counter}_matrix &&
                    #end for
                    #set $m = '" "'.join([ '%s_matrix' % $counter for $counter, $matrix in enumerate($xml_manyToOne.matrixHomer) ])
                #end if

                #if $xml_manyToOne.inputFormat_conditional.inputFormat_selector == 'optionHicpro':
                    --inputFormat hicpro
                    #for $counter, $m in enumerate($xml_manyToOne.matrixHicpro):

                        ln -s '$m' ${counter}_matrix &&
                    #end for
                    #set $m = '" "'.join([ '%s_matrix' % $counter for $counter, $matrix in enumerate($xml_manyToOne.matrixHicpro) ])

                    #for $counter, $bed in enumerate($xml_manyToOne.bedHicpro):

                        ln -s '$bed' ${counter}_matrix &&
                    #end for
                    #set $bed = '" "'.join([ '%s_matrix' % $counter for $counter, $matrix in enumerate($xml_manyToOne.bedHicpro) ])
                    --bedFileHicpro '$bed'
                #end if

                --matrices '$m'
            #end if
        #end if

        --outFileName matrix



]]>
    </command>
    <inputs>

        <conditional name="outputSingleMultiple_conditional">
            <param name="outputSingleMultiple_selector" type="select" label="Choose output matrix type">
                <option value="singleMatrix" selected="True">single matrix</option>
                <option value="multipleMatrix">multiple matrix</option>
            </param>            
            <when value='singleMatrix'>
                    <expand macro='convertFormat_single_macro' />
                    <expand macro='convertFormat_single_output_macro' />
            </when>
            <when value='multipleMatrix'>
                <conditional name="resolutionOrManyToOne_conditional">
                    <param name="inputFormat_selector" type="select" label="Choose input file type">
                        <option value='resolution_option' >Create out of one matrix a multi matrix with diffrerent resolutions</option>
                        <option value='manyToOne_option'>Create out of n matrices one multi matrix </option>
                    </param>
                    <when value='resolution_option'>
                        <param name='resolutions' type='text' label='To be stored resolutions'/>
                        <expand macro='convertFormat_single_macro' />
                    </when>
                    <when value='manyToOne_option'>
                        <expand macro='convertFormat_multiple_macro' />
                    </when>
                </conditional>
                <param name='storeAppliedCorrection' type="boolean" truevalue="yes" falsevalue="" label='Store applied correction factors in column count'/>
                <param name='enforceInteger' type="boolean" truevalue="yes" falsevalue="" label='Enforce integer for count column'/>
            </when>
        </conditional>
    </inputs>
    <outputs>

        <data name='output_converted_matrix' from_work_dir='matrix' format='cool' label='Converted matrix'>
            <filter>outputSingleMultiple_conditional.outputSingleMultiple_selector == 'singleMatrix'</filter>
            <change_format>
                <when input="outputSingleMultiple_conditional.convertFormat_single_output_macro.outputFormat_selector" value="optionH5" format="h5" />
                <when input="outputSingleMultiple_conditional.convertFormat_single_output_macro.outputFormat_selector" value="optionHomer" format="txt" />
                <when input="outputSingleMultiple_conditional.convertFormat_single_output_macro.optionGinteractions" value="optionHomer" format="txt" />
            </change_format>
        </data>
        <data name='output_converted_matrix_multi' from_work_dir='matrix' format='cool' label='Converted matrix'>
            <filter>outputSingleMultiple_conditional.outputSingleMultiple_selector == 'multipleMatrix'</filter>
        </data>
    </outputs>
    <!-- <tests>
        <test>
            <param name="matrix_h5_cooler" value="small_test_matrix_50kb_res.h5"/>
            <param name="outputFormat" value="bedgraph" />
            <output name="pca1" file="pca1.bedgraph" ftype="bedgraph" compare="sim_size"/>
            <output name="pca2" file="pca2.bedgraph" ftype="bedgraph" compare="sim_size"/>
        </test>
        <test>
            <param name="matrix_h5_cooler" value="small_test_matrix_50kb_res.h5"/>

            <param name="outputFormat" value="bigwig" />
            <output name="pca1" file="pca1.bw" ftype="bigwig" compare="sim_size"/>
            <output name="pca2" file="pca2.bw" ftype="bigwig" compare="sim_size"/>
        </test>
    </tests> -->
    <help><![CDATA[


| For more information about HiCExplorer please consider our documentation on readthedocs.io_

.. _readthedocs.io: http://hicexplorer.readthedocs.io/en/latest/index.html
.. _`Lieberman-Aiden et al. (2009)`: https://doi.org/10.1126%2Fscience.1181369
]]></help>
    <expand macro="citations" />
</tool>
