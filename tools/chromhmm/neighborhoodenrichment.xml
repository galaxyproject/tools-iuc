<?xml version="1.0"?>
<tool id="chromhmm_neighborhoodenrichment" name="chromHMM NeighborhoodEnrichment" version="@TOOL_VERSION@+@WRAPPER_VERSION@">
    <description>of segments</description>

    <macros>
        <import>macros.xml</import>
    </macros>

    <expand macro="requirements"/>

    <stdio></stdio>  

    <command detect_errors="exit_code"><![CDATA[
        ## initialize 
        @DEF@
        mkdir input &&

        ## input '_segment.bed' file
        #if $inputsegment_cond.inputsegment_sel == 'bed'
            ln -s '${inputsegment_cond.inputsegment}' input/segments.bed &&
        ## input _posterior.txt file(s)
        #else if $inputsegment_cond.inputsegment_sel == 'post'
            #for $i, $file in enumerate($inputsegment_cond.posterior)
                ## fetch information from header, e.g. ['GM12878', 'chr11']
                #set header = $obtainHeaderFromPosterior($file)
                ## generate filename, e.g. 'GM12878_2_chr11_posterior.txt'
                ln -s '${file}' input/${header[0]}_${i}_${header[1]}_posterior.txt &&
            #end for
            #unless $inputsegment_cond.a == ''
                -a $inputsegment_cond.a 
            #end unless
        #end if

        ## run
        @RUN@
            NeighborhoodEnrichment
            ## optional
            #if $inputsegment_cond.inputsegment_sel == 'post'
                -posterior
                #unless $inputsegment_cond.a == ''
                    -a $inputsegment_cond.a 
                #end unless
            #else if $inputsegment_cond.inputsegment_sel == 'bed'
                #unless $inputsegment_cond.labels == ""
                    '$inputsegment_cond.labels'
                #end unless
            #end if
            -b $ao.b
            -l $ao.l
            #if $ao.m
                -m '$ao.m'
            #end if
            -o $ao.o
            -r $ao.r
            -s $ao.s
            $ao.nostrand
            $ao.signal
            -color '$oo.color'
            ## required
            #if $inputsegment_cond.inputsegment_sel == 'bed'
                input/segments.bed ## inputsegment
            #else if $inputsegment_cond.inputsegment_sel == 'post'
                input ## inputsegment, folder with '_posterior.txt' file(s)
            #end if
            ${__tool_directory__}/tool-data/ANCHORFILES/${assembly}/RefSeq${anchorpositions}.${assembly}.txt.gz ## anchorpositions
            neighborhoodenrichment ## outfileprefix

        && head -n 10 neighborhoodenrichment.txt
        ]]></command>
    <inputs>
        <!-- excluded: outfileprefix, -colfields, lowmem -->
        <!-- included via wrapper: -noimage -->

        <!-- required parameters -->
        <conditional name="inputsegment_cond">
            <param name="inputsegment_sel" type="select" multiple="false" label="Specify input type." help="">
                <option value="bed">Segmentation (bed)</option>
                <option value="post">Posterior (txt)</option>
            </param>
            <when value="bed">
                <param argument="inputsegment" type="data" format="bed" multiple="true" label="Select segmentation file." help=""/>
                <param argument="-labels" type="boolean" truevalue="-labels" falsevalue="" checked="false" label="Should labels be used?" help="The four column should be treated as having state labels instead of state IDs or state numbers. If the fourth column has a state ID or state number before a '_' and then followed by a label, the states will state be ordered by the state ID or number, otherwise the state ordering in the output may differ from the original state ordering."/>
            </when>
            <when value="post">
                <param argument="-posterior" type="data" format="txt" multiple="true" label="Select posterior file(s)." help="Use the full posterior for the enrichment opposed to the default of the maximum probability state assignments."/>
                <param argument="-a" type="text" value="" label="Specify cell type for which to compute the enrichment." help="By default (no value) the posterior enrichment is computed in aggregate over all cell types."/>
            </when>
        </conditional>
        <param name="assembly" type="select" label="Specify assembly." help="">
            <options from_data_table="chromhmm_assemblies">
                <validator message="No assembly is available" type="no_options"/>
            </options>
        </param>
        <param argument="anchorpositions" type="select" label="Specify file with anchor positions." help="A file containing the coordinates of the anchor positions around which state enrichments will be determined.">
            <option value="TES">TES</option>
            <option value="TSS">TSS</option>
        </param>

        <!-- optional parameters -->
        <section name="ao" title="Advanced options">
            <param argument="-b" type="integer" value="200" min="0" label="Set binsize." help="The number of base pairs in a bin determining the resolution of the model learning and segmentation."/>
            <param argument="-l" type="integer" value="10" label="Set the number of enrichment columns to the left of the anchor position to display." help=""/>
            <param argument="-m" type="data" format="tabular" multiple="false" optional="true" label="Set label mapping file." help="This option can specify a file which maps state IDs to descriptive names. The descriptive names can be appended to the state IDs in the neighborhood enrichment output files. The format of this file is a two column tab delimited file. The first column contains each state ID with the state ordering letter prefix. The second column contains a descriptive name or mnemonic. If this file is not specified, then just the state IDs are displayed."/>
            <param argument="-o" type="integer" value="10" label="Set value that should be subtracted from the anchor coordinate so it is 0 based." help=""/>
            <param argument="-r" type="integer" value="10" label="Set the number of enrichment columns to the right of the anchor position to display." help=""/>
            <param argument="-s" type="integer" value="200" label="Set the spacing in base pairs at which column enrichments should be displayed." help=""/>
            <param argument="-nostrand" type="boolean" truevalue="-nostrand" falsevalue="" checked="false" label="If this flag is present then no strand information is used in the enrichment calculations." help=""/>
            <param argument="-signal" type="boolean" truevalue="-signal" falsevalue="" checked="false" label="Should signal information be used in enrichments?" help="If available otherwise all overlaps are given equal weight. If signal is used coordinates without signal given will be assumed to have 0 signal in the enrichment calculation."/>
        </section>
        <section name="oo" title="Output options">
            <param name="neighborhoodenrichment" type="select" multiple="true" optional="false" label="NeighborhoodEnrichment: Which files should be created?" help="">
                <option value="txt" selected="true">txt</option>
                <option value="png">png</option>
                <option value="svg">svg</option>
            </param>
            <param argument="-color" type="text" value="0,0,255" label="Set heatmap colors." help="Integer values between 0 and 255, separated by commas."/>
        </section>
    </inputs>

    <outputs>
        <data name="out_neighborhoodenrichment_txt" format="txt" from_work_dir="neighborhoodenrichment.txt" label="${tool.name} on ${on_string}: NeighborhoodEnrichment, txt">
            <filter>'txt' in str(oo['neighborhoodenrichment'])</filter>
        </data>
        <data name="out_neighborhoodenrichment_png" format="png" from_work_dir="neighborhoodenrichment.png" label="${tool.name} on ${on_string}: NeighborhoodEnrichment, png">
            <filter>'png' in str(oo['neighborhoodenrichment'])</filter>
        </data>
        <data name="out_neighborhoodenrichment_svg" format="svg" from_work_dir="neighborhoodenrichment.svg" label="${tool.name} on ${on_string}: NeighborhoodEnrichment, svg">
            <filter>'svg' in str(oo['neighborhoodenrichment'])</filter>
        </data>
    </outputs>

    <tests> 
        <!-- #1; required parameters; input: '_segments.bed', TES; output: all -->
        <test expect_num_outputs="3">
            <conditional name="inputsegment_cond">
                <param name="inputsegment_sel" value="bed"/>
                <param name="inputsegment" value="GM12878_2_segments.bed.gz"/>
            </conditional>
            <param name="assembly" value="hg18"/>
            <param name="anchorpositions" value="TES"/>
            <section name="oo">
                <param name="neighborhoodenrichment" value="txt,png,svg"/>
            </section>
            <output name="out_neighborhoodenrichment_png" file="neighborhoodenrichment_test1.png"/>
            <output name="out_neighborhoodenrichment_svg">
                <assert_contents>
                    <has_n_lines n="97"/>
                </assert_contents>
            </output>
            <output name="out_neighborhoodenrichment_txt">
                <assert_contents>
                    <has_n_lines n="3"/>
                    <has_line_matching expression="State \(Emission order\)&#009;-2000&#009;.+"/>
                    <has_line_matching expression="2&#009;.+"/>
                </assert_contents>
            </output>      
        </test>
        <!-- #2; required parameters; input: '_posterior.txt', TSS; output: all -->
        <test expect_num_outputs="3">
            <conditional name="inputsegment_cond">
                <param name="inputsegment_sel" value="post"/>
                <param name="posterior" value="GM12878_2_chr11_posterior.txt.gz"/>
            </conditional>
            <param name="assembly" value="hg18"/>
            <param name="anchorpositions" value="TSS"/>
            <section name="oo">
                <param name="neighborhoodenrichment" value="txt,png,svg"/>
            </section>
            <output name="out_neighborhoodenrichment_png" file="neighborhoodenrichment_test2.png"/>
            <output name="out_neighborhoodenrichment_svg">
                <assert_contents>
                    <has_n_lines n="97"/>
                </assert_contents>
            </output>  
            <output name="out_neighborhoodenrichment_txt">
                <assert_contents>
                    <has_n_lines n="3"/>
                    <has_line_matching expression="State \(Emission order\)&#009;-2000&#009;.+"/>
                    <has_line_matching expression="2&#009;.+"/>
                </assert_contents>
            </output>      
        </test>
        <!-- #3; optional parameters; input: '_posterior.txt', TSS, no defaults; output: all -->
        <test expect_num_outputs="3">
            <conditional name="inputsegment_cond">
                <param name="inputsegment_sel" value="post"/>
                <param name="posterior" value="GM12878_2_chr11_posterior.txt.gz"/>
            </conditional>
            <param name="assembly" value="hg18"/>
            <param name="anchorpositions" value="TSS"/>
            <section name="ao">
                <param name="b" value="190"/>
                <param name="l" value="9"/>
                <param name="o" value="9"/>
                <param name="r" value="11"/>
                <param name="s" value="190"/>
                <param name="signal" value="true"/>
            </section>
            <section name="oo">
                <param name="color" value="10,80,190"/>
                <param name="neighborhoodenrichment" value="txt,png,svg"/>
            </section>
            <output name="out_neighborhoodenrichment_png" file="neighborhoodenrichment_test3.png"/>
            <output name="out_neighborhoodenrichment_svg">
                <assert_contents>
                    <has_n_lines n="98"/>
                </assert_contents>
            </output>  
            <output name="out_neighborhoodenrichment_txt">
                <assert_contents>
                    <has_n_lines n="3"/>
                    <has_line_matching expression="State \(Emission order\)&#009;-1710&#009;.+"/>
                    <has_line_matching expression="2&#009;.+"/>
                </assert_contents>
            </output>
        </test>
        <!-- #4; optional parameters; input: '_segments.bed', TSS, no defaults; output: all -->
        <test expect_num_outputs="2">
            <conditional name="inputsegment_cond">
                <param name="inputsegment_sel" value="bed"/>
                <param name="inputsegment" value="GM12878_2_segments.bed.gz"/>
            </conditional>
            <param name="assembly" value="hg18"/>
            <param name="anchorpositions" value="TSS"/>
            <section name="ao">
                <param name="b" value="210"/>
                <param name="l" value="11"/>
                <param name="o" value="8"/>
                <param name="r" value="9"/>
                <param name="s" value="205"/>
                <param name="signal" value="true"/>
            </section>
            <section name="oo">
                <param name="color" value="15,10,90"/>
                <param name="neighborhoodenrichment" value="txt,svg"/>
            </section>
            <output name="out_neighborhoodenrichment_svg">
                <assert_contents>
                    <has_n_lines n="98"/>
                </assert_contents>
            </output>  
            <output name="out_neighborhoodenrichment_txt">
                <assert_contents>
                    <has_n_lines n="3"/>
                    <has_line_matching expression="State \(Emission order\)&#009;-2255&#009;.+"/>
                    <has_line_matching expression="2&#009;.+"/>
                </assert_contents>
            </output>
        </test>
        <!-- #5; missing: a, m, labels, nostrand; todo -->
    </tests>
    <help><![CDATA[
.. class:: infomark

**What it does**

NeighborhoodEnrichment @HELP_WID@

NeighborhoodEnrichment given a set of anchor positions determines the fold enrichment for each state at fixed positions relative to the anchor positions. Signal values can optionally be associated with each coordinate to weight the enrichments. Strand information can also be optionally used to compute the positional enrichments in a strand aware manner. Fold enrichments by default are calculated analogously as specified in OverlapEnrichment.

**Input**

@HELP_FILETYPE_SEGMENTS@
@HELP_FILETYPE_ANCHOR@
@HELP_FILETYPE_LABELMAPPING@

**Output**

The enrichments are outputted both as a text file and in image format. 

.. class:: infomark

**References**

@HELP_REFERENCES@
    ]]></help>
    <citations>
        <expand macro="citations"/>
    </citations>
</tool>