<?xml version="1.0"?>
<tool id="chromhmm_overlapenrichment" name="chromHMM OverlapEnrichment" version="@TOOL_VERSION@+@WRAPPER_VERSION@">
    <description>of states</description>

    <macros>
        <import>macros.xml</import>
    </macros>

    <expand macro="requirements"/>

    <stdio></stdio>  

    <command detect_errors="exit_code"><![CDATA[
        ## initialize 
        @DEF@
        mkdir input &&

        ## input '_segment.bed' file
        #if $inputsegment_cond.inputsegment_sel == 'bed'
            ln -s '${inputsegment_cond.inputsegment}' input/segments.bed &&
        ## input _posterior.txt file(s)
        #else if $inputsegment_cond.inputsegment_sel == 'post'
            #for $i, $file in enumerate($inputsegment_cond.posterior)
                ## fetch information from header, e.g. ['GM12878', 'chr11']
                #set header = $obtainHeaderFromPosterior($file)
                ## generate filename, e.g. 'GM12878_2_chr11_posterior.txt'
                ln -s '${file}' input/${header[0]}_${i}_${header[1]}_posterior.txt &&
            #end for
            #unless $inputsegment_cond.a == ''
                -a $inputsegment_cond.a 
            #end unless
        #end if     

        ## run
        @RUN@
            OverlapEnrichment
            ## optional
            #if $inputsegment_cond.inputsegment_sel == 'post'
                -posterior
                #unless $inputsegment_cond.a == ''
                    -a $inputsegment_cond.a 
                #end unless
            #else if $inputsegment_cond.inputsegment_sel == 'bed'
                #unless $inputsegment_cond.labels == ""
                    '$inputsegment_cond.labels'
                #end unless
            #end if
            -b $ao.b
            $ao.binres
            $ao.center
            -e $ao.e
            #if $ao.m
                -m '$ao.m'
            #end if
            $ao.multicount
            -s $ao.s
            $ao.signal
            -color '$oo.color'
            $oo.uniformscale
            ## required
            #if $inputsegment_cond.inputsegment_sel == 'bed'
                input/segments.bed ## inputsegment
            #else if $inputsegment_cond.inputsegment_sel == 'post'
                input ## inputsegment, folder with '_posterior.txt' file(s)
            #end if
            ${__tool_directory__}/tool-data/COORDS/${assembly}/ ## inputcoorddir
            overlapenrichment ## outfileprefix

            && ls -lisa
            && head -n 10 overlapenrichment.txt

        ]]></command>
    <inputs>
        <!-- excluded: noimage, colfields, -f -->
        <!-- included via wrapper: -->

        <!-- required parameters -->
        <conditional name="inputsegment_cond">
            <param name="inputsegment_sel" type="select" multiple="false" label="Specify input type." help="">
                <option value="bed">Segmentation (bed)</option>
                <option value="post">Posterior (txt)</option>
            </param>
            <when value="bed">
                <param argument="inputsegment" type="data" format="bed" multiple="true" label="Select segmentation file." help=""/>
                <param argument="-labels" type="boolean" truevalue="-labels" falsevalue="" checked="false" label="Should labels be used?" help="The four column should be treated as having state labels instead of state IDs or state numbers. If the fourth column has a state ID or state number before a '_' and then followed by a label, the states will state be ordered by the state ID or number, otherwise the state ordering in the output may differ from the original state ordering."/>
            </when>
            <when value="post">
                <param argument="-posterior" type="data" format="txt" multiple="true" label="Select posterior file(s)." help="Use the full posterior for the enrichment opposed to the default of the maximum probability state assignments."/>
                <param argument="-a" type="text" value="" label="Specify cell type for which to compute the enrichment." help="By default (no value) the posterior enrichment is computed in aggregate over all cell types."/>
            </when>
        </conditional>
        <param name="assembly" type="select" label="Specify assembly." help="">
            <options from_data_table="chromhmm_assemblies">
                <validator message="No assembly is available" type="no_options"/>
            </options>
        </param>

        <!-- optional parameters -->
        <section name="ao" title="Advanced options">
            <param argument="-multicount" type="boolean" truevalue="-multicount" falsevalue="" checked="false" label="Should overlaps be counted multiple times?" help="This flag indicates to count overlaps multiple times when the –signal flag is not present. If the -signal flag is present overlaps are always counted multiple times. By default without the –signaloverlaps are only counted once. Overlaps are defined to either be at the base resolution or the bin resolution based on the –binresflag. If the input coordinate data for enrichments is known to be non-overlapping then including this flag can speed up the enrichment calculation without effecting the final results."/>
            <param argument="-b" type="integer" value="200" min="0" label="Set binsize." help="The number of base pairs in a bin determining the resolution of the model learning and segmentation."/>
            <param argument="-binres" type="boolean" truevalue="" falsevalue="" checked="false" label="Should enrichments be computed at the bin resolution?" help="Requires single base overlap of a coordinate for a bin to fully count the bin opposed to the default of base resolution."/>
            <param argument="-center" type="boolean" truevalue="-center" falsevalue="" checked="false" label="Use the center base for computing enrichments instead of the entire interval." help=""/>
            <param argument="-e" type="integer" value="1" label="Specify the amount that should be subtracted from the end coordinate so the coordinate is inclusive and 0 based." help="The default value is 1 corresponding to standard bed convention of the end interval being 0-based and exclusive."/>
            <param argument="-m" type="data" format="txt" multiple="false" optional="true" label="Select file that maps IDs to descriptive names." help="The descriptive names can be appended to the state IDs in the emission and transition files. The format of this file is a two column tab delimited file. The first column contains each state ID with the state ordering letter prefix. The second column contains a descriptive name or mnemonic. If this file is not specified, then just the state IDs are displayed. If reordering the states when applying this option the state number and prefix should match the reordered model. So if specifying a stateorderingfile, then the prefix should be U and the second column should have the new states. It can be simpler to relabel after reordering the states."/>
            <param argument="-s" type="integer" value="0" label="Set offset start." help="Specify the value that should be subtracted from the interval start coordinate so the interval is inclusive and 0 based. Default is 0 corresponding to the standard .bed convention."/>
            <param argument="-signal" type="boolean" truevalue="-signal" falsevalue="" checked="false" label="Should signal information be used in enrichments?" help="If available otherwise all overlaps are given equal weight. If signal is used coordinates without signal given will be assumed to have 0 signal in the enrichment calculation."/>
        </section>
        <section name="oo" title="Output options">
            <param name="overlapenrichment" type="select" multiple="true" optional="false" label="OverlapEnrichment: Which files should be created?" help="">
                <option value="txt" selected="true">txt</option>
                <option value="png">png</option>
                <option value="svg">svg</option>
            </param>
            <param argument="-color" type="text" value="0,0,255" label="Set heatmap color" help="Integer values between 0 and 255 separated by commas."/>
            <param argument="-uniformscale" type="boolean" truevalue="-uniformscale" falsevalue="" checked="false" label="Use the same color scale in heatmaps." help="The default is to have a column specific color scalewhich subtracts the minimum value in the column and then divides by the maximum column value."/>
        </section>
    </inputs>

    <outputs>
        <data name="out_overlapenrichment_txt" format="txt" from_work_dir="overlapenrichment.txt" label="${tool.name} on ${on_string}: OverlapEnrichment, txt">
            <filter>'txt' in str(oo['overlapenrichment'])</filter>
        </data>
        <data name="out_overlapenrichment_png" format="png" from_work_dir="overlapenrichment.png" label="${tool.name} on ${on_string}: OverlapEnrichment, png">
            <filter>'png' in str(oo['overlapenrichment'])</filter>
        </data>
        <data name="out_overlapenrichment_svg" format="svg" from_work_dir="overlapenrichment.svg" label="${tool.name} on ${on_string}: OverlapEnrichment, svg">
            <filter>'svg' in str(oo['overlapenrichment'])</filter>
        </data>
    </outputs> 

    <tests> 
        <!-- #1; required parameters; input: '_segments.bed', TES; output: all -->
        <test expect_num_outputs="3">
            <conditional name="inputsegment_cond">
                <param name="inputsegment_sel" value="bed"/>
                <param name="inputsegment" value="GM12878_2_segments.bed.gz"/>
            </conditional>
            <param name="assembly" value="hg18"/>
            <section name="oo">
                <param name="overlapenrichment" value="txt,png,svg"/>
            </section>
            <output name="out_overlapenrichment_png" file="overlapenrichment_test1.png"/>
            <output name="out_overlapenrichment_svg">
                <assert_contents>
                    <has_n_lines n="56"/>
                </assert_contents>
            </output>
            <output name="out_overlapenrichment_txt">
                <assert_contents>
                    <has_n_lines n="4"/>
                    <has_line_matching expression="state \(Emission order\)&#009;Genome.+"/>
                    <has_line_matching expression="Base&#009;.+"/>
                </assert_contents>
            </output>      
        </test>
        <!-- #2; required parameters; input: '_posterior.txt', TSS; output: all -->
        <test expect_num_outputs="3">
            <conditional name="inputsegment_cond">
                <param name="inputsegment_sel" value="post"/>
                <param name="posterior" value="GM12878_2_chr11_posterior.txt.gz"/>
            </conditional>
            <param name="assembly" value="hg18"/>
            <section name="oo">
                <param name="overlapenrichment" value="txt,png,svg"/>
            </section>
            <output name="out_overlapenrichment_png" file="overlapenrichment_test2.png"/>
            <output name="out_overlapenrichment_svg">
                <assert_contents>
                    <has_n_lines n="56"/>
                </assert_contents>
            </output>  
            <output name="out_overlapenrichment_txt">
                <assert_contents>
                    <has_n_lines n="4"/>
                    <has_line_matching expression="state \(Emission order\)&#009;Genome %&#009;.+"/>
                    <has_line_matching expression="2&#009;.+"/>
                </assert_contents>
            </output>      
        </test>
        <!-- #3; optional parameters; input: '_posterior.txt', no defaults; output: all -->
        <test expect_num_outputs="3">
            <conditional name="inputsegment_cond">
                <param name="inputsegment_sel" value="post"/>
                <param name="posterior" value="GM12878_2_chr11_posterior.txt.gz"/>
            </conditional>
            <param name="assembly" value="hg18"/>
            <section name="ao">
                <param name="b" value="190"/>
                <param name="e" value="2"/>
                <param name="s" value="1"/>
                <param name="multicount" value="true"/>
                <param name="binres" value="true"/>
                <param name="center" value="true"/>
                <param name="signal" value="true"/>
                <param name="uniformscale" value="true"/>
            </section>
            <section name="oo">
                <param name="color" value="10,80,190"/>
                <param name="overlapenrichment" value="txt,png,svg"/>
            </section>
            <output name="out_overlapenrichment_png" file="overlapenrichment_test3.png"/>
            <output name="out_overlapenrichment_svg">
                <assert_contents>
                    <has_n_lines n="56"/>
                </assert_contents>
            </output>  
            <output name="out_overlapenrichment_txt">
                <assert_contents>
                    <has_n_lines n="4"/>
                    <has_line_matching expression="state \(Emission order\)&#009;Genome %&#009;.+"/>
                    <has_line_matching expression="Base&#009;100&#009;.+"/>
                </assert_contents>
            </output>
        </test>
        <!-- #4; optional parameters; input: '_segments.bed', TSS, no defaults; output: txt,svg -->
        <test expect_num_outputs="2">
            <conditional name="inputsegment_cond">
                <param name="inputsegment_sel" value="bed"/>
                <param name="inputsegment" value="GM12878_2_segments.bed.gz"/>
            </conditional>
            <param name="assembly" value="hg18"/>
            <section name="ao">
                <param name="b" value="200"/>
                <param name="e" value="3"/>
                <param name="s" value="2"/>
                <param name="multicount" value="true"/>
                <param name="binres" value="true"/>
                <param name="center" value="true"/>
                <param name="signal" value="true"/>
                <param name="uniformscale" value="true"/>
            </section>
            <section name="oo">
                <param name="color" value="15,10,90"/>
                <param name="overlapenrichment" value="txt,svg"/>
            </section>
            <output name="out_overlapenrichment_svg">
                <assert_contents>
                    <has_n_lines n="56"/>
                </assert_contents>
            </output>  
            <output name="out_overlapenrichment_txt">
                <assert_contents>
                    <has_n_lines n="4"/>
                    <has_line_matching expression="state \(Emission order\)&#009;Genome %&#009;.+"/>
                    <has_line_matching expression="Base&#009;.+"/>
                </assert_contents>
            </output>
        </test>
        <!-- #5; missing: a, m, labels, t; todo -->
    </tests>
    <help><![CDATA[
.. class:: infomark

**What it does**

OverlapEnrichment @HELP_WID@

OverlapEnrichment can be used to compute the fold enrichment of each state of the segmentation for a set of external coordinates by default in bed format. Signal values can optionally be associated with each coordinate to weight the enrichments. The enrichment is outputted as a table in both text and image format. The directory COORDS contains the subdirectories hg18, hg19, hg38, mm9, mm10, rn5, rn6, danRer7, danRer10, dm3, dm6,ce6, and ce10. These directories include bed files for the RefSeq transcription start site, transcript end site, gene, exon, and regions within 2kb of the transcription start site of the corresponding assembly. Also CpG islands are included for hg18, hg19, hg38, mm9, mm10, rn5,and rn6. For hg18 and hg19 a set of coordinates on NuclearLamin domains from (Guelenet, Nature 2008) are also provided. Coordinates were obtained from the UCSC genome browser. A user can also provide theirown coordinates. By default the fold enrichment calculation is as follows, let:

A - be the number of bases in the state
B - be the number of bases in the external annotation
C - be the number of bases in the state and the external annotation
D - be the number of bases in the genomeThe fold enrichment is then defined as (C/A)/(B/D).

**Input**

...

**Output**

...

.. class:: infomark

**References**

@HELP_REFERENCES@
    ]]></help>
    <citations>
        <expand macro="citations"/>
        <!-- mentioned in manual -->
        <citation type="doi">10.1038/nature06947</citation> 
    </citations>
</tool>