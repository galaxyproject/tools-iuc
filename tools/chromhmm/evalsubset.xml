<?xml version="1.0"?>
<tool id="chromhmm_evalsubset" name="chromHMM EvalSubset" version="@TOOL_VERSION@+@WRAPPER_VERSION@">
    <description>of chromatin states</description>
    <macros>
        <import>macros.xml</import>
    </macros>
    <expand macro="requirements"/>
    <stdio></stdio>
    <command detect_errors="exit_code"><![CDATA[
        ## initialize
        @FUNCTIONS@
        mkdir -p 'input/POSTERIOR' 'input/STATEBYLINE' &&
        @IN_MODEL@

        #set $marks_available = []

        ## binary, segments, posterior and statebyline filenames must match
        #for $i, $s in enumerate($input_rep)
            ## 0: cell; 1: chr
            #set $listHeader = $fetchHeader($s.in_binary)

            ## binary
            ## <cell>_<chr>_binary.txt, e.g. GM12878_chr11_binary.txt
            echo $listHeader &&
            ln -s '${s.in_binary}' 'input/${listHeader[0]}_${listHeader[1]}_binary.txt' &&

            ## segments
            ## <cell>_<numstates>_segments.bed, e.g. GM12878_2_segments.bed
            #if $inputtype == 'seg'
                ln -s '${s.seg_post_state}' 'input/${listHeader[0]}_${numstates}_segments.bed' &&
            ## posterior
            ## POSTERIOR/<cell>_<numstates>_<chr>_posterior.txt, e.g. GM12878_2_chr11_posterior.txt
            #else if $inputtype == 'post'
                ln -s '${s.seg_post_state}' 'input/POSTERIOR/${listHeader[0]}_${numstates}_${listHeader[1]}_posterior.txt' &&
            ## statebyline
            ## STATEBYLINE/<cell>_<numstates>_<chr>_statebyline.txt, e.g. GM12878_2_chr11_statebyline.txt
            #else if $inputtype == 'state'
                ln -s '${s.seg_post_state}' 'input/STATEBYLINE/${listHeader[0]}_${numstates}_${listHeader[1]}_statebyline.txt' &&
            #end if

            ## marks can be found in the second (== 1) line of every '_binary.txt' file
            #set $marks_available = [x for j, x in enumerate(open(str($s.in_binary))) if j == 1][0].strip().split()
        #end for

        ## create bit string with '1' for a mark selected by user, and '0' else
        #set $marks_selected = str($includemarks).strip().split(',')
        #set $marks_bit = ''.join(['1' if j in $marks_selected else '0' for j in $marks_available])

        ## run
        @RUN@
            EvalSubset
            ## optional parameters
            #if $oo.append == 'append'
                -append
            #end if
            -b $ap.b
            $ap.many
            $ap.scalebeta
            -color '$oo.color'
            ## required parameters (specific order)
            #if $inputtype == 'post'
                -readposterior
            #else if $inputtype == 'state'
                -readstatesbyline
            #end if
            'model_${numstates}.txt' ## inputmodel
            'input' ## inputdir
            'input' ## segmentdir, required, even if empty
            'evalsubset' ## outconfusionfileprefix
            '$marks_bit' ## includemarks    
        ]]></command>
    <inputs>
        <expand macro="in_model" argument="(inputmodel)"/>
        <param name="inputtype" type="select" label="Select input file type" help="EvalSubSet can use four column segmentation bed files, a posterior probability or single states per line. If the posterior is used the confusion matrix is based on soft assignments. Only one file type is accepted per run. (segmentdir, -readposterior, -readstatesbyline)">
            <option value="seg">Segmentation</option>
            <option value="post">Posterior</option>
            <option value="state">StateByLine</option>
        </param>
        <repeat name="input_rep" title="Dataset" min="1" help="Per celltype and chromosome only one binary and corresponding posterior/statebyline/segment file allowed.">
            <expand macro="in_binary" multiple="false" label="Select binary input file."/>
            <param name="seg_post_state" type="data" format="bed,txt" label="Select segmentation, posterior or statebyline file" help="Only one file type is accepted per run."/>
        </repeat>
        <param argument="includemarks" type="text" value="" label="Set mark(s) to be included" help="Comma separated list, e.g. H3K9ac,H4K20me1,WCE">
            <validator type="empty_field"/>
        </param>

        <section name="ap" title="Advanced parameters">
            <expand macro="b"/>
            <expand macro="many"/>
            <expand macro="scalebeta"/>
        </section>

        <section name="oo" title="Output options">
            <expand macro="color"/>
            <param argument="-append" type="select" label="Append output to result or overwrite it? " help="">
                <option value="overwritten">Overwrite</option>
                <option value="append">Append</option>
            </param>
            <param name="matrix" type="select" multiple="true" label="Confusion matrix: Which files should be created?" help="">
                <option value="txt" selected="true">txt</option>
                <option value="png">png</option>
                <option value="svg">svg</option>
            </param>
        </section>
    </inputs>
    <outputs>
        <data name="out_matrix_txt" format="txt" from_work_dir="evalsubset.txt" label="${tool.name} on $(on_string) Confusion Matrix, txt">
            <filter>'txt' in str(oo['matrix'])</filter>
        </data>
        <data name="out_matrix_png" format="png" from_work_dir="evalsubset.png" label="${tool.name} on $(on_string) Confusion Matrix, png">
            <filter>'png' in str(oo['matrix'])</filter>
        </data>
        <data name="out_matrix_svg" format="svg" from_work_dir="evalsubset.svg" label="${tool.name} on $(on_string) Confusion Matrix, svg">
            <filter>'svg' in str(oo['matrix'])</filter>
        </data>
    </outputs>
    <tests>
        <!-- #1; required parameters; all outputs -->
        <test expect_num_outputs="3">
            <param name="in_model" value="model_2.txt"/>
            <param name="inputtype" value="seg"/>
            <repeat name="input_rep">
                <param name="in_binary" value="GM12878_chr11_binary.txt.gz"/>
                <param name="seg_post_state" value="GM12878_2_segments.bed.gz"/>
            </repeat>
            <repeat name="input_rep">
                <param name="in_binary" value="K562_chr11_binary.txt.gz"/>
                <param name="seg_post_state" value="K562_2_segments.bed.gz"/>
            </repeat>
            <param name="includemarks" value="CTCF,H3K27ac"/>
            <section name="oo">
                <param name="matrix" value="png,svg,txt"/>
            </section>
            <output name="out_matrix_png" file="evalsubset_test1.png"/>
            <output name="out_matrix_svg">
                <assert_contents>
                    <has_n_lines n="36"/>
                </assert_contents>
            </output>
            <output name="out_matrix_txt">
                <assert_contents>
                    <has_line_matching expression="EvalSubset&#009;1100000000.+"/>
                    <has_n_lines n="4"/>
                </assert_contents>
            </output>
        </test>
        <!-- #2; advanced parameters; posterior, no defaults -->
        <test expect_num_outputs="2">
            <param name="in_model" value="model_2.txt"/>
            <param name="inputtype" value="post"/>
            <repeat name="input_rep">
                <param name="in_binary" value="GM12878_chr11_binary.txt.gz"/>
                <param name="seg_post_state" value="GM12878_2_chr11_posterior.txt.gz"/>
            </repeat>
            <repeat name="input_rep">
                <param name="in_binary" value="K562_chr11_binary.txt.gz"/>
                <param name="seg_post_state" value="K562_2_chr11_posterior.txt.gz"/>
            </repeat>
            <param name="includemarks" value="CTCF,H3K27ac,H3K27me3,H3K36me3,H3K4me1,H3K4me2,H3K4me3,H3K9ac,H4K20me1,WCE"/>
            <section name="ap">
                <param name="b" value="180"/>
                <param name="many" value="true"/>
                <param name="scalebeta" value="true"/>
            </section>
            <section name="oo">
                <param name="matrix" value="txt,png"/>
                <param name="append" value="append"/>
                <param name="color" value="180,10,200"/>
            </section>
            <output name="out_matrix_txt">
                <assert_contents>
                    <has_line_matching expression="EvalSubset&#009;1111111111.+"/>
                    <has_n_lines n="4"/>
                </assert_contents>
            </output>
            <output name="out_matrix_png" file="evalsubset_test2.png"/>
        </test>
    </tests>
    <help><![CDATA[
.. class:: infomark

**What it does**

EvalSubset @HELP_WID@

@HELP_CHROMHMM@

EvalSubset evaluates the extent to which an existing segmentation can be recovered using only a subset of marks. The method takes an input the model used to generate an existing segmentation, the data used to generate the segmentation, the existing segmentation, an output file prefix, and which subset of marks to include. The output is a confusion matrix comparing the state assignments based on the full set of marks and those based on using the model learned on the full data but with the state assignments generated based only on a subset of inputs. Each row of the confusion matrix indicates the proportion of state assignments based on the full marks assigned to each state using a subset of marks (columns).

**Input**

@HELP_FILETYPE_MODEL@
@HELP_FILETYPE_BINARY@
@HELP_FILETYPE_SEGMENTS@
@HELP_FILETYPE_POSTERIOR@
@HELP_FILETYPE_STATEBYLINE@

**Output**

@HELP_FILETYPE_CONFUSION@

.. class:: infomark

**References**

@HELP_REFERENCES@
    ]]></help>
    <citations>
        <expand macro="citations"/>
    </citations>
</tool>