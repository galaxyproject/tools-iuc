<tool id="rna_star" name="RNA STAR" version="@VERSION@" profile="17.01">
    <description>Gapped-read mapper for RNA-seq data</description>
    <macros>
        <import>macros.xml</import>
    </macros>
    <expand macro="requirements"/>
    <expand macro="stdio" />

<!--
    important quote (https://groups.google.com/forum/#!topic/rna-star/q4zGzlPgwXY):
    Hi Gary,

    if you generate the genome with GTF file, and do not specify the value for  - -sjdbOverhang, it will be set to the default 100.
    If you want to be able to set arbitrary value of  - -sjdbOverhang on the fly, you have to generate the genome without annotations (GTF) - then you supply both the  - -sjdbOverhang and GTF file at the mapping step.

    Cheers
    Alex
-->
    <command><![CDATA[
    @TEMPINDEX@
    STAR
    @REFGENOMEHANDLING@

        --readFilesIn
        #if str($singlePaired.sPaired) == 'paired_collection':
            '$singlePaired.input.forward' '$singlePaired.input.reverse'

            #if $singlePaired.input.forward.is_of_type('fastq.gz', 'fastqsanger.gz'):
                @FASTQ_GZ_OPTION@
            #end if
        #else
            '$singlePaired.input1'
            #if str($singlePaired.sPaired) == 'paired':
                '$singlePaired.input2'
            #end if

            #if $singlePaired.input1.is_of_type('fastq.gz', 'fastqsanger.gz'):
                @FASTQ_GZ_OPTION@
            #end if
        #end if

        --outSAMtype BAM SortedByCoordinate

        ## Two pass mode
        --twopassMode ${twopass.twopassMode} ${twopass.twopass_read_subset}
        #for $sj_input in $twopass.sj_precalculated:
            '$sj_input'
        #end for
        #if str($twopass.twopassMode) != 'None':
            #if str($refGenomeSource.GTFconditional.GTFselect) == 'with-gtf':
                #if not $refGenomeSource.GTFconditional.sjdbGTFfile:
                    ## case of cached index without built-in gene model,
                    ## when user does not supply the optional gtf, but
                    ## specifies the splice junction overhang
                    --sjdbOverhang $refGenomeSource.GTFconditional.sjdbOverhang
                #end if
            #end if
        #end if

        --quantMode ${quantmode_output.quantMode}
        #if 'TranscriptomeSAM' in str($quantmode_output.quantMode):
            --quantTranscriptomeBan ${quantmode_output.quantTranscriptomeBan}
        #end if

        ## Output format parameters

        ## Read tags
        #set read_tags = str($oformat.outSAMattributes).split(',')
        #if 'XS' in str($oformat.outSAMattributes):
            ## STAR writes XS tag when --outSAMstrandField intronMotif is used
            $read_tags.remove('XS')
            --outSAMstrandField intronMotif
        #end if
        #if 'HI' in str($oformat.outSAMattributes):
            --outSAMattrIHstart ${oformat.HI_offset}
        #end if
        #set $tag_names = ' '.join($read_tags)
        --outSAMattributes $tag_names

        ## Read FLAG
        --outSAMprimaryFlag ${oformat.outSAMprimaryFlag}

        ## Read MAPQ
        --outSAMmapqUnique ${oformat.outSAMmapqUnique}

        ## Output filter parameters

        ## Basic Filters
        #if str($filter.basic_filters) != 'None':
            #set $filter_options = str($filter.basic_filters).split(',')
        #else:
            #set filter_options = []
        #end if
        #if 'exclude_unmapped' in $filter_options:
            $filter_options.remove('exclude_unmapped')
            --outSAMunmapped None
        #else:
            --outSAMunmapped Within
        #end if
        #if '--outFilterIntronMotifs RemoveNoncanonical' in $filter_options:
            ## RemoveNoncanonical excludes a superset of the reads excluded
            ## with RemoveNoncanonicalUnannotated
            #if '--outFilterIntronMotifs RemoveNoncanonicalUnannotated' in $filter_options:
                $filter_options.remove('--outFilterIntronMotifs RemoveNoncanonicalUnannotated')
            #end if
        #end if
        #echo ' '.join($filter_options)

        ## Other Filters
        #if str( $filter.output_params2.output_select2 ) == 'yes':
            --outFilterType $filter.output_params2.outFilterType
            --outFilterMultimapScoreRange $filter.output_params2.outFilterMultimapScoreRange
            --outFilterMultimapNmax $filter.output_params2.outFilterMultimapNmax
            --outFilterMismatchNmax $filter.output_params2.outFilterMismatchNmax
            --outFilterMismatchNoverLmax $filter.output_params2.outFilterMismatchNoverLmax
            --outFilterMismatchNoverReadLmax $filter.output_params2.outFilterMismatchNoverReadLmax
            --outFilterScoreMin $filter.output_params2.outFilterScoreMin
            --outFilterScoreMinOverLread $filter.output_params2.outFilterScoreMinOverLread
            --outFilterMatchNmin $filter.output_params2.outFilterMatchNmin
            --outFilterMatchNminOverLread $filter.output_params2.outFilterMatchNminOverLread
            --outSAMmultNmax $filter.output_params2.outSAMmultNmax
            --outSAMtlen $filter.output_params2.outSAMtlen
        #end if

        ## Other parameters
        #if str( $algo.params.settingsType ) == 'star_fusion':
            ## Preset parameters for STAR-Fusion
            --chimSegmentMin 12
            --chimJunctionOverhangMin 12
            --alignSJDBoverhangMin 10
            --alignMatesGapMax 100000
            --alignIntronMax 100000
            --chimSegmentReadGapMax 3
            --alignSJstitchMismatchNmax 5 -1 5 5
            --peOverlapNbasesMin 12
            --peOverlapMMp 0.1
            --chimMultimapScoreRange 10
            --chimMultimapNmax 10
            --chimNonchimScoreDropMin 10

        #elif str( $algo.params.settingsType ) == 'full':
            ## Extended parameter options

            ## Seed parameter options
            --seedSearchStartLmax ${algo.params.seed.seedSearchStartLmax}
            --seedSearchStartLmaxOverLread ${algo.params.seed.seedSearchStartLmaxOverLread}
            --seedSearchLmax ${algo.params.seed.seedSearchLmax}
            --seedMultimapNmax ${algo.params.seed.seedMultimapNmax}
            --seedPerReadNmax ${algo.params.seed.seedPerReadNmax}
            --seedPerWindowNmax ${algo.params.seed.seedPerWindowNmax}
            --seedNoneLociPerWindow ${algo.params.seed.seedNoneLociPerWindow}

            ## Alignment parameter options
            --alignIntronMin ${algo.params.align.alignIntronMin}
            --alignIntronMax ${algo.params.align.alignIntronMax}
            --alignMatesGapMax ${algo.params.align.alignMatesGapMax}
            --alignSJoverhangMin ${algo.params.align.alignSJoverhangMin}
            --alignSJDBoverhangMin ${algo.params.align.alignSJDBoverhangMin}
            --alignSplicedMateMapLmin ${algo.params.align.alignSplicedMateMapLmin}
            --alignSplicedMateMapLminOverLmate ${algo.params.align.alignSplicedMateMapLminOverLmate}
            --alignWindowsPerReadNmax ${algo.params.align.alignWindowsPerReadNmax}
            --alignTranscriptsPerWindowNmax ${algo.params.align.alignTranscriptsPerWindowNmax}
            --alignTranscriptsPerReadNmax ${algo.params.align.alignTranscriptsPerReadNmax}
            --alignEndsType ${algo.params.align.alignEndsType}
            --peOverlapNbasesMin ${algo.params.align.peOverlapNbasesMin}
            --peOverlapMMp ${algo.params.align.peOverlapMMp}
            ## Chimeric alignment parameter options
            #if str($chimOutType):
                --chimSegmentMin ${algo.params.chim_settings.chimSegmentMin}
                --chimScoreMin ${algo.params.chim_settings.chimScoreMin}
                --chimScoreDropMax $algo.params.chim_settings.chimScoreDropMax
                --chimScoreSeparation $algo.params.chim_settings.chimScoreSeparation
                --chimScoreJunctionNonGTAG $algo.params.chim_settings.chimScoreJunctionNonGTAG
                --chimSegmentReadGapMax $algo.params.chim_settings.chimSegmentReadGapMax
                --chimFilter $algo.params.chim_settings.chimFilter
                --chimJunctionOverhangMin $algo.params.chim_settings.chimJunctionOverhangMin
                --chimMainSegmentMultNmax $algo.params.chim_settings.chimMainSegmentMultNmax
                #if str($chimOutType) == 'Junctions':
                    --chimMultimapNmax $algo.params.chim_settings.chimMultimapNmax
                #else:
                    --chimMultimapNmax 0
                #end if
                --chimMultimapScoreRange $algo.params.chim_settings.chimMultimapScoreRange
            #end if

            ## Limits
            --limitOutSJoneRead $algo.params.limits.limitOutSJoneRead
            --limitOutSJcollapsed $algo.params.limits.limitOutSJcollapsed
            --limitSjdbInsertNsj $algo.params.limits.limitSjdbInsertNsj
        #else:
            ## Go with STAR's default algorithmic settings,
            ## but we need to provide a reasonable default
            ## (taken from STAR-Fusion)
            ## for --chimSegmentMin in case the user enabled chimeric
            ## alignments (the STAR default is 0, which disables chimeric
            ## alignments). For consistency, also set
            ## --chimMultimapNmax to 1 when chimeric alignments are reported
            ## in Junctions format only.
            #if str($chimOutType):
                --chimSegmentMin 12
                #if str($chimOutType) == 'Junctions':
                    --chimMultimapNmax 1
                #end if
            #end if
        #end if

        --outBAMsortingThreadN \${GALAXY_SLOTS:-4}
        --outBAMsortingBinsN $perf.outBAMsortingBinsN
        --limitBAMsortRAM \$((\${GALAXY_MEMORY_MB:-0}*1000000))

        ## Handle chimeric options and output
        #if str($chimOutType):
            --chimOutType $chimOutType
            #if 'Junctions' in str($chimOutType):
                --chimOutJunctionFormat 1
            #end if
        #end if
        &&
        ## recompress BAM output for smaller file size
        samtools view -b -o '$mapped_reads' Aligned.sortedByCoord.out.bam
        #if 'TranscriptomeSAM' in str($quantmode_output.quantMode):
            ## same recompression for optional transcriptome BM
            &&
            samtools view -b -o '$transcriptome_mapped_reads' Aligned.toTranscriptome.out.bam
        #end if
    ]]></command>

    <inputs>
        <!-- FASTQ input(s) and options specifically for paired-end data. -->
        <conditional name="singlePaired">
            <param name="sPaired" type="select" label="Single-end or paired-end reads">
                <option value="single" selected="true">Single-end</option>
                <option value="paired">Paired-end (as individual datasets)</option>
                <option value="paired_collection">Paired-end (as collection)</option>
            </param>
            <when value="single">
                <param format="fastq,fasta,fastq.gz,fastqsanger.gz" name="input1" type="data" label="RNA-Seq FASTQ/FASTA file"/>
            </when>
            <when value="paired">
                <param format="fastq,fasta,fastq.gz,fastqsanger.gz" name="input1" type="data" label="RNA-Seq FASTQ/FASTA file, forward reads"/>
                <param format="fastq,fasta,fastq.gz,fastqsanger.gz" name="input2" type="data" label="RNA-Seq FASTQ/FASTA file, reverse reads"/>
            </when>
            <when value="paired_collection">
                <param format="fastq,fasta,fastq.gz,fastqsanger.gz" name="input" type="data_collection" collection_type="paired" label="RNA-Seq FASTQ/FASTA paired reads"/>
            </when>
        </conditional>

        <!-- Genome source. -->
        <expand macro="refgenomehandling" />

        <conditional name="twopass">
            <param argument="--twopassMode" type="select"
            label="Use 2-pass mapping for more sensitive novel splice junction discovery"
            help="For a study with multiple samples, multisample 2-pass mapping is the most sensitive approach. It involves two separate runs of STAR for each sample, where, in the second run of each sample, the splice junctions found in any sample in the first runs are treated as additional known junctions. If you plan to use the mapping results as input for STAR-Fusion it is recommended that you use at least single-sample 2-pass mapping of all reads.">
                <option value="None">No</option>
                <option value="Basic">Yes, perform single-sample 2-pass mapping of all reads</option>
                <option value="Basic --twopass1readsN">Yes, but base novel splice junction detection in the first pass on a subset of all reads (faster, but less sensitive than single-sample 2-pass mode)</option>
                <option value="None --sjdbFileChrStartEnd">Yes, I want to use multi-sample 2-pass mapping and I have obtained splice junctions datasets of all samples through previous 1-pass runs of STAR.</option>
            </param>
            <when value="None">
                <param name="twopass_read_subset" type="hidden" value="" />
                <param name="sj_precalculated" type="hidden" value="" />
            </when>
            <when value="Basic">
                <param name="twopass_read_subset" type="hidden" value="" />
                <param name="sj_precalculated" type="hidden" value="" />
            </when>
            <when value="Basic --twopass1readsN">
                <param name="sj_precalculated" type="hidden" value="" />
                <param argument="--twopass1readsN" name="twopass_read_subset" type="integer" min="1" value="50000" label="Number of reads to map in the first pass"/>
            </when>
            <when value="None --sjdbFileChrStartEnd">
                <param name="twopass_read_subset" type="hidden" value="" />
                <param name="sj_precalculated" type="data" multiple="true" format="interval"
                label="Pregenerated splice junctions datasets of your samples" />
            </when>
        </conditional>
        <conditional name="quantmode_output">
            <param argument="--quantMode" type="select"
            label="Per gene/transcript output"
            help="STAR can provide analysis results not only with respect to the reference genome, but also with respect to genes and transcripts described by a gene model. Note: This functionality requires either the selection above of a cached index with a gene model, or a gene model provided alongside the index/reference genome in GTF or GFF3 format!">
                <option value="-">No per gene or transcript output</option>
                <option value="GeneCounts">Per gene read counts (GeneCounts)</option>
                <option value="TranscriptomeSAM">Transcript-based BAM output (TranscriptomeSAM)</option>
                <option value="TranscriptomeSAM GeneCounts">Both per gene read counts and transcript-based BAM output (TranscriptomeSAM GeneCounts)</option>
            </param>
            <when value="-" />
            <when value="GeneCounts" />
            <when value="TranscriptomeSAM">
                <param argument="--quantTranscriptomeBan" type="boolean" truevalue="IndelSoftclipSingleend" falsevalue="Singleend"
                label="Exclude alignments with indels or soft clipping from the transcriptome BAM output?"
                help="You will need to exclude alignments with indels and soft-clipped bases from the transcriptome BAM output for compatibility with certain transcript quantification tools, most notably RSEM. If you are using a tool, like eXpress, that can deal with indels and soft-clipped bases, you can achieve better results by leaving this option disabled." />
            </when>
            <when value="TranscriptomeSAM GeneCounts">
                <param argument="--quantTranscriptomeBan" type="boolean" truevalue="IndelSoftclipSingleend" falsevalue="Singleend"
                label="Exclude alignments with indels or soft clipping from the transcriptome BAM output?"
                help="You will need to exclude alignments with indels and soft-clipped bases from the transcriptome BAM output for compatibility with certain transcript quantification tools, most notably RSEM. If you are using a tool, like eXpress, that can deal with indels and soft-clipped bases, you can achieve better results by leaving this option disabled." />
            </when>
        </conditional>
        <param argument="--chimOutType" type="select"
        label="Report chimeric alignments?"
        help="Choose if and how chimeric alignments should be reported. STAR-Fusion users should select the 'Junctions' option and use the resulting tabular dataset as input to STAR-Fusion. Everyone else: note that selecting 'WithinBAM' or 'WithinBAM Junctions' disables the --chimMultimapNmax setting in the algorithmic parameters section below (the tool will only consider uniquely mapped reads in the search for chimeric alignments). If you disable the reporting of chimeric alignments here, then all chimeric alignment settings in the algorithmic parameters section below will be ignored.">
            <option value="">Don't report chimeric alignments</option>
            <option value="Junctions">As separate tabular "Junctions" output (Junctions)</option>
            <option value="WithinBAM">Within the BAM output (together with regular alignments; WithinBAM)</option>
            <option value="WithinBAM Junctions">In both forms (WithinBAM Junctions)</option>
        </param>

        <section name="oformat" title="BAM output format specification" expanded="true">
            <param argument="--outSAMattributes" type="select" display="checkboxes" multiple="true" optional="true"
            label="Read alignment tags to include in the BAM output"
            help="Note on using the XS tag: If the XS tag is used, STAR will filter out alignments with undefined strand (i.e., those containing only non-canonical unannotated junctions). Using this tag is recommended if you plan to use the STAR results with STAR-Fusion. In addition, it is required for compatibility
with Cufflinks if your sequences come from an unstranded library preparation.">
                <option value="NH" selected="true">NH (number of reported alignments/hits for the read)</option>
                <option value="HI" selected="true">HI (query hit index)</option>
                <option value="AS" selected="true">AS (local alignment score)</option>
                <option value="nM" selected="true">nM (number of mismatches per (paired) alignment)</option>
                <option value="XS">XS (strand flag, see parameter help below) </option>
                <option value="NM">NM (edit distance of the aligned read to the reference)</option>
                <option value="MD">MD (string for mismatching positions)</option>
                <option value="MC">MC (CIGAR string for mate/next segment)</option>
                <option value="jM">jM (intron motifs for all junctions)</option>
                <option value="jI">jI (1-based start and end of introns for all junctions)</option>
                <option value="ch" selected="true">ch (used to indicate chimeric alignments)</option>
            </param>
            <param argument="--outSAMattrIHstart" name="HI_offset" type="select" display="radio"
            label="HI tag values should be">
                <option value="1" selected="true">one-based</option>
                <option value="0">zero-based</option>
            </param>
            <!-- Using - -outSAMprimaryFlag AllBestScore would cause a
            violation of the SAM/BAM spec, which says:
            "For each read/contig in a SAM file, it is required that one and
            only one line associated with the read satisfies
            ‘FLAG & 0x900 == 0’.
            This line is called the primary line of the read."

            Thus, this parameter has been removed from the tool interface:
            <param argument="- -outSAMprimaryFlag" type="boolean"
            truevalue="AllBestScore" falsevalue="OneBestScore" checked="false"
            label="Would you like all alignments with the best score labeled
            primary?"/> -->
            <param name="outSAMprimaryFlag" type="hidden" value="OneBestScore" />
            <param argument="--outSAMmapqUnique" type="integer" value="60" min="30" max="255"
            label="MAPQ value for unique mappers"
            help="STAR bases the mapping quality scores of alignment records in its BAM output on the number of alternative mappings for the read. If a read maps to multiple locations on the reference genome, the following MAPQ scoring scheme is
used: >=5 mappings => MAPQ=0; 3-4 mappings => MAPQ=1; 2 mappings => MAPQ=3. This setting lets you control the MAPQ used for reads mapped to a single location. Set to 255 for compatibility with Cufflinks." />
        </section>
        <section name="filter" title="Output filter criteria" expanded="true">
            <param name="basic_filters" type="select" display="checkboxes" multiple="true" optional="true"
            label="Exclude the following records from the BAM output">
                <option value="exclude_unmapped">Unmapped reads</option>
                <option value="--outFilterIntronStrands RemoveInconsistentStrands">Alignments that have junctions with inconsistent strands</option>
                <option value="--outFilterIntronMotifs RemoveNoncanonicalUnannotated">Alignments across unannotated non-canonical junctions</option>
                <option value="--outFilterIntronMotifs RemoveNoncanonical">All alignments across non-canonical junctions (recommended for compatibility with Cufflinks)</option>
            </param>
            <!-- Additional output parameter settings. -->
            <conditional name="output_params2">
                <param name="output_select2" type="select" label="Would you like to set additional output filters?">
                    <option value="no" selected="true">No</option>
                    <option value="yes">Yes</option>
                </param>
                <when value="yes">
                    <param argument="--outFilterType" type="boolean" truevalue="BySJout" falsevalue="Normal" checked="false" label="Would you like to keep only reads that contain junctions that passed filtering?"/>
                    <param argument="--outFilterMultimapScoreRange" type="integer" value="1" min="0" label="Score range below the maximum score for multimapping alignments"/>
                    <param argument="--outFilterMultimapNmax" type="integer" value="10" min="1" label="Maximum number of alignments to output a read's alignment results, plus 1" help="Reads with at least this number of alignments will have no alignments output"/>
                    <param argument="--outFilterMismatchNmax" type="integer" value="10" min="0" label="Maximum number of mismatches to output an alignment, plus 1" help="Alignments with at least this number of mismatches will not be output"/>
                    <param argument="--outFilterMismatchNoverLmax" type="float" value="0.3" min="0" max="1" label="Maximum ratio of mismatches to mapped length" help="Alignments with a mismatch ratio of at least this value will not be output"/>
                    <param argument="--outFilterMismatchNoverReadLmax" type="float" value="1" min="0" max="1" label="Maximum ratio of mismatches to read length" help="Alignments with a mismatch ratio of at least this value will not be output"/>
                    <param argument="--outFilterScoreMin" type="integer" value="0" min="0" label="Minimum alignment score" help="Alignments must have scores higher than this value to be output"/>
                    <param argument="--outFilterScoreMinOverLread" type="float" value="0.66" min="0" max="1" label="Minimum alignment score, normalized to read length" help="Alignments must have (normalized) scores higher than this value to be output"/>
                    <param argument="--outFilterMatchNmin" type="integer" value="0" min="0" label="Minimum number of matched bases" help="Alignments must have the number of matched bases higher than this value to be output"/>
                    <param argument="--outFilterMatchNminOverLread" type="float" value="0.66" min="0" max="1" label="Minimum number of matched bases, normalized to read length" help="Alignments must have the (normalized) number of matched bases higher than this value to be output"/>
                    <param argument="--outSAMmultNmax" type="integer" value="-1" min="-1" label="Maximum number of multimapping alignments to output for a read" help="A value of -1 (the default) results in all alignments (up to –-outFilterMultimapNmax) being output" />
                    <param argument="--outSAMtlen" type="select" label="Calculation method for TLEN">
                        <option value="1" selected="true">leftmost base of the (+)strand mate to rightmost base of the (-)mate. (+)sign for the (+)strand mate</option>
                        <option value="2">leftmost base of any mate to rightmost base of any mate. (+)sign for the mate with the leftmost base. This is different from 1 for overlapping mates with protruding ends</option>
                    </param>
                </when>
                <when value="no"/>
            </conditional>
        </section>

        <!-- Algorithmic settings. -->
        <section name="algo" title="Algorithmic settings" expanded="true">
            <conditional name="params">
                <param name="settingsType" type="select" label="Configure seed, alignment and limits options">
                    <option value="default" selected="true">Use Defaults</option>
                    <option value="star_fusion">Use parameters suggested for STAR-Fusion</option>
                    <option value="full">Extended parameter list</option>
                </param>
                <when value="default"/>
                <!-- Set STAR-fusion parameters in command section -->
                <when value="star_fusion"/>

                <when value="full">
                    <section name="seed" title="Seed parameters" expanded="false">
                        <param argument="--seedSearchStartLmax" type="integer" min="1" value="50" label="Search start point through the read"/>
                        <param argument="--seedSearchStartLmaxOverLread" type="float" min="0" value="1.0" label="Search start point through the read, normalized to read length"/>
                        <param argument="--seedSearchLmax" type="integer" min="0" value="0" label="Maximum length of seeds" help="Default of 0 indicates no maximum length"/>
                        <param argument="--seedMultimapNmax" type="integer" min="1" value="10000" label="Maximum number of mappings to use a piece in stitching"/>
                        <param argument="--seedPerReadNmax" type="integer" min="1" value="1000" label="Maximum number of seeds per read"/>
                        <param argument="--seedPerWindowNmax" type="integer" min="1" value="50" label="Maximum number of seeds per window"/>
                        <param argument="--seedNoneLociPerWindow" type="integer" min="1" value="10" label="Maximum number of one seed loci per window"/>
                    </section>

                    <section name="align" title="Alignment parameters" expanded="false">
                        <param argument="--alignIntronMin" name="alignIntronMin" type="integer" min="0" value="21" label="Minimum intron size"/>
                        <param argument="--alignIntronMax" type="integer" min="0" value="0" label="Maximum intron size"/>
                        <param argument="--alignMatesGapMax" type="integer" min="0" value="0" label="Maximum gap between two mates"/>
                        <param argument="--alignSJoverhangMin" type="integer" min="1" value="5" label="Minimum overhang for spliced alignments"/>
                        <param argument="--alignSJDBoverhangMin" type="integer" min="1" value="3" label="Minimum overhang for annotated spliced alignments"/>
                        <param argument="--alignSplicedMateMapLmin" type="integer" min="0" value="0" label="Minimum mapped length for a read mate that is spliced"/>
                        <param argument="--alignSplicedMateMapLminOverLmate" type="float" min="0" value="0.66" label="Minimum mapped length for a read mate that is spliced, normalized to mate length"/>
                        <param argument="--alignWindowsPerReadNmax" type="integer" min="1" value="10000" label="Maximum number of windows per read"/>
                        <param argument="--alignTranscriptsPerWindowNmax" type="integer" min="1" value="100" label="Maximum number of transcripts per window"/>
                        <param argument="--alignTranscriptsPerReadNmax" type="integer" min="1" value="10000" label="Maximum number of different alignments per read to consider"/>
                        <param argument="--alignEndsType" type="boolean" truevalue="EndToEnd" falsevalue="Local" checked="false" label="Use end-to-end read alignments, with no soft-clipping?"/>
                        <param argument="--peOverlapNbasesMin" type="integer" min="0" value="0"
                        label="minimum number of overlap bases to trigger mates merging and realignment" />
                        <param argument="--peOverlapMMp" type="float" min="0" max="1" value="0.01"
                        label="maximum proportion of mismatched bases in the overlap area" />
                    </section>
                    <section name="chim_settings" title="Chimeric alignment parameters" expanded="false">
                        <param argument="--chimSegmentMin" type="integer" min="1" value="12"
                        label="Minimum length of chimeric segment"
                        help="For small numbers this will cause large number of chimeric alignments. A value of 12 is commonly used." />
                        <param argument="--chimScoreMin" type="integer" min="0" value="0"
                        label="Minimum total (summed) score of chimeric segments"/>
                        <param argument="--chimScoreDropMax" type="integer" min="0" value="20"
                        label="Maximum difference of chimeric score from read length"/>
                        <param argument="--chimScoreSeparation" type="integer" min="0" value="10"
                        label="Minimum difference between the best chimeric score and the next one"/>
                        <param argument="--chimScoreJunctionNonGTAG" type="integer" value="-1"
                        label="Penalty for a non-GT/AG chimeric junction"/>
                        <param argument="--chimJunctionOverhangMin" type="integer" min="0" value="20"
                        label="Minimum overhang for a chimeric junction"/>
                        <param argument="--chimSegmentReadGapMax" type="integer" min="0" value="0"
                        label="Maximum gap in the read sequence between chimeric segments" />
                        <param argument="--chimFilter" type="boolean" truevalue="banGenomicN" falsevalue="None" checked="true"
                        label="Discard chimeric alignments with Ns in the genome sequence around the chimeric junction" />
                        <param argument="--chimMainSegmentMultNmax" type="integer" min="1" value="10"
                        label="Maximum number of multi-alignments for the main chimeric segment."
                        help="A value of 1 prohibits multimapping main segments"/>
                        <param argument="--chimMultimapNmax" type="integer" min="1" value="1"
                        label="Maximum number of chimeric multi-alignments"
                        help="The default value of 1 only considers unique alignments. If you chose to report chimeric alignments alongside regular ones in the BAM output, this setting is ignored and only uniquely mapping chimeric reads get reported. " />
                        <param argument="--chimMultimapScoreRange" type="integer" min="0" value="1"
                        label="Score range for multi-mapping chimeras"
                        help="The threshold below the best chimeric score that a multimapping chimera must have to be output. This is ignored unless --chimMultimapNmax is above 1" />
                    </section>
                    <section name="limits" title="Limits" expanded="false">
                        <param argument="--limitOutSJoneRead" type="integer" min="1" value="1000" label="Maximum number of junctions for one read (including all multimappers)" />
                        <param argument="--limitOutSJcollapsed" type="integer" min="1" value="1000000" label="Maximum number of collapsed junctions" />
                        <param argument="--limitSjdbInsertNsj" type="integer" min="0" value="1000000" label="Maximum number of inserts to be inserted into the genome on the fly." />
                    </section>
                </when>
            </conditional>
        </section>
        <section name="perf" title="Performance tweaks / Troubleshooting" expanded="false">
            <param argument="--outBAMsortingBinsN" type="integer" value="50" min="1" label="Number of genome bins for coordinate-sorting" help="Higher values result in lower RAM requirements during the sorting step. The default value is 50. Tweak this if you are facing memory-related errors." />
        </section>
    </inputs>

    <outputs>
        <data format="txt" name="output_log" label="${tool.name} on ${on_string}: log" from_work_dir="Log.final.out">
            <expand macro="dbKeyActions" />
        </data>

        <data format="interval" name="chimeric_junctions" label="${tool.name} on ${on_string}: chimeric junctions" from_work_dir="Chimeric.out.junction">
            <filter>('Junctions' in chimOutType)</filter>
            <expand macro="dbKeyActions" />
        </data>

        <data format="interval" name="splice_junctions" label="${tool.name} on ${on_string}: splice junctions.bed" from_work_dir="SJ.out.tab">
            <expand macro="dbKeyActions" />
        </data>

        <data name="mapped_reads" format="bam" label="${tool.name} on ${on_string}: mapped.bam">
            <expand macro="dbKeyActions" />
        </data>

        <data name="transcriptome_mapped_reads" format="unsorted.bam" label="${tool.name} on ${on_string}: transcriptome-mapped.bam" >
            <filter>'TranscriptomeSAM' in quantmode_output['quantMode']</filter>
            <expand macro="dbKeyActions" />
        </data>

        <data name="reads_per_gene" format="tabular" label="${tool.name} on ${on_string}: reads per gene" from_work_dir="ReadsPerGene.out.tab">
            <filter>'GeneCounts' in quantmode_output['quantMode']</filter>
            <expand macro="dbKeyActions" />
        </data>
    </outputs>

    <tests>
        <test expect_num_outputs="3">
            <conditional name="singlePaired">
                <param name="sPaired" value="single" />
                <param name="input1" value="tophat_in2.fastqsanger" ftype="fastqsanger" />
            </conditional>
            <conditional name="refGenomeSource">
                <param name="geneSource" value="history" />
                <param name="genomeFastaFiles" value="tophat_test.fa" />
                <param name="genomeSAindexNbases" value="5" />
            </conditional>
            <section name="oformat">
                <param name="outSAMattributes" value="NH,HI,AS,nM,NM,MD,jM,jI,MC,ch" />
                <param name="outSAMmapqUnique" value="255" />
            </section>
            <section name="algo">
                <conditional name="params">
                    <param name="settingsType" value="default" />
                </conditional>
            </section>
            <output name="output_log" file="rnastar_test.log" compare="re_match_multiline" />
            <output name="splice_junctions" file="rnastar_test_splicejunctions.bed"/>
            <output name="mapped_reads" file="rnastar_test_mapped_reads.bam" compare="sim_size" delta="634" />
        </test>
        <!-- test with cached genome index -->
        <test expect_num_outputs="3">
            <conditional name="singlePaired">
                <param name="sPaired" value="single" />
                <param name="input1" value="tophat_in2.fastqsanger" ftype="fastqsanger" />
            </conditional>
            <conditional name="refGenomeSource">
                <param name="geneSource" value="indexed" />
                <conditional name="GTFconditional">
                    <param name="GTFselect" value="with-gtf" />
                    <param name="genomeDir" value="001" />
                </conditional>
            </conditional>
            <section name="oformat">
                <param name="outSAMattributes" value="NH,HI,AS,nM,NM,MD,jM,jI,MC,ch" />
                <param name="outSAMmapqUnique" value="255" />
            </section>
            <section name="algo">
                <conditional name="params">
                    <param name="settingsType" value="default" />
                </conditional>
            </section>
            <output name="output_log" file="rnastar_test.log" compare="re_match_multiline" />
            <output name="splice_junctions" file="rnastar_test_splicejunctions.bed"/>
            <output name="mapped_reads" file="rnastar_test_mapped_reads.bam" compare="sim_size" delta="634" />
        </test>
        <!-- test gtf file and GeneCounts mode -->
        <test expect_num_outputs="4">
            <conditional name="singlePaired">
                <param name="sPaired" value="single" />
                <param name="input1" value="tophat_in2.fastqsanger" ftype="fastqsanger" />
            </conditional>
            <conditional name="refGenomeSource">
                <param name="geneSource" value="history" />
                <param name="genomeFastaFiles" value="tophat_test.fa" />
                <param name="genomeSAindexNbases" value="5" />
                <conditional name="GTFconditional">
                    <param name="GTFselect" value="with-gtf" />
                    <param name="sjdbOverhang" value="75"/>
                    <param name="sjdbGTFfile" value="test1.gtf" ftype="gtf"/>
                </conditional>
            </conditional>
            <conditional name="quantmode_output">
                <param name="quantMode" value="GeneCounts"/>
            </conditional>
            <section name="oformat">
                <param name="outSAMattributes" value="NH,HI,AS,nM,NM,MD,jM,jI,MC,ch" />
                <param name="outSAMmapqUnique" value="255" />
            </section>
            <section name="algo">
                <conditional name="params">
                    <param name="settingsType" value="default" />
                </conditional>
            </section>

            <output name="output_log" file="rnastar_test.log" compare="re_match_multiline" />
            <output name="splice_junctions" file="rnastar_test_splicejunctions.bed"/>
            <output name="mapped_reads" file="rnastar_test_mapped_reads.bam" compare="sim_size" delta="634" />
            <output name="reads_per_gene" file="tophat_test_reads_per_gene.txt" />
        </test>
        <!-- test gtf file and TranscriptomeSAM mode -->
        <test expect_num_outputs="4">
            <conditional name="singlePaired">
                <param name="sPaired" value="single" />
                <param name="input1" value="tophat_in2.fastqsanger" ftype="fastqsanger" />
            </conditional>
            <conditional name="refGenomeSource">
                <param name="geneSource" value="history" />
                <param name="genomeFastaFiles" value="tophat_test.fa" />
                <param name="genomeSAindexNbases" value="5" />
                <conditional name="GTFconditional">
                    <param name="GTFselect" value="with-gtf" />
                    <param name="sjdbOverhang" value="75"/>
                    <param name="sjdbGTFfile" value="test1.gtf" ftype="gtf"/>
                </conditional>
            </conditional>
            <conditional name="quantmode_output">
                <param name="quantMode" value="TranscriptomeSAM"/>
            </conditional>
            <section name="oformat">
                <param name="outSAMattributes" value="NH,HI,AS,nM,NM,MD,jM,jI,MC,ch" />
                <param name="outSAMmapqUnique" value="255" />
            </section>
            <section name="algo">
                <conditional name="params">
                    <param name="settingsType" value="default" />
                </conditional>
            </section>

            <output name="output_log" file="rnastar_test.log" compare="re_match_multiline" />
            <output name="splice_junctions" file="rnastar_test_splicejunctions.bed"/>
            <output name="mapped_reads" file="rnastar_test_mapped_reads.bam" compare="sim_size" delta="634" />
            <output name="transcriptome_mapped_reads" file="rnastar_test_transcriptome_mapped_reads.bam" />
        </test>
        <test expect_num_outputs="3">
            <conditional name="singlePaired">
                <param name="sPaired" value="single" />
                <param name="input1" value="tophat_in2.fastqsanger" ftype="fastqsanger" />
            </conditional>
            <conditional name="refGenomeSource">
                <param name="geneSource" value="history" />
                <param name="genomeFastaFiles" value="tophat_test.fa" />
                <param name="genomeSAindexNbases" value="5" />
            </conditional>
            <section name="oformat">
                <param name="outSAMattributes" value="NH,HI,AS,nM,NM,MD,jM,jI,MC,ch,XS" />
                <param name="outSAMmapqUnique" value="255" />
            </section>
            <section name="filter">
                <param name="basic_filters" value="exclude_unmapped,--outFilterIntronMotifs RemoveNoncanonical" />
                <conditional name="output_params2">
                    <param name="output_select2" value="yes" />
                    <param name="outFilterScoreMinOverLread" value="0.9" />
                </conditional>
            </section>
            <section name="algo">
                <conditional name="params">
                    <param name="settingsType" value="full" />
                    <section name="seed">
                        <param name="seed_select" value="yes" />
                        <param name="seedSearchStartLmax" value="25" />
                    </section>
                </conditional>
            </section>

            <output name="output_log" file="rnastar_test2.log" compare="re_match_multiline" />
            <output name="splice_junctions" file="rnastar_test2_splicejunctions.bed"/>
            <output name="mapped_reads" file="rnastar_test2_mapped_reads.bam" compare="sim_size" delta="200" />
        </test>
        <test expect_num_outputs="4">
            <conditional name="singlePaired">
                <param name="sPaired" value="single" />
                <param name="input1" value="test3.fastqsanger" ftype="fastqsanger" />
            </conditional>
            <conditional name="refGenomeSource">
                <param name="geneSource" value="history" />
                <param name="genomeFastaFiles" value="test3.ref.fa" />
                <param name="genomeSAindexNbases" value="5" />
            </conditional>
            <param name="chimOutType" value="Junctions" />
            <section name="oformat">
                <param name="outSAMattributes" value="NH,HI,AS,nM,NM,MD,jM,jI,MC,ch,XS" />
                <param name="outSAMmapqUnique" value="255" />
            </section>
            <section name="algo">
                <conditional name="params">
                    <param name="settingsType" value="star_fusion" />
                </conditional>
            </section>

            <output name="chimeric_junctions" file="test3.chimjunc.tabular" compare="diff" lines_diff="2"/>
        </test>
        <test expect_num_outputs="4"><!-- tests fastqsanger.gz -->
            <conditional name="singlePaired">
                <param name="sPaired" value="single" />
                <param name="input1" value="test3.fastqsanger.gz" ftype="fastqsanger.gz" />
            </conditional>
            <conditional name="refGenomeSource">
                <param name="geneSource" value="history" />
                <param name="genomeFastaFiles" value="test3.ref.fa" />
                <param name="genomeSAindexNbases" value="5" />
            </conditional>
            <param name="chimOutType" value="Junctions" />
            <section name="oformat">
                <param name="outSAMattributes" value="NH,HI,AS,nM,NM,MD,jM,jI,MC,ch,XS" />
                <param name="outSAMmapqUnique" value="255" />
            </section>
            <section name="algo">
                <conditional name="params">
                    <param name="settingsType" value="star_fusion" />
                </conditional>
            </section>

            <output name="chimeric_junctions" file="test3.chimjunc.tabular" compare="diff" lines_diff="2"/>
        </test>
        <test expect_num_outputs="3">
            <conditional name="singlePaired">
                <param name="sPaired" value="single" />
                <param name="input1" value="tophat_in2.fastqsanger" ftype="fastqsanger" />
            </conditional>
            <conditional name="refGenomeSource">
                <param name="geneSource" value="history" />
                <param name="genomeFastaFiles" value="tophat_test.fa" />
                <param name="genomeSAindexNbases" value="5" />
            </conditional>
            <section name="oformat">
                <param name="outSAMattributes" value="NH,HI,AS,nM,NM,MD,jM,jI,MC,ch" />
                <param name="outSAMmapqUnique" value="255" />
            </section>
            <section name="filter">
                <param name="basic_filters" value="--outFilterIntronMotifs RemoveNoncanonical" />
                <conditional name="output_params2">
                    <param name="output_select2" value="yes" />
                </conditional>
            </section>
            <section name="algo">
                <conditional name="params">
                    <param name="settingsType" value="full" />
                </conditional>
            </section>

            <output name="output_log" file="rnastar_test.log" compare="re_match_multiline" />
            <output name="splice_junctions" file="rnastar_test_splicejunctions.bed"/>
            <output name="mapped_reads" file="rnastar_test_mapped_reads.bam" compare="sim_size" delta="634" />
        </test>
        <!-- twopass mode tests -->
        <!-- test Basic twopass -->
        <test expect_num_outputs="3">
            <conditional name="singlePaired">
                <param name="sPaired" value="single" />
                <param name="input1" value="tophat_in2.fastqsanger" ftype="fastqsanger" />
            </conditional>
            <conditional name="refGenomeSource">
                <param name="geneSource" value="history" />
                <param name="genomeFastaFiles" value="tophat_test.fa" />
                <param name="genomeSAindexNbases" value="5" />
            </conditional>
            <conditional name="twopass">
                <param name="twopassMode" value="Basic" />
            </conditional>
            <section name="oformat">
                <param name="outSAMattributes" value="NH,HI,AS,nM,NM,MD,jM,jI,MC,ch" />
                <param name="outSAMmapqUnique" value="255" />
            </section>
            <section name="filter">
                <param name="basic_filters" value="exclude_unmapped,--outFilterIntronMotifs RemoveNoncanonical" />
                <conditional name="output_params2">
                    <param name="output_select2" value="yes" />
                </conditional>
            </section>
            <section name="algo">
                <conditional name="params">
                    <param name="settingsType" value="full" />
                </conditional>
            </section>

            <output name="output_log" file="rnastar_test_twopass.log" compare="re_match_multiline" />
            <output name="splice_junctions" file="rnastar_test_splicejunctions_twopass.bed"/>
            <output name="mapped_reads" file="rnastar_test_mapped_reads_twopass.bam" compare="sim_size" delta="634" />
        </test>
        <!-- test Basic twopass without a gtf file option -->
        <test expect_num_outputs="3">
            <conditional name="singlePaired">
                <param name="sPaired" value="single" />
                <param name="input1" value="tophat_in2.fastqsanger" ftype="fastqsanger" />
            </conditional>
            <conditional name="refGenomeSource">
                <param name="geneSource" value="indexed" />
                <conditional name="GTFconditional">
                    <param name="GTFselect" value="without-gtf" />
                    <param name="genomeDir" value="000" />
                </conditional>
            </conditional>
            <conditional name="twopass">
                <param name="twopassMode" value="Basic" />
            </conditional>
            <section name="oformat">
                <param name="outSAMattributes" value="NH,HI,AS,nM,NM,MD,jM,jI,MC,ch" />
                <param name="outSAMmapqUnique" value="255" />
            </section>
            <section name="filter">
                <param name="basic_filters" value="exclude_unmapped,--outFilterIntronMotifs RemoveNoncanonical" />
                <conditional name="output_params2">
                    <param name="output_select2" value="yes" />
                </conditional>
            </section>
            <section name="algo">
                <conditional name="params">
                    <param name="settingsType" value="full" />
                </conditional>
            </section>

            <output name="output_log" file="rnastar_test_twopass.log" compare="re_match_multiline" />
            <output name="splice_junctions" file="rnastar_test_splicejunctions_twopass.bed"/>
            <output name="mapped_reads" file="rnastar_test_mapped_reads_twopass.bam" compare="sim_size" delta="634" />
        </test>
        <!-- test "multisample" twopass -->
        <test expect_num_outputs="3">
            <conditional name="singlePaired">
                <param name="sPaired" value="single" />
                <param name="input1" value="tophat_in2.fastqsanger" ftype="fastqsanger" />
            </conditional>
            <conditional name="refGenomeSource">
                <param name="geneSource" value="history" />
                <param name="genomeFastaFiles" value="tophat_test.fa" />
                <param name="genomeSAindexNbases" value="5" />
            </conditional>
            <conditional name="twopass">
                <param name="twopassMode" value="None --sjdbFileChrStartEnd" />
                <param name="sj_precalculated" value="rnastar_test_splicejunctions_twopass.bed" />
            </conditional>
            <section name="oformat">
                <param name="outSAMattributes" value="NH,HI,AS,nM,NM,MD,jM,jI,MC,ch" />
                <param name="outSAMmapqUnique" value="255" />
            </section>
            <section name="filter">
                <param name="basic_filters" value="exclude_unmapped,--outFilterIntronMotifs RemoveNoncanonicalUnannotated,--outFilterIntronMotifs RemoveNoncanonical" />
                <conditional name="output_params2">
                    <param name="output_select2" value="yes" />
                </conditional>
            </section>
            <section name="algo">
                <conditional name="params">
                    <param name="settingsType" value="full" />
                </conditional>
            </section>

            <output name="output_log" file="rnastar_test_twopass.log" compare="re_match_multiline" />
            <output name="splice_junctions" file="rnastar_test_splicejunctions_twopass.bed"/>
            <output name="mapped_reads" file="rnastar_test_mapped_reads_twopass.bam" compare="sim_size" delta="634" />
        </test>
    </tests>
    <help><![CDATA[
**What it does**

STAR_ is an ultrafast universal RNA-seq aligner.

**Compatibility Notes**

STAR has a huge amount of options to filter alignments and to configure the
exact format of its output.

Some tools you may plan to use in your downstream analysis of the results are known to be sensitive to these settings or combinations of them.

*STAR-Fusion*

STAR-Fusion_ can use the chimeric junctions output of STAR as input, but you
need to enable **chimeric alignment detection** by STAR for that dataset to be
generated. Hence, be sure to select:

**Report chimeric alignments?**: `As separate tabular "Junctions" output (Junctions)`.

In addition, for best results it is recommended_ that you

- use **2-pass mapping** for more sensitive novel splice junction discovery

- under *BAM output format specification*,
  **Read alignment tags to include in the BAM output**: select `XS` as an
  additional tag to generate (this is the equivalent of using
  `--outSAMstrandField intronMotif` on the command line)

- under *Algorithmic settings*, **Configure seed, alignment and limits options**:
  `use parameters suggested for STAR-Fusion`.

*Cufflinks*

.. class:: infomark

   Cufflinks is not considered to be the best tool for use downstream of STAR
   anymore. Consider using *Stringtie* instead, which also should pose no
   compatibility issues.

To avoid compatibility issues with Cufflinks you should:

- select **XS** as a *Read alignment tag to include in the BAM output* if (and
  only if) your sequenced reads come from an unstranded library prep
- *not* select the *jM* and *jI* tags for inclusion
- keep the **HI** tag selected and
- select *HI tag values should be* **zero-based**
- exclude **All alignments across non-canonical junctions** under *Output
  filter criteria -> Exclude the following records from the BAM output*

-----

Attribution

Minor tweaks to output names to suit downstream purposes, toolshed automated
dependencies and odds and ends of other code and documentation comprising
this tool were originally written by Ross Lazarus and have been licensed under
the creative commons
`BY-NC_ND 3.0 license <http://creativecommons.org/licenses/by-nc-nd/3.0/>`__.

.. _STAR: https://github.com/alexdobin/STAR
.. _STAR-Fusion: https://github.com/STAR-Fusion/STAR-Fusion
.. _recommended: https://github.com/STAR-Fusion/STAR-Fusion/wiki#alternatively-kickstart-mode-running-star-yourself-and-then-running-star-fusion-using-the-existing-outputs
    ]]></help>
    <expand macro="citations"/>
</tool>
