<tool name="STR to bed" id="microsatbed" version="1.3.2" profile="22.05">
  <description>Short Tandem Repeats to bed features from fasta</description>
  <requirements>
    <requirement version="3.12.3" type="package">python</requirement>
    <requirement version="2.1.0" type="package">pyfastx</requirement>
    <requirement version="1.3.2" type="package">pytrf</requirement>
    <requirement version="0.2.0" type="package">pybigtools</requirement>
  </requirements>
   <required_files>
      <include path="find_str.py"/>
  </required_files>
   <version_command><![CDATA[python -c "import pytrf; from importlib.metadata import version; print(version('pytrf'))"]]></version_command>
  <command><![CDATA[
  #if $mode_cond.mode == "NATIVE":
    #if $reference_genome.genome_type_select == "history":
      pytrf findstr -f '$mode_cond.outformat' -o $bed -r $monomin $dimin $trimin $tetramin $pentamin $hexamin '${reference_genome.fasta}'
    #else:
      pytrf findstr -f '$mode_cond.outformat' -o $bed -r $monomin $dimin $trimin $tetramin $pentamin $hexamin '${reference_genome.fasta.fields.path}'
    #end if
  #else:
    python '${__tool_directory__}/find_str.py'
    #if $reference_genome.genome_type_select == "history":
      --fasta '${reference_genome.fasta}'
    #else:
      --fasta '${reference_genome.fasta.fields.path}'
    #end if
    --bed '$bed'
    #if $mode_cond.mode == "SPECIFIC":
    --specific '$mode_cond.specific'
    #elif $mode_cond.mode == "SPECIFICBW":
    --bigwig
    --winwidth '$mode_cond.winwidth'
    --specific '$mode_cond.specific'
    #else:
      #if "MONO" in $mode_cond.subset:
      --mono
      #end if
      #if "DI" in $mode_cond.subset:
      --di
      #end if
      #if "TRI" in $mode_cond.subset:
      --tri
      #end if
      #if "TETRA" in $mode_cond.subset:
      --tetra
      #end if
      #if "PENTA" in $mode_cond.subset:
      --penta
      #end if
      #if "HEXA" in $mode_cond.subset:
      --hexa
      #end if
    #end if
    --monomin '$monomin'
    --dimin '$dimin'
    --trimin '$trimin'
    --tetramin '$tetramin'
    --pentamin '$pentamin'
    --hexamin '$hexamin'
    #if $mode_cond.mode == "SPECIFICBW":
    --bigwig
    --winwidth '$mode_cond.winwidth'
    #end if
  #end if
]]></command>
  <inputs>
    <conditional name="reference_genome">
        <param name="genome_type_select" type="select" label="Select a source for fasta sequences to be searched for STRs" help="Options are to choose a built-in genome, or choose any history fasta file">
            <option value="indexed">Use a Galaxy server built-in reference genome fasta</option>
            <option value="history" selected="True">Use any fasta file from the current history</option>
        </param>
        <when value="indexed">
            <param name="fasta" type="select" multiple="false" label="Choose a built-in genome" 
                help="If the genome you need is not on the list, upload it and select it as a current history fasta">
                <options from_data_table="all_fasta"/>
            </param>
        </when>
        <when value="history">
            <param name="fasta" type="data" format="fasta,fasta.gz" optional="false" multiple="false" label="Choose a fasta file from the current history"/>
        </when>
    </conditional>
    <conditional name="mode_cond">
    <param name="mode" type="select" label="Select patterns by motif length; or provide a specific motif pattern to report?" help="Choose *By length:* or *By pattern:* to configure STR selection mode">
      <option selected="True" value="ALL">By length: Report all motifs of one or more specified lengths (1-6nt) as bed features</option>
      <option value="ALLBW">By length as windowed bigwig: Report all motifs of one or more specified lengths (1-6nt) as windowed density</option>
      <option value="SPECIFIC">By motif: Report one or more specific motifs (such as TCA,GC) as bed features</option>
      <option value="SPECIFICBW">By motif as windowed bigwig: Report one or more specific motifs (such as TCA,GC) as windowed density</option>
      <option value="NATIVE">All exact STR: use the pytrf findstr native command to a create csv, tsv or gtf output</option>
    </param>
    <when value="ALL">
      <param name="subset" type="select" multiple="true" optional="false" label="Select at least 1 specific motif length to report" 
        help="Bed features will be output for every motif of the selected length(s) with the minimum required repeats or more">
      <option value="DI" selected="true">All dimers (AC,AG,AT,...)</option>
      <option value="TRI">All trimers (ACG,..)</option>
      <option value="TETRA">All tetramers (ACGT,..)</option>
      <option value="PENTA">All pentamers (ACGTC,..)</option>
      <option value="HEXA">All hexamers (ACGTCG,..)</option>
      <option value="MONO">All monomers (A,C...). Warning! Can produce overwhelming numbers of bed features</option>
      </param>
    </when>
    <when value="ALLBW">
      <param name="subset" type="select" multiple="true" optional="false" label="Select at least 1 specific motif length to report" 
        help="Bed features will be output for every motif of the selected length(s) with the minimum required repeats or more">
      <option value="DI" selected="true">All dimers (AC,AG,AT,...)</option>
      <option value="TRI">All trimers (ACG,..)</option>
      <option value="TETRA">All tetramers (ACGT,..)</option>
      <option value="PENTA">All pentamers (ACGTC,..)</option>
      <option value="HEXA">All hexamers (ACGTCG,..)</option>
      <option value="MONO">All monomers (A,C...). Warning! Can produce overwhelming numbers of bed features</option>
      </param>
      <param type="integer" min="5" name="winwidth" label="Window with for estimating STR bigwig density" value="128"/>
    </when>
    <when value="SPECIFIC">
      <param name="specific" type="text" label="Supply a specific motif pattern. Separate multiple patterns with commas such as GA,GC" 
         help="Make bed features only for the nominated specific motifs." optional="false"/>
    </when>
    <when value="SPECIFICBW">
      <param name="specific" type="text" label="Supply a specific motif pattern. Separate multiple patterns with commas such as GA,GC" 
         help="Make bed features only for the nominated specific motifs." optional="false"/>
      <param type="integer" min="5" name="winwidth" label="Window with for estimating STR bigwig density" value="128"/>
    </when>
    <when value="NATIVE">
      <param name="outformat" type="select" optional="false" label="Select the required output format" 
        help="Pytrf can create GFF, CSV or TSV output files. Documentation is linked in the help section below">
        <option value="gff" >GFF</option>
        <option value="csv">Comma separated values</option>
        <option value="tsv" selected="true">Tab separated values</option>
      </param>
    </when>
    </conditional>
    <param type="integer" min="2" name="monomin" value="10"/>
    <param type="integer" min="1" name="dimin" value="3"/>
    <param type="integer" min="2" name="trimin" value="2"/>
    <param type="integer" min="2" name="tetramin" value="2"/>
    <param type="integer" min="2" name="pentamin" value="2"/>
    <param type="integer" min="2" name="hexamin" value="2"/>
  </inputs>
  <outputs>
    <data name="bed" format="bed" label="STR from $fasta.element_identifier" hidden="false">
      <change_format>
            <when input="mode_cond.outformat" value="gff" format="gff" />
            <when input="mode_cond.outformat" value="csv" format="csv" />
            <when input="mode_cond.outformat" value="tsv" format="tabular" />
            <when input="mode_cond.mode" value="ALLBW" format="bigwig" />
            <when input="mode_cond.mode" value="SPECIFICBW" format="bigwig" />
      </change_format>
    </data>
  </outputs>
  <tests>
    <test expect_num_outputs="1">
      <conditional name="reference_genome">
          <param name="genome_type_select" value="history"/>
          <param name="fasta" value="humsamp.fa"/>
      </conditional>
      <conditional name="mode_cond">
          <param name="mode" value="ALL"/>
          <param name="subset" value="DI,TRI,TETRA,PENTA,HEXA"/>
      </conditional>
      <param name="monomin" value="20"/>
      <param name="dimin" value="20"/>
      <param name="trimin" value="5"/>
      <param name="tetramin" value="5"/>
      <param name="pentamin" value="3"/>
      <param name="hexamin" value="2"/>
      <output name="bed" value="bed_sample" compare="diff" lines_diff="0"/>
    </test>    
    <test expect_num_outputs="1">
      <conditional name="reference_genome">
          <param name="genome_type_select" value="history"/>
          <param name="fasta" value="humsamp.fa"/>
      </conditional>
      <conditional name="mode_cond">
          <param name="mode" value="SPECIFIC"/>
          <param name="specific" value="GC"/>
      </conditional>
      <param name="monomin" value="20"/>
      <param name="dimin" value="1"/>
      <param name="trimin" value="20"/>
      <param name="tetramin" value="20"/>
      <param name="pentamin" value="20"/>
      <param name="hexamin" value="20"/>
      <output name="bed" value="dibed_sample" compare="diff" lines_diff="0"/>
    </test>
    <test expect_num_outputs="1">
      <conditional name="reference_genome">
          <param name="genome_type_select" value="history"/>
          <param name="fasta" value="mouse.fa"/>
      </conditional>
      <conditional name="mode_cond">
          <param name="mode" value="NATIVE"/>
          <param name="outformat" value="gff"/>
      </conditional>
      <param name="monomin" value="20"/>
      <param name="dimin" value="10"/>
      <param name="trimin" value="5"/>
      <param name="tetramin" value="4"/>
      <param name="pentamin" value="4"/>
      <param name="hexamin" value="2"/>
      <output name="bed" value="nativegff_sample" compare="diff" lines_diff="0"/>
    </test>
    <test expect_num_outputs="1">
      <conditional name="reference_genome">
          <param name="genome_type_select" value="history"/>
          <param name="fasta" value="humsamp.fa"/>
      </conditional>
      <conditional name="mode_cond">
          <param name="mode" value="SPECIFICBW"/>
          <param name="specific" value="GC"/>
      </conditional>
      <param name="monomin" value="20"/>
      <param name="dimin" value="1"/>
      <param name="trimin" value="20"/>
      <param name="tetramin" value="20"/>
      <param name="pentamin" value="20"/>
      <param name="hexamin" value="20"/>
      <output name="bed" value="dibed_wig_sample" compare="sim_size" delta="10"/>
    </test>
  </tests>
  <help><![CDATA[

 **Convert short repetitive sequences to bed features**

 Microsatellites are usually defined as repeated short DNA patterns in an unbroken sequence.
 A microsatellite pattern or *motif* can be any combination nucleotides, typically from 1 to 6nt in length.
 
 This tool allows microsatellite and related features to be selected from a fasta sequence input file, and output into a single bed track, suitable for viewing in a genome browser such as JBrowse2.

 All motifs of selected lengths can be reported as individual features in the output bed file, or specific motifs can be provided and all 
 others will be ignored. In all cases, a minimum required number of repeats can be specified. For example, requiring 2 or more repeats of the trimer *ACG* will report 
 every sequence of *ACGACG* or *ACGACGACG* or *ACGACGACGACG* and so on, as individual bed features.  Similarly, requiring 3 repeats of any trimer will 
 report every distinct 3 nucleotide pattern, including *ACGACGACG* as well as every other unique 3 nucleotide pattern with 3 sequential repeats or more such, as "CTCCTCCTC*.

 For other output formats, the pytrf native command line *findstr* can be used to produce a gff, csv or tsv output containing all exact short tandem repeats, as 
 described at the end of https://pytrf.readthedocs.io/en/latest

 A fasta file must be supplied for processing. A built in genome can be selected, or a fasta file of any kind can be selected from the current history. Note that all 
 symbols are treated as valid nucleotides by pytrf, so extraneous characters such as *-* or *N* in the input fasta may appear as unexpected bed features. Lower case fasta symbols will be converted
 to uppercase, to prevent them being reported as distinct motifs.


 **Select motifs by length**
 
 The default tool form setting is to select all dimer motif patterns. 
 
 Additional motif lengths from 1 to 6nt can be selected in the multiple-select drop-down list. All features will be returned in a single bed file. For each selected motif length, 
 the minimum number of repeats required for reporting can be adjusted. **Tandem repeats** are defined as at least 2 of any pattern. This tool allows singleton motifs to be reported,
 so is not restricted to short tandem repeats (STR)

 **Select motifs by pattern**

 This option allows a motif pattern to be specified as a text string such as *CG* or *ATC*. Multiple motifs can be specified as a comma separated string such as *CG,ATC*.
 All features will be returned as a single bed file.

 The minimum number of repeats for all motifs can be set to match specific requirements.

 For example, technical sequencing read bias may be influenced by the density of specific dimers, whether they are repeated or not
 such as in https://github.com/arangrhie/T2T-Polish/tree/master/pattern
 
 **Select all perfect STR using pytrf findstr in csv, tsv or gff output format**

This selection runs the pytrf *findstr* option to create gff/csv/tsv outputs as described at the end of https://pytrf.readthedocs.io/en/latest/. 

Quoted here:

   *A Tandem repeat (TR) in genomic sequence is a set of adjacent short DNA sequence repeated consecutively. The core sequence or repeat unit is generally called motif. 
   According to the motif length, tandem repeats can be classified as microsatellites and minisatellites. Microsatellites are also known as simple sequence repeats (SSRs) 
   or short tandem repeats (STRs) with motif length of 1-6 bp. Minisatellites are also sometimes referred to as variable number of tandem repeats (VNTRs) has longer motif length than microsatellites.
   Pytrf is a lightweight Python C extension for identification of tandem repeats. The pytrf enables to fastly identify both exact or perfect SSRs.
   It also can find generic tandem repeats with any size of motif, such as with maximum motif length of 100 bp. Additionally, it has capability of finding approximate or imperfect tandem repeats*
 
  ]]></help>
  <citations>
    <citation type="bibtex">@misc{pytrf,
  title = {{pytrf} Short tandem repeat finder, Accessed on July 10 2024},
  howpublished = {\url{https://github.com/lmdu/pytrf}},
  note = {Accessed on July 10 2024}
}</citation>
  </citations>
</tool>

