<tool id="stacks_denovomap" name="STACKS: De novo map"  version="@WRAPPER_VERSION@.0" force_history_refresh="True">
    <description>Run the STACKS denovo_map.pl wrapper</description>
    <macros>
        <import>macros.xml</import>
    </macros>
    <expand macro="requirements"/>
    <expand macro="stdio"/>
    <command><![CDATA[

        mkdir stacks_outputs

        &&

        denovo_map.pl

            -T \${GALAXY_SLOTS:-1}

            #if str( $options_usage.options_usage_selector ) == "genetic"
                #for $input_parent in $options_usage.parent_sequence:
                    -p ${input_parent}
                #end for

                -A $options_usage.cross_type

                #if str( $options_usage.options_progeny.options_progeny_selector ) == "yes"
                    #for $input_progeny in $options_usage.options_progeny.progeny_sequence:
                        -r ${input_progeny}
                    #end for
                    #if $options_usage.options_progeny.P
                        -P $options_usage.options_progeny.P
                    #end if
                #end if
            #else
                #for $input in $options_usage.individual_sample:
                    -s ${input}
                #end for
                #if str( $options_usage.options_popmap.popmap_selector) == "yes"
                    -O $options_usage.options_popmap.popmap
                #end if
            #end if

            #if $assembly_options.m
                -m $assembly_options.m
            #end if
            #if $assembly_options.N
                -N $assembly_options.N
            #end if
            -M $assembly_options.M
            -n $assembly_options.n
            -t $assembly_options.t
            -H $assembly_options.H

            ## Batch description
            -b 1

            ## No SQL recording
            -S

            ## snp_model
            #if str( $snp_options.select_model.model_type) == "bounded"
                --bound_low $snp_options.select_model.bound_low
                --bound_high $snp_options.select_model.bound_high
                --alpha $snp_options.select_model.alpha
            #else
                --alpha $snp_options.select_model.alpha
            #end if

            -o stacks_outputs

            ##if $options_output_infos_selector != "collection":
                ## &&
                ## TODO we need to create the zips here
            ##end if
    ]]></command>

    <inputs>
        <conditional name="options_usage">
            <param name="options_usage_selector" type="select" label="Select your usage">
                <option value="genetic" selected="true">Genetic map</option>
                <option value="population">Population</option>
            </param>
            <when value="genetic">
                <param name="parent_sequence" argument="-p" format="fastqsanger,fasta,zip,tar.gz" type="data" multiple="true" label="Files containing parent sequences" help="FASTQ/FASTA/ZIP/TAR.GZ files containing parent sequences from a mapping cross" /><!-- TODO clarify input types, and paired data handling-->
                <param name="paired" type="boolean" checked="false" default="false" label="Paired-end fastq files?" help="be careful, all files must have a paired-end friend"/><!-- FIXME this is probably useless (simply discard the R2 files) -->

                <conditional name="options_progeny">
                    <param name="options_progeny_selector" type="select" label="Use progeny files">
                        <option value="yes" selected="true">Yes</option>
                        <option value="no">No</option>
                    </param>
                    <when value="yes">
                        <param name="progeny_sequence" argument="-r" format="fastqsanger,fasta,zip,tar.gz" type="data" multiple="true" label="Files containing progeny sequences" help="FASTQ/FASTA/ZIP/TAR.GZ files containing progeny sequences from a mapping cross" />
                        <param name="P" argument="-P" type="integer" value="" optional="true" label="Minimum number of identical, raw reads required to create a stack in 'progeny' individuals" /> <!-- FIXME move this to assembly_optons section? -->
                    </when>
                    <when value="no">
                    </when>
                </conditional>
                <param name="cross_type" argument="-A" type="select" label="Cross type" help="please see below for details"> <!-- TODO find complete names-->
                    <option value="CP">CP (F1 cross)</option>
                    <option value="F2">F2 (F2 cross)</option>
                    <option value="BC1">BC1 (backcross)</option>
                    <option value="DH">DH (double haploid cross)</option>
                    <option value="GEN">GEN</option>
                </param>
            </when>
            <when value="population">
                <param name="individual_sample" format="fastqsanger,fasta,zip,tar.gz" type="data" multiple="true" label="Files containing an individual sample from a population" help="FASTQ/FASTA/ZIP/TAR.GZ files contiaining an individual sample from a population" />
                <conditional name="options_popmap">
                    <param name="popmap_selector" type="select" label="Analyzing one or more populations?" >
                        <option value="no" selected="true">No</option>        
                        <option value="yes">Yes</option>
                    </param>
                    <when value="no"></when>
                    <when value="yes">
                        <param name="popmap" argument="-O" type="data" format="tabular,txt" label="Specify a population map" help="If analyzing one or more populations, specify a population map" />
                    </when>
                </conditional>
            </when>
        </conditional>

        <!-- stack assembly options -->
        <section name="assembly_options" title="Assembly options" expanded="false">
            <param name="m" argument="-m" type="integer" value="" optional="true" label="Minimum number of identical raw reads required to create a stack" />
            <param name="M" argument="-M" type="integer" value="2" label="Number of mismatches allowed between loci when processing a single individual"/>
            <param name="N" argument="-N" type="integer" value="" optional="true" label="Number of mismatches allowed when aligning secondary reads" help="default is [-M]+2" />
            <param name="n" argument="-n" type="integer" value="1" label="specify the number of mismatches allowed between loci when building the catalog"/>
            
            <param name="t" argument="-t" type="boolean" checked="false" default="false" truevalue="-t" falsevalue="" label="Remove, or break up, highly repetitive RAD-Tags in the ustacks program" />
            <param name="H" argument="-H" type="boolean" checked="false" default="false" truevalue="-H" falsevalue="" label="Disable calling haplotypes from secondary reads" />
        </section>

        <!-- SNP Model options -->
        <section name="snp_options" title="SNP Model Options (ustacks options)" expanded="False">
            <conditional name="select_model">
                <param name="model_type" type="select" label="Choose the model"> <!-- FIXME is it required? no corresponding option in help page -->
                    <option value="snp" selected="true">SNP</option>
                    <option value="bounded">Bounded</option>
                </param>
                <when value="snp">
                    <param name="alpha" argument="--alpha" type="select" format="float" label="Chi square significance level required to call a heterozygote or homozygote [--alpha]" >
                        <option value="0.1">0.1</option>
                        <option value="0.05" selected="True">0.05</option>
                        <option value="0.01">0.01</option>
                        <option value="0.001">0.001</option>
                    </param>
                </when>
                <when value="bounded">
                    <param name="bound_low" argument="--bound_low" type="float" value="0.0" min="0.0" max="1.0" label="lower bound for epsilon, the error rate [--bound_low]" help="between 0 and 1.0"/>
                    <param name="bound_high" argument="--bound_high" type="float" value="1.0" min="0.0" max="1.0" label="upper bound for epsilon, the error rate [--bound_high]" help="between 0 and 1.0" />
                    <param name="alpha" argument="--alpha" type="select" label="Chi square significance level required to call a heterozygote or homozygote [--alpha]" >
                        <option value="0.1">0.1</option>
                        <option value="0.05" selected="True">0.05</option>
                        <option value="0.01">0.01</option>
                        <option value="0.001">0.001</option>
                    </param>
                </when>
            </conditional>
        </section>
        <!-- Output options -->
        <param name="output_compress" type="select" label="Output type" help="please see below for details">
            <option value="default" selected="true">No compression</option>        
            <option value="categories">Compressed by categories</option>
            <option value="total">Compressed all outputs</option>
        </param>
    </inputs>
    <outputs>
        <data format="txt" name="output_log" label="result.log with ${tool.name} on ${on_string}" from_work_dir="stacks_outputs/denovo_map.log" />

        <data format="tabular" name="catalogsnps" label="catalog.snps with ${tool.name} on ${on_string}" from_work_dir="stacks_outputs/batch_1.catalog.snps.tsv" />
        <data format="tabular" name="catalogalleles" label="catalog.alleles with ${tool.name} on ${on_string}" from_work_dir="stacks_outputs/batch_1.catalog.alleles.tsv" />
        <data format="tabular" name="catalogtags" label="catalog.tags with ${tool.name} on ${on_string}" from_work_dir="stacks_outputs/batch_1.catalog.tags.tsv" />

        <collection name="tags" type="list" label="Assembled loci from ${on_string}">
            <discover_datasets pattern="(?P&lt;name&gt;.+)tags\.tsv" ext="tabular" directory="stacks_outputs" visible="true" />
        </collection>

        <collection name="snps" type="list" label="Model calls from each locus on ${on_string}">
            <discover_datasets pattern="(?P&lt;name&gt;.+)snps\.tsv" ext="tabular" directory="stacks_outputs" visible="true" />
        </collection>

        <collection name="alleles" type="list" label="Haplotypes/alleles recorded from each locus on ${on_string}">
            <discover_datasets pattern="(?P&lt;name&gt;.+)alleles\.tsv" ext="tabular" directory="stacks_outputs" visible="true" />
        </collection>

        <collection name="matches" type="list" label="Matches to the catalog on ${on_string}">
            <discover_datasets pattern="(?P&lt;name&gt;.+)matches\.tsv" ext="tabular" directory="stacks_outputs" visible="true" />
        </collection>

        <data format="txt" name="additional" label="additional file with ${tool.name}" hidden="true"> <!-- FIXME do we expect something more here?-->
              <discover_datasets pattern="__designation_and_ext__" directory="stacks_outputs" visible="true" />
        </data>


        <!-- additionnal output archives -->
        <data format="zip" name="total_output" label="total_output.zip with ${tool.name} on ${on_string}" >
           <filter>output_compress == "total"</filter>
        </data>
        <data format="zip" name="tags_output" label="tags_output.zip with ${tool.name} on ${on_string}" >
           <filter>output_compress == "categories"</filter>
        </data>
        <data format="zip" name="snps_output" label="snps_output.zip with ${tool.name} on ${on_string}" >
           <filter>output_compress == "categories"</filter>
        </data>
        <data format="zip" name="alleles_output" label="alleles_output.zip with ${tool.name} on ${on_string}" >
           <filter>output_compress == "categories"</filter>
        </data>
        <data format="zip" name="matches_output" label="matches_output.zip with ${tool.name} on ${on_string}" >
           <filter>output_compress == "categories"</filter>
        </data>
    </outputs>

    <tests>
        <test><!-- FIXME fails because cannot determine file type based on input file extension -->
            <param name="options_usage|options_usage_selector" value="genetic"/>
            <param name="options_usage|parent_sequence" value="procrad/PopA_01.1.fq" />
            <param name="options_usage|options_progeny|progeny_sequence" value="procrad/PopA_02.1.fq" />
            <output name="catalogalleles" ftype="tabular" file="Parents_catalog.alleles_with_STACKS___De_novo_map.tabular" />
            <output name="catalogsnps" ftype="tabular" file="Parents_catalog.snps_with_STACKS___De_novo_map.tabular" />
            <output name="catalogtags" ftype="tabular" file="Parents_catalog.tags_with_STACKS___De_novo_map.tabular" />
            <output name="output_log">
                <assert_contents>
                    <has_text text="Loaded 33021 RAD-Tags; inserted 5129 elements into the RAD-Tags hash map" />
                </assert_contents>
            </output>
        </test>
        <!--test>
            <param name="options_usage|individual_sample" ftype="zip" value="Parents.zip" />
            <param name="options_usage|options_popmap|popmap_selector" value="no" />
            <param name="assembly_options|m" value="3" />
            <param name="assembly_options|M" value="3" />
            <param name="assembly_options|N" value="2" />
            <param name="assembly_options|n" value="0" />
            <param name="assembly_options|t" value="false" />
            <param name="assembly_options|H" value="false" />
            <output name="catalogalleles" ftype="tabular" file="Parents_catalog.alleles_with_STACKS___De_novo_map.tabular" />
            <output name="catalogsnps" ftype="tabular" file="Parents_catalog.snps_with_STACKS___De_novo_map.tabular" />
            <output name="catalogtags" ftype="tabular" file="Parents_catalog.tags_with_STACKS___De_novo_map.tabular" />
            <output name="output_log">
                <assert_contents>
                    <has_text text="Loaded 33021 RAD-Tags; inserted 5129 elements into the RAD-Tags hash map" />
                </assert_contents>
            </output>
        </test-->
    </tests>

    <help>

.. class:: infomark

**What it does**

This program will run each of the Stacks components: first, running ustacks on each of the samples specified, building loci and calling SNPs in each. Second, cstacks will be run to create a catalog of all loci that were marked as 'parents' or 'samples' on the command line, and finally, sstacks will be executed to match each sample against the catalog. A bit more detail on this process can be found in the FAQ. The denovo_map.pl program will also load the results of each stage of the analysis: individual loci, the catalog, and matches against the catalog into the database (although this can be disabled). After matching, the program will build a database index to speed up access (index_radtags.pl) and enable web-based filtering. 

--------

**Created by:**

Stacks was developed by Julian Catchen with contributions from Angel Amores, Paul Hohenlohe, and Bill Cresko

--------

**Example:**

Input files:

FASTQ, FASTA, zip, tar.gz

- Population map::

    indv_01    1
    indv_02    1
    indv_03    1
    indv_04    2
    indv_05    2
    indv_06    2


Output files:

- XXX.tags.tsv file::

    Column    Name                     Description
    1         Sql ID                   This field will always be "0", however the MySQL database will assign an ID when it is loaded.
    2         Sample ID                Each sample passed through Stacks gets a unique id for that sample.
    3         Stack ID                 Each stack formed gets an ID.
    4         Chromosome               If aligned to a reference genome using pstacks, otherwise it is blank.
    5         Basepair                 If aligned to ref genome using pstacks.
    6         Strand                   If aligned to ref genome using pstacks.
    7         Sequence Type            Either 'consensus', 'primary' or 'secondary', see the Stacks paper for definitions of these terms.
    8         Sequence ID              The individual sequence read that was merged into this stack.
    9         Sequence                 The raw sequencing read.
    10        Deleveraged Flag         If "1", this stack was processed by the deleveraging algorithm and was broken down from a larger stack.
    11        Blacklisted Flag         If "1", this stack was still confounded depsite processing by the deleveraging algorithm.
    12        Lumberja ckstack Flag    If "1", this stack was set aside due to having an extreme depth of coverage.

Notes: For the tags file, each stack will start in the file with a consensus sequence for the entire stack followed by the flags for that stack. Then, each individual read that was merged into that stack will follow. The next stack will start with another consensus sequence.


- XXX.snps.tsv file::

    Column    Name                     Description
    1         Sql ID                   This field will always be "0", however the MySQL database will assign an ID when it is loaded.
    2         Sample ID                
    3         Stack ID                 
    4         SNP Column               
    5         Likelihood ratio         From the SNP-calling model.
    6         Rank_1                   Majority nucleotide.
    7         Rank_2                   Alternative nucleotide.

Notes: If a stack has two SNPs called within it, then there will be two lines in this file listing each one.


- XXX.alleles.tsv file::

    Column    Name                     Description
    1         Sql ID                   This field will always be "0", however the MySQL database will assign an ID when it is loaded.
    2         Sample ID                
    3         Stack ID                 
    4         Haplotype                The haplotype, as constructed from the called SNPs at each locus.
    5         Percent                  Percentage of reads that have this haplotype
    6         Count                    Raw number of reads that have this haplotype


- XXX.matches.tsv file::

    Column    Name                     Description
    1         Sql ID                   This field will always be "0", however the MySQL database will assign an ID when it is loaded.
    2         Batch ID                
    3         Catalog ID                 
    4         Sample ID               
    5         Stack ID         
    6         Haplotype 
    7         Stack Depth    

Notes: Each line in this file records a match between a catalog locus and a locus in an individual, for a particular haplotype. The Batch ID plus the Catalog ID together represent a unique locus in the entire population, while the Sample ID and the Stack ID together represent a unique locus in an individual sample.


- batch_X.sumstats.tsv Summary Statistics Output::

    Batch ID            The batch identifier for this data set.
    Locus ID            Catalog locus identifier.
    Chromosome            If aligned to a reference genome.
    Basepair            If aligned to a reference genome. This is the alignment of the whole catalog locus. The exact basepair reported is aligned to the location of the RAD site (depending on whether alignment is to the positive or negative strand).
    Column                The nucleotide site within the catalog locus.
    Population ID            The ID supplied to the populations program, as written in the population map file.
    P Nucleotide            The most frequent allele at this position in this population.
    Q Nucleotide            The alternative allele.
    Number of Individuals         Number of individuals sampled in this population at this site.
    P                 Frequency of most frequent allele.
    Observed Heterozygosity        The proportion of individuals that are heterozygotes in this population.
    Observed Homozygosity         The proportion of individuals that are homozygotes in this population.
    Expected Heterozygosity        Heterozygosity expected under Hardy-Weinberg equilibrium.
    Expected Homozygosity         Homozygosity expected under Hardy-Weinberg equilibrium.
    pi                An estimate of nucleotide diversity.
    Smoothed pi            A weighted average of p depending on the surrounding 3s of sequence in both directions.
    Smoothed pi P-value         If bootstrap resampling is enabled, a p-value ranking the significance of p within this population.
    FIS                 The inbreeding coefficient of an individual (I) relative to the subpopulation (S).
    Smoothed FIS             A weighted average of FIS depending on the surrounding 3s of sequence in both directions.
    Smoothed FIS P-value        If bootstrap resampling is enabled, a p-value ranking the significance of FIS within this population.
    Private allele             True (1) or false (0), depending on if this allele is only occurs in this population.

- batch_X.fst_Y-Z.tsv Pairwise FST Output::

    Batch ID             The batch identifier for this data set.
    Locus ID             Catalog locus identifier.
    Population ID 1         The ID supplied to the populations program, as written in the population map file.
    Population ID 2         The ID supplied to the populations program, as written in the population map file.
    Chromosome             If aligned to a reference genome.
    Basepair             If aligned to a reference genome. This is the alignment of the whole catalog locus. The exact basepair reported is aligned to the location of the RAD site (depending on whether alignment is to the positive or negative strand).
    Column                 The nucleotide site within the catalog locus.
    Overall pi             An estimate of nucleotide diversity across the two populations.
    FST                 A measure of population differentiation.
    FET p-value             P-value describing if the FST measure is statistically significant according to Fisher's Exact Test.
    Odds Ratio             Fisher's Exact Test odds ratio
    CI High             Fisher's Exact Test confidence interval.
    CI Low                 Fisher's Exact Test confidence interval.
    LOD Score             Logarithm of odds score.
    Expected Heterozygosity        Heterozygosity expected under Hardy-Weinberg equilibrium.
    Expected Homozygosity         Homozygosity expected under Hardy-Weinberg equilibrium.
    Corrected FST             FST with either the FET p-value, or a window-size or genome size Bonferroni correction.
    Smoothed FST             A weighted average of FST depending on the surrounding 3s of sequence in both directions.
    Smoothed FST P-value         If bootstrap resampling is enabled, a p-value ranking the significance of FST within this pair of populations.


Instructions to add the functionality of archives management in Galaxy on the `eBiogenouest HUB wiki &lt;https://www.e-biogenouest.org/wiki/ManArchiveGalaxy&gt;`_ .

--------

**Output type:**

- Output type details::

    No compression             All files will be added in the current history.
    Compressed by categories    Files will be compressed by categories (snps, allele, matches and tags) into 4 zip archives. These archives and batch files will be added in the current history.
    Compressed all outputs         All files will be compressed in an unique zip archive. Batch files will be added in the current history with the archive.


--------

**Project links:**

`STACKS website &lt;http://creskolab.uoregon.edu/stacks/&gt;`_ .

`STACKS manual &lt;http://creskolab.uoregon.edu/stacks/stacks_manual.pdf&gt;`_ .

`STACKS google group &lt;https://groups.google.com/forum/#!forum/stacks-users&gt;`_ .

--------

**References:**

-J. Catchen, P. Hohenlohe, S. Bassham, A. Amores, and W. Cresko. Stacks: an analysis tool set for population genomics. Molecular Ecology. 2013.

-J. Catchen, S. Bassham, T. Wilson, M. Currey, C. O'Brien, Q. Yeates, and W. Cresko. The population structure and recent colonization history of Oregon threespine stickleback determined using restriction-site associated DNA-sequencing. Molecular Ecology. 2013.

-J. Catchen, A. Amores, P. Hohenlohe, W. Cresko, and J. Postlethwait. Stacks: building and genotyping loci de novo from short-read sequences. G3: Genes, Genomes, Genetics, 1:171-182, 2011.

-A. Amores, J. Catchen, A. Ferrara, Q. Fontenot and J. Postlethwait. Genome evolution and meiotic maps by massively parallel DNA sequencing: Spotted gar, an outgroup for the teleost genome duplication. Genetics, 188:799'808, 2011.

-P. Hohenlohe, S. Amish, J. Catchen, F. Allendorf, G. Luikart. RAD sequencing identifies thousands of SNPs for assessing hybridization between rainbow trout and westslope cutthroat trout. Molecular Ecology Resources, 11(s1):117-122, 2011.

-K. Emerson, C. Merz, J. Catchen, P. Hohenlohe, W. Cresko, W. Bradshaw, C. Holzapfel. Resolving postglacial phylogeography using high-throughput sequencing. Proceedings of the National Academy of Science, 107(37):16196-200, 2010.

--------

**Integrated by:**

Yvan Le Bras and Cyril Monjeaud 

GenOuest Bio-informatics Core Facility

UMR 6074 IRISA INRIA-CNRS-UR1 Rennes (France)

support@genouest.org

    </help>
    <expand macro="citation" />
</tool>

