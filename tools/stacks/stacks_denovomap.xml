<tool id="stacks_denovomap" name="Stacks: De novo map"  version="@WRAPPER_VERSION@.0" force_history_refresh="True">
    <description>Run the Stacks denovo_map.pl wrapper</description>
    <macros>
        <import>macros.xml</import>
    </macros>
    <expand macro="requirements"/>
    <expand macro="stdio"/>
    <command><![CDATA[
        #from os.path import splitext
        #import re

        #if str( $options_usage.rad_analysis_type ) == "genetic":
            #for $input_parent in $options_usage.parent_sequences:

                #if $input_parent.ext == "fastqsanger":
                    #set $data_path = splitext($input_parent.name)[0]
                    #set $data_path = re.sub(r'\.1$', '', $data_path)
                    #set $data_path = $data_path + ".fq"
                #else:
                    #set $data_path = splitext($input_parent.name)[0]
                    #set $data_path = re.sub(r'\.1$', '', $data_path)
                    #set $data_path = $data_path + ".fa"
                #end if

                ln -s ${input_parent} "${data_path}" &&
            #end for

            #for $input_progeny in $options_usage.progeny_sequences:

                #if $input_progeny.ext == "fastqsanger":
                    #set $data_path = splitext($input_progeny.name)[0]
                    #set $data_path = re.sub(r'\.1$', '', $data_path)
                    #set $data_path = $data_path + ".fq"
                #else:
                    #set $data_path = splitext($input_progeny.name)[0]
                    #set $data_path = re.sub(r'\.1$', '', $data_path)
                    #set $data_path = $data_path + ".fa"
                #end if

                ln -s ${input_progeny} "${data_path}" &&
            #end for
        #else:
            #for $input_indiv in $options_usage.individual_sample:

                #if $input_indiv.ext == "fastqsanger":
                    #set $data_path = splitext($input_indiv.name)[0]
                    #set $data_path = re.sub(r'\.1$', '', $data_path)
                    #set $data_path = $data_path + ".fq"
                #else:
                    #set $data_path = splitext($input_indiv.name)[0]
                    #set $data_path = re.sub(r'\.1$', '', $data_path)
                    #set $data_path = $data_path + ".fa"
                #end if

                ln -s ${input_indiv} "${data_path}" &&
            #end for
        #end if

        mkdir stacks_outputs

        &&

        denovo_map.pl

            -T \${GALAXY_SLOTS:-1}

            #if str( $options_usage.rad_analysis_type ) == "genetic":
                #for $input_parent in $options_usage.parent_sequences:
                    #if $input_parent.ext == "fastqsanger":
                        #set $data_path = splitext($input_parent.name)[0]
                        #set $data_path = re.sub(r'\.1$', '', $data_path)
                        #set $data_path = $data_path + ".fq"
                    #else:
                        #set $data_path = splitext($input_parent.name)[0]
                        #set $data_path = re.sub(r'\.1$', '', $data_path)
                        #set $data_path = $data_path + ".fa"
                    #end if

                    -p "${data_path}"
                #end for

                -A $options_usage.cross_type

                #for $input_progeny in $options_usage.progeny_sequences:
                    #if $input_progeny.ext == "fastqsanger":
                        #set $data_path = splitext($input_progeny.name)[0]
                        #set $data_path = re.sub(r'\.1$', '', $data_path)
                        #set $data_path = $data_path + ".fq"
                    #else:
                        #set $data_path = splitext($input_progeny.name)[0]
                        #set $data_path = re.sub(r'\.1$', '', $data_path)
                        #set $data_path = $data_path + ".fa"
                    #end if

                    -r "${data_path}"
                #end for

                #if $assembly_options.P:
                    -P $assembly_options.P
                #end if
            #else:
                #for $i_indiv, $input_indiv in enumerate($options_usage.individual_sample):

                    #if $input_indiv.ext == "fastqsanger":
                        #set $data_path = splitext($input_indiv.name)[0]
                        #set $data_path = re.sub(r'\.1$', '', $data_path)
                        #set $data_path = $data_path + ".fq"
                    #else:
                        #set $data_path = splitext($input_indiv.name)[0]
                        #set $data_path = re.sub(r'\.1$', '', $data_path)
                        #set $data_path = $data_path + ".fa"
                    #end if

                    -s "${data_path}"
                #end for
                -O $options_usage.popmap
            #end if

            #if $assembly_options.m:
                -m $assembly_options.m
            #end if
            #if $assembly_options.N:
                -N $assembly_options.N
            #end if
            -M $assembly_options.M
            -n $assembly_options.n
            -t $assembly_options.t
            -H $assembly_options.H

            ## Batch description
            -b 1

            ## No SQL recording
            -S

            ## snp_model
            #if str( $snp_options.select_model.model_type) == "bounded":
                --bound_low $snp_options.select_model.bound_low
                --bound_high $snp_options.select_model.bound_high
                --alpha $snp_options.select_model.alpha
            #else:
                --alpha $snp_options.select_model.alpha
            #end if

            -o stacks_outputs

            #if str( $options_usage.rad_analysis_type ) == "genetic":
                @NORM_GENOTYPES_OUTPUT_LIGHT@
            #end if
    ]]></command>

    <inputs>
        <conditional name="options_usage">
            <param name="rad_analysis_type" type="select" label="Select your usage">
                <option value="genetic" selected="true">Genetic map</option>
                <option value="population">Population</option>
            </param>
            <when value="genetic">
                <param name="parent_sequences" argument="-p" format="fastqsanger,fasta" type="data" multiple="true" label="Files containing parent sequences" help="Files containing parent sequences from a mapping cross" />

                <param name="progeny_sequences" argument="-r" format="fastqsanger,fasta" type="data" multiple="true" optional="true" label="Files containing progeny sequences" help="FASTQ/FASTA/ZIP/TAR.GZ files containing progeny sequences from a mapping cross" />

                <param name="cross_type" argument="-A" type="select" label="Cross type">
                    <expand macro="cross_types"/>
                </param>
            </when>
            <when value="population">
                <param name="individual_sample" argument="-s" format="fastqsanger,fasta" type="data" multiple="true" label="Files containing an individual sample from a population" help="FASTQ/FASTA/ZIP/TAR.GZ files contiaining an individual sample from a population" />
                <param name="popmap" argument="-O" type="data" format="tabular,txt" label="Specify a population map" />
            </when>
        </conditional>

        <!-- stack assembly options -->
        <section name="assembly_options" title="Assembly options" expanded="false">
            <param name="m" argument="-m" type="integer" value="" optional="true" label="Minimum number of identical raw reads required to create a stack" />
            <param name="P" argument="-P" type="integer" value="" optional="true" label="Minimum number of identical, raw reads required to create a stack in 'progeny' individuals" />
            <param name="M" argument="-M" type="integer" value="2" label="Number of mismatches allowed between loci when processing a single individual"/>
            <param name="N" argument="-N" type="integer" value="" optional="true" label="Number of mismatches allowed when aligning secondary reads" help="default is [-M]+2" />
            <param name="n" argument="-n" type="integer" value="1" label="specify the number of mismatches allowed between loci when building the catalog"/>

            <param name="t" argument="-t" type="boolean" checked="false" truevalue="-t" falsevalue="" label="Remove, or break up, highly repetitive RAD-Tags in the ustacks program" />
            <param name="H" argument="-H" type="boolean" checked="false" truevalue="-H" falsevalue="" label="Disable calling haplotypes from secondary reads" />
        </section>

        <!-- SNP Model options -->
        <section name="snp_options" title="SNP Model Options (ustacks options)" expanded="False">
            <expand macro="snp_options"/>
        </section>
    </inputs>
    <outputs>
        <data format="txt" name="output_log" label="denovo_map.log with ${tool.name} on ${on_string}" from_work_dir="stacks_outputs/denovo_map.log" />

        <data format="tabular" name="catalogtags" label="Catalog assembled loci (tags) with ${tool.name} on ${on_string}" from_work_dir="stacks_outputs/batch_1.catalog.tags.tsv" />
        <data format="tabular" name="catalogsnps" label="Catalog model calls (snps) with ${tool.name} on ${on_string}" from_work_dir="stacks_outputs/batch_1.catalog.snps.tsv" />
        <data format="tabular" name="catalogalleles" label="Catalog haplotypes (alleles) with ${tool.name} on ${on_string}" from_work_dir="stacks_outputs/batch_1.catalog.alleles.tsv" />

        <expand macro="genotypes_output_light"/>
        <expand macro="populations_output_light"/>

        <collection name="tags" type="list" label="Assembled loci from ${on_string}">
            <discover_datasets pattern="(?P&lt;name&gt;.+\.tags)\.tsv" ext="tabular" directory="stacks_outputs" visible="true" />
        </collection>

        <collection name="snps" type="list" label="Model calls from each locus on ${on_string}">
            <discover_datasets pattern="(?P&lt;name&gt;.+\.snps)\.tsv" ext="tabular" directory="stacks_outputs" visible="true" />
        </collection>

        <collection name="alleles" type="list" label="Haplotypes/alleles recorded from each locus on ${on_string}">
            <discover_datasets pattern="(?P&lt;name&gt;.+\.alleles)\.tsv" ext="tabular" directory="stacks_outputs" visible="true" />
        </collection>

        <collection name="matches" type="list" label="Matches to the catalog on ${on_string}">
            <discover_datasets pattern="(?P&lt;name&gt;.+\.matches)\.tsv" ext="tabular" directory="stacks_outputs" visible="true" />
        </collection>

        <collection name="all_output" type="list" label="Full output from denovo_map on ${on_string}">
            <discover_datasets pattern="(?P&lt;name&gt;.+\.(tags|snps|alleles|matches))\.tsv" ext="tabular" directory="stacks_outputs" visible="true" />
        </collection>
    </outputs>

    <tests>
        <test>
            <param name="options_usage|rad_analysis_type" value="genetic"/>
            <param name="options_usage|parent_sequences" value="demultiplexed/PopA_01.1.fq" ftype="fastqsanger" />
            <param name="options_usage|progeny_sequences" value="demultiplexed/PopA_02.1.fq" ftype="fastqsanger" />
            <output name="output_log">
                <assert_contents>
                    <has_text text="denovo_map.pl completed" />
                </assert_contents>
            </output>

            <!-- catalog -->
            <output name="catalogtags">
                <assert_contents>
                    <has_text text="catalog generated on" />
                </assert_contents>
            </output>
            <output name="catalogsnps">
                <assert_contents>
                    <has_text text="catalog generated on" />
                </assert_contents>
            </output>
            <output name="catalogalleles">
                <assert_contents>
                    <has_text text="catalog generated on" />
                </assert_contents>
            </output>

            <!-- genotypes -->
            <output name="out_generic_haplo">
                <assert_contents>
                    <has_text text="Catalog ID" />
                </assert_contents>
            </output>
            <output name="out_sql_markers">
                <assert_contents>
                    <has_text text="Total Genotypes" />
                </assert_contents>
            </output>
            <output name="out_joinmap">
                <assert_contents>
                    <has_text text="batch_1.genotypes_" />
                </assert_contents>
            </output>
            <output name="out_sql_genotypes">
                <assert_contents>
                    <has_text text="SQL ID" />
                </assert_contents>
            </output>

            <!-- samples -->
            <output_collection name="tags">
                <element name="PopA_01.tags">
                    <assert_contents>
                        <has_text text="generated on " />
                    </assert_contents>
                </element>
            </output_collection>
            <output_collection name="snps">
                <element name="PopA_01.snps">
                    <assert_contents>
                        <has_text text="generated on " />
                    </assert_contents>
                </element>
            </output_collection>
            <output_collection name="alleles">
                <element name="PopA_01.alleles">
                    <assert_contents>
                        <has_text text="generated on " />
                    </assert_contents>
                </element>
            </output_collection>
            <output_collection name="matches">
                <element name="PopA_01.matches">
                    <assert_contents>
                        <has_text text="generated on " />
                    </assert_contents>
                </element>
            </output_collection>
        </test>
        <test>
            <param name="options_usage|rad_analysis_type" value="population"/>
            <param name="options_usage|individual_sample" value="demultiplexed/PopA_01.1.fq,demultiplexed/PopA_02.1.fq,demultiplexed/PopA_03.1.fq,demultiplexed/PopA_04.1.fq,demultiplexed/PopB_01.1.fq,demultiplexed/PopB_02.1.fq,demultiplexed/PopB_03.1.fq,demultiplexed/PopB_04.1.fq" ftype="fastqsanger" />
            <param name="options_usage|popmap" value="denovo_map/popmap.tsv" />
            <output name="output_log">
                <assert_contents>
                    <has_text text="denovo_map.pl completed" />
                </assert_contents>
            </output>

            <!-- catalog -->
            <output name="catalogtags">
                <assert_contents>
                    <has_text text="catalog generated on" />
                </assert_contents>
            </output>
            <output name="catalogsnps">
                <assert_contents>
                    <has_text text="catalog generated on" />
                </assert_contents>
            </output>
            <output name="catalogalleles">
                <assert_contents>
                    <has_text text="catalog generated on" />
                </assert_contents>
            </output>

            <!-- populations -->
            <output name="out_haplotypes">
                <assert_contents>
                    <has_text text="PopA_01" />
                </assert_contents>
            </output>
            <output name="out_hapstats">
                <assert_contents>
                    <has_text text="Smoothed Gene Diversity" />
                </assert_contents>
            </output>
            <output name="out_populations_log">
                <assert_contents>
                    <has_text text="populations version" />
                </assert_contents>
            </output>
            <output name="out_sumstats_sum">
                <assert_contents>
                    <has_text text="Polymorphic Sites" />
                </assert_contents>
            </output>
            <output name="out_sumstats">
                <assert_contents>
                    <has_text text="Smoothed Pi" />
                </assert_contents>
            </output>

            <!-- samples -->
            <output_collection name="tags">
                <element name="PopA_01.tags">
                    <assert_contents>
                        <has_text text="generated on " />
                    </assert_contents>
                </element>
            </output_collection>
            <output_collection name="snps">
                <element name="PopA_01.snps">
                    <assert_contents>
                        <has_text text="generated on " />
                    </assert_contents>
                </element>
            </output_collection>
            <output_collection name="alleles">
                <element name="PopA_01.alleles">
                    <assert_contents>
                        <has_text text="generated on " />
                    </assert_contents>
                </element>
            </output_collection>
            <output_collection name="matches">
                <element name="PopA_01.matches">
                    <assert_contents>
                        <has_text text="generated on " />
                    </assert_contents>
                </element>
            </output_collection>
        </test>
    </tests>

    <help>

.. class:: infomark

**What it does**

This program will run each of the Stacks components: first, running ustacks on each of the samples specified, building loci and calling SNPs in each. Second, cstacks will be run to create a catalog of all loci that were marked as 'parents' or 'samples' on the command line, and finally, sstacks will be executed to match each sample against the catalog. A bit more detail on this process can be found in the FAQ. The denovo_map.pl program will also load the results of each stage of the analysis: individual loci, the catalog, and matches against the catalog into the database (although this can be disabled). After matching, the program will build a database index to speed up access (index_radtags.pl) and enable web-based filtering.

--------

**Created by:**

Stacks was developed by Julian Catchen with contributions from Angel Amores, Paul Hohenlohe, and Bill Cresko

--------

**Example:**

Input files:

FASTQ, FASTA

- Population map::

    indv_01    1
    indv_02    1
    indv_03    1
    indv_04    2
    indv_05    2
    indv_06    2


Output files:

- XXX.tags.tsv file::

    Column    Name                     Description
    1         Sql ID                   This field will always be "0", however the MySQL database will assign an ID when it is loaded.
    2         Sample ID                Each sample passed through Stacks gets a unique id for that sample.
    3         Stack ID                 Each stack formed gets an ID.
    4         Chromosome               If aligned to a reference genome using pstacks, otherwise it is blank.
    5         Basepair                 If aligned to ref genome using pstacks.
    6         Strand                   If aligned to ref genome using pstacks.
    7         Sequence Type            Either 'consensus', 'primary' or 'secondary', see the Stacks paper for definitions of these terms.
    8         Sequence ID              The individual sequence read that was merged into this stack.
    9         Sequence                 The raw sequencing read.
    10        Deleveraged Flag         If "1", this stack was processed by the deleveraging algorithm and was broken down from a larger stack.
    11        Blacklisted Flag         If "1", this stack was still confounded depsite processing by the deleveraging algorithm.
    12        Lumberja ckstack Flag    If "1", this stack was set aside due to having an extreme depth of coverage.

Notes: For the tags file, each stack will start in the file with a consensus sequence for the entire stack followed by the flags for that stack. Then, each individual read that was merged into that stack will follow. The next stack will start with another consensus sequence.


- XXX.snps.tsv file::

    Column    Name                     Description
    1         Sql ID                   This field will always be "0", however the MySQL database will assign an ID when it is loaded.
    2         Sample ID
    3         Stack ID
    4         SNP Column
    5         Likelihood ratio         From the SNP-calling model.
    6         Rank_1                   Majority nucleotide.
    7         Rank_2                   Alternative nucleotide.

Notes: If a stack has two SNPs called within it, then there will be two lines in this file listing each one.


- XXX.alleles.tsv file::

    Column    Name                     Description
    1         Sql ID                   This field will always be "0", however the MySQL database will assign an ID when it is loaded.
    2         Sample ID
    3         Stack ID
    4         Haplotype                The haplotype, as constructed from the called SNPs at each locus.
    5         Percent                  Percentage of reads that have this haplotype
    6         Count                    Raw number of reads that have this haplotype


- XXX.matches.tsv file::

    Column    Name                     Description
    1         Sql ID                   This field will always be "0", however the MySQL database will assign an ID when it is loaded.
    2         Batch ID
    3         Catalog ID
    4         Sample ID
    5         Stack ID
    6         Haplotype
    7         Stack Depth

Notes: Each line in this file records a match between a catalog locus and a locus in an individual, for a particular haplotype. The Batch ID plus the Catalog ID together represent a unique locus in the entire population, while the Sample ID and the Stack ID together represent a unique locus in an individual sample.


- batch_X.sumstats.tsv Summary Statistics Output::

    Batch ID            The batch identifier for this data set.
    Locus ID            Catalog locus identifier.
    Chromosome            If aligned to a reference genome.
    Basepair            If aligned to a reference genome. This is the alignment of the whole catalog locus. The exact basepair reported is aligned to the location of the RAD site (depending on whether alignment is to the positive or negative strand).
    Column                The nucleotide site within the catalog locus.
    Population ID            The ID supplied to the populations program, as written in the population map file.
    P Nucleotide            The most frequent allele at this position in this population.
    Q Nucleotide            The alternative allele.
    Number of Individuals         Number of individuals sampled in this population at this site.
    P                 Frequency of most frequent allele.
    Observed Heterozygosity        The proportion of individuals that are heterozygotes in this population.
    Observed Homozygosity         The proportion of individuals that are homozygotes in this population.
    Expected Heterozygosity        Heterozygosity expected under Hardy-Weinberg equilibrium.
    Expected Homozygosity         Homozygosity expected under Hardy-Weinberg equilibrium.
    pi                An estimate of nucleotide diversity.
    Smoothed pi            A weighted average of p depending on the surrounding 3s of sequence in both directions.
    Smoothed pi P-value         If bootstrap resampling is enabled, a p-value ranking the significance of p within this population.
    FIS                 The inbreeding coefficient of an individual (I) relative to the subpopulation (S).
    Smoothed FIS             A weighted average of FIS depending on the surrounding 3s of sequence in both directions.
    Smoothed FIS P-value        If bootstrap resampling is enabled, a p-value ranking the significance of FIS within this population.
    Private allele             True (1) or false (0), depending on if this allele is only occurs in this population.

- batch_X.fst_Y-Z.tsv Pairwise FST Output::

    Batch ID             The batch identifier for this data set.
    Locus ID             Catalog locus identifier.
    Population ID 1         The ID supplied to the populations program, as written in the population map file.
    Population ID 2         The ID supplied to the populations program, as written in the population map file.
    Chromosome             If aligned to a reference genome.
    Basepair             If aligned to a reference genome. This is the alignment of the whole catalog locus. The exact basepair reported is aligned to the location of the RAD site (depending on whether alignment is to the positive or negative strand).
    Column                 The nucleotide site within the catalog locus.
    Overall pi             An estimate of nucleotide diversity across the two populations.
    FST                 A measure of population differentiation.
    FET p-value             P-value describing if the FST measure is statistically significant according to Fisher's Exact Test.
    Odds Ratio             Fisher's Exact Test odds ratio
    CI High             Fisher's Exact Test confidence interval.
    CI Low                 Fisher's Exact Test confidence interval.
    LOD Score             Logarithm of odds score.
    Expected Heterozygosity        Heterozygosity expected under Hardy-Weinberg equilibrium.
    Expected Homozygosity         Homozygosity expected under Hardy-Weinberg equilibrium.
    Corrected FST             FST with either the FET p-value, or a window-size or genome size Bonferroni correction.
    Smoothed FST             A weighted average of FST depending on the surrounding 3s of sequence in both directions.
    Smoothed FST P-value         If bootstrap resampling is enabled, a p-value ranking the significance of FST within this pair of populations.


--------

**Project links:**

`STACKS website &lt;http://creskolab.uoregon.edu/stacks/&gt;`_ .

`STACKS manual &lt;http://creskolab.uoregon.edu/stacks/stacks_manual.pdf&gt;`_ .

`STACKS google group &lt;https://groups.google.com/forum/#!forum/stacks-users&gt;`_ .

--------

**Integrated by:**

Yvan Le Bras and Cyril Monjeaud

GenOuest Bio-informatics Core Facility

UMR 6074 IRISA INRIA-CNRS-UR1 Rennes (France)

support@genouest.org

    </help>
    <expand macro="citation" />
</tool>

