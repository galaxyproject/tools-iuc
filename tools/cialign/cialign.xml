<tool id="cialign" name="CIAlign" version="@TOOL_VERSION@+galaxy@VERSION_SUFFIX@" profile="23.2">
    <description>CIAlign a tool to clean, visualise and analyse a multiple sequence alignment</description>
    <macros>
        <import>macros.xml</import>
    </macros>
    <expand macro="requirements"/>
    <version_command>CIAlign --version</version_command>
    <command detect_errors="exit_code"><![CDATA[
        CIAlign --infile $input
                --outfile_stem output

                ###### Basic Options
                $basic_options.all
                $basic_options.clean
                $basic_options.visualise
                $basic_options.interpret
                $basic_options.keep_gaponly
                
                ###### Cleaning Options
                ### Remove Divergent options
                #if str($cleaning_options.remove_divergent_cond.remove_divergent_param) == "true": 
                    --remove_divergent
                    --remove_divergent_minperc $cleaning_options.remove_divergent_cond.remove_divergent_minperc
                    #for $s in $cleaning_options.remove_divergent_cond.remove_divergent_retain_seqs
                        --remove_divergent_retain "$s.remove_divergent_retain"
                    #end for
                    #for $s in $cleaning_options.remove_divergent_cond.remove_divergent_retain_strings
                        --remove_divergent_retain_str "$s.remove_divergent_retain_str"
                    #end for
                #end if

                ### Remove Insertions options
                #if str($cleaning_options.remove_insertions_cond.remove_insertions_param) == "true": 
                    --remove_insertions
                    --insertion_min_size $cleaning_options.remove_insertions_cond.insertion_min_size
                    --insertion_max_size $cleaning_options.remove_insertions_cond.insertion_max_size
                    --insertion_min_flank $cleaning_options.remove_insertions_cond.insertion_min_flank
                    --insertion_min_perc $cleaning_options.remove_insertions_cond.insertion_min_perc
                #end if

                ### Crop Ends options
                #if str($cleaning_options.crop_ends_cond.crop_ends_param) == "true":
                    --crop_ends
                    --crop_ends_mingap_perc $cleaning_options.crop_ends_cond.crop_ends_mingap_perc
                    --crop_ends_redefine_perc $cleaning_options.crop_ends_cond.crop_ends_redefine_perc
                    #for $s in $cleaning_options.crop_ends_cond.crop_ends_retain_seqs
                        --crop_ends_retain "$s.crop_ends_retain"
                    #end for
                    #for $s in $cleaning_options.crop_ends_cond.crop_ends_retain_strings
                        --crop_ends_retain_str "$s.crop_ends_retain_str"
                    #end for
                #end if

                ### Remove Short options
                #if str($cleaning_options.remove_short_cond.remove_short_param) == "true":
                    --remove_short
                    --remove_min_length $cleaning_options.remove_short_cond.remove_min_length       
                    #for $s in $cleaning_options.remove_short_cond.remove_short_retain_seqs
                        --remove_short_retain "$s.remove_short_retain"
                    #end for
                    #for $s in $cleaning_options.remove_short_cond.remove_short_retain_strings
                        --remove_short_retain_str "$s.remove_short_retain_str"
                    #end for
                #end if

                ### Crop Divergent options
                #if str($cleaning_options.crop_divergent_cond.crop_divergent_param) == "true":
                    --crop_divergent
                    --crop_divergent_min_prop_ident $cleaning_options.crop_divergent_cond.crop_divergent_min_prop_ident
                    --crop_divergent_min_prop_nongap $cleaning_options.crop_divergent_cond.crop_divergent_min_prop_nongap
                    --crop_divergent_buffer_size $cleaning_options.crop_divergent_cond.crop_divergent_buffer_size
                #end if
                
                ### Retain options
                #if str($cleaning_options.retain_cond.retain_param) == "true":
                    #for $s in $cleaning_options.retain_seqs
                        --retain "$s.retain"
                    #end for
                    #for $s in $cleaning_options.retain_strings
                        --retain_str "$s.retain_str"
                    #end for
                #end if

                ###### Visualisation Options
                ### basic visualisation options
                $visualisation_options.basic_visualisation_options.plot_input
                $visualisation_options.basic_visualisation_options.plot_output
                $visualisation_options.basic_visualisation_options.plot_markup
                $visualisation_options.basic_visualisation_options.plot_consensus_identity
                $visualisation_options.basic_visualisation_options.plot_consensus_similarity
                --plot_width $visualisation_options.basic_visualisation_options.output_settings.plot_width
                --plot_height $visualisation_options.basic_visualisation_options.output_settings.plot_height
                --plot_dpi $visualisation_options.basic_visualisation_options.output_settings.plot_dpi
                $visualisation_options.basic_visualisation_options.output_settings.plot_keep_numbers
                $visualisation_options.basic_visualisation_options.output_settings.plot_force_numbers
                --plot_identity_palette "$visualisation_options.basic_visualisation_options.output_settings.plot_identity_palette"
                --plot_identity_gap_col "$visualisation_options.basic_visualisation_options.output_settings.plot_identity_gap_col"
                --plot_similarity_palette "$visualisation_options.basic_visualisation_options.output_settings.plot_similarity_palette"
                --plot_similarity_gap_col "$visualisation_options.basic_visualisation_options.output_settings.plot_similarity_gap_col"
                --palette "$visualisation_options.basic_visualisation_options.output_settings.palette"

                ### Sequence logos
                #if str($visualisation_options.sequence_logo_cond.sequence_logo_param) == "true":
                    --make_sequence_logo
                    --sequence_logo_type "$visualisation_options.sequence_logo_cond.sequence_logo_type"
                    --sequence_logo_dpi $visualisation_options.sequence_logo_cond.sequence_logo_dpi
                    --sequence_logo_font "$visualisation_options.sequence_logo_cond.sequence_logo_font"
                    --sequence_logo_nt_per_row $visualisation_options.sequence_logo_cond.sequence_logo_nt_per_row
                    #if $visualisation_options.sequence_logo_cond.logo_start:
                        --logo_start $visualisation_options.sequence_logo_cond.logo_start
                    #end if
                    #if $visualisation_options.sequence_logo_cond.logo_end:
                        --logo_end $visualisation_options.sequence_logo_cond.logo_end
                    #end if
                #end if

                ### Statistics Plots
                $visualisation_options.statistics_plots.plot_stats_input
                $visualisation_options.statistics_plots.plot_stats_output
                --plot_stats_dpi $visualisation_options.statistics_plots.stats_settings.plot_stats_dpi
                --plot_stats_height $visualisation_options.statistics_plots.stats_settings.plot_stats_width
                --plot_stats_width $visualisation_options.statistics_plots.stats_settings.plot_stats_height

                ###### Interpretation Functions
                ### consensus sequences
                #if str($interpretation_options.consensus_sequences_cond.consensus_sequences_param) == "true":
                    --make_consensus
                    --consensus_type "$interpretation_options.consensus_sequences_cond.consensus_type"
                    $interpretation_options.consensus_sequences_cond.consensus_keep_gaps
                #end if
                
                ### Position Matrices
                $interpretation_options.position_matrices.pwm_input
                $interpretation_options.position_matrices.pwm_output
                #if $interpretation_options.position_matrices.matrices_settings.pwm_start:
                    --pwm_start $interpretation_options.position_matrices.matrices_settings.pwm_start
                #end if
                #if $interpretation_options.position_matrices.matrices_settings.pwm_end:
                    --pwm_end $interpretation_options.position_matrices.matrices_settings.pwm_end
                #end if
                --pwm_freqtype "$interpretation_options.position_matrices.matrices_settings.pwm_freqtype"
                --pwm_alphatype "$interpretation_options.position_matrices.matrices_settings.pwm_alphatype"
                --pwm_alphaval $interpretation_options.position_matrices.matrices_settings.pwm_alphaval
                $interpretation_options.position_matrices.pwm_output_blamm
                $interpretation_options.position_matrices.pwm_output_meme
                
                ### Similarity Matrices
                $interpretation_options.similarity_matrices.make_similarity_matrix_input
                $interpretation_options.similarity_matrices.make_similarity_matrix_output
                --make_simmatrix_keepgaps $interpretation_options.similarity_matrices.similarity_matrices_settings.make_simmatrix_keepgaps
                --make_simmatrix_dp $interpretation_options.similarity_matrices.similarity_matrices_settings.make_simmatrix_dp
                --make_simmatrix_minoverlap $interpretation_options.similarity_matrices.similarity_matrices_settings.make_simmatrix_minoverlap

                ###### Editing Functions
                #if str($editing_functions.get_section_cond.get_section_param) == "true":
                    --get_section
                    --section_start $editing_functions.get_section_cond.section_start
                    --section_end $editing_functions.get_section_cond.section_end
                #end if
                $editing_functions.replace_input_tu
                $editing_functions.replace_input_ut
                $editing_functions.replace_output_tu
                $editing_functions.replace_output_ut
                ### Unaligning
                $editing_functions.unalign_input
                $editing_functions.unalign_output
                ### Removing Duplicates
                $editing_functions.deduplicate_ids
                --duporder $editing_functions.duporder
    ]]></command>
    <inputs>
        <param name="input" type="data" format="fasta" label="Input FASTA" help="Upload a multiple sequence alignment in FASTA format."/>
        <!-- BASIC options -->
        <section name="basic_options" title="Basic Options" expanded="false">
            <param argument="--all" type="boolean" truevalue="--all" falsevalue="" checked="false" label="Use All Functions" help="Enable all available functions with default parameters unless overridden."/>
            <param argument="--clean" type="boolean" truevalue="--clean" falsevalue="" checked="false" label="Use All Cleaning Functions" help="Use all available cleaning functions with default parameters"/>
            <param argument="--visualise" type="boolean" truevalue="--visualise" falsevalue="" checked="false" label="Use All Visualisation Functions" help="Use all available mini alignment visualisation functions with default parameters."/>
            <param argument="--interpret" type="boolean" truevalue="--interpret" falsevalue="" checked="false" label="Use All Interpretation Functions" help="Use all available interpretation functions with default parameters"/>
            <param argument="--keep_gaponly" type="boolean" truevalue="--keep_gaponly" falsevalue="" checked="false" label="Keep Gap-Only Columns" help=" Keep columns in the alignment that consist entirely of gaps."/>
        </section>

        <section name="cleaning_options" title="Cleaning Options" expanded="false">
            <!-- Remove divergent options -->
            <conditional name="remove_divergent_cond">
                <param name="remove_divergent_param" type="select" label="Remove divergent" help="Remove sequences with identity below a specified proportion of conserved positions.">
                    <option value="true">yes</option>
                    <option value="false" selected="true">no</option>
                </param>            
                <when value="true">
                    <param argument="--remove_divergent_minperc" type="float" value="0.65" min="0" max="1" label="Minimum Identity Proportion" help="Minimum proportion of positions that must match the most common base or amino acid for a sequence to be kept."/>
                    <repeat name="remove_divergent_retain_seqs" title="sequences to retain" min="0">
                        <param argument="--remove_divergent_retain" type="text" value="" label="Retain Sequence by Name" help="Always keep the sequence with this exact name. (must match a seq name)"/>
                    </repeat>
                    <repeat name="remove_divergent_retain_strings" title="strings to retain" min="0">
                        <param argument="--remove_divergent_retain_str" type="text" value="" label="Retain Sequences Containing Text" help="Always keep sequences whose names contain this text."/>            
                    </repeat>
                </when>
                <when value="false"/>
            </conditional>

            <!-- Remove Insertions options -->
            <conditional name="remove_insertions_cond">
                <param name="remove_insertions_param" type="select" label="Remove Rare Insertions" help="Remove insertions not present in the majority of sequences.">
                    <option value="true">yes</option>
                    <option value="false" selected="true">no</option>
                </param>            
                <when value="true">
                    <param argument="--insertion_min_size" type="integer" value="3" min="1" label="Minimum Insertion Size" help="Only remove insertions larger than this number of residues. Must be less than or equal to the number of columns in your alignment."/>
                    <param argument="--insertion_max_size" type="integer" value="200" min="1" max="10000" label="Maximum Insertion Size" help="Only remove insertions smaller than this number of residues."/>
                    <param argument="--insertion_min_flank" type="integer" value="5" min="0"  label="Minimum Flank Size" help="Minimum number of bases required on each side of an insertion. Must be less than half the alignment length."/>            
                    <param argument="--insertion_min_perc" type="float" value="0.5" min="0" max="1" label="Minimum Presence Proportion" help="Remove insertions found in less than this proportion of sequences."/>            
                </when>
                <when value="false"/>
            </conditional>

            <!-- Crop Ends options -->
            <conditional name="crop_ends_cond">
                <param name="crop_ends_param" type="select" label="Crop Sequence Ends" help="Trim ends of sequences if they are poorly aligned.">
                    <option value="true">yes</option>
                    <option value="false" selected="true">no</option>
                </param>            
                <when value="true">
                    <param argument="--crop_ends_mingap_perc" type="float" value="0.05" min="0" max="0.6" label="Minimum Gap Change Threshold" help="Minimum proportion of sequence length (excluding gaps) used to detect significant change in gap numbers."/>            
                    <param argument="--crop_ends_redefine_perc" type="float" value="0.1" min="0" max="0.5" label="Region Proportion to Check" help="Proportion of the sequence (excluding gaps) checked at each end to redefine cropping boundaries."/>                        
                    <repeat name="crop_ends_retain_seqs" title="sequences to retain" min="0">
                        <param argument="--crop_ends_retain" type="text" value="" label="Retain Sequence by Name" help="Do not crop the sequence with this exact name. (must match a seq name)"/>
                    </repeat>
                    <repeat name="crop_ends_retain_strings" title="strings to retain" min="0">
                        <param argument="--crop_ends_retain_str" type="text" value="" label="Retain Sequences Containing Text" help="Do not crop sequences whose names contain this text. Case-sensitive."/>            
                    </repeat>
                </when>
                <when value="false"/>
            </conditional>
        
            <!-- Remove Short options -->
            <conditional name="remove_short_cond">
                <param name="remove_short_param" type="select" label="Remove Short Sequences" help="Remove sequences shorter than a specified length (excluding gaps).">
                    <option value="true">yes</option>
                    <option value="false" selected="true">no</option>
                </param>            
                <when value="true">
                    <param argument="--remove_min_length" type="integer" value="50" min="0" label="Minimum Sequence Length" help="Remove sequences shorter than this length, excluding gaps."/>            
                    <repeat name="remove_short_retain_seqs" title="sequences to retain" min="0">
                        <param argument="--remove_short_retain" type="text" value="" label="Retain Sequence by Name" help="Do not remove the sequence with this exact name. (must match a seq name)"/>
                    </repeat>
                    <repeat name="remove_short_retain_strings" title="strings to retain" min="0">
                        <param argument="--remove_short_retain_str" type="text" value="" label="Retain Sequences Containing Text" help="Do not remove sequences whose names contain this text. Case-sensitive."/>            
                    </repeat>
                </when>
                <when value="false"/>
            </conditional>

            <!-- Crop Divergent options -->
            <conditional name="crop_divergent_cond">
                <param name="crop_divergent_param" type="select" label="Crop Divergent Sequences" help="Remove highly divergent regions to improve alignment quality by focusing on more conserved parts.">
                    <option value="true">yes</option>
                    <option value="false" selected="true">no</option>
                </param>            
                <when value="true">
                    <param argument="--crop_divergent_min_prop_ident" type="float" value="0.5" min="0.01" max="1" label="Minimum Identity Proportion" help="Minimum proportion of sequences that must share the same residue in a column."/>            
                    <param argument="--crop_divergent_min_prop_nongap" type="float" value="0.5" min="0.01" max="1" label="Minimum Non-Gap Proportion" help="Minimum proportion of sequences that must contain a non-gap residue in a column."/>            
                    <param argument="--crop_divergent_buffer_size" type="integer" value="5" min="1" label="Buffer Size" help="Number of consecutive columns that must meet the identity and non-gap criteria to retain a region."/>            
                </when>
                <when value="false"/>
            </conditional>

            <!-- Retain options -->
            <conditional name="retain_cond">
                <param name="retain_param" type="select" label="Retain Specific Sequences" help="Specify sequences that should not be edited or removed during row-wise functions.">
                    <option value="true">yes</option>
                    <option value="false" selected="true">no</option>
                </param>            
                <when value="true">
                    <repeat name="retain_seqs" title="sequences to retain" min="0">
                        <param argument="--retain" type="text" value="" label="Retain Sequence with This Name" help="Do not edit or remove the sequence with this exact name during row-wise functions. Can be used multiple times. (must match a seq name)"/>
                    </repeat>
                    <repeat name="retain_strings" title="strings to retain" min="0">
                        <param argument="--retain_str" type="text" value="" label="Retain Sequences Containing This String" help="Do not edit or remove sequences with names containing this text. Case-sensitive."/>            
                    </repeat>
                </when>
                <when value="false"/>
            </conditional>
        </section>

        <section name="visualisation_options" title="Visualisation Options" expanded="false">
            <!-- Visualisation options -->
            <section name="basic_visualisation_options" title="Basic Visualisation Options" expanded="false">
                <param argument="--plot_input" type="boolean" checked="false" falsevalue="" truevalue="--plot_input" label="plot input" help="visualisation of the input alignment"/>
                <param argument="--plot_output" type="boolean" checked="false" falsevalue="" truevalue="--plot_output" label="plot output" help="visualisation of the cleaned output alignment"/>
                <param argument="--plot_markup" type="boolean" checked="false" falsevalue="" truevalue="--plot_markup" label="plot markup" help="visualisation of the input alignment with deleted rows and columns marked"/>
                <param argument="--plot_consensus_identity" type="boolean" checked="false" falsevalue="" truevalue="--plot_consensus_identity" label="plot consensus identity" help="Plot a mini alignment showing positions which are identical to or differ from the consensus."/>
                <param argument="--plot_consensus_similarity" type="boolean" checked="false" falsevalue="" truevalue="--plot_consensus_similarity" label="plot consensus similarity" help="Plot a mini alignment showing positions based on their score when when compared via a substitution matrix to the consensus."/>        
                <section name="output_settings" title="Output Settings" expanded="false">
                    <param argument="--plot_width" type="integer" value="5" label="plot width" help="Mini alignment width in inches."/>
                    <param argument="--plot_height" type="integer" value="3" label="plot height" help="Mini alignment height in inches."/>
                    <param argument="--plot_dpi" type="integer" value="300" label="plot DPI" help="DPI for mini alignments"/>
                    <param argument="--plot_keep_numbers" type="boolean" checked="false" falsevalue="" truevalue="--plot_keep_numbers" label="plot keep numbers" help="If specified, for mini alignments based on CIAlign output with smaller than 10 sequences (or if force_numbers is switched on) the rows will be labelled based on the input alignment, rather than renumbered."/>
                    <param argument="--plot_force_numbers" type="boolean" checked="false" falsevalue="" truevalue="--plot_force_numbers" label="plot force numbers" help="Force all rows to be numbered on the mini alignments rather than labelling e.g. every 10th row for larger plots. Will cause labels to overlap on large plots."/>
                    <param argument="--plot_identity_palette" type="text" value="bone" label="plot identity palette" help="Matplotlib palette name for identity mini alignments."/>
                    <param argument="--plot_identity_gap_col" type="text" value="white" label="plot identity gap col" help="Colour for gaps in identity mini alignments."/>
                    <param argument="--plot_similarity_palette" type="text" value="bone" label="plot similarity palette" help="Matplotlib palette name for similarity mini alignments."/>
                    <param argument="--plot_similarity_gap_col" type="text" value="white" label="plot similarity gap col" help="Colour for gaps in similarity mini alignments."/>
                    <param argument="--palette" type="text" value="CBS" label="Colour palette" help="Colour palette. Currently implemented CBS (colour blind safe) or bright."/>
                </section>
             </section>

            <!-- Sequence Logos -->
            <conditional name="sequence_logo_cond">
                <param name="sequence_logo_param" type="select" label="make sequence logo?" help=" 	Draw a sequence logo.">
                    <option value="true">yes</option>
                    <option value="false" selected="true">no</option>
                </param>            
                <when value="true">
                    <param argument="--sequence_logo_type" type="select" label="Type of sequence logo:" help="Type of sequence logo - bar/text/both">
                        <option value="bar">bar</option>
                        <option value="text" selected="true">text</option>
                        <option value="both">both</option>
                    </param> 
                    <param argument="--sequence_logo_dpi" type="integer" value="300" label="Resolution (DPI)" help="DPI (dots per inch) for sequence logo. "/>
                    <param argument="--sequence_logo_font" type="text" value="monospace" label="Logo Font:" help="Font for bases / amino acids in a text based sequence logo"/>
                    <param argument="--sequence_logo_nt_per_row" type="integer" value="50" label="Number of Bases/amino acids per row:" help="Number of bases / amino acids to show per row in the sequence logo, where the logo is too large to show on a single line"/>
                    <param argument="--logo_start" type="integer" optional="true" label="Logo Start" help="Start sequence logo"/>
                    <param argument="--logo_end" type="integer" optional="true" label="Logo End" help="End sequence logo"/>
                </when>
                <when value="false"/>
            </conditional>


            <!-- Statistics Plots -->
            <section name="statistics_plots" title="Statistics Plots" expanded="false">
                <param argument="--plot_stats_input" type="boolean" checked="false" falsevalue="" truevalue="--plot_stats_input" label="plot stats input" help="Plot the statistics for the input MSA"/>        
                <param argument="--plot_stats_output" type="boolean" checked="false" falsevalue="" truevalue="--plot_stats_output" label="plot stats input" help="Plot the statistics for the output MSA"/>        
                <section name="stats_settings" title="Statistics Plots Settings" expanded="false">
                    <param argument="--plot_stats_dpi" type="integer" value="300" label="DPI" help="DPI for coverage plot"/>
                    <param argument="--plot_stats_width" type="integer" value="5" label="plot width" help="Width for coverage plot (inches)"/>
                    <param argument="--plot_stats_height" type="integer" value="3" label="plot height" help="Height for coverage plot (inches)"/>
                </section>
            </section>
        </section>
        
        
        <section name="interpretation_options" title="Interpretation Options" expanded="false">
            <!-- Consensus Sequences -->
            <conditional name="consensus_sequences_cond">
                <param name="consensus_sequences_param" type="select" label="Consensus Sequences" help="This generates a consensus sequence based on the cleaned alignment.">
                    <option value="true">yes</option>
                    <option value="false" selected="true">no</option>
                </param>            
                <when value="true">
                    <!-- consensus_sequences -->
                    <param argument="--consensus_type" type="select" label="type of consensus sequence:" help="can be majority, to use the most common character at each position in the consensus, even if this is a gap, or majority_nongap, to use the most common non-gap character at each position">
                        <option value="majority" selected="true">majority</option>
                        <option value="majority_nongap">majority_nongap</option>
                    </param> 
                    <param argument="--consensus_keep_gaps" type="boolean" truevalue="--consensus_keep_gaps" falsevalue="" checked="false" label="with gaps?" help="should gaps be included in the consensus"/>            
                </when>
                <when value="false"/>
            </conditional>

            <!-- Position Matrices -->
            <section name="position_matrices" title="Position Matrices" expanded="false">
                <param argument="--pwm_input" type="boolean" checked="false" falsevalue="" truevalue="--pwm_input" label="generate input matrices" help="Generate a position frequency matrix, position probability matrix and position weight matrix based on the input alignment"/>        
                <param argument="--pwm_output" type="boolean" checked="false" falsevalue="" truevalue="--pwm_output" label="generate output matrices" help="Generate a position frequency matrix, position probability matrix and position weight matrix based on the cleaned output alignment"/>        
                <section name="matrices_settings" title="Position Matrices Settings" expanded="false">
                    <param argument="--pwm_start" type="integer" optional="true" label="Start the PWM" help="Start the PWM and other matrices from this column of the input alignment"/>
                    <param argument="--pwm_end" type="integer" optional="true" label="End the PWM" help="End the PWM and other matrices at this column of the input alignment"/>
                    <param argument="--pwm_freqtype" type="select" label="Type of background frequency matrix:" help="Type of background frequency matrix to use when generating the PWM. Should be 'equal', 'calc', 'calc2' or 'user'. 'equal', assume all residues are equally common, 'calc', frequency is calculated using the PFM, 'calc2', frequency is calculated using the full alignment (same as calc if pwm_start and pwm_end are not specified).">
                        <option value="equal" selected="true">equal</option>
                        <option value="calc">calc</option>
                        <option value="calc2">calc2</option>
                    </param> 
                    <param argument="--pwm_alphatype" type="select" label="Alpha value:" help="If alphatype is 'calc', alpha is calculated as frequency(base), If alpha type is 'user' the user provides the value of alpha as pwm_alphatype. To run without pseudocounts set pwm_alphatype as user and pwm_alphaval as 0.">
                        <option value="user">user</option>
                        <option value="calc" selected="true">calc</option>
                    </param>
                    <param argument="--pwm_alphaval" type="integer" value="1" label="Alpha value" help="User defined value of the alpha parameter to use as a pseudocount in the PPM."/>
                </section>
                <param argument="--pwm_output_blamm" type="boolean" checked="false" falsevalue="" truevalue="--pwm_output_blamm" label="output for BLAM" help="Output PPM formatted for BLAMM software"/>        
                <param argument="--pwm_output_meme" type="boolean" checked="false" falsevalue="" truevalue="--pwm_output_meme" label="output for MEME" help="Output PPM formatted for MEME software"/>        
            </section>

            <!-- Similarity Matrices -->
            <section name="similarity_matrices" title="Similarity Matrices" expanded="false">
                <param argument="--make_similarity_matrix_input" type="boolean" checked="false" falsevalue="" truevalue="--make_similarity_matrix_input" label="input similarity matrix" help="Make a similarity matrix for the input alignment"/>        
                <param argument="--make_similarity_matrix_output" type="boolean" checked="false" falsevalue="" truevalue="--make_similarity_matrix_output" label="output similarity matrix" help="Make a similarity matrix for the output alignment"/>        
                <section name="similarity_matrices_settings" title="Similarity Matrices Settings" expanded="false">
                    <param argument="--make_simmatrix_keepgaps" type="integer" value="0" label="keep gaps" help="0 - exclude positions which are gaps in either or both sequences from similarity calculations, 1 - exclude positions which are gaps in both sequences, 2 - include all positions"/>
                    <param argument="--make_simmatrix_dp" type="integer" value="4" label="decimal places" help="Number of decimal places to display in the similarity matrix output file"/>
                    <param argument="--make_simmatrix_minoverlap" type="integer" value="1" label="Minimum overlap:" help="Minimum overlap between two sequences to have non-zero similarity in the similarity matrix"/>
                </section>
            </section>
        </section>

        <!-- Editing Functions -->
        <section name="editing_functions" title="Editing Options" expanded="false">
            <!-- get section -->
            <conditional name="get_section_cond">
            <param name="get_section_param" type="select" label="Retrieve and process a section of the alignment?">
                <option value="true" >yes</option>
                <option value="false" selected="true">no</option>
            </param>            
            <when value="true">
                <param argument="--section_start" type="integer" label="section start: " help="Start position in the original alignment for the section to be extracted"/>        
                <param argument="--section_end" type="integer" label="section end: " help="End position in the original alignment for the section to be extracted"/>        
            </when>
            <when value="false"/>
        </conditional>
            <!-- replace bases-->
            <param argument="--replace_input_tu" type="boolean" checked="false" falsevalue="" truevalue="--replace_input_tu" label="replace input tu " help="Generates a copy of the input alignment with U's instead of T's"/>        
            <param argument="--replace_input_ut" type="boolean" checked="false" falsevalue="" truevalue="--replace_input_ut" label="replace input ut " help="Generates a copy of the input alignment with T's instead of U's"/>        
            <param argument="--replace_output_tu" type="boolean" checked="false" falsevalue="" truevalue="--replace_output_tu" label="replace output tu " help="Generates a copy of the output alignment with U's instead of T's"/>        
            <param argument="--replace_output_ut" type="boolean" checked="false" falsevalue="" truevalue="--replace_output_ut" label="replace output ut " help="Generates a copy of the output alignment with T's instead of U's"/>        
            <!-- Unaligning -->
            <param argument="--unalign_input" type="boolean" checked="false" falsevalue="" truevalue="--unalign_input" label=" input alignment with no gaps " help="Generates a copy of the input alignment with no gaps"/>        
            <param argument="--unalign_output" type="boolean" checked="false" falsevalue="" truevalue="--unalign_output" label=" out alignment with no gaps " help="Generates a copy of the output alignment with no gaps"/>        
            <param argument="--deduplicate_ids" type="boolean" checked="false" falsevalue="" truevalue="--deduplicate_ids" label="remove duplicates" help="Remove sequences with duplicate names from the input."/>        
            <param argument="--duporder" type="select" label="Duplicates order:" help="Set to first to keep the first instance of the sequence name and last to keep the last">
                    <option value="first" selected="true">first</option>
                    <option value="last">last</option>
            </param>
        </section>
    </inputs>

    <outputs>
        <data name="output_cleaned" format="fasta" from_work_dir="output_cleaned.fasta" label="${tool.name} on ${on_string}: Cleaned Alignment"/>
        <data name="output_removed" format="txt" from_work_dir="output_removed.txt" label="${tool.name} on ${on_string}: Removed Sequences"/>
        <!-- 
        <data name="output_log" format="txt" from_work_dir="output_log.txt" label="${tool.name} on ${on_string}: Log File"/>
        -->
        <!-- Visualisation Options Outputs -->
        <data name="plot_input" format="png" from_work_dir="output_input.png" label="${tool.name} on ${on_string}: Input Plot">
            <filter>visualisation_options['basic_visualisation_options']['plot_input'] or basic_options['visualise']</filter>
        </data>
        <data name="plot_output" format="png" from_work_dir="output_output.png" label="${tool.name} on ${on_string}: Output Plot">
            <filter>visualisation_options['basic_visualisation_options']['plot_output'] or basic_options['visualise']</filter>
        </data>
        <data name="plot_markup" format="png" from_work_dir="output_markup.png" label="${tool.name} on ${on_string}: Markup Plot">
            <filter>visualisation_options['basic_visualisation_options']['plot_markup'] or basic_options['visualise']</filter>
        </data>
        <data name="plot_consensus_identity" format="png" from_work_dir="output_consensus_identity.png" label="${tool.name} on ${on_string}: Consensus Identity Plot">
            <filter>visualisation_options['basic_visualisation_options']['plot_consensus_identity']</filter>
        </data>
        <data name="plot_consensus_similarity" format="png" from_work_dir="output_consensus_similarity.png" label="${tool.name} on ${on_string}: Consensus Similarity Plot">
            <filter>visualisation_options['basic_visualisation_options']['plot_consensus_similarity']</filter>
        </data>
        <data name="logo_bar" format="png" from_work_dir="output_logo_bar.png" label="${tool.name} on ${on_string}: Logo Bar Chart">
            <filter>(visualisation_options['sequence_logo_cond']['sequence_logo_param'] == 'true' and (visualisation_options['sequence_logo_cond']['sequence_logo_type'] == 'bar' or visualisation_options['sequence_logo_cond']['sequence_logo_type'] == 'both'))</filter>
        </data>
        <data name="logo_text" format="png" from_work_dir="output_logo_text.png" label="${tool.name} on ${on_string}: Logo Text Chart">
            <filter>(visualisation_options['sequence_logo_cond']['sequence_logo_param'] == 'true' and (visualisation_options['sequence_logo_cond']['sequence_logo_type'] == 'text' or visualisation_options['sequence_logo_cond']['sequence_logo_type'] == 'both'))</filter>
        </data>
        <data name="input_coverage" format="png" from_work_dir="output_input_coverage.png" label="${tool.name} on ${on_string}: Input Coverage">
            <filter>visualisation_options['statistics_plots']['plot_stats_input'] or basic_options['interpret']</filter>
        </data>
        <data name="input_information_content" format="png" from_work_dir="output_input_information_content.png" label="${tool.name} on ${on_string}: Input Info Content">
            <filter>visualisation_options['statistics_plots']['plot_stats_input'] or basic_options['interpret']</filter>
        </data>
        <data name="input_shannon_entropy" format="png" from_work_dir="output_input_shannon_entropy.png" label="${tool.name} on ${on_string}: Input Entropy">
            <filter>visualisation_options['statistics_plots']['plot_stats_input'] or basic_options['interpret']</filter>
        </data>
        <data name="input_resfreq" format="png" from_work_dir="output_input_resfreq.png" label="${tool.name} on ${on_string}: Input ResFreq">
            <filter>visualisation_options['statistics_plots']['plot_stats_input'] or basic_options['interpret']</filter>
        </data>
        <data name="input_changefreq" format="png" from_work_dir="output_input_changefreq.png" label="${tool.name} on ${on_string}: Input ChangeFreq">
            <filter>visualisation_options['statistics_plots']['plot_stats_input'] or basic_options['interpret']</filter>
        </data>
        <data name="output_coverage" format="png" from_work_dir="output_output_coverage.png" label="${tool.name} on ${on_string}: Output Coverage">
            <filter>visualisation_options['statistics_plots']['plot_stats_output'] or basic_options['interpret']</filter>
        </data>
        <data name="output_information_content" format="png" from_work_dir="output_output_information_content.png" label="${tool.name} on ${on_string}: Output Info Content">
            <filter>visualisation_options['statistics_plots']['plot_stats_output'] or basic_options['interpret']</filter>
        </data>
        <data name="output_shannon_entropy" format="png" from_work_dir="output_output_shannon_entropy.png" label="${tool.name} on ${on_string}: Output Entropy">
            <filter>visualisation_options['statistics_plots']['plot_stats_output'] or basic_options['interpret']</filter>
        </data>
        <data name="output_resfreq" format="png" from_work_dir="output_output_resfreq.png" label="${tool.name} on ${on_string}: Output ResFreq">
            <filter>visualisation_options['statistics_plots']['plot_stats_output'] or basic_options['interpret']</filter>
        </data>
        <data name="output_changefreq" format="png" from_work_dir="output_output_changefreq.png" label="${tool.name} on ${on_string}: Output ChangeFreq">
            <filter>visualisation_options['statistics_plots']['plot_stats_output'] or basic_options['interpret']</filter>
        </data>
        <!-- Interpretaion Options Outputs -->
        <data name="output_consensus" format="fasta" from_work_dir="output_consensus.fasta" label="${tool.name} on ${on_string}: Consensus Sequence">
            <filter>interpretation_options['consensus_sequences_cond']['consensus_sequences_param'] == 'true' or basic_options['interpret']</filter>
        </data>
        <data name="output_with_consensus" format="fasta" from_work_dir="output_with_consensus.fasta" label="${tool.name} on ${on_string}: Cleaned + Consensus">
            <filter>interpretation_options['consensus_sequences_cond']['consensus_sequences_param'] == 'true' or basic_options['interpret']</filter>
        </data>
        <data name="pwm_input" format="txt" from_work_dir="output_pwm_input.txt" label="${tool.name} on ${on_string}: PWM Input">
            <filter>interpretation_options['position_matrices']['pwm_input']</filter>
        </data>
        <data name="ppm_input" format="txt" from_work_dir="output_ppm_input.txt" label="${tool.name} on ${on_string}: PPM Input">
            <filter>interpretation_options['position_matrices']['pwm_input']</filter>
        </data>
        <data name="pfm_input" format="txt" from_work_dir="output_pfm_input.txt" label="${tool.name} on ${on_string}: PFM Input">
            <filter>interpretation_options['position_matrices']['pwm_input']</filter>
        </data>
        <data name="ppm_meme_input" format="txt" from_work_dir="output_ppm_meme_input.txt" label="${tool.name} on ${on_string}: PPM for MEME (Input)">
            <filter>interpretation_options['position_matrices']['pwm_input'] and interpretation_options['position_matrices']['pwm_output_meme']</filter>
        </data>
        <data name="blamm_input" format="txt" from_work_dir="output_pfm_blamm_input.txt" label="${tool.name} on ${on_string}: PFM for BLAMM (Input)">
            <filter>interpretation_options['position_matrices']['pwm_input'] and interpretation_options['position_matrices']['pwm_output_blamm']</filter>
        </data>
        <data name="pwm_output" format="txt" from_work_dir="output_pwm_output.txt" label="${tool.name} on ${on_string}: PWM Output">
            <filter>interpretation_options['position_matrices']['pwm_output']</filter>
        </data>
        <data name="ppm_output" format="txt" from_work_dir="output_ppm_output.txt" label="${tool.name} on ${on_string}: PPM Output">
            <filter>interpretation_options['position_matrices']['pwm_output']</filter>
        </data>
        <data name="pfm_output" format="txt" from_work_dir="output_pfm_output.txt" label="${tool.name} on ${on_string}: PFM Output">
            <filter>interpretation_options['position_matrices']['pwm_output']</filter>
        </data>
        <data name="ppm_meme_output" format="txt" from_work_dir="output_ppm_meme_output.txt" label="${tool.name} on ${on_string}: PPM for MEME (Output)">
            <filter>interpretation_options['position_matrices']['pwm_output'] and interpretation_options['position_matrices']['pwm_output_meme']</filter>
        </data>
        <data name="blamm_output" format="txt" from_work_dir="output_pfm_blamm_output.txt" label="${tool.name} on ${on_string}: PFM for BLAMM (Output)">
            <filter>interpretation_options['position_matrices']['pwm_output'] and interpretation_options['position_matrices']['pwm_output_blamm']</filter>
        </data>
        <data name="input_similarity" format="tsv" from_work_dir="output_input_similarity.tsv" label="${tool.name} on ${on_string}: Input Similarity">
            <filter>interpretation_options['similarity_matrices']['make_similarity_matrix_input'] or basic_options['interpret']</filter>
        </data>
        <data name="output_similarity" format="tsv" from_work_dir="output_input_similarity.tsv" label="${tool.name} on ${on_string}: Output Similarity">
            <filter>interpretation_options['similarity_matrices']['make_similarity_matrix_output'] or basic_options['interpret']</filter>
        </data>
        <!-- Editing Options Outputs -->
        <data name="U_input" format="fasta" from_work_dir="output_U_input.fasta" label="${tool.name} on ${on_string}: Input: U instead of T">
            <filter>editing_functions['replace_input_tu']</filter>
        </data>
        <data name="T_input" format="fasta" from_work_dir="output_T_input.fasta" label="${tool.name} on ${on_string}: Input: T instead of U">
            <filter>editing_functions['replace_input_ut']</filter>
        </data>
        <data name="U_output" format="fasta" from_work_dir="output_U_output.fasta" label="${tool.name} on ${on_string}: Output: U instead of T">
            <filter>editing_functions['replace_output_tu']</filter>
        </data>
        <data name="T_output" format="fasta" from_work_dir="output_T_output.fasta" label="${tool.name} on ${on_string}: Output: T instead of U">
            <filter>editing_functions['replace_output_ut']</filter>
        </data>
        <data name="unaligned_input" format="fasta" from_work_dir="output_unaligned_input.fasta" label="${tool.name} on ${on_string}: Unaligned Input">
            <filter>editing_functions['unalign_input']</filter>
        </data>
        <data name="unaligned_output" format="fasta" from_work_dir="output_unaligned_output.fasta" label="${tool.name} on ${on_string}: Unaligned Output">
            <filter>editing_functions['unalign_output']</filter>
        </data>
    </outputs>

    <tests>
        <!-- Test 1 to check clean mode -->
        <test expect_num_outputs="2">
            <param name="input" value="example1.fasta" ftype="fasta"/>
            <section name="basic_options">
                <param name="clean" value="true"/>
            </section>
            <output name="output_cleaned" file="output_cleaned.fasta" ftype="fasta"/>
            <output name="output_removed" file="output_removed.txt" ftype="txt"/>
            <!-- 
            <output name="output_log" file="output_log.txt" ftype="txt"/>
            -->
        </test>
        <!-- Test 3 to check interpretiation options -->
        <test expect_num_outputs="4">
            <param name="input" value="example1.fasta" ftype="fasta"/>

            <section name="basic_options">
                <param name="clean" value="true"/>
            </section>

            <section name="interpretation_options">
                <conditional name="consensus_sequences_cond">
                    <param name="consensus_sequences_param" value="true"/>
                    <param name="consensus_type" value="majority"/>
                    <param name="consensus_keep_gaps" value="false"/>
                </conditional>
            </section>

            <output name="output_cleaned" file="output_cleaned.fasta" ftype="fasta"/>
            <output name="output_removed" file="output_removed.txt" ftype="txt"/>
            <output name="output_consensus" file="output_consensus.fasta" ftype="fasta"/>
            <output name="output_with_consensus" file="output_with_consensus.fasta" ftype="fasta"/>
        </test>
        <!-- Test 4 to check editing functions -->
        <test expect_num_outputs="3">
            <param name="input" value="example1.fasta" ftype="fasta"/>

            <section name="basic_options">
                <param name="clean" value="true"/>
            </section>

            <section name="editing_functions">
                <param name="replace_output_ut" value="true"/>
            </section>

            <output name="output_cleaned" file="output_cleaned.fasta" ftype="fasta"/>
            <output name="output_removed" file="output_removed.txt" ftype="txt"/>
            <output name="T_output" file="output_T_output.fasta" ftype="fasta"/>
        </test>
    </tests>
    <expand macro="help"/>
    <citations>
        <citation type="bibtex">
            @misc{githubCIAlign,
            author = {Brown, Katy},
            year = {2022},
            title = {CIAlign},
            publisher = {GitHub},
            journal = {GitHub repository},
            url = {https://github.com/KatyBrown/CIAlign},}
            </citation>
    </citations>
</tool>
