<!-- Not Ready for Review Yet -->
<tool id="sourmash_signature" name="sourmash signature" version="@TOOL_VERSION@+galaxy@VERSION_SUFFIX@" profile="@PROFILE@">
    <macros>
        <import>macros.xml</import>
    </macros>
    <expand macro="requirements"/>
    <command detect_errors="exit_code"><![CDATA[
        sourmash sig

        #if $sig.subcommand == "describe":
            describe $sig.signature
            > describe.txt
        #else if $sig.subcommand == "cat": 
            @list_inputs@
            -o all.sig.zip
        #else if $sig.subcommand == "grep": 
            grep
            #set patterns_string = ""
            #for $i, $s in enumerate($sig.patterns):
                #if $i > 0:
                    #set patterns_string += "|"
                #end if
                #set patterns_string += '%s' % ($s.pattern) 
            #end for
            '$patterns_string'
            #for $file in $sig.input_files:
                $file
            #end for
            $sig.case_insensitive
            $sig.exclusion
            -o match.sig.zip
        #else if $sig.subcommand == "merge":
            @list_inputs@
            $sig.flatten
            @sig_params@
            -o merged.sig
        #else if $sig.subcommand == "split":  
            split
            $sig.signature
            @sig_params@
            --outdir sigs
        #else if $sig.subcommand == "subtract":
            @list_inputs@
            $sig.flatten
            @sig_params@
            -o subtracted.sig
        #else if $sig.subcommand == "intersect":
            @list_inputs@
            @sig_params@
            #if $sig.abundance_from:
                -A $sig.abundance_from
            #end if
            -o intersected.sig
        #else if $sig.subcommand == "inflate":
            @list_inputs@
            @sig_params@
            -o inflated.sig
        #else if $sig.subcommand == "downsample":
            @list_inputs@
            $sig.downsample_cond.downsample_type
            $sig.downsample_cond.downsample_value
            -o downsampled.sig
        #else if $sig.subcommand == "flatten":
            @list_inputs@
            -o flattened.sig
        #else if $sig.subcommand == "filter":
            @list_inputs@
            #if $sig.min_abundance:
                -m $sig.min_abundance
            #end if
            #if $sig.max_abundance:
                -m $sig.max_abundance
            #end if
            -o filtered.sig
        #else if $sig.subcommand == "import":
            import
            $sig.signature
            -o imported.sig
        #else if $sig.subcommand == "export":
            export
            $sig.signature
            @sig_params@
            -o exported.sig.msh.json
        #else if $sig.subcommand == "overlap":
            @list_inputs@
            > overlap.txt
        #else if $sig.subcommand == "manifest":
            manifest
            $sig.input
            --no-rebuild-manifest
            -o manifest.csv
        #else if $sig.subcommand == "check":
            @list_inputs@
            --picklist
            $sig.list::manifest
            -m matches.csv
        #else if $sig.subcommand == "collect":
        #end if
    ]]></command>
    <inputs>
        <conditional name="sig" label="Sourmash Signature Subcommand">
            <param name="subcommand" type="select" optional="false" label="Subcommand" help="Choose the sourmash lca subcommand tool. Read Help section for detailed information about each subcommand.">
                <option value="describe">describe</option>
                <option value="cat">cat</option>
                <option value="grep">grep</option>
                <option value="merge">merge</option>
                <option value="split">split</option>
                <option value="subtract">subtract</option>
                <option value="intersect">intersect</option>
                <option value="inflate">inflate</option>
                <option value="downsample">downsample</option>
                <option value="extract">extract</option>
                <option value="flatten">flatten</option>
                <option value="filter">filter</option>
                <option value="import">import</option>
                <option value="export">export</option>
                <option value="overlap">overlap</option>
                <option value="manifest">manisfest</option>
                <option value="check">check</option>
                <option value="collect">collect</option>
            </param>
            <when value="describe">
                <expand macro="single_signature"/>
            </when>
            <when value="cat">
                <expand macro="multiple_signatures"/>
            </when>
            <when value="grep">
                <param name="input_files" type="data" format="json,zip" multiple="true" label="Input files" help="Signature files to search against. Accepts individual signature files or compressed archives containing multiple signatures."/>
                <repeat name="patterns" title="Patterns" min="0"  help="Insert a pattern to match against the provided signature files.">
                    <param name="pattern" type="text" label="Pattern"/> 
                </repeat>
                <param name="case_insensitive" argument="-i" type="boolean" truevalue="-i" falsevalue="" checked="false" label="Case-insensitive" help="If checked, matching is performed in a case-insensitive manner."/> 
                <param name="exclusion" argument="-v" type="boolean" truevalue="-v" falsevalue="" checked="false" label="Exclusion" help="If checked, exclude signatures that match the given patterns instead of including them."/> 
            </when>
            <when value="merge">
                <expand macro="multiple_signatures"/>
                <expand macro="sig_flatten" help="Remove abundances from all signatures."/>
                <expand macro="sig_ksize" help="Specifies which k-mer size to merge when multiple signature files with different k-sizes are provided."/>
                <expand macro="sig_moltype" help="Specifies which moltype to merge when multiple signature files with different moltypes are provided."/>
            </when>
            <when value="split">
                <expand macro="single_signature"/>
                <expand macro="sig_ksize" help="Select the k-mer size to extract when splitting a merged signatures file containing multiple k-sizes. Leave blank to keep all k-sizes."/>
                <expand macro="sig_moltype" help="Select the molecule type to extract when splitting signatures with mixed moltypes. Leave blank to keep all moltypes."/>
            </when>
            <when value="subtract">
                <expand macro="multiple_signatures"/>
                <expand macro="sig_flatten" help="Check here to use subtract on signatures calculated with -p abund."/>
                <expand macro="sig_ksize" help="Specifies which k-mer size to subtract when multiple signature files with different k-sizes are provided."/>
                <expand macro="sig_moltype" help="Specifies which moltype to subtract when multiple signature files with different moltypes are provided."/>
            </when>
            <when value="intersect">
                <expand macro="multiple_signatures"/>
                <param name="abundance_from" type="data" format="json" optional="true" label="Abundance from file" help="This argument will borrow abundances from the specified signature (which will also be added to the intersection)."/>
                <expand macro="sig_ksize" help="Specifies which k-mer size to subtract when multiple signature files with different k-sizes are provided."/>
                <expand macro="sig_moltype" help="Specifies which moltype to subtract when multiple signature files with different moltypes are provided."/>
            </when>
            <when value="inflate">
                <expand macro="multiple_signatures"/>
                <expand macro="sig_ksize" help="Specifies which k-mer size to subtract when multiple signature files with different k-sizes are provided."/>
                <expand macro="sig_moltype" help="Specifies which moltype to subtract when multiple signature files with different moltypes are provided."/>
            </when>
            <when value="downsample">
                <expand macro="multiple_signatures"/>
                <conditional name="downsample_cond" label="Downsample Type">
                    <param name="downsample_type" type="select" optional="false" label="Downsample Type" help="Select how to downsample the signature: 
                    scaled — Downsample by increasing the scaled value (reduces signature size based on hash density) or num — Downsample by setting a target number of hashes (reduces signature size based on hash count).
                    ">
                    <option value="--scaled">scaled</option>
                    <option value="--num">num</option>
                    </param>
                    <when value="--scaled">
                        <param name="downsample_value" type="integer" label="Downsample Value" help="TODO"/>
                    </when>
                    <when value="--num">
                        <param name="downsample_value" type="integer" label="Downsample Value" help="TODO"/>
                    </when>
                </conditional>                
            </when>
            <when value="extract">
            </when>
            <when value="flatten">
                <expand macro="multiple_signatures"/>
            </when>
            <when value="filter">
                <expand macro="multiple_signatures"/>
                <param name="min_abundance" label="Min Abundance" argument="-m" optional="true" type="integer" min="0" help="Keep only hashes with an abundance greater than or equal to this value."/>
                <param name="max_abundance" label="Max Abundance" argument="-M" optional="true" type="integer" min="0" help="Keep only hashes with an abundance less than or equal to this value."/>
            </when>
            <when value="import">
                <expand macro="single_signature"/>
            </when>
            <when value="export">
                <expand macro="single_signature"/>
                <expand macro="sig_ksize" help="Choose a k-mer size to export as."/>
                <expand macro="sig_moltype" help="Choose a moltype to export as."/>
            </when>
            <when value="overlap">
                <expand macro="multiple_signatures"/>
            </when>
            <when value="manifest">
                <param name="input" type="data" format="json,zip" label="Input file" help="signature, database, or a zipped collection of signatures."/>
            </when>
            <when value="check">
                <expand macro="multiple_signatures"/>
                <param name="list" type="data" format="csv" label="Picklist" help="A list against which the input signature is compared, with matching entries saved to a manifest file."/>
            </when>
            <when value="collect">
            </when>
        </conditional>
    </inputs>
    <outputs>
        <data name="describe" from_work_dir="describe.txt" format="txt" label="${tool.name} on ${on_string}: Signature Describtion">
            <filter>sig['subcommand'] == 'describe'</filter>
        </data>
        <data name="cat" from_work_dir="all.sig.zip" format="zip" label="${tool.name} on ${on_string}: All signatures">
            <filter>sig['subcommand'] == 'cat'</filter>
        </data>
        <data name="grep" from_work_dir="match.sig.zip" format="zip" label="${tool.name} on ${on_string}: Found Matches">
            <filter>sig['subcommand'] == 'grep'</filter>
        </data>
        <data name="merge" from_work_dir="merged.sig" format="json" label="${tool.name} on ${on_string}: Merged Sigantures">
            <filter>sig['subcommand'] == 'merge'</filter>
        </data>
        <collection name="split_output" type="list" format="json" label="Split Signatures on ${on_string}">
            <discover_datasets pattern="__name_and_ext__" directory="sigs" />
            <filter>sig['subcommand'] == 'split'</filter>
        </collection>
        <data name="subtract" from_work_dir="subtracted.sig" format="json" label="${tool.name} on ${on_string}: Subtraction Siganture">
            <filter>sig['subcommand'] == 'subtract'</filter>
        </data>
        <data name="intersect" from_work_dir="intersected.sig" format="json" label="${tool.name} on ${on_string}: Intersection Siganture">
            <filter>sig['subcommand'] == 'intersect'</filter>
        </data>
        <data name="inflate" from_work_dir="inflated.sig" format="json" label="${tool.name} on ${on_string}: Inflated Siganture">
            <filter>sig['subcommand'] == 'inflate'</filter>
        </data>
        <data name="downsample" from_work_dir="downsample.sig" format="json" label="${tool.name} on ${on_string}: Downsampled Signatures">
            <filter>sig['subcommand'] == 'downsample'</filter>
        </data>
        <data name="flatten" from_work_dir="flattened.sig" format="json" label="${tool.name} on ${on_string}: Flattened Signatures">
            <filter>sig['subcommand'] == 'flatten'</filter>
        </data>
        <data name="filter" from_work_dir="filtered.sig" format="json" label="${tool.name} on ${on_string}: Filtered Signatures">
            <filter>sig['subcommand'] == 'filter'</filter>
        </data>
        <data name="import" from_work_dir="imported.sig" format="json" label="${tool.name} on ${on_string}: Imported Siganture">
            <filter>sig['subcommand'] == 'import'</filter>
        </data>
        <data name="export" from_work_dir="exported.sig.msh.json" format="json" label="${tool.name} on ${on_string}: Exported Siganture">
            <filter>sig['subcommand'] == 'export'</filter>
        </data>
        <data name="overlap" from_work_dir="overlap.txt" format="txt" label="${tool.name} on ${on_string}: Overlap">
            <filter>sig['subcommand'] == 'overlap'</filter>
        </data>
        <data name="manifest" from_work_dir="manifest.csv" format="csv" label="${tool.name} on ${on_string}: Manifest">
            <filter>sig['subcommand'] == 'manifest'</filter>
        </data>
        <data name="check" from_work_dir="matches.csv" format="csv" label="${tool.name} on ${on_string}: Matches">
            <filter>sig['subcommand'] == 'check'</filter>
        </data>
        <!-- 
        <data name="collect" from_work_dir="mf.csv" format="csv" label="${tool.name} on ${on_string}: Collect manifests">
            <filter>sig['subcommand'] == 'collect'</filter>
        </data>
        -->
    </outputs>
    <tests>
    <!-- 1) describe -->
    <test expect_num_outputs="1">
        <conditional name="sig">
            <param name="subcommand" value="describe"/>
            <param name="signature" value="GCF_000005845.2_ASM584v2_genomic.fna.gz.sig"/>
        </conditional>
        <output name="describe" ftype="txt">
            <assert_contents>
                <has_text text="size: 4476"/>
            </assert_contents>
        </output>
    </test>
    <!-- 2) cat -->
    <test expect_num_outputs="1">
        <conditional name="sig">
            <param name="subcommand" value="cat"/>
            <param name="signatures" value="GCF_000005845.2_ASM584v2_genomic.fna.gz.sig,GCF_000017325.1_ASM1732v1_genomic.fna.gz.sig,GCF_000021665.1_ASM2166v1_genomic.fna.gz.sig"/>
        </conditional>
        <output name="cat" ftype="zip">
            <assert_contents>
                <has_archive_member path=".*\.csv" min="1">
                    <has_n_lines n="5"/>
                </has_archive_member>
            </assert_contents>
        </output>
    </test>
    <!-- 3) grep normal 2 patterns-->
    <test expect_num_outputs="1">
        <conditional name="sig">
            <param name="subcommand" value="grep"/>
            <param name="input_files" value="GCF_000005845.2_ASM584v2_genomic.fna.gz.sig,GCF_000017325.1_ASM1732v1_genomic.fna.gz.sig,GCF_000021665.1_ASM2166v1_genomic.fna.gz.sig"/>
            <param name="patterns_0|pattern" value="09a08691ce52952152f0e866a59f6261"/>
            <param name="patterns_1|pattern" value="0a8632c67e6d88f737ddb510bef90337"/>
        </conditional>
        <output name="grep" ftype="zip">
            <assert_contents>
                <has_archive_member path=".*\.csv" min="1">
                    <has_n_lines n="4"/>
                </has_archive_member>
            </assert_contents>
        </output>
        <assert_stderr>
            <has_text text="Kextracted 2 signatures from 3 file(s)"/>
        </assert_stderr>
    </test>
    <!-- 4) grep - case insensitive-->
    <test expect_num_outputs="1">
        <conditional name="sig">
            <param name="subcommand" value="grep"/>
            <param name="input_files" value="GCF_000005845.2_ASM584v2_genomic.fna.gz.sig,GCF_000017325.1_ASM1732v1_genomic.fna.gz.sig,GCF_000021665.1_ASM2166v1_genomic.fna.gz.sig"/>
            <param name="patterns_0|pattern" value="09A08691ce52952152f0e866a59f6261"/>
            <param name="patterns_1|pattern" value="0A8632c67e6d88f737ddb510bef90337"/>
            <param name="case_insensitive" value="true"/>
        </conditional>
        <output name="grep" ftype="zip">
            <assert_contents>
                <has_archive_member path=".*\.csv" min="1">
                    <has_n_lines n="4"/>
                </has_archive_member>
            </assert_contents>
        </output>
        <assert_stderr>
            <has_text text="Kextracted 2 signatures from 3 file(s)"/>
        </assert_stderr>
    </test>
    <!-- 5) grep - EXCLUSION-->
    <test expect_num_outputs="1">
        <conditional name="sig">
            <param name="subcommand" value="grep"/>
            <param name="input_files" value="GCF_000005845.2_ASM584v2_genomic.fna.gz.sig,GCF_000017325.1_ASM1732v1_genomic.fna.gz.sig,GCF_000021665.1_ASM2166v1_genomic.fna.gz.sig"/>
            <param name="patterns_0|pattern" value="09A08691ce52952152f0e866a59f6261"/>
            <param name="patterns_1|pattern" value="0A8632c67e6d88f737ddb510bef90337"/>
            <param name="case_insensitive" value="true"/>
            <param name="exclusion" value="true"/>
        </conditional>
        <output name="grep" ftype="zip">
            <assert_contents>
                <has_archive_member path=".*\.csv" min="1">
                    <has_n_lines n="3"/>
                </has_archive_member>
            </assert_contents>
        </output>
        <assert_stderr>
            <has_text text="Kextracted 1 signatures from 3 file(s)"/>
        </assert_stderr>
    </test>
    <!-- 6) Merge -->
    <test expect_num_outputs="1">
        <conditional name="sig">
            <param name="subcommand" value="merge"/>
            <param name="signatures" value="GCF_000005845.2_ASM584v2_genomic.fna.gz.sig,GCF_000017325.1_ASM1732v1_genomic.fna.gz.sig,GCF_000021665.1_ASM2166v1_genomic.fna.gz.sig"/>
            <param name="mol_type" value="--dna"/>
        </conditional>
        <output name="merge" ftype="json">
            <assert_contents>
                <has_text text="1652243004613"/>
            </assert_contents>
        </output>
        <assert_stderr>
            <has_text text="Kloaded and merged 3 signatures"/>
        </assert_stderr>
    </test>
    <!-- 7) split -->
    <test expect_num_outputs="1">
        <conditional name="sig">
            <param name="subcommand" value="split"/>
            <param name="signature" value="2.fa.sig"/>
            <param name="ksize" value="51"/>
        </conditional>
        <output_collection name="split_output" type="list">
            <element name="43f3b48e.k=51.scaled=1000.DNA.dup=0.2.fa" >
                <assert_contents>
                    <has_text text="1652688679521"/>
                </assert_contents>
            </element>
        </output_collection>
        <assert_stderr>
            <has_text text="Kloaded and split 1 signatures total."/>
        </assert_stderr>
    </test>
    <!-- 8) subtract-->
    <test expect_num_outputs="1">
        <conditional name="sig">
            <param name="subcommand" value="subtract"/>
            <param name="signatures" value="GCF_000005845.2_ASM584v2_genomic.fna.gz.sig,GCF_000017325.1_ASM1732v1_genomic.fna.gz.sig,GCF_000021665.1_ASM2166v1_genomic.fna.gz.sig"/>
            <param name="mol_type" value="--dna"/>
        </conditional>
        <output name="subtract" ftype="json">
            <assert_contents>
                <has_text text="1652243004613"/>
            </assert_contents>
        </output>
        <assert_stderr>
            <has_text text="Kloaded and subtracted 2 signatures"/>
        </assert_stderr>
    </test>
    <!-- 9) intersected -->
    <test expect_num_outputs="1">
        <conditional name="sig">
            <param name="subcommand" value="intersect"/>
            <param name="signatures" value="GCF_000005845.2_ASM584v2_genomic.fna.gz.sig,GCF_000017325.1_ASM1732v1_genomic.fna.gz.sig,GCF_000021665.1_ASM2166v1_genomic.fna.gz.sig"/>
            <param name="mol_type" value="--dna"/>
        </conditional>
        <output name="subtract" ftype="json">
            <assert_contents>
                <not_has_text text="1652243004613"/>
            </assert_contents>
        </output>
        <assert_stderr>
            <has_text text="Kloaded and intersected 3 signatures"/>
        </assert_stderr>
    </test>
    <!-- 10) inflated -->
    <test expect_num_outputs="1">
        <conditional name="sig">
            <param name="subcommand" value="inflate"/>
            <param name="signatures" value="47_abund.fa.sig,47_flat.fa.sig"/>
            <param name="mol_type" value="--dna"/>
        </conditional>
        <output name="inflate" ftype="json">
            <assert_contents>
                <has_text text="1,1,1"/>
            </assert_contents>
        </output>
        <assert_stderr>
            <has_text text="Kloaded and intersected 1 signatures"/>
        </assert_stderr>
    </test>
    <!-- 11) downsample -->
    <test expect_num_outputs="1">
        <conditional name="sig">
            <param name="subcommand" value="downsample"/>
            <param name="signatures" value="GCF_000005845.2_ASM584v2_genomic.fna.gz.sig"/>
            <conditional name="downsample_cond">
                <param name="downsample_type" value="--scaled"/>
                <param name="downsample_value" value="1000"/>
            </conditional>
        </conditional>
        <output name="downsample" ftype="json">
            <assert_contents>
                <not_has_text text="2925290528259"/>
            </assert_contents>
        </output>
        <assert_stderr>
            <has_text text="Koutput 1 downsampled signatures"/>
        </assert_stderr>
    </test>
    <!-- 12) flatten -->
    <test expect_num_outputs="1">
        <conditional name="sig">
            <param name="subcommand" value="flatten"/>
            <param name="signatures" value="47_abund.fa.sig"/>
        </conditional>
        <output name="flatten" ftype="json">
            <assert_contents>
                <not_has_text text="1,1,1"/>
            </assert_contents>
        </output>
        <assert_stderr>
            <has_text text="Kextracted 1 signatures from 1 file(s)"/>
        </assert_stderr>
    </test>
    <!-- 13) filter -->
    <test expect_num_outputs="1">
        <conditional name="sig">
            <param name="subcommand" value="filter"/>
            <param name="signatures" value="47_abund.fa.sig"/>
            <param name="min_abundance" value="2"/>
        </conditional>
        <output name="flatten" ftype="json">
            <assert_contents>
                <not_has_text text="1,1,1"/>
            </assert_contents>
        </output>
        <assert_stderr>
            <has_text text="extracted 1 signatures from 1 file(s)"/>
        </assert_stderr>
    </test>
    <!-- 14) export -->
    <test expect_num_outputs="1">
        <conditional name="sig">
            <param name="subcommand" value="export"/>
            <param name="signature" value="genome-s11.fa.gz.sig"/>
            <param name="ksize" value="21"/>
            <param name="mol_type" value="--dna"/>
        </conditional>
        <output name="export" ftype="json">
            <assert_contents>
                <has_text text="21,"/>
            </assert_contents>
        </output>
        <assert_stderr>
            <has_text text="exported signature"/>
        </assert_stderr>
    </test>
    <!-- 15) import -->
    <test expect_num_outputs="1">
        <conditional name="sig">
            <param name="subcommand" value="import"/>
            <param name="signature" value="exported.sig.msh.json"/>
        </conditional>
        <output name="import" ftype="json">
            <assert_contents>
                <has_text text="34197227818852"/>
            </assert_contents>
        </output>
        <assert_stderr>
            <has_text text="Ksaving 1 signatures to JSON"/>
        </assert_stderr>
    </test>
    <!-- 16) overlap -->
    <test expect_num_outputs="1">
        <conditional name="sig">
            <param name="subcommand" value="overlap"/>
            <param name="signatures" value="GCF_000017325.1_ASM1732v1_genomic.fna.gz.sig,GCF_000021665.1_ASM2166v1_genomic.fna.gz.sig"/>
        </conditional>
        <output name="overlap" ftype="txt">
            <assert_contents>
                <has_text text="--- Similarity measures ---"/>
            </assert_contents>
        </output>
    </test>
    <!-- 17) manifest -->
    <test expect_num_outputs="1">
        <conditional name="sig">
            <param name="subcommand" value="manifest"/>
            <param name="input" value="genome-s11.fa.gz.sig"/>
        </conditional>
        <output name="manifest" ftype="csv">
            <assert_contents>
                <has_n_lines n="6"/>
            </assert_contents>
        </output>
        <assert_stderr>
            <has_text text="Kmanifest contains 4 signatures total."/>
        </assert_stderr>
    </test>
    <!-- 18) check -->
    <test expect_num_outputs="1">
        <conditional name="sig">
            <param name="subcommand" value="check"/>
            <param name="signatures" value="genome-s11.fa.gz.sig"/>
            <param name="list" value="manifest.csv"/>
        </conditional>
        <output name="manifest" ftype="csv">
            <assert_contents>
                <has_n_lines n="5"/>
            </assert_contents>
        </output>
        <assert_stderr>
            <has_text text="Kfor given picklist, found 3 matches to 4 distinct values"/>
        </assert_stderr>
    </test>
    </tests>
    <help><![CDATA[
        **Sourmash Signature**

        These Signature subcommands manipulate signatures.

        The signature commands that combine or otherwise have multiple signatures interacting (merge, intersect, subtract) work only on compatible signatures, where the k-mer size and nucleotide/protein sequences match each other.

        List of Subcomand to choose from:
            - **Describe**:
            - **cat**:
            - **grep**:
            - **Merge**: Merge two (or more) signatures. Please note that sig merge can only merge compatible sketches - if there are multiple k-mer sizes or molecule types present in any of the signature files, you will need to choose one k-mer size and/or one moltype.
            - **Split**: Split each signature in the input file(s) into individual files..
            - **Subtract**: Subtract all of the hash values from one signature that are in one or more of the others. Note: subtract only creates one output file, with one signature in it.
            - **Intersect**: Output the intersection of the hash values in multiple signature files.
            - **Inflate**: Use abundances from one signature to provide abundances on other signatures.
            - **Downsample**: Downsample one or more signatures.
            - **flatten**: Flatten the specified signature(s), removing abundances and setting track_abundance to False. saving all input signatures into 1 output file!
            - **filter**: Filter the hashes in the specified signature(s) by abundance, by either -m/--min-abundance or -M/--max-abundance or both. 
            - **import**: Import signatures into sourmash format. Currently only supports mash, and can import mash sketches.
            - **export**: Export signatures from sourmash format. Currently only supports mash dump format.
            - **overlap**: Display a detailed comparison of two signatures.
            - **kmer**: Given one or more compatible sketches and some sequence files, extract the k-mers and/or sequences corresponding to the hash values in the sketch.
            - **manifest**: Creates a CSV file, in the internal sourmash manifest format. The manifest will contain an entry for every signature in the file, database, or collection. This format is largely meant for internal use, but it can serve as a picklist pickfile for subsetting large collections.
            - **check**:
            - **collect**:

        **Sourmash Signatre File Formats**

        Sourmash uses various file formats for signatures and databases, each optimized for specific use cases:

        - **.sig / .sig.gz**: Single or multi-signature JSON files (gzipped optional).
        - **.zip**: Signature collections with `SOURMASH-MANIFEST.csv` for fast subselection and picklists.
        - **Manifest (.csv / .csv.gz)**: Standalone CSV catalogs listing signatures; enables rapid loading without full files.
        - **Databases**:
            - **.rocksdb**: Indexed RocksDB format for fast, low-memory searches.
            - **.sqldb**: SQLite database catalogs for signature indexing.
            - **.sbt.zip**: Legacy sketch tree zips for hierarchical searching.
    ]]></help>
    <expand macro="citations"/>
</tool>
