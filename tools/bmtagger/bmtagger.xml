<tool id="bmtagger" name="bmtagger" version="@TOOL_VERSION@+galaxy@VERSION_SUFFIX@" profile="@PROFILE@" license="MIT">
    <description></description>
    <macros>
        <token name="@TOOL_VERSION@">3.101</token>
        <token name="@VERSION_SUFFIX@">0</token>
        <token name="@PROFILE@">25.0</token>
        <xml name="element_assert" tokens="name,ftype" token_decompress="false">
            <element name="@NAME@" ftype="@FTYPE@" decompress="@DECOMPRESS@">
                <assert_contents>
                    <has_n_lines n="2668"/>
                </assert_contents>
            </element>
        </xml>
    </macros>
    <xrefs>
        <xref type="bio.tools">bmtagger</xref>
    </xrefs>
    <requirements>
        <requirement type="package" version="@TOOL_VERSION@">bmtagger</requirement>
    </requirements>
    <version_command><![CDATA[bmtagger.sh -V 2> /dev/null | grep version | cut -d" " -f2]]></version_command>
    <command detect_errors="exit_code"><![CDATA[
        set -eo pipefail;
        #set gz = False
        #if $reads.has_single_item
            #if $reads.single_item.ext.endswith(".gz")
                gunzip -c '$reads.single_item' > forward &&
                #set gz = True
            #else
                ln -s '$reads.single_item' forward &&
            #end if
        #else
            #if $reads.forward.ext.endswith(".gz")
                gunzip -c '$reads.forward' > forward &&
                gunzip -c '$reads.reverse' > reverse &&
                #set gz = True
            #else
                ln -s '$reads.forward' forward &&
                ln -s '$reads.reverse' reverse &&
            #end if
        #end if

        #if $host.source == "cached"
            #set reference = $host.reference.fields.path
            ## srprism test data is to large (>100MB) to store ar IUC
            ## hence we generate it on the fly for tool tests using the
            ## fasta file which we keep in the path referred by the
            ## data table (not needed otherwise)
            #if $test == "true"
                srprism mkindex -i '${host.reference.fields.path}.fa' -o reference.srprism &&
            #end if
        #else
            #if $host.sequence.ext == "fasta.gz"
                gunzip -c '$host.sequence' > reference.fa &&
            #else
                ln -s '$host.sequence' reference.fa &&
            #end if
            ## bmtool creates multi GB file if used with default parameters
            ## -> use much smaller word size for testing
            bmtool -d reference.fa -o reference.bitmask -w #if $test != "" then 10 else 18 # &&
            srprism mkindex -i reference.fa -o reference.srprism &&
            makeblastdb -in reference.fa -dbtype nucl &&
            #set reference = "reference"
        #end if

        bmtagger.sh
            -q #if $reads.single_item.ext.startswith("fasta") then 0 else 1#
            -1 forward
            #if not $reads.has_single_item
                -2 reverse
            #end if
            -b '${reference}.bitmask'
            #if $test == "" or $host.source != "cached"
                -x '${reference}.srprism'
            #else
                -x reference.srprism
            #end if
            -d '${reference}'
            -o host_ids
            &&

        echo $test &&

        extract_fullseq host_ids -keep -fastq 
        #if $reads.has_single_item
            -single
        #else
            -mate1
        #end if
        'forward' 
        #if $gz
            | gzip -c
        #end if
        #if $reads.has_single_item
            ## > '$out_single'
            > '$out.single_item'
        #else
            ## > '$out_pair.forward'
            > '$out.forward'
            &&
            extract_fullseq host_ids -keep -fastq -mate2 'reverse' 
            #if $gz
                | gzip -c
            #end if
            ## > '$out_pair.reverse'
            > '$out.reverse'
        #end if
    ]]></command>
    <inputs>
        <param name="reads" type="data_collection" collection_type="paired_or_unpaired" format="fasta,fasta.gz,fastqsanger,fastqsanger.gz,fastqillumina,fastqillumina.gz" label="Paired reads"/>
        <conditional name="host">
            <param name="source" type="select" label="Host data source">
                <option value="cached">Precomputed indices</option>
                <option value="history">Sequence from History</option>
            </param>
            <when value="cached">
                <param name="reference" type="select" label="Reference">
                    <options from_data_table="bmtagger">
                        <filter type="sort_by" column="2"/>
                        <validator type="no_options" message="No indexes are available for the selected input dataset"/>
                    </options>
                </param>
            </when>
            <when value="history">
                <param name="sequence" type="data" format="fasta,fasta.gz" label="Host sequence" help="nucleotide sequence" />
            </when>
        </conditional>
        <param name="test" type="hidden"/>
    </inputs>
    <outputs>
        <collection name="out" type="paired_or_unpaired" structured_like="reads" format_source="reads"/>
        <!-- <data name="out_single" format_source="reads" label="${tool.name} on ${on_string}">
            <filter>len(reads.collection.elements)==1</filter>
        </data>
        <collection name="out_pair" type="paired" label="${tool.name} on ${on_string}: pairs">
            <data name="forward" format_source="reads" />
            <data name="reverse" format_source="reads" />
            <filter>len(reads.collection.elements)==2</filter>
        </collection> -->
    </outputs>
    <tests>
        <!-- single input, cached reference -->
        <test expect_num_outputs="2">
            <param name="reads">
                <collection type="paired_or_unpaired" name="reads">
                    <element name="unpaired" value="host_and_contaminant.fq1.fq" ftype="fastqsanger" />
                </collection>
            </param>
            <param name="test" value="true"/>
            <output_collection name="out" count="1">
                <expand macro="element_assert" name="unpaired" ftype="fastqsanger"/>
            </output_collection>

        </test>
        <!-- paired input, cached reference -->
        <test expect_num_outputs="3">
            <param name="reads">
                <collection type="paired_or_unpaired" name="reads">
                    <element name="forward" value="host_and_contaminant.fq1.fq" ftype="fastqsanger"/>
                    <element name="reverse" value="host_and_contaminant.fq2.fq" ftype="fastqsanger" />
                </collection>
            </param>
            <param name="test" value="true"/>
            <output_collection name="out" count="2">
                <expand macro="element_assert" name="forward" ftype="fastqsanger"/>
                <expand macro="element_assert" name="reverse" ftype="fastqsanger"/>
            </output_collection>
        </test>
        <!-- gz input, cached reference -->
        <test expect_num_outputs="3">
            <param name="reads">
                <collection type="paired_or_unpaired" name="reads">
                    <element name="forward" value="host_and_contaminant.fq1.fq.gz" ftype="fastqsanger.gz"/>
                    <element name="reverse" value="host_and_contaminant.fq2.fq.gz" ftype="fastqsanger.gz" />
                </collection>
            </param>
            <param name="test" value="true"/>
            <output_collection name="out" count="2">
                <expand macro="element_assert" name="forward" ftype="fastqsanger.gz" decompress="true"/>
                <expand macro="element_assert" name="reverse" ftype="fastqsanger.gz" decompress="true"/>
            </output_collection>
        </test>

        <!-- single gz input, fasta reference -->
        <test expect_num_outputs="2">
            <param name="reads">
                <collection type="paired_or_unpaired" name="reads">
                    <element name="unpaired" value="host_and_contaminant.fq1.fq.gz" ftype="fastqsanger.gz" />
                </collection>
            </param>
            <conditional name="host">
                <param name="source" value="history"/>
                <param name="sequence" value="host.fa" ftype="fasta"/>
            </conditional>
            <param name="test" value="true"/>
            <output_collection name="out" count="1">
                <expand macro="element_assert" name="unpaired" ftype="fastqsanger.gz" decompress="true"/>
            </output_collection>
        </test>

        <!-- gz input, gzipped fasta reference -->
        <test expect_num_outputs="3">
            <param name="reads">
                <collection type="paired_or_unpaired" name="reads">
                    <element name="forward" value="host_and_contaminant.fq1.fq.gz" ftype="fastqsanger.gz"/>
                    <element name="reverse" value="host_and_contaminant.fq2.fq.gz" ftype="fastqsanger.gz" />
                </collection>
            </param>
            <conditional name="host">
                <param name="source" value="history"/>
                <param name="sequence" value="host.fa.gz" ftype="fasta.gz"/>
            </conditional>
            <param name="test" value="true"/>
            <output_collection name="out"  count="2">
                <expand macro="element_assert" name="forward" ftype="fastqsanger.gz" decompress="true"/>
                <expand macro="element_assert" name="reverse" ftype="fastqsanger.gz" decompress="true"/>
            </output_collection>
        </test>
    </tests>
    <help><![CDATA[

.. class:: infomark

**What it does**

Filter contaminant sequences from input FASTA or FASTQ sequences.

This is done by iteratively applying

- bmfilter
- srprism
- blastn (megablast)

Usage
.....

**Input**

FASTA/FASTQ sequences and a reference database.

**Output**

FASTA/FASTQ sequences

    ]]></help>
    <citations>
        <citation type="bibtex">@article{rotmistrovsky2011bmtagger,
            title={BMTagger: Best Match Tagger for removing human reads from metagenomics datasets},
            author={Rotmistrovsky, Kirill and Agarwala, Richa},
            journal={NCBI/NLM, National Institutes of Health},
            year={2011}
         }</citation>
    </citations>
</tool>