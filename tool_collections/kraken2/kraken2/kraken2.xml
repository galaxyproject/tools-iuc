<tool id="kraken2" name="Kraken2" version="@TOOL_VERSION@+galaxy@VERSION_SUFFIX@" profile="@PROFILE@">
    <description>
        assign taxonomic labels to sequencing reads
    </description>
    <macros>
        <import>macros.xml</import>
    </macros>
    <xrefs>
        <xref type="bio.tools">kraken2</xref>
    </xrefs>
    <requirements>
        <requirement type="package" version="@TOOL_VERSION@">kraken2</requirement>
    </requirements>
    <version_command>kraken2 --version</version_command>
    <command detect_errors="exit_code">
        <![CDATA[
        kraken2
            --threads \${GALAXY_SLOTS:-1}
            --db '${kraken2_database.fields.path}'

            $quick

            #if $single_paired.single_paired_selector == "collection":
                --paired 
                '${single_paired.input_pair.forward}' '${single_paired.input_pair.reverse}'
            #else:
                '${single_paired.input_sequences}'
            #end if

            #if $split_reads:
                #if $single_paired.single_paired_selector == "no":
                    --unclassified-out 'un_out'
                    --classified-out 'cl_out'
                #else:
                    --unclassified-out 'un_out#'
                    --classified-out 'cl_out#'
                #end if
            #end if

            --confidence '${confidence}'
            --minimum-base-quality '${min_base_quality}'
            --minimum-hit-groups '${minimum_hit_groups}'

            $use_names

            #if $report.create_report == "true":
                --report '${report_output}'
                $report.use_mpa_style
                $report.report_zero_counts
                $report.report_minimizer_data
            #end if

            > '${output}'

        #if $split_reads:
            #if $single_paired.single_paired_selector == "no":
                #if $single_paired.input_sequences.ext.endswith(".gz")
                    #set command = "gzip -c"
                #elif $single_paired.input_sequences.ext.endswith(".bz2")
                    #set command = "bzip2 -c"
                #else
                    #set command = "cat"
                #end if
                && $command un_out > '$unclassified_out_s'
                && $command cl_out > '$classified_out_s'
            #else:
                #if $single_paired.input_pair.forward.ext.endswith(".gz")
                    #set command = "gzip -c"
                #elif $single_paired.input_pair.forward.ext.endswith(".bz2")
                    #set command = "bzip2 -c"
                #else
                    #set command = "cat"
                #end if
                && $command un_out_1 > '$out_unclassified_paired.forward'
                && $command un_out_2 > '$out_unclassified_paired.reverse'
                && $command cl_out_1 > '$out_classified_paired.forward'
                && $command cl_out_1 > '$out_classified_paired.forward'
            #end if
        #end if
    ]]></command>
    <inputs>
        <conditional name="single_paired">
            <param name="single_paired_selector" type="select" label="Single or paired reads" help="--paired">
                <option value="collection">Paired</option>
                <option selected="True" value="no">Single</option>
            </param>
            <when value="collection">
                <param format="@INTYPES@" name="input_pair" type="data_collection" collection_type="paired" label="Collection of paired reads"/>
            </when>
            <when value="no">
                <param format="@INTYPES@" label="Input sequences" name="input_sequences" type="data"/>
            </when>
        </conditional>
        <param argument="--use-names" type="boolean" truevalue="--use-names" falsevalue="" label="Print scientific names instead of just taxids"/>
        <param argument="--confidence" type="float" label="Confidence" value="0.0" min="0" max="1" help="Confidence score threshold. Must be in [0, 1]"/>
        <param argument="--minimum-base-quality" name="min_base_quality" type="integer" label="Minimum Base Quality" value="0" help="Minimum base quality used in classification (only effective with FASTQ input)"/>
        <param argument="--minimum-hit-groups" type="integer" label="Minimum hit groups" value="2" help="Number of overlapping k-mers sharing the same minimizer needed to make a call" />
        <param argument="--quick" type="boolean" truevalue="--quick" falsevalue="" label="Enable quick operation" help="Quick operation (use first hit)"/>
        <param name="split_reads" type="boolean" label="Split classified and unclassified outputs?" help="Sets --unclassified-out and --classified-out"/>
        <conditional name="report">
            <param argument="--report" name="create_report" type="select" label="Print a report with aggregrate counts/clade to file" help="Can be used as input for bracken">
                <option value="true">Yes</option>
                <option value="false" selected="true">No</option>
            </param>
            <when value="true">
                <param argument="--use-mpa-style" type="boolean" truevalue="--use-mpa-style" falsevalue="" label="Format report output like Kraken 1's kraken-mpa-report" />
                <param argument="--report-zero-counts" type="boolean" truevalue="--report-zero-counts" falsevalue="" label="Report counts for ALL taxa, even if counts are zero" />
                <param argument="--report-minimizer-data" type="boolean" truevalue="--report-minimizer-data" falsevalue="" label="Report minimizer data" help="Report minimizer and distinct minimizer count information in addition to normal Kraken report" />
            </when>
            <when value="false"/>
        </conditional>
        <expand macro="input_database"/>  
    </inputs>
    <outputs>
        <data name="classified_out_s" format_source="input_sequences" label="${tool.name} on ${on_string}: Classified reads">
            <filter>split_reads and single_paired['single_paired_selector'] == "no"</filter>   
        </data>
        <data name="unclassified_out_s" format_source="input_sequences" label="${tool.name} on ${on_string}: Unclassified reads">
            <filter>split_reads and single_paired['single_paired_selector'] == "no"</filter>	
        </data>
        <data name="report_output" format="tabular" label="${tool.name} on ${on_string}: Report">
            <filter>report['create_report'] == "true"</filter>
        </data>
        <collection name="out_unclassified_paired" type="paired" format_source="input_pair" label="${tool.name} on ${on_string}: Unclassified read pairs">
            <filter>split_reads and single_paired['single_paired_selector'] == "collection"</filter>	
        </collection>
        <collection name="out_classified_paired" type="paired" format_source="input_pair" label="${tool.name} on ${on_string}: Classified read pairs">
            <filter>split_reads and "collection" in single_paired['single_paired_selector'] == "collection"</filter>	
        </collection>

        <data name="output" format="tabular" label="${tool.name} on ${on_string}: Classification"/>
        <!--<data format="tabular" label="${tool.name} on ${on_string}: Translated classification" name="translated" />-->
    </outputs>
    <tests>
        <test expect_num_outputs="1">
            <conditional name="single_paired">
                <param name="single_paired_selector" value="no"/>
                <param name="input_sequences" value="kraken_test1.fa" ftype="fasta"/>
            </conditional>
            <param name="split_reads" value="false"/>
            <param name="quick" value="no"/>
            <param name="confidence" value=".2"/>
            <param name="kraken2_database" value="test_entry"/>
            <output name="output" file="kraken_test1_output.tab" ftype="tabular"/>
        </test>

        <test expect_num_outputs="3">
            <conditional name="single_paired">
                <param name="single_paired_selector" value="no"/>
                <param name="input_sequences" value="kraken_test1.fa" ftype="fasta"/>
            </conditional>
            <param name="split_reads" value="true"/>
            <param name="quick" value="no"/>
            <param name="confidence" value=".2"/>
            <param name="kraken2_database" value="test_entry"/>
            <output name="output" file="kraken_test1_output.tab" ftype="tabular"/>
            <output name="classified_out_s" file="kraken_test1_cl.fas" ftype="fasta"/>
            <output name="unclassified_out_s" file="kraken_test1_un.fas" ftype="fasta"/>
        </test>

        <test expect_num_outputs="7">
            <conditional name="single_paired">
                <param name="single_paired_selector" value="collection"/>
                <param name="input_pair">
                    <collection type="paired">
                        <element name="forward" value="kraken_test2_R1.fastq.gz" ftype="fastqsanger.gz"/>
                        <element name="reverse" value="kraken_test2_R2.fastq.gz" ftype="fastqsanger.gz"/>
                    </collection>
                </param>
                <param name="single_paired_selector" value="collection"/>
            </conditional>
            <param name="split_reads" value="true"/>
            <param name="quick" value="no"/>
            <param name="confidence" value="0"/>
            <param name="kraken2_database" value="test_entry"/>
            <output_collection name="out_unclassified_paired" type="paired">
                <element name="forward" file="un_test2_output_1.fastq" ftype="fastqsanger.gz" decompress="true"/>
                <element name="reverse" file="un_test2_output_2.fastq" ftype="fastqsanger.gz" decompress="true"/>
            </output_collection>
            <output_collection name="out_classified_paired" type="paired">
                <element name="forward" file="cl_test2_output_1.fastq" ftype="fastqsanger.gz" decompress="true"/>
                <element name="reverse" file="cl_test2_output_2.fastq" ftype="fastqsanger.gz" decompress="true"/>
            </output_collection>
            <output name="output" file="kraken_test2_output.tab" ftype="tabular"/>
            <assert_command>
                <has_text text="gzip -c"/>
            </assert_command>
        </test>

        <test expect_num_outputs="2">
            <conditional name="single_paired">
                <param name="single_paired_selector" value="collection"/>
                <param name="input_pair">
                    <collection type="paired">
                        <element name="forward" value="kraken_test2_R1.fastq" ftype="fastqsanger"/>
                        <element name="reverse" value="kraken_test2_R2.fastq" ftype="fastqsanger"/>
                    </collection>
                </param>
            </conditional>
            <param name="use_names" value="true"/>
            <conditional name="report">
                <param name="create_report" value="true"/>
                <param name="report_minimizer_data" value="true"/>
            </conditional>
            <param name="kraken2_database" value="test_entry"/>
            <output name="report_output" file="kraken_test2_report.tab" ftype="tabular"/>
        </test>
    </tests>
    <help>
        <![CDATA[
**What it does**

Kraken2 is a taxonomic sequence classifier that assigns taxonomic labels to short DNA reads. It does this by examining the k-mers within a read and querying a database with those k-mers. This database contains a mapping of every k-mer in Kraken's genomic library to the lowest common ancestor (LCA) in a taxonomic tree of all genomes that contain that k-mer. The set of LCA taxa that correspond to the k-mers in a read are then analyzed to create a single taxonomic label for the read; this label can be any of the nodes in the taxonomic tree. Kraken is designed to be rapid, sensitive, and highly precise.

-----

**Output Format**

Each sequence classified by Kraken results in a single line of output. Output lines contain five tab-delimited fields; from left to right, they are::

    1. "C"/"U": a one letter code indicating that the sequence was either classified or unclassified.
    2. The sequence ID, obtained from the FASTA/FASTQ header.
    3. The taxonomy ID Kraken 2 used to label the sequence; this is 0 if the sequence is unclassified.
    4. The length of the sequence in bp.
    5. A space-delimited list indicating the LCA mapping of each k-mer in the sequence. For example, "562:13 561:4 A:31 0:1 562:3" would indicate that:
            a) the first 13 k-mers mapped to taxonomy ID #562
            b) the next 4 k-mers mapped to taxonomy ID #561
            c) the next 31 k-mers contained an ambiguous nucleotide
            d) the next k-mer was not in the database
            e) the last 3 k-mers mapped to taxonomy ID #562
        ]]>
    </help>
    <expand macro="citations" />
</tool>
