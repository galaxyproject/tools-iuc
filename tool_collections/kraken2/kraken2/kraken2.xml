<tool id="kraken2" name="Kraken2" version="@TOOL_VERSION@+galaxy@VERSION_SUFFIX@" profile="@PROFILE@">
    <description>
        assign taxonomic labels to sequencing reads
    </description>
    <macros>
        <import>macros.xml</import>
    </macros>
    <xrefs>
        <xref type="bio.tools">kraken2</xref>
    </xrefs>
    <requirements>
        <requirement type="package" version="@TOOL_VERSION@">kraken2</requirement>
    </requirements>
    <version_command>kraken2 --version</version_command>
    <command detect_errors="exit_code">
        <![CDATA[
        #if $kraken2_database.database_source == "history":
            DB_DIR=\$(ls -d '${kraken2_database.custom_database.extra_files_path}/dataset_'*/) &&
        #end if 
        kraken2
            --threads \${GALAXY_SLOTS:-1}
            #if $kraken2_database.database_source == "builtin"
                --db '${kraken2_database.builtin_database.fields.path}'
            #elif $kraken2_database.database_source == "history"
                --db "\$DB_DIR"
            #end if
            
            $quick

            #if $single_paired.single_paired_selector == "collection":
                --paired 
                '${single_paired.input_pair.forward}' '${single_paired.input_pair.reverse}'
            #else:
                '${single_paired.input_sequences}'
            #end if

            #if $split_reads:
                #if $single_paired.single_paired_selector == "no":
                    --unclassified-out 'un_out'
                    --classified-out 'cl_out'
                #else:
                    --unclassified-out 'un_out#'
                    --classified-out 'cl_out#'
                #end if
            #end if

            --confidence ${confidence}
            --minimum-base-quality ${min_base_quality}
            --minimum-hit-groups ${minimum_hit_groups}

            $use_names

            #if $report.create_report:
                --report '${report_output}'
                $report.use_mpa_style
                $report.report_zero_counts
                $report.report_minimizer_data
            #end if

            > '${output}'

        #if $split_reads:
            #if $single_paired.single_paired_selector == "no":
                #if $single_paired.input_sequences.ext.endswith(".gz")
                    #set command = "gzip -c"
                #elif $single_paired.input_sequences.ext.endswith(".bz2")
                    #set command = "bzip2 -c"
                #else
                    #set command = "cat"
                #end if
                && $command un_out > '$unclassified_out_s'
                && $command cl_out > '$classified_out_s'
            #else:
                #if $single_paired.input_pair.forward.ext.endswith(".gz")
                    #set command = "gzip -c"
                #elif $single_paired.input_pair.forward.ext.endswith(".bz2")
                    #set command = "bzip2 -c"
                #else
                    #set command = "cat"
                #end if
                && $command un_out_1 > '$out_unclassified_paired.forward'
                && $command un_out_2 > '$out_unclassified_paired.reverse'
                && $command cl_out_1 > '$out_classified_paired.forward'
                && $command cl_out_1 > '$out_classified_paired.forward'
            #end if
        #end if
    ]]></command>
    <inputs>
        <conditional name="single_paired">
            <param name="single_paired_selector" type="select" label="Single or paired reads" help="--paired">
                <option value="collection">Paired</option>
                <option selected="True" value="no">Single</option>
            </param>
            <when value="collection">
                <param format="@INTYPES@" name="input_pair" type="data_collection" collection_type="paired" label="Collection of paired reads"/>
            </when>
            <when value="no">
                <param format="@INTYPES@" label="Input sequences" name="input_sequences" type="data"/>
            </when>
        </conditional>
        <param argument="--use-names" type="boolean" truevalue="--use-names" falsevalue="" label="Print scientific names instead of just taxids"/>
        <param argument="--confidence" type="float" label="Confidence" value="0.0" min="0" max="1" help="Confidence score threshold. Must be in [0, 1]"/>
        <param argument="--minimum-base-quality" name="min_base_quality" type="integer" label="Minimum Base Quality" value="0" help="Minimum base quality used in classification (only effective with FASTQ input)"/>
        <param argument="--minimum-hit-groups" type="integer" label="Minimum hit groups" value="2" help="Number of overlapping k-mers sharing the same minimizer needed to make a call" />
        <param argument="--quick" type="boolean" truevalue="--quick" falsevalue="" label="Enable quick operation" help="Quick operation (use first hit)"/>
        <param name="split_reads" type="boolean" label="Split classified and unclassified outputs?" help="Sets --unclassified-out and --classified-out"/>

        <section name="report" title="Create Report" expanded="false">
            <param name="create_report" type="boolean"  label="Print a report with aggregrate counts/clade to file" help="--report" />
            <param argument="--use-mpa-style" type="boolean" truevalue="--use-mpa-style" falsevalue="" label="Format report output like Kraken 1's kraken-mpa-report" />
            <param argument="--report-zero-counts" type="boolean" truevalue="--report-zero-counts" falsevalue="" label="Report counts for ALL taxa, even if counts are zero" />
            <param argument="--report-minimizer-data" type="boolean" truevalue="--report-minimizer-data" falsevalue="" label="Report minimizer data" help="Report minimizer and distinct minimizer count information in addition to normal Kraken report" />
        </section>

        <expand macro="input_database"/>  
    </inputs>
    <outputs>
        <data name="classified_out_s" format_source="input_sequences" label="${tool.name} on ${on_string}: Classified reads">
            <filter>(split_reads and ('no' in single_paired['single_paired_selector']))</filter>   
        </data>
        <data name="unclassified_out_s" format_source="input_sequences" label="${tool.name} on ${on_string}: Unclassified reads">
            <filter>(split_reads and ('no' in single_paired['single_paired_selector']))</filter>	
        </data>
        <data name="report_output" format="tabular" label="${tool.name} on ${on_string}: Report">
            <filter>(report['create_report'])</filter>
        </data>

        <collection name="out_unclassified_paired" type="paired" format_source="input_pair" label="${tool.name} on ${on_string}: Unclassified read pairs">
            <filter>(split_reads and ("collection" in single_paired['single_paired_selector']))</filter>	
        </collection>
        <collection name="out_classified_paired" type="paired" format_source="input_pair" label="${tool.name} on ${on_string}: Classified read pairs">
            <filter>(split_reads and ("collection" in single_paired['single_paired_selector']))</filter>	
        </collection>

        <data name="output" format="tabular" label="${tool.name} on ${on_string}: Classification"/>
        <!--<data format="tabular" label="${tool.name} on ${on_string}: Translated classification" name="translated" />-->
    </outputs>
    <tests>
        <!-- test1 -->
        <test expect_num_outputs="1">
            <conditional name="single_paired">
                <param name="single_paired_selector" value="no"/>
                <param name="input_sequences" value="kraken_test1.fa" ftype="fasta"/>
            </conditional>
            <param name="split_reads" value="false"/>
            <param name="quick" value="no"/>
            <param name="confidence" value=".2"/>
            <conditional name="kraken2_database">
                <param name="database_source" value="builtin" />
                <param name="builtin_database" value="test_entry"/>
            </conditional>
            <output name="output" file="kraken_test1_output.tab" ftype="tabular"/>
        </test>

        <!-- test2 -->
        <test expect_num_outputs="3">
            <conditional name="single_paired">
                <param name="single_paired_selector" value="no"/>
                <param name="input_sequences" value="kraken_test1.fa" ftype="fasta"/>
            </conditional>
            <param name="split_reads" value="true"/>
            <param name="quick" value="no"/>
            <param name="confidence" value=".2"/>
            <conditional name="kraken2_database">
                <param name="database_source" value="builtin" />
                <param name="builtin_database" value="test_entry"/>
            </conditional>
            <output name="output" file="kraken_test1_output.tab" ftype="tabular"/>
            <output name="classified_out_s" file="kraken_test1_cl.fas" ftype="fasta"/>
            <output name="unclassified_out_s" file="kraken_test1_un.fas" ftype="fasta"/>
        </test>

        <!-- test3 -->
        <test expect_num_outputs="7">
            <conditional name="single_paired">
                <param name="single_paired_selector" value="collection"/>
                <param name="input_pair">
                    <collection type="paired">
                        <element name="forward" value="kraken_test2_R1.fastq.gz" ftype="fastqsanger.gz"/>
                        <element name="reverse" value="kraken_test2_R2.fastq.gz" ftype="fastqsanger.gz"/>
                    </collection>
                </param>
                <param name="single_paired_selector" value="collection"/>
            </conditional>
            <param name="split_reads" value="true"/>
            <param name="quick" value="no"/>
            <param name="confidence" value="0"/>
            <conditional name="kraken2_database">
                <param name="database_source" value="builtin" />
                <param name="builtin_database" value="test_entry"/>
            </conditional>
            <output_collection name="out_unclassified_paired" type="paired">
                <element name="forward" file="un_test2_output_1.fastq" ftype="fastqsanger.gz" decompress="true"/>
                <element name="reverse" file="un_test2_output_2.fastq" ftype="fastqsanger.gz" decompress="true"/>
            </output_collection>
            <output_collection name="out_classified_paired" type="paired">
                <element name="forward" file="cl_test2_output_1.fastq" ftype="fastqsanger.gz" decompress="true"/>
                <element name="reverse" file="cl_test2_output_2.fastq" ftype="fastqsanger.gz" decompress="true"/>
            </output_collection>
            <output name="output" file="kraken_test2_output.tab" ftype="tabular"/>
            <assert_command>
                <has_text text="gzip -c"/>
            </assert_command>
        </test>

        <!-- test4 -->
        <test expect_num_outputs="2">
            <conditional name="single_paired">
                <param name="single_paired_selector" value="collection"/>
                <param name="input_pair">
                    <collection type="paired">
                        <element name="forward" value="kraken_test2_R1.fastq" ftype="fastqsanger"/>
                        <element name="reverse" value="kraken_test2_R2.fastq" ftype="fastqsanger"/>
                    </collection>
                </param>
            </conditional>
            <param name="use_names" value="true"/>
            <section name="report">
                <param name="create_report" value="true"/>
                <param name="report_minimizer_data" value="true"/>
            </section>
            <conditional name="kraken2_database">
                <param name="database_source" value="builtin" />
                <param name="builtin_database" value="test_entry"/>
            </conditional>
            <output name="report_output" file="kraken_test2_report.tab" ftype="tabular"/>
        </test>

        <!-- test5 -->
        <test expect_num_outputs="1">
            <conditional name="single_paired">
                <param name="single_paired_selector" value="no"/>
                <param name="input_sequences" value="kraken_test1.fa" ftype="fasta"/>
            </conditional>
            <param name="split_reads" value="false"/>
            <param name="quick" value="no"/>
            <param name="confidence" value=".2"/>
            <conditional name="kraken2_database">
                <param name="database_source" value="history" />
                <param name="custom_database" ftype="zip" value="test_db.zip" />
            </conditional>
            <output name="output" file="kraken_test1_output.tab" ftype="tabular"/>
        </test>
    </tests>
    <help>
        <![CDATA[
**What it does**

Kraken2 is a taxonomic sequence classifier that assigns taxonomic labels to short DNA reads. It does this by examining the k-mers within a read and querying a database with those k-mers. This database contains a mapping of every k-mer in Kraken's genomic library to the lowest common ancestor (LCA) in a taxonomic tree of all genomes that contain that k-mer. The set of LCA taxa that correspond to the k-mers in a read are then analyzed to create a single taxonomic label for the read; this label can be any of the nodes in the taxonomic tree. Kraken is designed to be rapid, sensitive, and highly precise.

-----

**Output Format**

Each sequence classified by Kraken results in a single line of output. Output lines contain five tab-delimited fields; from left to right, they are::

    1. "C"/"U": a one letter code indicating that the sequence was either classified or unclassified.
    2. The sequence ID, obtained from the FASTA/FASTQ header.
    3. The taxonomy ID Kraken 2 used to label the sequence; this is 0 if the sequence is unclassified.
    4. The length of the sequence in bp.
    5. A space-delimited list indicating the LCA mapping of each k-mer in the sequence. For example, "562:13 561:4 A:31 0:1 562:3" would indicate that:
            a) the first 13 k-mers mapped to taxonomy ID #562
            b) the next 4 k-mers mapped to taxonomy ID #561
            c) the next 31 k-mers contained an ambiguous nucleotide
            d) the next k-mer was not in the database
            e) the last 3 k-mers mapped to taxonomy ID #562


-----

**Custom databases**

The database can either be provided from a built-in selection of databases on the Galaxy server, in which case they are installed by the Galaxy administrator, typically using a tool manager, or can be provided by the user.

The kraken2 tool can use custom databases provided, as directories, from the user's history. These directory datasets must contain the files `hash.k2d`, `opts.k2d` and `taxo.k2d`. Since Galaxy does not support uploading directory datatypes directly, users can upload a zip file containing these three files and then extract it using the "Extract compressed file" tool in Galaxy. The resulting directory can then be used as a custom database for Kraken2. A compressed zip archive can also be used as input to the tool, in which case Galaxy will automatically extract it before running the tool.

To further clarify, the structure of the uploaded zip file should be as follows::

    hash.k2d
    opts.k2d
    taxo.k2d

For more information on building custom databases for Kraken2, please refer to the `Kraken2 documentation <https://github.com/DerrickWood/kraken2/wiki/Manual#custom-databases>`_.
        ]]>
    </help>
    <expand macro="citations" />
</tool>
