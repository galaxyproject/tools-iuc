<?xml version="1.0"?>
<tool id="kraken2" name="Kraken2" version="@TOOL_VERSION@+galaxy0">
    <description>
        assign taxonomic labels to sequencing reads
    </description>
    <macros>
        <import>macros.xml</import>
    </macros>
    <requirements>
        <requirement type="package" version="@TOOL_VERSION@">kraken2</requirement>
    </requirements>
    <version_command>kraken2 --version</version_command>
    <command detect_errors="exit_code">
        <![CDATA[
        kraken2
            --threads \${GALAXY_SLOTS:-1}
            --db '${kraken2_database.fields.path}'

            #if $quick:
                --quick
            #end if

            #if $single_paired.single_paired_selector == "yes"
                --paired
                '${single_paired.forward_input}' '${single_paired.reverse_input}'
	    #elif $single_paired.single_paired_selector == "collection":
	        --paired
	        '${single_paired.input_pair.forward}' '${single_paired.input_pair.reverse}'
	    #else:
                '${single_paired.input_sequences}'
            #end if

	    #if $split_reads:
                #if $single_paired.single_paired_selector == "yes":
                    --classified-out '${classified_out_p}' --unclassified-out '${unclassified_out_p}'
                #elif $single_paired.single_paired_selector == "collection": 
                    --classified-out '${classified_out_c}' --unclassified-out '${unclassified_out_c}'
                #else:
                    --classified-out '${classified_out_s}' --unclassified-out '${unclassified_out_s}'
                #end if
             #end if

            --confidence '${confidence}'
	    
            --minimum-base-quality '${min_base_quality}'

            #if $use_names:
                --use-names
            #end if

            #if $report.create_report:
                --report '${report_output}'
                #if $report.use_mpa_style:
                    --use-mpa-style
                #end if
                #if $report.report_zero_counts:
                    --report-zero-counts
                #end if
            #end if

            > '${output}'
    ]]></command>
    <inputs>
        <conditional name="single_paired">
            <param name="single_paired_selector" type="select" label="Single or paired reads" help="--paired">
                <option value="collection">Collection</option>
                <option value="yes">Paired</option>
                <option selected="True" value="no">Single</option>
            </param>
            <when value="collection">
                <param format="@INTYPES@" name="input_pair" type="data_collection" collection_type="paired" label="Collection of paired reads"/>
            </when>
            <when value="yes">
                <param format="@INTYPES@" name="forward_input" type="data" label="Forward strand"/>
                <param format="@INTYPES@" name="reverse_input" type="data" label="Reverse strand"/>
            </when>
            <when value="no">
                <param format="@INTYPES@" label="Input sequences" name="input_sequences" type="data"/>
            </when>
        </conditional>

        <param name="use_names" type="boolean" label="Print scientific names instead of just taxids"/>

        <param name="confidence"  type="float" label="Confidence" value="0.0" help="Confidence score threshold. Must be in [0, 1]">
            <validator type="in_range" min="0.0" max="1.0" message="Confidence score threshold should be between 0 and 1" />
        </param>

        <param name="min_base_quality" type="integer" label="Minimum Base Quality" value="0" help="Minimum base quality used in classification (only effective with FASTQ input)"/>
	
        <param name="quick" type="boolean" label="Enable quick operation" help="Quick operation (use first hit)"/>

        <param name="split_reads" type="boolean" label="Split classified and unclassified outputs?" help="Sets --unclassified-out and --classified-out"/>

        <section name="report" title="Create Report" expanded="false">
            <param name="create_report" type="boolean"  label="Print a report with aggregrate counts/clade to file" help="--report" optional="true"/>
            <param name="use_mpa_style" type="boolean" label="Format report output like Kraken 1's kraken-mpa-report" help="--use-mpa-style" optional="true"/>
            <param name="report_zero_counts" type="boolean" label="Report counts for ALL taxa, even if counts are zero" help="--report-zero-counts" optional="true"/>
        </section>

        <expand macro="input_database"/>
    
    </inputs>
    <outputs>
        <data name="classified_out_c" format="input_pair['forward']" label="${tool.name} on ${on_string}: Classified reads">
            <filter>(split_reads and ("collection" in single_paired['single_paired_selector']))</filter>   
        </data>
        <data name="unclassified_out_c" format_source="input_pair['forward']" label="${tool.name} on ${on_string}: Unclassified reads">
            <filter>(split_reads and ("collection" in single_paired['single_paired_selector']))</filter>	
        </data>

        <data name="classified_out_p" format_source="forward_input" label="${tool.name} on ${on_string}: Classified reads">
            <filter>(split_reads and ("yes" in single_paired['single_paired_selector']))</filter>   
        </data>
        <data name="unclassified_out_p" format_source="forward_input" label="${tool.name} on ${on_string}: Unclassified reads">
            <filter>(split_reads and ("yes" in single_paired['single_paired_selector']))</filter>	
        </data>

        <data name="classified_out_s" format_source="input_sequences" label="${tool.name} on ${on_string}: Classified reads">
            <filter>(split_reads and ('no' in single_paired['single_paired_selector']))</filter>   
        </data>
        <data name="unclassified_out_s" format_source="input_sequences" label="${tool.name} on ${on_string}: Unclassified reads">
            <filter>(split_reads and ('no' in single_paired['single_paired_selector']))</filter>	
        </data>

        <data name="report_output" format="tabular" label="Report: ${tool.name} on ${on_string}">
            <filter>(report['create_report'])</filter>
        </data>
        <data name="output" format="tabular" label="${tool.name} on ${on_string}: Classification"/>
        <!--<data format="tabular" label="${tool.name} on ${on_string}: Translated classification" name="translated" />-->
    </outputs>

    <tests>    
        <test>
            <param name="single_paired_selector" value="no"/>
            <param name="input_sequences" value="kraken_test1.fa" ftype="fasta"/>
            <param name="split_reads" value="false"/>
            <param name="quick" value="no"/>
            <param name="confidence" value=".2"/>
            <param name="only-classified-output" value="false"/>
            <param name="kraken2_database" value="test_entry"/>
            <output name="output" file="kraken_test1_output.tab" ftype="tabular"/>
        </test>
    </tests>
    <help>
        <![CDATA[
**What it does**

Kraken2 is a taxonomic sequence classifier that assigns taxonomic labels to short DNA reads. It does this by examining the k-mers within a read and querying a database with those k-mers. This database contains a mapping of every k-mer in Kraken's genomic library to the lowest common ancestor (LCA) in a taxonomic tree of all genomes that contain that k-mer. The set of LCA taxa that correspond to the k-mers in a read are then analyzed to create a single taxonomic label for the read; this label can be any of the nodes in the taxonomic tree. Kraken is designed to be rapid, sensitive, and highly precise.

-----

**Output Format**

Each sequence classified by Kraken results in a single line of output. Output lines contain five tab-delimited fields; from left to right, they are::

    1. "C"/"U": a one letter code indicating that the sequence was either classified or unclassified.
    2. The sequence ID, obtained from the FASTA/FASTQ header.
    3. The taxonomy ID Kraken 2 used to label the sequence; this is 0 if the sequence is unclassified.
    4. The length of the sequence in bp.
    5. A space-delimited list indicating the LCA mapping of each k-mer in the sequence. For example, "562:13 561:4 A:31 0:1 562:3" would indicate that:
            a) the first 13 k-mers mapped to taxonomy ID #562
            b) the next 4 k-mers mapped to taxonomy ID #561
            c) the next 31 k-mers contained an ambiguous nucleotide
            d) the next k-mer was not in the database
            e) the last 3 k-mers mapped to taxonomy ID #562
        ]]>
    </help>
    <expand macro="citations" />
</tool>
